/**
* @vue/shared v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function zt(r, e) {
  const t = new Set(r.split(","));
  return (s) => t.has(s);
}
const Oe = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, gn = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], Ge = () => {
}, zw = () => !1, Yi = (r) => r.charCodeAt(0) === 111 && r.charCodeAt(1) === 110 && // uppercase letter
(r.charCodeAt(2) > 122 || r.charCodeAt(2) < 97), Yu = (r) => r.startsWith("onUpdate:"), Be = Object.assign, td = (r, e) => {
  const t = r.indexOf(e);
  t > -1 && r.splice(t, 1);
}, Gw = Object.prototype.hasOwnProperty, Pe = (r, e) => Gw.call(r, e), se = Array.isArray, Ci = (r) => zn(r) === "[object Map]", Qi = (r) => zn(r) === "[object Set]", lg = (r) => zn(r) === "[object Date]", Kw = (r) => zn(r) === "[object RegExp]", fe = (r) => typeof r == "function", _e = (r) => typeof r == "string", Zr = (r) => typeof r == "symbol", Ae = (r) => r !== null && typeof r == "object", es = (r) => (Ae(r) || fe(r)) && fe(r.then) && fe(r.catch), xb = Object.prototype.toString, zn = (r) => xb.call(r), rd = (r) => zn(r).slice(8, -1), wb = (r) => zn(r) === "[object Object]", sd = (r) => _e(r) && r !== "NaN" && r[0] !== "-" && "" + parseInt(r, 10) === r, yn = /* @__PURE__ */ zt(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Xw = /* @__PURE__ */ zt(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), Ql = (r) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = r(t));
}, Jw = /-(\w)/g, Et = Ql((r) => r.replace(Jw, (e, t) => t ? t.toUpperCase() : "")), Yw = /\B([A-Z])/g, Tt = Ql(
  (r) => r.replace(Yw, "-$1").toLowerCase()
), ii = Ql((r) => r.charAt(0).toUpperCase() + r.slice(1)), ps = Ql((r) => r ? `on${ii(r)}` : ""), jt = (r, e) => !Object.is(r, e), Gs = (r, ...e) => {
  for (let t = 0; t < r.length; t++)
    r[t](...e);
}, An = (r, e, t, s = !1) => {
  Object.defineProperty(r, e, {
    configurable: !0,
    enumerable: !1,
    writable: s,
    value: t
  });
}, Qu = (r) => {
  const e = parseFloat(r);
  return isNaN(e) ? r : e;
}, Zu = (r) => {
  const e = _e(r) ? Number(r) : NaN;
  return isNaN(e) ? r : e;
};
let cg;
const Zl = () => cg || (cg = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), Qw = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error", Zw = /* @__PURE__ */ zt(Qw);
function Zi(r) {
  if (se(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
      const s = r[t], i = _e(s) ? sT(s) : Zi(s);
      if (i)
        for (const n in i)
          e[n] = i[n];
    }
    return e;
  } else if (_e(r) || Ae(r))
    return r;
}
const eT = /;(?![^(]*\))/g, tT = /:([^]+)/, rT = /\/\*[^]*?\*\//g;
function sT(r) {
  const e = {};
  return r.replace(rT, "").split(eT).forEach((t) => {
    if (t) {
      const s = t.split(tT);
      s.length > 1 && (e[s[0].trim()] = s[1].trim());
    }
  }), e;
}
function Tb(r) {
  let e = "";
  if (!r || _e(r))
    return e;
  for (const t in r) {
    const s = r[t];
    if (_e(s) || typeof s == "number") {
      const i = t.startsWith("--") ? t : Tt(t);
      e += `${i}:${s};`;
    }
  }
  return e;
}
function en(r) {
  let e = "";
  if (_e(r))
    e = r;
  else if (se(r))
    for (let t = 0; t < r.length; t++) {
      const s = en(r[t]);
      s && (e += s + " ");
    }
  else if (Ae(r))
    for (const t in r)
      r[t] && (e += t + " ");
  return e.trim();
}
function iT(r) {
  if (!r) return null;
  let { class: e, style: t } = r;
  return e && !_e(e) && (r.class = en(e)), t && (r.style = Zi(t)), r;
}
const nT = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", aT = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", oT = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", uT = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr", lT = /* @__PURE__ */ zt(nT), Pb = /* @__PURE__ */ zt(aT), cT = /* @__PURE__ */ zt(oT), fT = /* @__PURE__ */ zt(uT), Ab = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", pT = /* @__PURE__ */ zt(Ab), ap = /* @__PURE__ */ zt(
  Ab + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"
);
function Ao(r) {
  return !!r || r === "";
}
const hT = /[>/="'\u0009\u000a\u000c\u0020]/, yf = {};
function dT(r) {
  if (yf.hasOwnProperty(r))
    return yf[r];
  const e = hT.test(r);
  return e && console.error(`unsafe attribute name: ${r}`), yf[r] = !e;
}
const mT = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
}, gT = /* @__PURE__ */ zt(
  "accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"
), yT = /* @__PURE__ */ zt(
  "xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"
);
function id(r) {
  if (r == null)
    return !1;
  const e = typeof r;
  return e === "string" || e === "number" || e === "boolean";
}
const bT = /["'&<>]/;
function Wr(r) {
  const e = "" + r, t = bT.exec(e);
  if (!t)
    return e;
  let s = "", i, n, a = 0;
  for (n = t.index; n < e.length; n++) {
    switch (e.charCodeAt(n)) {
      case 34:
        i = "&quot;";
        break;
      case 38:
        i = "&amp;";
        break;
      case 39:
        i = "&#39;";
        break;
      case 60:
        i = "&lt;";
        break;
      case 62:
        i = "&gt;";
        break;
      default:
        continue;
    }
    a !== n && (s += e.slice(a, n)), a = n + 1, s += i;
  }
  return a !== n ? s + e.slice(a, n) : s;
}
const vT = /^-?>|<!--|-->|--!>|<!-$/g;
function ET(r) {
  return r.replace(vT, "");
}
function ST(r, e) {
  if (r.length !== e.length) return !1;
  let t = !0;
  for (let s = 0; t && s < r.length; s++)
    t = Or(r[s], e[s]);
  return t;
}
function Or(r, e) {
  if (r === e) return !0;
  let t = lg(r), s = lg(e);
  if (t || s)
    return t && s ? r.getTime() === e.getTime() : !1;
  if (t = Zr(r), s = Zr(e), t || s)
    return r === e;
  if (t = se(r), s = se(e), t || s)
    return t && s ? ST(r, e) : !1;
  if (t = Ae(r), s = Ae(e), t || s) {
    if (!t || !s)
      return !1;
    const i = Object.keys(r).length, n = Object.keys(e).length;
    if (i !== n)
      return !1;
    for (const a in r) {
      const o = r.hasOwnProperty(a), u = e.hasOwnProperty(a);
      if (o && !u || !o && u || !Or(r[a], e[a]))
        return !1;
    }
  }
  return String(r) === String(e);
}
function Co(r, e) {
  return r.findIndex((t) => Or(t, e));
}
const Cb = (r) => !!(r && r.__v_isRef === !0), nd = (r) => _e(r) ? r : r == null ? "" : se(r) || Ae(r) && (r.toString === xb || !fe(r.toString)) ? Cb(r) ? nd(r.value) : JSON.stringify(r, Nb, 2) : String(r), Nb = (r, e) => Cb(e) ? Nb(r, e.value) : Ci(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (t, [s, i], n) => (t[bf(s, n) + " =>"] = i, t),
    {}
  )
} : Qi(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((t) => bf(t))
} : Zr(e) ? bf(e) : Ae(e) && !se(e) && !wb(e) ? String(e) : e, bf = (r, e = "") => {
  var t;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Zr(r) ? `Symbol(${(t = r.description) != null ? t : e})` : r
  );
};
/**
* @vue/reactivity v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function ts(r, ...e) {
  console.warn(`[Vue warn] ${r}`, ...e);
}
let rr;
class ad {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = rr, !e && rr && (this.index = (rr.scopes || (rr.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const t = rr;
      try {
        return rr = this, e();
      } finally {
        rr = t;
      }
    } else process.env.NODE_ENV !== "production" && ts("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    rr = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    rr = this.parent;
  }
  stop(e) {
    if (this._active) {
      let t, s;
      for (t = 0, s = this.effects.length; t < s; t++)
        this.effects[t].stop();
      for (t = 0, s = this.cleanups.length; t < s; t++)
        this.cleanups[t]();
      if (this.scopes)
        for (t = 0, s = this.scopes.length; t < s; t++)
          this.scopes[t].stop(!0);
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function _T(r) {
  return new ad(r);
}
function Ob(r, e = rr) {
  e && e.active && e.effects.push(r);
}
function Ib() {
  return rr;
}
function xT(r) {
  rr ? rr.cleanups.push(r) : process.env.NODE_ENV !== "production" && ts(
    "onScopeDispose() is called when there is no active effect scope to be associated with."
  );
}
let Ni;
class Cn {
  constructor(e, t, s, i) {
    this.fn = e, this.trigger = t, this.scheduler = s, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, Ob(this, i);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1, Os();
      for (let e = 0; e < this._depsLength; e++) {
        const t = this.deps[e];
        if (t.computed && (wT(t.computed), this._dirtyLevel >= 4))
          break;
      }
      this._dirtyLevel === 1 && (this._dirtyLevel = 0), Is();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(e) {
    this._dirtyLevel = e ? 4 : 0;
  }
  run() {
    if (this._dirtyLevel = 0, !this.active)
      return this.fn();
    let e = Qs, t = Ni;
    try {
      return Qs = !0, Ni = this, this._runnings++, fg(this), this.fn();
    } finally {
      pg(this), this._runnings--, Ni = t, Qs = e;
    }
  }
  stop() {
    this.active && (fg(this), pg(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function wT(r) {
  return r.value;
}
function fg(r) {
  r._trackId++, r._depsLength = 0;
}
function pg(r) {
  if (r.deps.length > r._depsLength) {
    for (let e = r._depsLength; e < r.deps.length; e++)
      kb(r.deps[e], r);
    r.deps.length = r._depsLength;
  }
}
function kb(r, e) {
  const t = r.get(e);
  t !== void 0 && e._trackId !== t && (r.delete(e), r.size === 0 && r.cleanup());
}
function TT(r, e) {
  r.effect instanceof Cn && (r = r.effect.fn);
  const t = new Cn(r, Ge, () => {
    t.dirty && t.run();
  });
  e && (Be(t, e), e.scope && Ob(t, e.scope)), (!e || !e.lazy) && t.run();
  const s = t.run.bind(t);
  return s.effect = t, s;
}
function PT(r) {
  r.effect.stop();
}
let Qs = !0, op = 0;
const Db = [];
function Os() {
  Db.push(Qs), Qs = !1;
}
function Is() {
  const r = Db.pop();
  Qs = r === void 0 ? !0 : r;
}
function od() {
  op++;
}
function ud() {
  for (op--; !op && up.length; )
    up.shift()();
}
function Lb(r, e, t) {
  var s;
  if (e.get(r) !== r._trackId) {
    e.set(r, r._trackId);
    const i = r.deps[r._depsLength];
    i !== e ? (i && kb(i, r), r.deps[r._depsLength++] = e) : r._depsLength++, process.env.NODE_ENV !== "production" && ((s = r.onTrack) == null || s.call(r, Be({ effect: r }, t)));
  }
}
const up = [];
function Mb(r, e, t) {
  var s;
  od();
  for (const i of r.keys()) {
    let n;
    i._dirtyLevel < e && (n ?? (n = r.get(i) === i._trackId)) && (i._shouldSchedule || (i._shouldSchedule = i._dirtyLevel === 0), i._dirtyLevel = e), i._shouldSchedule && (n ?? (n = r.get(i) === i._trackId)) && (process.env.NODE_ENV !== "production" && ((s = i.onTrigger) == null || s.call(i, Be({ effect: i }, t))), i.trigger(), (!i._runnings || i.allowRecurse) && i._dirtyLevel !== 2 && (i._shouldSchedule = !1, i.scheduler && up.push(i.scheduler)));
  }
  ud();
}
const Rb = (r, e) => {
  const t = /* @__PURE__ */ new Map();
  return t.cleanup = r, t.computed = e, t;
}, el = /* @__PURE__ */ new WeakMap(), Oi = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : ""), lp = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
function Ct(r, e, t) {
  if (Qs && Ni) {
    let s = el.get(r);
    s || el.set(r, s = /* @__PURE__ */ new Map());
    let i = s.get(t);
    i || s.set(t, i = Rb(() => s.delete(t))), Lb(
      Ni,
      i,
      process.env.NODE_ENV !== "production" ? {
        target: r,
        type: e,
        key: t
      } : void 0
    );
  }
}
function zr(r, e, t, s, i, n) {
  const a = el.get(r);
  if (!a)
    return;
  let o = [];
  if (e === "clear")
    o = [...a.values()];
  else if (t === "length" && se(r)) {
    const u = Number(s);
    a.forEach((l, c) => {
      (c === "length" || !Zr(c) && c >= u) && o.push(l);
    });
  } else
    switch (t !== void 0 && o.push(a.get(t)), e) {
      case "add":
        se(r) ? sd(t) && o.push(a.get("length")) : (o.push(a.get(Oi)), Ci(r) && o.push(a.get(lp)));
        break;
      case "delete":
        se(r) || (o.push(a.get(Oi)), Ci(r) && o.push(a.get(lp)));
        break;
      case "set":
        Ci(r) && o.push(a.get(Oi));
        break;
    }
  od();
  for (const u of o)
    u && Mb(
      u,
      4,
      process.env.NODE_ENV !== "production" ? {
        target: r,
        type: e,
        key: t,
        newValue: s,
        oldValue: i,
        oldTarget: n
      } : void 0
    );
  ud();
}
function AT(r, e) {
  const t = el.get(r);
  return t && t.get(e);
}
const CT = /* @__PURE__ */ zt("__proto__,__v_isRef,__isVue"), $b = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((r) => r !== "arguments" && r !== "caller").map((r) => Symbol[r]).filter(Zr)
), hg = /* @__PURE__ */ NT();
function NT() {
  const r = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    r[e] = function(...t) {
      const s = Ee(this);
      for (let n = 0, a = this.length; n < a; n++)
        Ct(s, "get", n + "");
      const i = s[e](...t);
      return i === -1 || i === !1 ? s[e](...t.map(Ee)) : i;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    r[e] = function(...t) {
      Os(), od();
      const s = Ee(this)[e].apply(this, t);
      return ud(), Is(), s;
    };
  }), r;
}
function OT(r) {
  Zr(r) || (r = String(r));
  const e = Ee(this);
  return Ct(e, "has", r), e.hasOwnProperty(r);
}
class Fb {
  constructor(e = !1, t = !1) {
    this._isReadonly = e, this._isShallow = t;
  }
  get(e, t, s) {
    const i = this._isReadonly, n = this._isShallow;
    if (t === "__v_isReactive")
      return !i;
    if (t === "__v_isReadonly")
      return i;
    if (t === "__v_isShallow")
      return n;
    if (t === "__v_raw")
      return s === (i ? n ? Wb : Hb : n ? qb : jb).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(s) ? e : void 0;
    const a = se(e);
    if (!i) {
      if (a && Pe(hg, t))
        return Reflect.get(hg, t, s);
      if (t === "hasOwnProperty")
        return OT;
    }
    const o = Reflect.get(e, t, s);
    return (Zr(t) ? $b.has(t) : CT(t)) || (i || Ct(e, "get", t), n) ? o : pt(o) ? a && sd(t) ? o : o.value : Ae(o) ? i ? cd(o) : rc(o) : o;
  }
}
class Bb extends Fb {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, t, s, i) {
    let n = e[t];
    if (!this._isShallow) {
      const u = rs(n);
      if (!Gr(s) && !rs(s) && (n = Ee(n), s = Ee(s)), !se(e) && pt(n) && !pt(s))
        return u ? !1 : (n.value = s, !0);
    }
    const a = se(e) && sd(t) ? Number(t) < e.length : Pe(e, t), o = Reflect.set(e, t, s, i);
    return e === Ee(i) && (a ? jt(s, n) && zr(e, "set", t, s, n) : zr(e, "add", t, s)), o;
  }
  deleteProperty(e, t) {
    const s = Pe(e, t), i = e[t], n = Reflect.deleteProperty(e, t);
    return n && s && zr(e, "delete", t, void 0, i), n;
  }
  has(e, t) {
    const s = Reflect.has(e, t);
    return (!Zr(t) || !$b.has(t)) && Ct(e, "has", t), s;
  }
  ownKeys(e) {
    return Ct(
      e,
      "iterate",
      se(e) ? "length" : Oi
    ), Reflect.ownKeys(e);
  }
}
class Vb extends Fb {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, t) {
    return process.env.NODE_ENV !== "production" && ts(
      `Set operation on key "${String(t)}" failed: target is readonly.`,
      e
    ), !0;
  }
  deleteProperty(e, t) {
    return process.env.NODE_ENV !== "production" && ts(
      `Delete operation on key "${String(t)}" failed: target is readonly.`,
      e
    ), !0;
  }
}
const IT = /* @__PURE__ */ new Bb(), kT = /* @__PURE__ */ new Vb(), DT = /* @__PURE__ */ new Bb(
  !0
), LT = /* @__PURE__ */ new Vb(!0), ld = (r) => r, ec = (r) => Reflect.getPrototypeOf(r);
function Jo(r, e, t = !1, s = !1) {
  r = r.__v_raw;
  const i = Ee(r), n = Ee(e);
  t || (jt(e, n) && Ct(i, "get", e), Ct(i, "get", n));
  const { has: a } = ec(i), o = s ? ld : t ? fd : Za;
  if (a.call(i, e))
    return o(r.get(e));
  if (a.call(i, n))
    return o(r.get(n));
  r !== i && r.get(e);
}
function Yo(r, e = !1) {
  const t = this.__v_raw, s = Ee(t), i = Ee(r);
  return e || (jt(r, i) && Ct(s, "has", r), Ct(s, "has", i)), r === i ? t.has(r) : t.has(r) || t.has(i);
}
function Qo(r, e = !1) {
  return r = r.__v_raw, !e && Ct(Ee(r), "iterate", Oi), Reflect.get(r, "size", r);
}
function dg(r, e = !1) {
  !e && !Gr(r) && !rs(r) && (r = Ee(r));
  const t = Ee(this);
  return ec(t).has.call(t, r) || (t.add(r), zr(t, "add", r, r)), this;
}
function mg(r, e, t = !1) {
  !t && !Gr(e) && !rs(e) && (e = Ee(e));
  const s = Ee(this), { has: i, get: n } = ec(s);
  let a = i.call(s, r);
  a ? process.env.NODE_ENV !== "production" && Ub(s, i, r) : (r = Ee(r), a = i.call(s, r));
  const o = n.call(s, r);
  return s.set(r, e), a ? jt(e, o) && zr(s, "set", r, e, o) : zr(s, "add", r, e), this;
}
function gg(r) {
  const e = Ee(this), { has: t, get: s } = ec(e);
  let i = t.call(e, r);
  i ? process.env.NODE_ENV !== "production" && Ub(e, t, r) : (r = Ee(r), i = t.call(e, r));
  const n = s ? s.call(e, r) : void 0, a = e.delete(r);
  return i && zr(e, "delete", r, void 0, n), a;
}
function yg() {
  const r = Ee(this), e = r.size !== 0, t = process.env.NODE_ENV !== "production" ? Ci(r) ? new Map(r) : new Set(r) : void 0, s = r.clear();
  return e && zr(r, "clear", void 0, void 0, t), s;
}
function Zo(r, e) {
  return function(s, i) {
    const n = this, a = n.__v_raw, o = Ee(a), u = e ? ld : r ? fd : Za;
    return !r && Ct(o, "iterate", Oi), a.forEach((l, c) => s.call(i, u(l), u(c), n));
  };
}
function eu(r, e, t) {
  return function(...s) {
    const i = this.__v_raw, n = Ee(i), a = Ci(n), o = r === "entries" || r === Symbol.iterator && a, u = r === "keys" && a, l = i[r](...s), c = t ? ld : e ? fd : Za;
    return !e && Ct(
      n,
      "iterate",
      u ? lp : Oi
    ), {
      // iterator protocol
      next() {
        const { value: f, done: p } = l.next();
        return p ? { value: f, done: p } : {
          value: o ? [c(f[0]), c(f[1])] : c(f),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Ls(r) {
  return function(...e) {
    if (process.env.NODE_ENV !== "production") {
      const t = e[0] ? `on key "${e[0]}" ` : "";
      ts(
        `${ii(r)} operation ${t}failed: target is readonly.`,
        Ee(this)
      );
    }
    return r === "delete" ? !1 : r === "clear" ? void 0 : this;
  };
}
function MT() {
  const r = {
    get(n) {
      return Jo(this, n);
    },
    get size() {
      return Qo(this);
    },
    has: Yo,
    add: dg,
    set: mg,
    delete: gg,
    clear: yg,
    forEach: Zo(!1, !1)
  }, e = {
    get(n) {
      return Jo(this, n, !1, !0);
    },
    get size() {
      return Qo(this);
    },
    has: Yo,
    add(n) {
      return dg.call(this, n, !0);
    },
    set(n, a) {
      return mg.call(this, n, a, !0);
    },
    delete: gg,
    clear: yg,
    forEach: Zo(!1, !0)
  }, t = {
    get(n) {
      return Jo(this, n, !0);
    },
    get size() {
      return Qo(this, !0);
    },
    has(n) {
      return Yo.call(this, n, !0);
    },
    add: Ls("add"),
    set: Ls("set"),
    delete: Ls("delete"),
    clear: Ls("clear"),
    forEach: Zo(!0, !1)
  }, s = {
    get(n) {
      return Jo(this, n, !0, !0);
    },
    get size() {
      return Qo(this, !0);
    },
    has(n) {
      return Yo.call(this, n, !0);
    },
    add: Ls("add"),
    set: Ls("set"),
    delete: Ls("delete"),
    clear: Ls("clear"),
    forEach: Zo(!0, !0)
  };
  return [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((n) => {
    r[n] = eu(n, !1, !1), t[n] = eu(n, !0, !1), e[n] = eu(n, !1, !0), s[n] = eu(
      n,
      !0,
      !0
    );
  }), [
    r,
    t,
    e,
    s
  ];
}
const [
  RT,
  $T,
  FT,
  BT
] = /* @__PURE__ */ MT();
function tc(r, e) {
  const t = e ? r ? BT : FT : r ? $T : RT;
  return (s, i, n) => i === "__v_isReactive" ? !r : i === "__v_isReadonly" ? r : i === "__v_raw" ? s : Reflect.get(
    Pe(t, i) && i in s ? t : s,
    i,
    n
  );
}
const VT = {
  get: /* @__PURE__ */ tc(!1, !1)
}, UT = {
  get: /* @__PURE__ */ tc(!1, !0)
}, jT = {
  get: /* @__PURE__ */ tc(!0, !1)
}, qT = {
  get: /* @__PURE__ */ tc(!0, !0)
};
function Ub(r, e, t) {
  const s = Ee(t);
  if (s !== t && e.call(r, s)) {
    const i = rd(r);
    ts(
      `Reactive ${i} contains both the raw and reactive versions of the same object${i === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const jb = /* @__PURE__ */ new WeakMap(), qb = /* @__PURE__ */ new WeakMap(), Hb = /* @__PURE__ */ new WeakMap(), Wb = /* @__PURE__ */ new WeakMap();
function HT(r) {
  switch (r) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function WT(r) {
  return r.__v_skip || !Object.isExtensible(r) ? 0 : HT(rd(r));
}
function rc(r) {
  return rs(r) ? r : sc(
    r,
    !1,
    IT,
    VT,
    jb
  );
}
function zb(r) {
  return sc(
    r,
    !1,
    DT,
    UT,
    qb
  );
}
function cd(r) {
  return sc(
    r,
    !0,
    kT,
    jT,
    Hb
  );
}
function Ar(r) {
  return sc(
    r,
    !0,
    LT,
    qT,
    Wb
  );
}
function sc(r, e, t, s, i) {
  if (!Ae(r))
    return process.env.NODE_ENV !== "production" && ts(
      `value cannot be made ${e ? "readonly" : "reactive"}: ${String(
        r
      )}`
    ), r;
  if (r.__v_raw && !(e && r.__v_isReactive))
    return r;
  const n = i.get(r);
  if (n)
    return n;
  const a = WT(r);
  if (a === 0)
    return r;
  const o = new Proxy(
    r,
    a === 2 ? s : t
  );
  return i.set(r, o), o;
}
function Zs(r) {
  return rs(r) ? Zs(r.__v_raw) : !!(r && r.__v_isReactive);
}
function rs(r) {
  return !!(r && r.__v_isReadonly);
}
function Gr(r) {
  return !!(r && r.__v_isShallow);
}
function Qa(r) {
  return r ? !!r.__v_raw : !1;
}
function Ee(r) {
  const e = r && r.__v_raw;
  return e ? Ee(e) : r;
}
function Gb(r) {
  return Object.isExtensible(r) && An(r, "__v_skip", !0), r;
}
const Za = (r) => Ae(r) ? rc(r) : r, fd = (r) => Ae(r) ? cd(r) : r, zT = "Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free";
class Kb {
  constructor(e, t, s, i) {
    this.getter = e, this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new Cn(
      () => e(this._value),
      () => bn(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    ), this.effect.computed = this, this.effect.active = this._cacheable = !i, this.__v_isReadonly = s;
  }
  get value() {
    const e = Ee(this);
    return (!e._cacheable || e.effect.dirty) && jt(e._value, e._value = e.effect.run()) && bn(e, 4), pd(e), e.effect._dirtyLevel >= 2 && (process.env.NODE_ENV !== "production" && this._warnRecursive && ts(zT, `

getter: `, this.getter), bn(e, 2)), e._value;
  }
  set value(e) {
    this._setter(e);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(e) {
    this.effect.dirty = e;
  }
  // #endregion
}
function GT(r, e, t = !1) {
  let s, i;
  const n = fe(r);
  n ? (s = r, i = process.env.NODE_ENV !== "production" ? () => {
    ts("Write operation failed: computed value is readonly");
  } : Ge) : (s = r.get, i = r.set);
  const a = new Kb(s, i, n || !i, t);
  return process.env.NODE_ENV !== "production" && e && !t && (a.effect.onTrack = e.onTrack, a.effect.onTrigger = e.onTrigger), a;
}
function pd(r) {
  var e;
  Qs && Ni && (r = Ee(r), Lb(
    Ni,
    (e = r.dep) != null ? e : r.dep = Rb(
      () => r.dep = void 0,
      r instanceof Kb ? r : void 0
    ),
    process.env.NODE_ENV !== "production" ? {
      target: r,
      type: "get",
      key: "value"
    } : void 0
  ));
}
function bn(r, e = 4, t, s) {
  r = Ee(r);
  const i = r.dep;
  i && Mb(
    i,
    e,
    process.env.NODE_ENV !== "production" ? {
      target: r,
      type: "set",
      key: "value",
      newValue: t,
      oldValue: s
    } : void 0
  );
}
function pt(r) {
  return !!(r && r.__v_isRef === !0);
}
function Ii(r) {
  return Xb(r, !1);
}
function KT(r) {
  return Xb(r, !0);
}
function Xb(r, e) {
  return pt(r) ? r : new XT(r, e);
}
class XT {
  constructor(e, t) {
    this.__v_isShallow = t, this.dep = void 0, this.__v_isRef = !0, this._rawValue = t ? e : Ee(e), this._value = t ? e : Za(e);
  }
  get value() {
    return pd(this), this._value;
  }
  set value(e) {
    const t = this.__v_isShallow || Gr(e) || rs(e);
    if (e = t ? e : Ee(e), jt(e, this._rawValue)) {
      const s = this._rawValue;
      this._rawValue = e, this._value = t ? e : Za(e), bn(this, 4, e, s);
    }
  }
}
function JT(r) {
  bn(r, 4, process.env.NODE_ENV !== "production" ? r.value : void 0);
}
function hd(r) {
  return pt(r) ? r.value : r;
}
function YT(r) {
  return fe(r) ? r() : hd(r);
}
const QT = {
  get: (r, e, t) => hd(Reflect.get(r, e, t)),
  set: (r, e, t, s) => {
    const i = r[e];
    return pt(i) && !pt(t) ? (i.value = t, !0) : Reflect.set(r, e, t, s);
  }
};
function dd(r) {
  return Zs(r) ? r : new Proxy(r, QT);
}
class ZT {
  constructor(e) {
    this.dep = void 0, this.__v_isRef = !0;
    const { get: t, set: s } = e(
      () => pd(this),
      () => bn(this)
    );
    this._get = t, this._set = s;
  }
  get value() {
    return this._get();
  }
  set value(e) {
    this._set(e);
  }
}
function Jb(r) {
  return new ZT(r);
}
function eP(r) {
  process.env.NODE_ENV !== "production" && !Qa(r) && ts("toRefs() expects a reactive object but received a plain one.");
  const e = se(r) ? new Array(r.length) : {};
  for (const t in r)
    e[t] = Yb(r, t);
  return e;
}
class tP {
  constructor(e, t, s) {
    this._object = e, this._key = t, this._defaultValue = s, this.__v_isRef = !0;
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return AT(Ee(this._object), this._key);
  }
}
class rP {
  constructor(e) {
    this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0;
  }
  get value() {
    return this._getter();
  }
}
function sP(r, e, t) {
  return pt(r) ? r : fe(r) ? new rP(r) : Ae(r) && arguments.length > 1 ? Yb(r, e, t) : Ii(r);
}
function Yb(r, e, t) {
  const s = r[e];
  return pt(s) ? s : new tP(r, e, t);
}
const iP = {
  GET: "get",
  HAS: "has",
  ITERATE: "iterate"
}, nP = {
  SET: "set",
  ADD: "add",
  DELETE: "delete",
  CLEAR: "clear"
};
/**
* @vue/runtime-core v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const ki = [];
function Da(r) {
  ki.push(r);
}
function La() {
  ki.pop();
}
let vf = !1;
function j(r, ...e) {
  if (vf) return;
  vf = !0, Os();
  const t = ki.length ? ki[ki.length - 1].component : null, s = t && t.appContext.config.warnHandler, i = aP();
  if (s)
    Kr(
      s,
      t,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        r + e.map((n) => {
          var a, o;
          return (o = (a = n.toString) == null ? void 0 : a.call(n)) != null ? o : JSON.stringify(n);
        }).join(""),
        t && t.proxy,
        i.map(
          ({ vnode: n }) => `at <${mc(t, n.type)}>`
        ).join(`
`),
        i
      ]
    );
  else {
    const n = [`[Vue warn]: ${r}`, ...e];
    i.length && n.push(`
`, ...oP(i)), console.warn(...n);
  }
  Is(), vf = !1;
}
function aP() {
  let r = ki[ki.length - 1];
  if (!r)
    return [];
  const e = [];
  for (; r; ) {
    const t = e[0];
    t && t.vnode === r ? t.recurseCount++ : e.push({
      vnode: r,
      recurseCount: 0
    });
    const s = r.component && r.component.parent;
    r = s && s.vnode;
  }
  return e;
}
function oP(r) {
  const e = [];
  return r.forEach((t, s) => {
    e.push(...s === 0 ? [] : [`
`], ...uP(t));
  }), e;
}
function uP({ vnode: r, recurseCount: e }) {
  const t = e > 0 ? `... (${e} recursive calls)` : "", s = r.component ? r.component.parent == null : !1, i = ` at <${mc(
    r.component,
    r.type,
    s
  )}`, n = ">" + t;
  return r.props ? [i, ...lP(r.props), n] : [i + n];
}
function lP(r) {
  const e = [], t = Object.keys(r);
  return t.slice(0, 3).forEach((s) => {
    e.push(...Qb(s, r[s]));
  }), t.length > 3 && e.push(" ..."), e;
}
function Qb(r, e, t) {
  return _e(e) ? (e = JSON.stringify(e), t ? e : [`${r}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? t ? e : [`${r}=${e}`] : pt(e) ? (e = Qb(r, Ee(e.value), !0), t ? e : [`${r}=Ref<`, e, ">"]) : fe(e) ? [`${r}=fn${e.name ? `<${e.name}>` : ""}`] : (e = Ee(e), t ? e : [`${r}=`, e]);
}
function md(r, e) {
  process.env.NODE_ENV !== "production" && r !== void 0 && (typeof r != "number" ? j(`${e} is not a valid number - got ${JSON.stringify(r)}.`) : isNaN(r) && j(`${e} is NaN - the duration expression might be incorrect.`));
}
const cP = {
  SETUP_FUNCTION: 0,
  0: "SETUP_FUNCTION",
  RENDER_FUNCTION: 1,
  1: "RENDER_FUNCTION",
  WATCH_GETTER: 2,
  2: "WATCH_GETTER",
  WATCH_CALLBACK: 3,
  3: "WATCH_CALLBACK",
  WATCH_CLEANUP: 4,
  4: "WATCH_CLEANUP",
  NATIVE_EVENT_HANDLER: 5,
  5: "NATIVE_EVENT_HANDLER",
  COMPONENT_EVENT_HANDLER: 6,
  6: "COMPONENT_EVENT_HANDLER",
  VNODE_HOOK: 7,
  7: "VNODE_HOOK",
  DIRECTIVE_HOOK: 8,
  8: "DIRECTIVE_HOOK",
  TRANSITION_HOOK: 9,
  9: "TRANSITION_HOOK",
  APP_ERROR_HANDLER: 10,
  10: "APP_ERROR_HANDLER",
  APP_WARN_HANDLER: 11,
  11: "APP_WARN_HANDLER",
  FUNCTION_REF: 12,
  12: "FUNCTION_REF",
  ASYNC_COMPONENT_LOADER: 13,
  13: "ASYNC_COMPONENT_LOADER",
  SCHEDULER: 14,
  14: "SCHEDULER",
  COMPONENT_UPDATE: 15,
  15: "COMPONENT_UPDATE"
}, ic = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update"
};
function Kr(r, e, t, s) {
  try {
    return s ? r(...s) : r();
  } catch (i) {
    ci(i, e, t);
  }
}
function ar(r, e, t, s) {
  if (fe(r)) {
    const i = Kr(r, e, t, s);
    return i && es(i) && i.catch((n) => {
      ci(n, e, t);
    }), i;
  }
  if (se(r)) {
    const i = [];
    for (let n = 0; n < r.length; n++)
      i.push(ar(r[n], e, t, s));
    return i;
  } else process.env.NODE_ENV !== "production" && j(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof r}`
  );
}
function ci(r, e, t, s = !0) {
  const i = e ? e.vnode : null;
  if (e) {
    let n = e.parent;
    const a = e.proxy, o = process.env.NODE_ENV !== "production" ? ic[t] : `https://vuejs.org/error-reference/#runtime-${t}`;
    for (; n; ) {
      const l = n.ec;
      if (l) {
        for (let c = 0; c < l.length; c++)
          if (l[c](r, a, o) === !1)
            return;
      }
      n = n.parent;
    }
    const u = e.appContext.config.errorHandler;
    if (u) {
      Os(), Kr(
        u,
        null,
        10,
        [r, a, o]
      ), Is();
      return;
    }
  }
  fP(r, t, i, s);
}
function fP(r, e, t, s = !0) {
  if (process.env.NODE_ENV !== "production") {
    const i = ic[e];
    if (t && Da(t), j(`Unhandled error${i ? ` during execution of ${i}` : ""}`), t && La(), s)
      throw r;
    console.error(r);
  } else
    console.error(r);
}
let eo = !1, cp = !1;
const Dt = [];
let Fr = 0;
const vn = [];
let qs = null, xi = 0;
const Zb = /* @__PURE__ */ Promise.resolve();
let gd = null;
const pP = 100;
function nc(r) {
  const e = gd || Zb;
  return r ? e.then(this ? r.bind(this) : r) : e;
}
function hP(r) {
  let e = Fr + 1, t = Dt.length;
  for (; e < t; ) {
    const s = e + t >>> 1, i = Dt[s], n = ro(i);
    n < r || n === r && i.pre ? e = s + 1 : t = s;
  }
  return e;
}
function No(r) {
  (!Dt.length || !Dt.includes(
    r,
    eo && r.allowRecurse ? Fr + 1 : Fr
  )) && (r.id == null ? Dt.push(r) : Dt.splice(hP(r.id), 0, r), ev());
}
function ev() {
  !eo && !cp && (cp = !0, gd = Zb.then(tv));
}
function dP(r) {
  const e = Dt.indexOf(r);
  e > Fr && Dt.splice(e, 1);
}
function to(r) {
  se(r) ? vn.push(...r) : (!qs || !qs.includes(
    r,
    r.allowRecurse ? xi + 1 : xi
  )) && vn.push(r), ev();
}
function bg(r, e, t = eo ? Fr + 1 : 0) {
  for (process.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()); t < Dt.length; t++) {
    const s = Dt[t];
    if (s && s.pre) {
      if (r && s.id !== r.uid || process.env.NODE_ENV !== "production" && yd(e, s))
        continue;
      Dt.splice(t, 1), t--, s();
    }
  }
}
function tl(r) {
  if (vn.length) {
    const e = [...new Set(vn)].sort(
      (t, s) => ro(t) - ro(s)
    );
    if (vn.length = 0, qs) {
      qs.push(...e);
      return;
    }
    for (qs = e, process.env.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()), xi = 0; xi < qs.length; xi++) {
      const t = qs[xi];
      process.env.NODE_ENV !== "production" && yd(r, t) || t.active !== !1 && t();
    }
    qs = null, xi = 0;
  }
}
const ro = (r) => r.id == null ? 1 / 0 : r.id, mP = (r, e) => {
  const t = ro(r) - ro(e);
  if (t === 0) {
    if (r.pre && !e.pre) return -1;
    if (e.pre && !r.pre) return 1;
  }
  return t;
};
function tv(r) {
  cp = !1, eo = !0, process.env.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()), Dt.sort(mP);
  const e = process.env.NODE_ENV !== "production" ? (t) => yd(r, t) : Ge;
  try {
    for (Fr = 0; Fr < Dt.length; Fr++) {
      const t = Dt[Fr];
      if (t && t.active !== !1) {
        if (process.env.NODE_ENV !== "production" && e(t))
          continue;
        Kr(
          t,
          t.i,
          t.i ? 15 : 14
        );
      }
    }
  } finally {
    Fr = 0, Dt.length = 0, tl(r), eo = !1, gd = null, (Dt.length || vn.length) && tv(r);
  }
}
function yd(r, e) {
  if (!r.has(e))
    r.set(e, 1);
  else {
    const t = r.get(e);
    if (t > pP) {
      const s = e.i, i = s && ao(s.type);
      return ci(
        `Maximum recursive updates exceeded${i ? ` in component <${i}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      ), !0;
    } else
      r.set(e, t + 1);
  }
}
let ei = !1;
const Cu = /* @__PURE__ */ new Map();
process.env.NODE_ENV !== "production" && (Zl().__VUE_HMR_RUNTIME__ = {
  createRecord: Ef(rv),
  rerender: Ef(bP),
  reload: Ef(vP)
});
const Hi = /* @__PURE__ */ new Map();
function gP(r) {
  const e = r.type.__hmrId;
  let t = Hi.get(e);
  t || (rv(e, r.type), t = Hi.get(e)), t.instances.add(r);
}
function yP(r) {
  Hi.get(r.type.__hmrId).instances.delete(r);
}
function rv(r, e) {
  return Hi.has(r) ? !1 : (Hi.set(r, {
    initialDef: rl(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function rl(r) {
  return nE(r) ? r.__vccOpts : r;
}
function bP(r, e) {
  const t = Hi.get(r);
  t && (t.initialDef.render = e, [...t.instances].forEach((s) => {
    e && (s.render = e, rl(s.type).render = e), s.renderCache = [], ei = !0, s.effect.dirty = !0, s.update(), ei = !1;
  }));
}
function vP(r, e) {
  const t = Hi.get(r);
  if (!t) return;
  e = rl(e), vg(t.initialDef, e);
  const s = [...t.instances];
  for (let i = 0; i < s.length; i++) {
    const n = s[i], a = rl(n.type);
    let o = Cu.get(a);
    o || (a !== t.initialDef && vg(a, e), Cu.set(a, o = /* @__PURE__ */ new Set())), o.add(n), n.appContext.propsCache.delete(n.type), n.appContext.emitsCache.delete(n.type), n.appContext.optionsCache.delete(n.type), n.ceReload ? (o.add(n), n.ceReload(e.styles), o.delete(n)) : n.parent ? (n.parent.effect.dirty = !0, No(() => {
      n.parent.update(), o.delete(n);
    })) : n.appContext.reload ? n.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    );
  }
  to(() => {
    Cu.clear();
  });
}
function vg(r, e) {
  Be(r, e);
  for (const t in r)
    t !== "__file" && !(t in e) && delete r[t];
}
function Ef(r) {
  return (e, t) => {
    try {
      return r(e, t);
    } catch (s) {
      console.error(s), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let Tr, Aa = [], fp = !1;
function Oo(r, ...e) {
  Tr ? Tr.emit(r, ...e) : fp || Aa.push({ event: r, args: e });
}
function bd(r, e) {
  var t, s;
  Tr = r, Tr ? (Tr.enabled = !0, Aa.forEach(({ event: i, args: n }) => Tr.emit(i, ...n)), Aa = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((s = (t = window.navigator) == null ? void 0 : t.userAgent) != null && s.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((n) => {
    bd(n, e);
  }), setTimeout(() => {
    Tr || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, fp = !0, Aa = []);
  }, 3e3)) : (fp = !0, Aa = []);
}
function EP(r, e) {
  Oo("app:init", r, e, {
    Fragment: ct,
    Text: Xr,
    Comment: Je,
    Static: Es
  });
}
function SP(r) {
  Oo("app:unmount", r);
}
const pp = /* @__PURE__ */ vd(
  "component:added"
  /* COMPONENT_ADDED */
), sv = /* @__PURE__ */ vd(
  "component:updated"
  /* COMPONENT_UPDATED */
), _P = /* @__PURE__ */ vd(
  "component:removed"
  /* COMPONENT_REMOVED */
), xP = (r) => {
  Tr && typeof Tr.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !Tr.cleanupBuffer(r) && _P(r);
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function vd(r) {
  return (e) => {
    Oo(
      r,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
const wP = /* @__PURE__ */ iv(
  "perf:start"
  /* PERFORMANCE_START */
), TP = /* @__PURE__ */ iv(
  "perf:end"
  /* PERFORMANCE_END */
);
function iv(r) {
  return (e, t, s) => {
    Oo(r, e.appContext.app, e.uid, e, t, s);
  };
}
function PP(r, e, t) {
  Oo(
    "component:emit",
    r.appContext.app,
    r,
    e,
    t
  );
}
let st = null, ac = null;
function so(r) {
  const e = st;
  return st = r, ac = r && r.type.__scopeId || null, e;
}
function AP(r) {
  ac = r;
}
function CP() {
  ac = null;
}
const NP = (r) => Ed;
function Ed(r, e = st, t) {
  if (!e || r._n)
    return r;
  const s = (...i) => {
    s._d && _p(-1);
    const n = so(e);
    let a;
    try {
      a = r(...i);
    } finally {
      so(n), s._d && _p(1);
    }
    return process.env.NODE_ENV !== "production" && sv(e), a;
  };
  return s._n = !0, s._c = !0, s._d = !0, s;
}
function nv(r) {
  Xw(r) && j("Do not use built-in directive ids as custom directive id: " + r);
}
function OP(r, e) {
  if (st === null)
    return process.env.NODE_ENV !== "production" && j("withDirectives can only be used inside render functions."), r;
  const t = Mo(st), s = r.dirs || (r.dirs = []);
  for (let i = 0; i < e.length; i++) {
    let [n, a, o, u = Oe] = e[i];
    n && (fe(n) && (n = {
      mounted: n,
      updated: n
    }), n.deep && Xs(a), s.push({
      dir: n,
      instance: t,
      value: a,
      oldValue: void 0,
      arg: o,
      modifiers: u
    }));
  }
  return r;
}
function Mr(r, e, t, s) {
  const i = r.dirs, n = e && e.dirs;
  for (let a = 0; a < i.length; a++) {
    const o = i[a];
    n && (o.oldValue = n[a].value);
    let u = o.dir[s];
    u && (Os(), ar(u, t, 8, [
      r.el,
      o,
      r,
      e
    ]), Is());
  }
}
const Hs = Symbol("_leaveCb"), tu = Symbol("_enterCb");
function Sd() {
  const r = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return Io(() => {
    r.isMounted = !0;
  }), cc(() => {
    r.isUnmounting = !0;
  }), r;
}
const pr = [Function, Array], _d = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: pr,
  onEnter: pr,
  onAfterEnter: pr,
  onEnterCancelled: pr,
  // leave
  onBeforeLeave: pr,
  onLeave: pr,
  onAfterLeave: pr,
  onLeaveCancelled: pr,
  // appear
  onBeforeAppear: pr,
  onAppear: pr,
  onAfterAppear: pr,
  onAppearCancelled: pr
}, av = (r) => {
  const e = r.subTree;
  return e.component ? av(e.component) : e;
}, IP = {
  name: "BaseTransition",
  props: _d,
  setup(r, { slots: e }) {
    const t = is(), s = Sd();
    return () => {
      const i = e.default && oc(e.default(), !0);
      if (!i || !i.length)
        return;
      let n = i[0];
      if (i.length > 1) {
        let p = !1;
        for (const h of i)
          if (h.type !== Je) {
            if (process.env.NODE_ENV !== "production" && p) {
              j(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            if (n = h, p = !0, process.env.NODE_ENV === "production") break;
          }
      }
      const a = Ee(r), { mode: o } = a;
      if (process.env.NODE_ENV !== "production" && o && o !== "in-out" && o !== "out-in" && o !== "default" && j(`invalid <transition> mode: ${o}`), s.isLeaving)
        return Sf(n);
      const u = Eg(n);
      if (!u)
        return Sf(n);
      let l = Nn(
        u,
        a,
        s,
        t,
        // #11061, ensure enterHooks is fresh after clone
        (p) => l = p
      );
      ni(u, l);
      const c = t.subTree, f = c && Eg(c);
      if (f && f.type !== Je && !Pr(u, f) && av(t).type !== Je) {
        const p = Nn(
          f,
          a,
          s,
          t
        );
        if (ni(f, p), o === "out-in" && u.type !== Je)
          return s.isLeaving = !0, p.afterLeave = () => {
            s.isLeaving = !1, t.update.active !== !1 && (t.effect.dirty = !0, t.update());
          }, Sf(n);
        o === "in-out" && u.type !== Je && (p.delayLeave = (h, m, d) => {
          const y = uv(
            s,
            f
          );
          y[String(f.key)] = f, h[Hs] = () => {
            m(), h[Hs] = void 0, delete l.delayedLeave;
          }, l.delayedLeave = d;
        });
      }
      return n;
    };
  }
}, ov = IP;
function uv(r, e) {
  const { leavingVNodes: t } = r;
  let s = t.get(e.type);
  return s || (s = /* @__PURE__ */ Object.create(null), t.set(e.type, s)), s;
}
function Nn(r, e, t, s, i) {
  const {
    appear: n,
    mode: a,
    persisted: o = !1,
    onBeforeEnter: u,
    onEnter: l,
    onAfterEnter: c,
    onEnterCancelled: f,
    onBeforeLeave: p,
    onLeave: h,
    onAfterLeave: m,
    onLeaveCancelled: d,
    onBeforeAppear: y,
    onAppear: S,
    onAfterAppear: E,
    onAppearCancelled: g
  } = e, b = String(r.key), v = uv(t, r), A = (_, T) => {
    _ && ar(
      _,
      s,
      9,
      T
    );
  }, C = (_, T) => {
    const P = T[1];
    A(_, T), se(_) ? _.every((I) => I.length <= 1) && P() : _.length <= 1 && P();
  }, x = {
    mode: a,
    persisted: o,
    beforeEnter(_) {
      let T = u;
      if (!t.isMounted)
        if (n)
          T = y || u;
        else
          return;
      _[Hs] && _[Hs](
        !0
        /* cancelled */
      );
      const P = v[b];
      P && Pr(r, P) && P.el[Hs] && P.el[Hs](), A(T, [_]);
    },
    enter(_) {
      let T = l, P = c, I = f;
      if (!t.isMounted)
        if (n)
          T = S || l, P = E || c, I = g || f;
        else
          return;
      let $ = !1;
      const Y = _[tu] = (W) => {
        $ || ($ = !0, W ? A(I, [_]) : A(P, [_]), x.delayedLeave && x.delayedLeave(), _[tu] = void 0);
      };
      T ? C(T, [_, Y]) : Y();
    },
    leave(_, T) {
      const P = String(r.key);
      if (_[tu] && _[tu](
        !0
        /* cancelled */
      ), t.isUnmounting)
        return T();
      A(p, [_]);
      let I = !1;
      const $ = _[Hs] = (Y) => {
        I || (I = !0, T(), Y ? A(d, [_]) : A(m, [_]), _[Hs] = void 0, v[P] === r && delete v[P]);
      };
      v[P] = r, h ? C(h, [_, $]) : $();
    },
    clone(_) {
      const T = Nn(
        _,
        e,
        t,
        s,
        i
      );
      return i && i(T), T;
    }
  };
  return x;
}
function Sf(r) {
  if (Gn(r))
    return r = yr(r), r.children = null, r;
}
function Eg(r) {
  if (!Gn(r))
    return r;
  if (process.env.NODE_ENV !== "production" && r.component)
    return r.component.subTree;
  const { shapeFlag: e, children: t } = r;
  if (t) {
    if (e & 16)
      return t[0];
    if (e & 32 && fe(t.default))
      return t.default();
  }
}
function ni(r, e) {
  r.shapeFlag & 6 && r.component ? ni(r.component.subTree, e) : r.shapeFlag & 128 ? (r.ssContent.transition = e.clone(r.ssContent), r.ssFallback.transition = e.clone(r.ssFallback)) : r.transition = e;
}
function oc(r, e = !1, t) {
  let s = [], i = 0;
  for (let n = 0; n < r.length; n++) {
    let a = r[n];
    const o = t == null ? a.key : String(t) + String(a.key != null ? a.key : n);
    a.type === ct ? (a.patchFlag & 128 && i++, s = s.concat(
      oc(a.children, e, o)
    )) : (e || a.type !== Je) && s.push(o != null ? yr(a, { key: o }) : a);
  }
  if (i > 1)
    for (let n = 0; n < s.length; n++)
      s[n].patchFlag = -2;
  return s;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function xd(r, e) {
  return fe(r) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Be({ name: r.name }, e, { setup: r })
  ) : r;
}
const Di = (r) => !!r.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function kP(r) {
  fe(r) && (r = { loader: r });
  const {
    loader: e,
    loadingComponent: t,
    errorComponent: s,
    delay: i = 200,
    timeout: n,
    // undefined = never times out
    suspensible: a = !0,
    onError: o
  } = r;
  let u = null, l, c = 0;
  const f = () => (c++, u = null, p()), p = () => {
    let h;
    return u || (h = u = e().catch((m) => {
      if (m = m instanceof Error ? m : new Error(String(m)), o)
        return new Promise((d, y) => {
          o(m, () => d(f()), () => y(m), c + 1);
        });
      throw m;
    }).then((m) => {
      if (h !== u && u)
        return u;
      if (process.env.NODE_ENV !== "production" && !m && j(
        "Async component loader resolved to undefined. If you are using retry(), make sure to return its return value."
      ), m && (m.__esModule || m[Symbol.toStringTag] === "Module") && (m = m.default), process.env.NODE_ENV !== "production" && m && !Ae(m) && !fe(m))
        throw new Error(`Invalid async component load result: ${m}`);
      return l = m, m;
    }));
  };
  return /* @__PURE__ */ xd({
    name: "AsyncComponentWrapper",
    __asyncLoader: p,
    get __asyncResolved() {
      return l;
    },
    setup() {
      const h = nt;
      if (l)
        return () => _f(l, h);
      const m = (E) => {
        u = null, ci(
          E,
          h,
          13,
          !s
        );
      };
      if (a && h.suspense || Lo)
        return p().then((E) => () => _f(E, h)).catch((E) => (m(E), () => s ? He(s, {
          error: E
        }) : null));
      const d = Ii(!1), y = Ii(), S = Ii(!!i);
      return i && setTimeout(() => {
        S.value = !1;
      }, i), n != null && setTimeout(() => {
        if (!d.value && !y.value) {
          const E = new Error(
            `Async component timed out after ${n}ms.`
          );
          m(E), y.value = E;
        }
      }, n), p().then(() => {
        d.value = !0, h.parent && Gn(h.parent.vnode) && (h.parent.effect.dirty = !0, No(h.parent.update));
      }).catch((E) => {
        m(E), y.value = E;
      }), () => {
        if (d.value && l)
          return _f(l, h);
        if (y.value && s)
          return He(s, {
            error: y.value
          });
        if (t && !S.value)
          return He(t);
      };
    }
  });
}
function _f(r, e) {
  const { ref: t, props: s, children: i, ce: n } = e.vnode, a = He(r, s, i);
  return a.ref = t, a.ce = n, delete e.vnode.ce, a;
}
const Gn = (r) => r.type.__isKeepAlive, DP = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: !0,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(r, { slots: e }) {
    const t = is(), s = t.ctx;
    if (!s.renderer)
      return () => {
        const E = e.default && e.default();
        return E && E.length === 1 ? E[0] : E;
      };
    const i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set();
    let a = null;
    process.env.NODE_ENV !== "production" && (t.__v_cache = i);
    const o = t.suspense, {
      renderer: {
        p: u,
        m: l,
        um: c,
        o: { createElement: f }
      }
    } = s, p = f("div");
    s.activate = (E, g, b, v, A) => {
      const C = E.component;
      l(E, g, b, 0, o), u(
        C.vnode,
        E,
        g,
        b,
        C,
        o,
        v,
        E.slotScopeIds,
        A
      ), mt(() => {
        C.isDeactivated = !1, C.a && Gs(C.a);
        const x = E.props && E.props.onVnodeMounted;
        x && Kt(x, C.parent, E);
      }, o), process.env.NODE_ENV !== "production" && pp(C);
    }, s.deactivate = (E) => {
      const g = E.component;
      ol(g.m), ol(g.a), l(E, p, null, 1, o), mt(() => {
        g.da && Gs(g.da);
        const b = E.props && E.props.onVnodeUnmounted;
        b && Kt(b, g.parent, E), g.isDeactivated = !0;
      }, o), process.env.NODE_ENV !== "production" && pp(g);
    };
    function h(E) {
      xf(E), c(E, t, o, !0);
    }
    function m(E) {
      i.forEach((g, b) => {
        const v = ao(g.type);
        v && (!E || !E(v)) && d(b);
      });
    }
    function d(E) {
      const g = i.get(E);
      g && (!a || !Pr(g, a)) ? h(g) : a && xf(a), i.delete(E), n.delete(E);
    }
    Fa(
      () => [r.include, r.exclude],
      ([E, g]) => {
        E && m((b) => Ca(E, b)), g && m((b) => !Ca(g, b));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: !0 }
    );
    let y = null;
    const S = () => {
      y != null && (Ep(t.subTree.type) ? mt(() => {
        i.set(y, ru(t.subTree));
      }, t.subTree.suspense) : i.set(y, ru(t.subTree)));
    };
    return Io(S), lc(S), cc(() => {
      i.forEach((E) => {
        const { subTree: g, suspense: b } = t, v = ru(g);
        if (E.type === v.type && E.key === v.key) {
          xf(v);
          const A = v.component.da;
          A && mt(A, b);
          return;
        }
        h(E);
      });
    }), () => {
      if (y = null, !e.default)
        return null;
      const E = e.default(), g = E[0];
      if (E.length > 1)
        return process.env.NODE_ENV !== "production" && j("KeepAlive should contain exactly one component child."), a = null, E;
      if (!ws(g) || !(g.shapeFlag & 4) && !(g.shapeFlag & 128))
        return a = null, g;
      let b = ru(g);
      if (b.type === Je)
        return a = null, b;
      const v = b.type, A = ao(
        Di(b) ? b.type.__asyncResolved || {} : v
      ), { include: C, exclude: x, max: _ } = r;
      if (C && (!A || !Ca(C, A)) || x && A && Ca(x, A))
        return a = b, g;
      const T = b.key == null ? v : b.key, P = i.get(T);
      return b.el && (b = yr(b), g.shapeFlag & 128 && (g.ssContent = b)), y = T, P ? (b.el = P.el, b.component = P.component, b.transition && ni(b, b.transition), b.shapeFlag |= 512, n.delete(T), n.add(T)) : (n.add(T), _ && n.size > parseInt(_, 10) && d(n.values().next().value)), b.shapeFlag |= 256, a = b, Ep(g.type) ? g : b;
    };
  }
}, LP = DP;
function Ca(r, e) {
  return se(r) ? r.some((t) => Ca(t, e)) : _e(r) ? r.split(",").includes(e) : Kw(r) ? r.test(e) : !1;
}
function lv(r, e) {
  fv(r, "a", e);
}
function cv(r, e) {
  fv(r, "da", e);
}
function fv(r, e, t = nt) {
  const s = r.__wdc || (r.__wdc = () => {
    let i = t;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return r();
  });
  if (uc(e, s, t), t) {
    let i = t.parent;
    for (; i && i.parent; )
      Gn(i.parent.vnode) && MP(s, e, t, i), i = i.parent;
  }
}
function MP(r, e, t, s) {
  const i = uc(
    e,
    r,
    s,
    !0
    /* prepend */
  );
  fc(() => {
    td(s[e], i);
  }, t);
}
function xf(r) {
  r.shapeFlag &= -257, r.shapeFlag &= -513;
}
function ru(r) {
  return r.shapeFlag & 128 ? r.ssContent : r;
}
function uc(r, e, t = nt, s = !1) {
  if (t) {
    const i = t[r] || (t[r] = []), n = e.__weh || (e.__weh = (...a) => {
      Os();
      const o = zi(t), u = ar(e, t, r, a);
      return o(), Is(), u;
    });
    return s ? i.unshift(n) : i.push(n), n;
  } else if (process.env.NODE_ENV !== "production") {
    const i = ps(ic[r].replace(/ hook$/, ""));
    j(
      `${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const ks = (r) => (e, t = nt) => {
  (!Lo || r === "sp") && uc(r, (...s) => e(...s), t);
}, wd = ks("bm"), Io = ks("m"), pv = ks("bu"), lc = ks("u"), cc = ks("bum"), fc = ks("um"), hv = ks("sp"), dv = ks(
  "rtg"
), mv = ks(
  "rtc"
);
function gv(r, e = nt) {
  uc("ec", r, e);
}
const sl = "components", RP = "directives";
function $P(r, e) {
  return Pd(sl, r, !0, e) || r;
}
const Td = Symbol.for("v-ndc");
function FP(r) {
  return _e(r) ? Pd(sl, r, !1) || r : r || Td;
}
function BP(r) {
  return Pd(RP, r);
}
function Pd(r, e, t = !0, s = !1) {
  const i = st || nt;
  if (i) {
    const n = i.type;
    if (r === sl) {
      const o = ao(
        n,
        !1
      );
      if (o && (o === e || o === Et(e) || o === ii(Et(e))))
        return n;
    }
    const a = (
      // local registration
      // check instance[type] first which is resolved for options API
      Sg(i[r] || n[r], e) || // global registration
      Sg(i.appContext[r], e)
    );
    if (!a && s)
      return n;
    if (process.env.NODE_ENV !== "production" && t && !a) {
      const o = r === sl ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      j(`Failed to resolve ${r.slice(0, -1)}: ${e}${o}`);
    }
    return a;
  } else process.env.NODE_ENV !== "production" && j(
    `resolve${ii(r.slice(0, -1))} can only be used in render() or setup().`
  );
}
function Sg(r, e) {
  return r && (r[e] || r[Et(e)] || r[ii(Et(e))]);
}
function VP(r, e, t, s) {
  let i;
  const n = t && t[s];
  if (se(r) || _e(r)) {
    i = new Array(r.length);
    for (let a = 0, o = r.length; a < o; a++)
      i[a] = e(r[a], a, void 0, n && n[a]);
  } else if (typeof r == "number") {
    process.env.NODE_ENV !== "production" && !Number.isInteger(r) && j(`The v-for range expect an integer value but got ${r}.`), i = new Array(r);
    for (let a = 0; a < r; a++)
      i[a] = e(a + 1, a, void 0, n && n[a]);
  } else if (Ae(r))
    if (r[Symbol.iterator])
      i = Array.from(
        r,
        (a, o) => e(a, o, void 0, n && n[o])
      );
    else {
      const a = Object.keys(r);
      i = new Array(a.length);
      for (let o = 0, u = a.length; o < u; o++) {
        const l = a[o];
        i[o] = e(r[l], l, o, n && n[o]);
      }
    }
  else
    i = [];
  return t && (t[s] = i), i;
}
function UP(r, e) {
  for (let t = 0; t < e.length; t++) {
    const s = e[t];
    if (se(s))
      for (let i = 0; i < s.length; i++)
        r[s[i].name] = s[i].fn;
    else s && (r[s.name] = s.key ? (...i) => {
      const n = s.fn(...i);
      return n && (n.key = s.key), n;
    } : s.fn);
  }
  return r;
}
function jP(r, e, t = {}, s, i) {
  if (st.isCE || st.parent && Di(st.parent) && st.parent.isCE)
    return e !== "default" && (t.name = e), He("slot", t, s && s());
  let n = r[e];
  process.env.NODE_ENV !== "production" && n && n.length > 1 && (j(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), n = () => []), n && n._c && (n._d = !1), dc();
  const a = n && Ad(n(t)), o = kd(
    ct,
    {
      key: (t.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      a && a.key || `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!a && s ? "_fb" : "")
    },
    a || (s ? s() : []),
    a && r._ === 1 ? 64 : -2
  );
  return !i && o.scopeId && (o.slotScopeIds = [o.scopeId + "-s"]), n && n._c && (n._d = !0), o;
}
function Ad(r) {
  return r.some((e) => ws(e) ? !(e.type === Je || e.type === ct && !Ad(e.children)) : !0) ? r : null;
}
function qP(r, e) {
  const t = {};
  if (process.env.NODE_ENV !== "production" && !Ae(r))
    return j("v-on with no argument expects an object value."), t;
  for (const s in r)
    t[e && /[A-Z]/.test(s) ? `on:${s}` : ps(s)] = r[s];
  return t;
}
const hp = (r) => r ? tE(r) ? Mo(r) : hp(r.parent) : null, Li = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Be(/* @__PURE__ */ Object.create(null), {
    $: (r) => r,
    $el: (r) => r.vnode.el,
    $data: (r) => r.data,
    $props: (r) => process.env.NODE_ENV !== "production" ? Ar(r.props) : r.props,
    $attrs: (r) => process.env.NODE_ENV !== "production" ? Ar(r.attrs) : r.attrs,
    $slots: (r) => process.env.NODE_ENV !== "production" ? Ar(r.slots) : r.slots,
    $refs: (r) => process.env.NODE_ENV !== "production" ? Ar(r.refs) : r.refs,
    $parent: (r) => hp(r.parent),
    $root: (r) => hp(r.root),
    $emit: (r) => r.emit,
    $options: (r) => Nd(r),
    $forceUpdate: (r) => r.f || (r.f = () => {
      r.effect.dirty = !0, No(r.update);
    }),
    $nextTick: (r) => r.n || (r.n = nc.bind(r.proxy)),
    $watch: (r) => j3.bind(r)
  })
), Cd = (r) => r === "_" || r === "$", wf = (r, e) => r !== Oe && !r.__isScriptSetup && Pe(r, e), Ma = {
  get({ _: r }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: t, setupState: s, data: i, props: n, accessCache: a, type: o, appContext: u } = r;
    if (process.env.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    let l;
    if (e[0] !== "$") {
      const h = a[e];
      if (h !== void 0)
        switch (h) {
          case 1:
            return s[e];
          case 2:
            return i[e];
          case 4:
            return t[e];
          case 3:
            return n[e];
        }
      else {
        if (wf(s, e))
          return a[e] = 1, s[e];
        if (i !== Oe && Pe(i, e))
          return a[e] = 2, i[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (l = r.propsOptions[0]) && Pe(l, e)
        )
          return a[e] = 3, n[e];
        if (t !== Oe && Pe(t, e))
          return a[e] = 4, t[e];
        dp && (a[e] = 0);
      }
    }
    const c = Li[e];
    let f, p;
    if (c)
      return e === "$attrs" ? (Ct(r.attrs, "get", ""), process.env.NODE_ENV !== "production" && ul()) : process.env.NODE_ENV !== "production" && e === "$slots" && Ct(r, "get", e), c(r);
    if (
      // css module (injected by vue-loader)
      (f = o.__cssModules) && (f = f[e])
    )
      return f;
    if (t !== Oe && Pe(t, e))
      return a[e] = 4, t[e];
    if (
      // global properties
      p = u.config.globalProperties, Pe(p, e)
    )
      return p[e];
    process.env.NODE_ENV !== "production" && st && (!_e(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (i !== Oe && Cd(e[0]) && Pe(i, e) ? j(
      `Property ${JSON.stringify(
        e
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : r === st && j(
      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: r }, e, t) {
    const { data: s, setupState: i, ctx: n } = r;
    return wf(i, e) ? (i[e] = t, !0) : process.env.NODE_ENV !== "production" && i.__isScriptSetup && Pe(i, e) ? (j(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : s !== Oe && Pe(s, e) ? (s[e] = t, !0) : Pe(r.props, e) ? (process.env.NODE_ENV !== "production" && j(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in r ? (process.env.NODE_ENV !== "production" && j(
      `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
    ), !1) : (process.env.NODE_ENV !== "production" && e in r.appContext.config.globalProperties ? Object.defineProperty(n, e, {
      enumerable: !0,
      configurable: !0,
      value: t
    }) : n[e] = t, !0);
  },
  has({
    _: { data: r, setupState: e, accessCache: t, ctx: s, appContext: i, propsOptions: n }
  }, a) {
    let o;
    return !!t[a] || r !== Oe && Pe(r, a) || wf(e, a) || (o = n[0]) && Pe(o, a) || Pe(s, a) || Pe(Li, a) || Pe(i.config.globalProperties, a);
  },
  defineProperty(r, e, t) {
    return t.get != null ? r._.accessCache[e] = 0 : Pe(t, "value") && this.set(r, e, t.value, null), Reflect.defineProperty(r, e, t);
  }
};
process.env.NODE_ENV !== "production" && (Ma.ownKeys = (r) => (j(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(r)));
const HP = /* @__PURE__ */ Be(
  {},
  Ma,
  {
    get(r, e) {
      if (e !== Symbol.unscopables)
        return Ma.get(r, e, r);
    },
    has(r, e) {
      const t = e[0] !== "_" && !Zw(e);
      return process.env.NODE_ENV !== "production" && !t && Ma.has(r, e) && j(
        `Property ${JSON.stringify(
          e
        )} should not start with _ which is a reserved prefix for Vue internals.`
      ), t;
    }
  }
);
function WP(r) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => r
  }), Object.keys(Li).forEach((t) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      get: () => Li[t](r),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: Ge
    });
  }), e;
}
function zP(r) {
  const {
    ctx: e,
    propsOptions: [t]
  } = r;
  t && Object.keys(t).forEach((s) => {
    Object.defineProperty(e, s, {
      enumerable: !0,
      configurable: !0,
      get: () => r.props[s],
      set: Ge
    });
  });
}
function GP(r) {
  const { ctx: e, setupState: t } = r;
  Object.keys(Ee(t)).forEach((s) => {
    if (!t.__isScriptSetup) {
      if (Cd(s[0])) {
        j(
          `setup() return property ${JSON.stringify(
            s
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(e, s, {
        enumerable: !0,
        configurable: !0,
        get: () => t[s],
        set: Ge
      });
    }
  });
}
const tn = (r) => j(
  `${r}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
);
function KP() {
  return process.env.NODE_ENV !== "production" && tn("defineProps"), null;
}
function XP() {
  return process.env.NODE_ENV !== "production" && tn("defineEmits"), null;
}
function JP(r) {
  process.env.NODE_ENV !== "production" && tn("defineExpose");
}
function YP(r) {
  process.env.NODE_ENV !== "production" && tn("defineOptions");
}
function QP() {
  return process.env.NODE_ENV !== "production" && tn("defineSlots"), null;
}
function ZP() {
  process.env.NODE_ENV !== "production" && tn("defineModel");
}
function e3(r, e) {
  return process.env.NODE_ENV !== "production" && tn("withDefaults"), null;
}
function t3() {
  return yv().slots;
}
function r3() {
  return yv().attrs;
}
function yv() {
  const r = is();
  return process.env.NODE_ENV !== "production" && !r && j("useContext() called without active instance."), r.setupContext || (r.setupContext = iE(r));
}
function io(r) {
  return se(r) ? r.reduce(
    (e, t) => (e[t] = null, e),
    {}
  ) : r;
}
function s3(r, e) {
  const t = io(r);
  for (const s in e) {
    if (s.startsWith("__skip")) continue;
    let i = t[s];
    i ? se(i) || fe(i) ? i = t[s] = { type: i, default: e[s] } : i.default = e[s] : i === null ? i = t[s] = { default: e[s] } : process.env.NODE_ENV !== "production" && j(`props default key "${s}" has no corresponding declaration.`), i && e[`__skip_${s}`] && (i.skipFactory = !0);
  }
  return t;
}
function i3(r, e) {
  return !r || !e ? r || e : se(r) && se(e) ? r.concat(e) : Be({}, io(r), io(e));
}
function n3(r, e) {
  const t = {};
  for (const s in r)
    e.includes(s) || Object.defineProperty(t, s, {
      enumerable: !0,
      get: () => r[s]
    });
  return t;
}
function a3(r) {
  const e = is();
  process.env.NODE_ENV !== "production" && !e && j(
    "withAsyncContext called without active current instance. This is likely a bug."
  );
  let t = r();
  return Tp(), es(t) && (t = t.catch((s) => {
    throw zi(e), s;
  })), [t, () => zi(e)];
}
function o3() {
  const r = /* @__PURE__ */ Object.create(null);
  return (e, t) => {
    r[t] ? j(`${e} property "${t}" is already defined in ${r[t]}.`) : r[t] = e;
  };
}
let dp = !0;
function u3(r) {
  const e = Nd(r), t = r.proxy, s = r.ctx;
  dp = !1, e.beforeCreate && _g(e.beforeCreate, r, "bc");
  const {
    // state
    data: i,
    computed: n,
    methods: a,
    watch: o,
    provide: u,
    inject: l,
    // lifecycle
    created: c,
    beforeMount: f,
    mounted: p,
    beforeUpdate: h,
    updated: m,
    activated: d,
    deactivated: y,
    beforeDestroy: S,
    beforeUnmount: E,
    destroyed: g,
    unmounted: b,
    render: v,
    renderTracked: A,
    renderTriggered: C,
    errorCaptured: x,
    serverPrefetch: _,
    // public API
    expose: T,
    inheritAttrs: P,
    // assets
    components: I,
    directives: $,
    filters: Y
  } = e, W = process.env.NODE_ENV !== "production" ? o3() : null;
  if (process.env.NODE_ENV !== "production") {
    const [K] = r.propsOptions;
    if (K)
      for (const Z in K)
        W("Props", Z);
  }
  if (l && l3(l, s, W), a)
    for (const K in a) {
      const Z = a[K];
      fe(Z) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(s, K, {
        value: Z.bind(t),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : s[K] = Z.bind(t), process.env.NODE_ENV !== "production" && W("Methods", K)) : process.env.NODE_ENV !== "production" && j(
        `Method "${K}" has type "${typeof Z}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (i) {
    process.env.NODE_ENV !== "production" && !fe(i) && j(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const K = i.call(t, t);
    if (process.env.NODE_ENV !== "production" && es(K) && j(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !Ae(K))
      process.env.NODE_ENV !== "production" && j("data() should return an object.");
    else if (r.data = rc(K), process.env.NODE_ENV !== "production")
      for (const Z in K)
        W("Data", Z), Cd(Z[0]) || Object.defineProperty(s, Z, {
          configurable: !0,
          enumerable: !0,
          get: () => K[Z],
          set: Ge
        });
  }
  if (dp = !0, n)
    for (const K in n) {
      const Z = n[K], Ce = fe(Z) ? Z.bind(t, t) : fe(Z.get) ? Z.get.bind(t, t) : Ge;
      process.env.NODE_ENV !== "production" && Ce === Ge && j(`Computed property "${K}" has no getter.`);
      const Ve = !fe(Z) && fe(Z.set) ? Z.set.bind(t) : process.env.NODE_ENV !== "production" ? () => {
        j(
          `Write operation failed: computed property "${K}" is readonly.`
        );
      } : Ge, ee = aE({
        get: Ce,
        set: Ve
      });
      Object.defineProperty(s, K, {
        enumerable: !0,
        configurable: !0,
        get: () => ee.value,
        set: (k) => ee.value = k
      }), process.env.NODE_ENV !== "production" && W("Computed", K);
    }
  if (o)
    for (const K in o)
      bv(o[K], s, t, K);
  if (u) {
    const K = fe(u) ? u.call(t) : u;
    Reflect.ownKeys(K).forEach((Z) => {
      Ev(Z, K[Z]);
    });
  }
  c && _g(c, r, "c");
  function F(K, Z) {
    se(Z) ? Z.forEach((Ce) => K(Ce.bind(t))) : Z && K(Z.bind(t));
  }
  if (F(wd, f), F(Io, p), F(pv, h), F(lc, m), F(lv, d), F(cv, y), F(gv, x), F(mv, A), F(dv, C), F(cc, E), F(fc, b), F(hv, _), se(T))
    if (T.length) {
      const K = r.exposed || (r.exposed = {});
      T.forEach((Z) => {
        Object.defineProperty(K, Z, {
          get: () => t[Z],
          set: (Ce) => t[Z] = Ce
        });
      });
    } else r.exposed || (r.exposed = {});
  v && r.render === Ge && (r.render = v), P != null && (r.inheritAttrs = P), I && (r.components = I), $ && (r.directives = $);
}
function l3(r, e, t = Ge) {
  se(r) && (r = mp(r));
  for (const s in r) {
    const i = r[s];
    let n;
    Ae(i) ? "default" in i ? n = Ra(
      i.from || s,
      i.default,
      !0
    ) : n = Ra(i.from || s) : n = Ra(i), pt(n) ? Object.defineProperty(e, s, {
      enumerable: !0,
      configurable: !0,
      get: () => n.value,
      set: (a) => n.value = a
    }) : e[s] = n, process.env.NODE_ENV !== "production" && t("Inject", s);
  }
}
function _g(r, e, t) {
  ar(
    se(r) ? r.map((s) => s.bind(e.proxy)) : r.bind(e.proxy),
    e,
    t
  );
}
function bv(r, e, t, s) {
  const i = s.includes(".") ? jv(t, s) : () => t[s];
  if (_e(r)) {
    const n = e[r];
    fe(n) ? Fa(i, n) : process.env.NODE_ENV !== "production" && j(`Invalid watch handler specified by key "${r}"`, n);
  } else if (fe(r))
    Fa(i, r.bind(t));
  else if (Ae(r))
    if (se(r))
      r.forEach((n) => bv(n, e, t, s));
    else {
      const n = fe(r.handler) ? r.handler.bind(t) : e[r.handler];
      fe(n) ? Fa(i, n, r) : process.env.NODE_ENV !== "production" && j(`Invalid watch handler specified by key "${r.handler}"`, n);
    }
  else process.env.NODE_ENV !== "production" && j(`Invalid watch option: "${s}"`, r);
}
function Nd(r) {
  const e = r.type, { mixins: t, extends: s } = e, {
    mixins: i,
    optionsCache: n,
    config: { optionMergeStrategies: a }
  } = r.appContext, o = n.get(e);
  let u;
  return o ? u = o : !i.length && !t && !s ? u = e : (u = {}, i.length && i.forEach(
    (l) => il(u, l, a, !0)
  ), il(u, e, a)), Ae(e) && n.set(e, u), u;
}
function il(r, e, t, s = !1) {
  const { mixins: i, extends: n } = e;
  n && il(r, n, t, !0), i && i.forEach(
    (a) => il(r, a, t, !0)
  );
  for (const a in e)
    if (s && a === "expose")
      process.env.NODE_ENV !== "production" && j(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const o = c3[a] || t && t[a];
      r[a] = o ? o(r[a], e[a]) : e[a];
    }
  return r;
}
const c3 = {
  data: xg,
  props: wg,
  emits: wg,
  // objects
  methods: Na,
  computed: Na,
  // lifecycle
  beforeCreate: Vt,
  created: Vt,
  beforeMount: Vt,
  mounted: Vt,
  beforeUpdate: Vt,
  updated: Vt,
  beforeDestroy: Vt,
  beforeUnmount: Vt,
  destroyed: Vt,
  unmounted: Vt,
  activated: Vt,
  deactivated: Vt,
  errorCaptured: Vt,
  serverPrefetch: Vt,
  // assets
  components: Na,
  directives: Na,
  // watch
  watch: p3,
  // provide / inject
  provide: xg,
  inject: f3
};
function xg(r, e) {
  return e ? r ? function() {
    return Be(
      fe(r) ? r.call(this, this) : r,
      fe(e) ? e.call(this, this) : e
    );
  } : e : r;
}
function f3(r, e) {
  return Na(mp(r), mp(e));
}
function mp(r) {
  if (se(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++)
      e[r[t]] = r[t];
    return e;
  }
  return r;
}
function Vt(r, e) {
  return r ? [...new Set([].concat(r, e))] : e;
}
function Na(r, e) {
  return r ? Be(/* @__PURE__ */ Object.create(null), r, e) : e;
}
function wg(r, e) {
  return r ? se(r) && se(e) ? [.../* @__PURE__ */ new Set([...r, ...e])] : Be(
    /* @__PURE__ */ Object.create(null),
    io(r),
    io(e ?? {})
  ) : e;
}
function p3(r, e) {
  if (!r) return e;
  if (!e) return r;
  const t = Be(/* @__PURE__ */ Object.create(null), r);
  for (const s in e)
    t[s] = Vt(r[s], e[s]);
  return t;
}
function vv() {
  return {
    app: null,
    config: {
      isNativeTag: zw,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let h3 = 0;
function d3(r, e) {
  return function(s, i = null) {
    fe(s) || (s = Be({}, s)), i != null && !Ae(i) && (process.env.NODE_ENV !== "production" && j("root props passed to app.mount() must be an object."), i = null);
    const n = vv(), a = /* @__PURE__ */ new WeakSet();
    let o = !1;
    const u = n.app = {
      _uid: h3++,
      _component: s,
      _props: i,
      _container: null,
      _context: n,
      _instance: null,
      version: Np,
      get config() {
        return n.config;
      },
      set config(l) {
        process.env.NODE_ENV !== "production" && j(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(l, ...c) {
        return a.has(l) ? process.env.NODE_ENV !== "production" && j("Plugin has already been applied to target app.") : l && fe(l.install) ? (a.add(l), l.install(u, ...c)) : fe(l) ? (a.add(l), l(u, ...c)) : process.env.NODE_ENV !== "production" && j(
          'A plugin must either be a function or an object with an "install" function.'
        ), u;
      },
      mixin(l) {
        return n.mixins.includes(l) ? process.env.NODE_ENV !== "production" && j(
          "Mixin has already been applied to target app" + (l.name ? `: ${l.name}` : "")
        ) : n.mixins.push(l), u;
      },
      component(l, c) {
        return process.env.NODE_ENV !== "production" && Pp(l, n.config), c ? (process.env.NODE_ENV !== "production" && n.components[l] && j(`Component "${l}" has already been registered in target app.`), n.components[l] = c, u) : n.components[l];
      },
      directive(l, c) {
        return process.env.NODE_ENV !== "production" && nv(l), c ? (process.env.NODE_ENV !== "production" && n.directives[l] && j(`Directive "${l}" has already been registered in target app.`), n.directives[l] = c, u) : n.directives[l];
      },
      mount(l, c, f) {
        if (o)
          process.env.NODE_ENV !== "production" && j(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          process.env.NODE_ENV !== "production" && l.__vue_app__ && j(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const p = He(s, i);
          return p.appContext = n, f === !0 ? f = "svg" : f === !1 && (f = void 0), process.env.NODE_ENV !== "production" && (n.reload = () => {
            r(
              yr(p),
              l,
              f
            );
          }), c && e ? e(p, l) : r(p, l, f), o = !0, u._container = l, l.__vue_app__ = u, process.env.NODE_ENV !== "production" && (u._instance = p.component, EP(u, Np)), Mo(p.component);
        }
      },
      unmount() {
        o ? (r(null, u._container), process.env.NODE_ENV !== "production" && (u._instance = null, SP(u)), delete u._container.__vue_app__) : process.env.NODE_ENV !== "production" && j("Cannot unmount an app that is not mounted.");
      },
      provide(l, c) {
        return process.env.NODE_ENV !== "production" && l in n.provides && j(
          `App already provides property with key "${String(l)}". It will be overwritten with the new value.`
        ), n.provides[l] = c, u;
      },
      runWithContext(l) {
        const c = Mi;
        Mi = u;
        try {
          return l();
        } finally {
          Mi = c;
        }
      }
    };
    return u;
  };
}
let Mi = null;
function Ev(r, e) {
  if (!nt)
    process.env.NODE_ENV !== "production" && j("provide() can only be used inside setup().");
  else {
    let t = nt.provides;
    const s = nt.parent && nt.parent.provides;
    s === t && (t = nt.provides = Object.create(s)), t[r] = e;
  }
}
function Ra(r, e, t = !1) {
  const s = nt || st;
  if (s || Mi) {
    const i = Mi ? Mi._context.provides : s ? s.parent == null ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0;
    if (i && r in i)
      return i[r];
    if (arguments.length > 1)
      return t && fe(e) ? e.call(s && s.proxy) : e;
    process.env.NODE_ENV !== "production" && j(`injection "${String(r)}" not found.`);
  } else process.env.NODE_ENV !== "production" && j("inject() can only be used inside setup() or functional components.");
}
function m3() {
  return !!(nt || st || Mi);
}
const Sv = {}, _v = () => Object.create(Sv), xv = (r) => Object.getPrototypeOf(r) === Sv;
function g3(r, e, t, s = !1) {
  const i = {}, n = _v();
  r.propsDefaults = /* @__PURE__ */ Object.create(null), wv(r, e, i, n);
  for (const a in r.propsOptions[0])
    a in i || (i[a] = void 0);
  process.env.NODE_ENV !== "production" && Pv(e || {}, i, r), t ? r.props = s ? i : zb(i) : r.type.props ? r.props = i : r.props = n, r.attrs = n;
}
function y3(r) {
  for (; r; ) {
    if (r.type.__hmrId) return !0;
    r = r.parent;
  }
}
function b3(r, e, t, s) {
  const {
    props: i,
    attrs: n,
    vnode: { patchFlag: a }
  } = r, o = Ee(i), [u] = r.propsOptions;
  let l = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(process.env.NODE_ENV !== "production" && y3(r)) && (s || a > 0) && !(a & 16)
  ) {
    if (a & 8) {
      const c = r.vnode.dynamicProps;
      for (let f = 0; f < c.length; f++) {
        let p = c[f];
        if (pc(r.emitsOptions, p))
          continue;
        const h = e[p];
        if (u)
          if (Pe(n, p))
            h !== n[p] && (n[p] = h, l = !0);
          else {
            const m = Et(p);
            i[m] = gp(
              u,
              o,
              m,
              h,
              r,
              !1
            );
          }
        else
          h !== n[p] && (n[p] = h, l = !0);
      }
    }
  } else {
    wv(r, e, i, n) && (l = !0);
    let c;
    for (const f in o)
      (!e || // for camelCase
      !Pe(e, f) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((c = Tt(f)) === f || !Pe(e, c))) && (u ? t && // for camelCase
      (t[f] !== void 0 || // for kebab-case
      t[c] !== void 0) && (i[f] = gp(
        u,
        o,
        f,
        void 0,
        r,
        !0
      )) : delete i[f]);
    if (n !== o)
      for (const f in n)
        (!e || !Pe(e, f)) && (delete n[f], l = !0);
  }
  l && zr(r.attrs, "set", ""), process.env.NODE_ENV !== "production" && Pv(e || {}, i, r);
}
function wv(r, e, t, s) {
  const [i, n] = r.propsOptions;
  let a = !1, o;
  if (e)
    for (let u in e) {
      if (yn(u))
        continue;
      const l = e[u];
      let c;
      i && Pe(i, c = Et(u)) ? !n || !n.includes(c) ? t[c] = l : (o || (o = {}))[c] = l : pc(r.emitsOptions, u) || (!(u in s) || l !== s[u]) && (s[u] = l, a = !0);
    }
  if (n) {
    const u = Ee(t), l = o || Oe;
    for (let c = 0; c < n.length; c++) {
      const f = n[c];
      t[f] = gp(
        i,
        u,
        f,
        l[f],
        r,
        !Pe(l, f)
      );
    }
  }
  return a;
}
function gp(r, e, t, s, i, n) {
  const a = r[t];
  if (a != null) {
    const o = Pe(a, "default");
    if (o && s === void 0) {
      const u = a.default;
      if (a.type !== Function && !a.skipFactory && fe(u)) {
        const { propsDefaults: l } = i;
        if (t in l)
          s = l[t];
        else {
          const c = zi(i);
          s = l[t] = u.call(
            null,
            e
          ), c();
        }
      } else
        s = u;
    }
    a[
      0
      /* shouldCast */
    ] && (n && !o ? s = !1 : a[
      1
      /* shouldCastTrue */
    ] && (s === "" || s === Tt(t)) && (s = !0));
  }
  return s;
}
const v3 = /* @__PURE__ */ new WeakMap();
function Tv(r, e, t = !1) {
  const s = t ? v3 : e.propsCache, i = s.get(r);
  if (i)
    return i;
  const n = r.props, a = {}, o = [];
  let u = !1;
  if (!fe(r)) {
    const c = (f) => {
      u = !0;
      const [p, h] = Tv(f, e, !0);
      Be(a, p), h && o.push(...h);
    };
    !t && e.mixins.length && e.mixins.forEach(c), r.extends && c(r.extends), r.mixins && r.mixins.forEach(c);
  }
  if (!n && !u)
    return Ae(r) && s.set(r, gn), gn;
  if (se(n))
    for (let c = 0; c < n.length; c++) {
      process.env.NODE_ENV !== "production" && !_e(n[c]) && j("props must be strings when using array syntax.", n[c]);
      const f = Et(n[c]);
      Tg(f) && (a[f] = Oe);
    }
  else if (n) {
    process.env.NODE_ENV !== "production" && !Ae(n) && j("invalid props options", n);
    for (const c in n) {
      const f = Et(c);
      if (Tg(f)) {
        const p = n[c], h = a[f] = se(p) || fe(p) ? { type: p } : Be({}, p), m = h.type;
        let d = !1, y = !0;
        if (se(m))
          for (let S = 0; S < m.length; ++S) {
            const E = m[S], g = fe(E) && E.name;
            if (g === "Boolean") {
              d = !0;
              break;
            } else g === "String" && (y = !1);
          }
        else
          d = fe(m) && m.name === "Boolean";
        h[
          0
          /* shouldCast */
        ] = d, h[
          1
          /* shouldCastTrue */
        ] = y, (d || Pe(h, "default")) && o.push(f);
      }
    }
  }
  const l = [a, o];
  return Ae(r) && s.set(r, l), l;
}
function Tg(r) {
  return r[0] !== "$" && !yn(r) ? !0 : (process.env.NODE_ENV !== "production" && j(`Invalid prop name: "${r}" is a reserved property.`), !1);
}
function E3(r) {
  return r === null ? "null" : typeof r == "function" ? r.name || "" : typeof r == "object" && r.constructor && r.constructor.name || "";
}
function Pv(r, e, t) {
  const s = Ee(e), i = t.propsOptions[0];
  for (const n in i) {
    let a = i[n];
    a != null && S3(
      n,
      s[n],
      a,
      process.env.NODE_ENV !== "production" ? Ar(s) : s,
      !Pe(r, n) && !Pe(r, Tt(n))
    );
  }
}
function S3(r, e, t, s, i) {
  const { type: n, required: a, validator: o, skipCheck: u } = t;
  if (a && i) {
    j('Missing required prop: "' + r + '"');
    return;
  }
  if (!(e == null && !a)) {
    if (n != null && n !== !0 && !u) {
      let l = !1;
      const c = se(n) ? n : [n], f = [];
      for (let p = 0; p < c.length && !l; p++) {
        const { valid: h, expectedType: m } = x3(e, c[p]);
        f.push(m || ""), l = h;
      }
      if (!l) {
        j(w3(r, e, f));
        return;
      }
    }
    o && !o(e, s) && j('Invalid prop: custom validator check failed for prop "' + r + '".');
  }
}
const _3 = /* @__PURE__ */ zt(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function x3(r, e) {
  let t;
  const s = E3(e);
  if (_3(s)) {
    const i = typeof r;
    t = i === s.toLowerCase(), !t && i === "object" && (t = r instanceof e);
  } else s === "Object" ? t = Ae(r) : s === "Array" ? t = se(r) : s === "null" ? t = r === null : t = r instanceof e;
  return {
    valid: t,
    expectedType: s
  };
}
function w3(r, e, t) {
  if (t.length === 0)
    return `Prop type [] for prop "${r}" won't match anything. Did you mean to use type Array instead?`;
  let s = `Invalid prop: type check failed for prop "${r}". Expected ${t.map(ii).join(" | ")}`;
  const i = t[0], n = rd(e), a = Pg(e, i), o = Pg(e, n);
  return t.length === 1 && Ag(i) && !T3(i, n) && (s += ` with value ${a}`), s += `, got ${n} `, Ag(n) && (s += `with value ${o}.`), s;
}
function Pg(r, e) {
  return e === "String" ? `"${r}"` : e === "Number" ? `${Number(r)}` : `${r}`;
}
function Ag(r) {
  return ["string", "number", "boolean"].some((t) => r.toLowerCase() === t);
}
function T3(...r) {
  return r.some((e) => e.toLowerCase() === "boolean");
}
const Av = (r) => r[0] === "_" || r === "$stable", Od = (r) => se(r) ? r.map(qt) : [qt(r)], P3 = (r, e, t) => {
  if (e._n)
    return e;
  const s = Ed((...i) => (process.env.NODE_ENV !== "production" && nt && (!t || t.root === nt.root) && j(
    `Slot "${r}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), Od(e(...i))), t);
  return s._c = !1, s;
}, Cv = (r, e, t) => {
  const s = r._ctx;
  for (const i in r) {
    if (Av(i)) continue;
    const n = r[i];
    if (fe(n))
      e[i] = P3(i, n, s);
    else if (n != null) {
      process.env.NODE_ENV !== "production" && j(
        `Non-function value encountered for slot "${i}". Prefer function slots for better performance.`
      );
      const a = Od(n);
      e[i] = () => a;
    }
  }
}, Nv = (r, e) => {
  process.env.NODE_ENV !== "production" && !Gn(r.vnode) && j(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const t = Od(e);
  r.slots.default = () => t;
}, yp = (r, e, t) => {
  for (const s in e)
    (t || s !== "_") && (r[s] = e[s]);
}, A3 = (r, e, t) => {
  const s = r.slots = _v();
  if (r.vnode.shapeFlag & 32) {
    const i = e._;
    i ? (yp(s, e, t), t && An(s, "_", i, !0)) : Cv(e, s);
  } else e && Nv(r, e);
}, C3 = (r, e, t) => {
  const { vnode: s, slots: i } = r;
  let n = !0, a = Oe;
  if (s.shapeFlag & 32) {
    const o = e._;
    o ? process.env.NODE_ENV !== "production" && ei ? (yp(i, e, t), zr(r, "set", "$slots")) : t && o === 1 ? n = !1 : yp(i, e, t) : (n = !e.$stable, Cv(e, i)), a = e;
  } else e && (Nv(r, e), a = { default: 1 });
  if (n)
    for (const o in i)
      !Av(o) && a[o] == null && delete i[o];
};
function nl(r, e, t, s, i = !1) {
  if (se(r)) {
    r.forEach(
      (p, h) => nl(
        p,
        e && (se(e) ? e[h] : e),
        t,
        s,
        i
      )
    );
    return;
  }
  if (Di(s) && !i)
    return;
  const n = s.shapeFlag & 4 ? Mo(s.component) : s.el, a = i ? null : n, { i: o, r: u } = r;
  if (process.env.NODE_ENV !== "production" && !o) {
    j(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const l = e && e.r, c = o.refs === Oe ? o.refs = {} : o.refs, f = o.setupState;
  if (l != null && l !== u && (_e(l) ? (c[l] = null, Pe(f, l) && (f[l] = null)) : pt(l) && (l.value = null)), fe(u))
    Kr(u, o, 12, [a, c]);
  else {
    const p = _e(u), h = pt(u);
    if (p || h) {
      const m = () => {
        if (r.f) {
          const d = p ? Pe(f, u) ? f[u] : c[u] : u.value;
          i ? se(d) && td(d, n) : se(d) ? d.includes(n) || d.push(n) : p ? (c[u] = [n], Pe(f, u) && (f[u] = c[u])) : (u.value = [n], r.k && (c[r.k] = u.value));
        } else p ? (c[u] = a, Pe(f, u) && (f[u] = a)) : h ? (u.value = a, r.k && (c[r.k] = a)) : process.env.NODE_ENV !== "production" && j("Invalid template ref type:", u, `(${typeof u})`);
      };
      a ? (m.id = -1, mt(m, t)) : m();
    } else process.env.NODE_ENV !== "production" && j("Invalid template ref type:", u, `(${typeof u})`);
  }
}
const Ov = Symbol("_vte"), N3 = (r) => r.__isTeleport, Ri = (r) => r && (r.disabled || r.disabled === ""), Cg = (r) => typeof SVGElement < "u" && r instanceof SVGElement, Ng = (r) => typeof MathMLElement == "function" && r instanceof MathMLElement, bp = (r, e) => {
  const t = r && r.to;
  if (_e(t))
    if (e) {
      const s = e(t);
      return process.env.NODE_ENV !== "production" && !s && !Ri(r) && j(
        `Failed to locate Teleport target with selector "${t}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), s;
    } else
      return process.env.NODE_ENV !== "production" && j(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return process.env.NODE_ENV !== "production" && !t && !Ri(r) && j(`Invalid Teleport target: ${t}`), t;
}, O3 = {
  name: "Teleport",
  __isTeleport: !0,
  process(r, e, t, s, i, n, a, o, u, l) {
    const {
      mc: c,
      pc: f,
      pbc: p,
      o: { insert: h, querySelector: m, createText: d, createComment: y }
    } = l, S = Ri(e.props);
    let { shapeFlag: E, children: g, dynamicChildren: b } = e;
    if (process.env.NODE_ENV !== "production" && ei && (u = !1, b = null), r == null) {
      const v = e.el = process.env.NODE_ENV !== "production" ? y("teleport start") : d(""), A = e.anchor = process.env.NODE_ENV !== "production" ? y("teleport end") : d("");
      h(v, t, s), h(A, t, s);
      const C = e.target = bp(e.props, m), x = kv(C, e, d, h);
      C ? a === "svg" || Cg(C) ? a = "svg" : (a === "mathml" || Ng(C)) && (a = "mathml") : process.env.NODE_ENV !== "production" && !S && j("Invalid Teleport target on mount:", C, `(${typeof C})`);
      const _ = (T, P) => {
        E & 16 && c(
          g,
          T,
          P,
          i,
          n,
          a,
          o,
          u
        );
      };
      S ? _(t, A) : C && _(C, x);
    } else {
      e.el = r.el, e.targetStart = r.targetStart;
      const v = e.anchor = r.anchor, A = e.target = r.target, C = e.targetAnchor = r.targetAnchor, x = Ri(r.props), _ = x ? t : A, T = x ? v : C;
      if (a === "svg" || Cg(A) ? a = "svg" : (a === "mathml" || Ng(A)) && (a = "mathml"), b ? (p(
        r.dynamicChildren,
        b,
        _,
        i,
        n,
        a,
        o
      ), $a(r, e, !0)) : u || f(
        r,
        e,
        _,
        T,
        i,
        n,
        a,
        o,
        !1
      ), S)
        x ? e.props && r.props && e.props.to !== r.props.to && (e.props.to = r.props.to) : su(
          e,
          t,
          v,
          l,
          1
        );
      else if ((e.props && e.props.to) !== (r.props && r.props.to)) {
        const P = e.target = bp(
          e.props,
          m
        );
        P ? su(
          e,
          P,
          null,
          l,
          0
        ) : process.env.NODE_ENV !== "production" && j(
          "Invalid Teleport target on update:",
          A,
          `(${typeof A})`
        );
      } else x && su(
        e,
        A,
        C,
        l,
        1
      );
    }
    Iv(e);
  },
  remove(r, e, t, { um: s, o: { remove: i } }, n) {
    const {
      shapeFlag: a,
      children: o,
      anchor: u,
      targetStart: l,
      targetAnchor: c,
      target: f,
      props: p
    } = r;
    if (f && (i(l), i(c)), n && i(u), a & 16) {
      const h = n || !Ri(p);
      for (let m = 0; m < o.length; m++) {
        const d = o[m];
        s(
          d,
          e,
          t,
          h,
          !!d.dynamicChildren
        );
      }
    }
  },
  move: su,
  hydrate: I3
};
function su(r, e, t, { o: { insert: s }, m: i }, n = 2) {
  n === 0 && s(r.targetAnchor, e, t);
  const { el: a, anchor: o, shapeFlag: u, children: l, props: c } = r, f = n === 2;
  if (f && s(a, e, t), (!f || Ri(c)) && u & 16)
    for (let p = 0; p < l.length; p++)
      i(
        l[p],
        e,
        t,
        2
      );
  f && s(o, e, t);
}
function I3(r, e, t, s, i, n, {
  o: { nextSibling: a, parentNode: o, querySelector: u, insert: l, createText: c }
}, f) {
  const p = e.target = bp(
    e.props,
    u
  );
  if (p) {
    const h = p._lpa || p.firstChild;
    if (e.shapeFlag & 16)
      if (Ri(e.props))
        e.anchor = f(
          a(r),
          e,
          o(r),
          t,
          s,
          i,
          n
        ), e.targetStart = h, e.targetAnchor = h && a(h);
      else {
        e.anchor = a(r);
        let m = h;
        for (; m; ) {
          if (m && m.nodeType === 8) {
            if (m.data === "teleport start anchor")
              e.targetStart = m;
            else if (m.data === "teleport anchor") {
              e.targetAnchor = m, p._lpa = e.targetAnchor && a(e.targetAnchor);
              break;
            }
          }
          m = a(m);
        }
        e.targetAnchor || kv(p, e, c, l), f(
          h && a(h),
          e,
          p,
          t,
          s,
          i,
          n
        );
      }
    Iv(e);
  }
  return e.anchor && a(e.anchor);
}
const k3 = O3;
function Iv(r) {
  const e = r.ctx;
  if (e && e.ut) {
    let t = r.children[0].el;
    for (; t && t !== r.targetAnchor; )
      t.nodeType === 1 && t.setAttribute("data-v-owner", e.uid), t = t.nextSibling;
    e.ut();
  }
}
function kv(r, e, t, s) {
  const i = e.targetStart = t(""), n = e.targetAnchor = t("");
  return i[Ov] = n, r && (s(i, r), s(n, r)), n;
}
let Og = !1;
const mi = () => {
  Og || (console.error("Hydration completed but contains mismatches."), Og = !0);
}, D3 = (r) => r.namespaceURI.includes("svg") && r.tagName !== "foreignObject", L3 = (r) => r.namespaceURI.includes("MathML"), iu = (r) => {
  if (D3(r)) return "svg";
  if (L3(r)) return "mathml";
}, fa = (r) => r.nodeType === 8;
function M3(r) {
  const {
    mt: e,
    p: t,
    o: {
      patchProp: s,
      createText: i,
      nextSibling: n,
      parentNode: a,
      remove: o,
      insert: u,
      createComment: l
    }
  } = r, c = (g, b) => {
    if (!b.hasChildNodes()) {
      process.env.NODE_ENV !== "production" && j(
        "Attempting to hydrate existing markup but container is empty. Performing full mount instead."
      ), t(null, g, b), tl(), b._vnode = g;
      return;
    }
    f(b.firstChild, g, null, null, null), tl(), b._vnode = g;
  }, f = (g, b, v, A, C, x = !1) => {
    x = x || !!b.dynamicChildren;
    const _ = fa(g) && g.data === "[", T = () => d(
      g,
      b,
      v,
      A,
      C,
      _
    ), { type: P, ref: I, shapeFlag: $, patchFlag: Y } = b;
    let W = g.nodeType;
    b.el = g, process.env.NODE_ENV !== "production" && (An(g, "__vnode", b, !0), An(g, "__vueParentComponent", v, !0)), Y === -2 && (x = !1, b.dynamicChildren = null);
    let F = null;
    switch (P) {
      case Xr:
        W !== 3 ? b.children === "" ? (u(b.el = i(""), a(g), g), F = g) : F = T() : (g.data !== b.children && (process.env.NODE_ENV !== "production" && j(
          "Hydration text mismatch in",
          g.parentNode,
          `
  - rendered on server: ${JSON.stringify(
            g.data
          )}
  - expected on client: ${JSON.stringify(b.children)}`
        ), mi(), g.data = b.children), F = n(g));
        break;
      case Je:
        E(g) ? (F = n(g), S(
          b.el = g.content.firstChild,
          g,
          v
        )) : W !== 8 || _ ? F = T() : F = n(g);
        break;
      case Es:
        if (_ && (g = n(g), W = g.nodeType), W === 1 || W === 3) {
          F = g;
          const K = !b.children.length;
          for (let Z = 0; Z < b.staticCount; Z++)
            K && (b.children += F.nodeType === 1 ? F.outerHTML : F.data), Z === b.staticCount - 1 && (b.anchor = F), F = n(F);
          return _ ? n(F) : F;
        } else
          T();
        break;
      case ct:
        _ ? F = m(
          g,
          b,
          v,
          A,
          C,
          x
        ) : F = T();
        break;
      default:
        if ($ & 1)
          (W !== 1 || b.type.toLowerCase() !== g.tagName.toLowerCase()) && !E(g) ? F = T() : F = p(
            g,
            b,
            v,
            A,
            C,
            x
          );
        else if ($ & 6) {
          b.slotScopeIds = C;
          const K = a(g);
          if (_ ? F = y(g) : fa(g) && g.data === "teleport start" ? F = y(g, g.data, "teleport end") : F = n(g), e(
            b,
            K,
            null,
            v,
            A,
            iu(K),
            x
          ), Di(b)) {
            let Z;
            _ ? (Z = He(ct), Z.anchor = F ? F.previousSibling : K.lastChild) : Z = g.nodeType === 3 ? Ld("") : He("div"), Z.el = g, b.component.subTree = Z;
          }
        } else $ & 64 ? W !== 8 ? F = T() : F = b.type.hydrate(
          g,
          b,
          v,
          A,
          C,
          x,
          r,
          h
        ) : $ & 128 ? F = b.type.hydrate(
          g,
          b,
          v,
          A,
          iu(a(g)),
          C,
          x,
          r,
          f
        ) : process.env.NODE_ENV !== "production" && j("Invalid HostVNode type:", P, `(${typeof P})`);
    }
    return I != null && nl(I, null, A, b), F;
  }, p = (g, b, v, A, C, x) => {
    x = x || !!b.dynamicChildren;
    const { type: _, props: T, patchFlag: P, shapeFlag: I, dirs: $, transition: Y } = b, W = _ === "input" || _ === "option";
    if (process.env.NODE_ENV !== "production" || W || P !== -1) {
      $ && Mr(b, null, v, "created");
      let F = !1;
      if (E(g)) {
        F = $v(A, Y) && v && v.vnode.props && v.vnode.props.appear;
        const Z = g.content.firstChild;
        F && Y.beforeEnter(Z), S(Z, g, v), b.el = g = Z;
      }
      if (I & 16 && // skip if element has innerHTML / textContent
      !(T && (T.innerHTML || T.textContent))) {
        let Z = h(
          g.firstChild,
          b,
          g,
          v,
          A,
          C,
          x
        ), Ce = !1;
        for (; Z; ) {
          process.env.NODE_ENV !== "production" && !Ce && (j(
            "Hydration children mismatch on",
            g,
            `
Server rendered element contains more child nodes than client vdom.`
          ), Ce = !0), mi();
          const Ve = Z;
          Z = Z.nextSibling, o(Ve);
        }
      } else I & 8 && g.textContent !== b.children && (process.env.NODE_ENV !== "production" && j(
        "Hydration text content mismatch on",
        g,
        `
  - rendered on server: ${g.textContent}
  - expected on client: ${b.children}`
      ), mi(), g.textContent = b.children);
      if (T) {
        if (process.env.NODE_ENV !== "production" || W || !x || P & 48) {
          const Z = g.tagName.includes("-");
          for (const Ce in T)
            process.env.NODE_ENV !== "production" && // #11189 skip if this node has directives that have created hooks
            // as it could have mutated the DOM in any possible way
            !($ && $.some((Ve) => Ve.dir.created)) && R3(g, Ce, T[Ce], b, v) && mi(), (W && (Ce.endsWith("value") || Ce === "indeterminate") || Yi(Ce) && !yn(Ce) || // force hydrate v-bind with .prop modifiers
            Ce[0] === "." || Z) && s(g, Ce, null, T[Ce], void 0, v);
        } else if (T.onClick)
          s(
            g,
            "onClick",
            null,
            T.onClick,
            void 0,
            v
          );
        else if (P & 4 && Zs(T.style))
          for (const Z in T.style) T.style[Z];
      }
      let K;
      (K = T && T.onVnodeBeforeMount) && Kt(K, v, b), $ && Mr(b, null, v, "beforeMount"), ((K = T && T.onVnodeMounted) || $ || F) && Gv(() => {
        K && Kt(K, v, b), F && Y.enter(g), $ && Mr(b, null, v, "mounted");
      }, A);
    }
    return g.nextSibling;
  }, h = (g, b, v, A, C, x, _) => {
    _ = _ || !!b.dynamicChildren;
    const T = b.children, P = T.length;
    let I = !1;
    for (let $ = 0; $ < P; $++) {
      const Y = _ ? T[$] : T[$] = qt(T[$]), W = Y.type === Xr;
      if (g) {
        if (W && !_) {
          let F = T[$ + 1];
          F && (F = qt(F)).type === Xr && (u(
            i(
              g.data.slice(Y.children.length)
            ),
            v,
            n(g)
          ), g.data = Y.children);
        }
        g = f(
          g,
          Y,
          A,
          C,
          x,
          _
        );
      } else W && !Y.children ? u(Y.el = i(""), v) : (process.env.NODE_ENV !== "production" && !I && (j(
        "Hydration children mismatch on",
        v,
        `
Server rendered element contains fewer child nodes than client vdom.`
      ), I = !0), mi(), t(
        null,
        Y,
        v,
        null,
        A,
        C,
        iu(v),
        x
      ));
    }
    return g;
  }, m = (g, b, v, A, C, x) => {
    const { slotScopeIds: _ } = b;
    _ && (C = C ? C.concat(_) : _);
    const T = a(g), P = h(
      n(g),
      b,
      T,
      v,
      A,
      C,
      x
    );
    return P && fa(P) && P.data === "]" ? n(b.anchor = P) : (mi(), u(b.anchor = l("]"), T, P), P);
  }, d = (g, b, v, A, C, x) => {
    if (process.env.NODE_ENV !== "production" && j(
      `Hydration node mismatch:
- rendered on server:`,
      g,
      g.nodeType === 3 ? "(text)" : fa(g) && g.data === "[" ? "(start of fragment)" : "",
      `
- expected on client:`,
      b.type
    ), mi(), b.el = null, x) {
      const P = y(g);
      for (; ; ) {
        const I = n(g);
        if (I && I !== P)
          o(I);
        else
          break;
      }
    }
    const _ = n(g), T = a(g);
    return o(g), t(
      null,
      b,
      T,
      _,
      v,
      A,
      iu(T),
      C
    ), _;
  }, y = (g, b = "[", v = "]") => {
    let A = 0;
    for (; g; )
      if (g = n(g), g && fa(g) && (g.data === b && A++, g.data === v)) {
        if (A === 0)
          return n(g);
        A--;
      }
    return g;
  }, S = (g, b, v) => {
    const A = b.parentNode;
    A && A.replaceChild(g, b);
    let C = v;
    for (; C; )
      C.vnode.el === b && (C.vnode.el = C.subTree.el = g), C = C.parent;
  }, E = (g) => g.nodeType === 1 && g.tagName.toLowerCase() === "template";
  return [c, f];
}
function R3(r, e, t, s, i) {
  let n, a, o, u;
  if (e === "class")
    o = r.getAttribute("class"), u = en(t), $3(Ig(o || ""), Ig(u)) || (n = a = "class");
  else if (e === "style") {
    o = r.getAttribute("style") || "", u = _e(t) ? t : Tb(Zi(t));
    const l = kg(o), c = kg(u);
    if (s.dirs)
      for (const { dir: f, value: p } of s.dirs)
        f.name === "show" && !p && c.set("display", "none");
    i && Dv(i, s, c), F3(l, c) || (n = a = "style");
  } else (r instanceof SVGElement && yT(e) || r instanceof HTMLElement && (ap(e) || gT(e))) && (ap(e) ? (o = r.hasAttribute(e), u = Ao(t)) : t == null ? (o = r.hasAttribute(e), u = !1) : (r.hasAttribute(e) ? o = r.getAttribute(e) : e === "value" && r.tagName === "TEXTAREA" ? o = r.value : o = !1, u = id(t) ? String(t) : !1), o !== u && (n = "attribute", a = e));
  if (n) {
    const l = (p) => p === !1 ? "(not rendered)" : `${a}="${p}"`, c = `Hydration ${n} mismatch on`, f = `
  - rendered on server: ${l(o)}
  - expected on client: ${l(u)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
    return j(c, r, f), !0;
  }
  return !1;
}
function Ig(r) {
  return new Set(r.trim().split(/\s+/));
}
function $3(r, e) {
  if (r.size !== e.size)
    return !1;
  for (const t of r)
    if (!e.has(t))
      return !1;
  return !0;
}
function kg(r) {
  const e = /* @__PURE__ */ new Map();
  for (const t of r.split(";")) {
    let [s, i] = t.split(":");
    s = s.trim(), i = i && i.trim(), s && i && e.set(s, i);
  }
  return e;
}
function F3(r, e) {
  if (r.size !== e.size)
    return !1;
  for (const [t, s] of r)
    if (s !== e.get(t))
      return !1;
  return !0;
}
function Dv(r, e, t) {
  const s = r.subTree;
  if (r.getCssVars && (e === s || s && s.type === ct && s.children.includes(e))) {
    const i = r.getCssVars();
    for (const n in i)
      t.set(`--${n}`, String(i[n]));
  }
  e === s && r.parent && Dv(r.parent, r.vnode, t);
}
let pa, Ks;
function as(r, e) {
  r.appContext.config.performance && al() && Ks.mark(`vue-${e}-${r.uid}`), process.env.NODE_ENV !== "production" && wP(r, e, al() ? Ks.now() : Date.now());
}
function os(r, e) {
  if (r.appContext.config.performance && al()) {
    const t = `vue-${e}-${r.uid}`, s = t + ":end";
    Ks.mark(s), Ks.measure(
      `<${mc(r, r.type)}> ${e}`,
      t,
      s
    ), Ks.clearMarks(t), Ks.clearMarks(s);
  }
  process.env.NODE_ENV !== "production" && TP(r, e, al() ? Ks.now() : Date.now());
}
function al() {
  return pa !== void 0 || (typeof window < "u" && window.performance ? (pa = !0, Ks = window.performance) : pa = !1), pa;
}
function B3() {
  const r = [];
  if (process.env.NODE_ENV !== "production" && r.length) {
    const e = r.length > 1;
    console.warn(
      `Feature flag${e ? "s" : ""} ${r.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const mt = Gv;
function Lv(r) {
  return Rv(r);
}
function Mv(r) {
  return Rv(r, M3);
}
function Rv(r, e) {
  B3();
  const t = Zl();
  t.__VUE__ = !0, process.env.NODE_ENV !== "production" && bd(t.__VUE_DEVTOOLS_GLOBAL_HOOK__, t);
  const {
    insert: s,
    remove: i,
    patchProp: n,
    createElement: a,
    createText: o,
    createComment: u,
    setText: l,
    setElementText: c,
    parentNode: f,
    nextSibling: p,
    setScopeId: h = Ge,
    insertStaticContent: m
  } = r, d = (w, N, M, q = null, V = null, U = null, J = void 0, G = null, X = process.env.NODE_ENV !== "production" && ei ? !1 : !!N.dynamicChildren) => {
    if (w === N)
      return;
    w && !Pr(w, N) && (q = ne(w), R(w, V, U, !0), w = null), N.patchFlag === -2 && (X = !1, N.dynamicChildren = null);
    const { type: z, ref: re, shapeFlag: ce } = N;
    switch (z) {
      case Xr:
        y(w, N, M, q);
        break;
      case Je:
        S(w, N, M, q);
        break;
      case Es:
        w == null ? E(N, M, q, J) : process.env.NODE_ENV !== "production" && g(w, N, M, J);
        break;
      case ct:
        $(
          w,
          N,
          M,
          q,
          V,
          U,
          J,
          G,
          X
        );
        break;
      default:
        ce & 1 ? A(
          w,
          N,
          M,
          q,
          V,
          U,
          J,
          G,
          X
        ) : ce & 6 ? Y(
          w,
          N,
          M,
          q,
          V,
          U,
          J,
          G,
          X
        ) : ce & 64 || ce & 128 ? z.process(
          w,
          N,
          M,
          q,
          V,
          U,
          J,
          G,
          X,
          me
        ) : process.env.NODE_ENV !== "production" && j("Invalid VNode type:", z, `(${typeof z})`);
    }
    re != null && V && nl(re, w && w.ref, U, N || w, !N);
  }, y = (w, N, M, q) => {
    if (w == null)
      s(
        N.el = o(N.children),
        M,
        q
      );
    else {
      const V = N.el = w.el;
      N.children !== w.children && l(V, N.children);
    }
  }, S = (w, N, M, q) => {
    w == null ? s(
      N.el = u(N.children || ""),
      M,
      q
    ) : N.el = w.el;
  }, E = (w, N, M, q) => {
    [w.el, w.anchor] = m(
      w.children,
      N,
      M,
      q,
      w.el,
      w.anchor
    );
  }, g = (w, N, M, q) => {
    if (N.children !== w.children) {
      const V = p(w.anchor);
      v(w), [N.el, N.anchor] = m(
        N.children,
        M,
        V,
        q
      );
    } else
      N.el = w.el, N.anchor = w.anchor;
  }, b = ({ el: w, anchor: N }, M, q) => {
    let V;
    for (; w && w !== N; )
      V = p(w), s(w, M, q), w = V;
    s(N, M, q);
  }, v = ({ el: w, anchor: N }) => {
    let M;
    for (; w && w !== N; )
      M = p(w), i(w), w = M;
    i(N);
  }, A = (w, N, M, q, V, U, J, G, X) => {
    N.type === "svg" ? J = "svg" : N.type === "math" && (J = "mathml"), w == null ? C(
      N,
      M,
      q,
      V,
      U,
      J,
      G,
      X
    ) : T(
      w,
      N,
      V,
      U,
      J,
      G,
      X
    );
  }, C = (w, N, M, q, V, U, J, G) => {
    let X, z;
    const { props: re, shapeFlag: ce, transition: pe, dirs: ve } = w;
    if (X = w.el = a(
      w.type,
      U,
      re && re.is,
      re
    ), ce & 8 ? c(X, w.children) : ce & 16 && _(
      w.children,
      X,
      null,
      q,
      V,
      Tf(w, U),
      J,
      G
    ), ve && Mr(w, null, q, "created"), x(X, w, w.scopeId, J, q), re) {
      for (const qe in re)
        qe !== "value" && !yn(qe) && n(X, qe, null, re[qe], U, q);
      "value" in re && n(X, "value", null, re.value, U), (z = re.onVnodeBeforeMount) && Kt(z, q, w);
    }
    process.env.NODE_ENV !== "production" && (An(X, "__vnode", w, !0), An(X, "__vueParentComponent", q, !0)), ve && Mr(w, null, q, "beforeMount");
    const xe = $v(V, pe);
    xe && pe.beforeEnter(X), s(X, N, M), ((z = re && re.onVnodeMounted) || xe || ve) && mt(() => {
      z && Kt(z, q, w), xe && pe.enter(X), ve && Mr(w, null, q, "mounted");
    }, V);
  }, x = (w, N, M, q, V) => {
    if (M && h(w, M), q)
      for (let U = 0; U < q.length; U++)
        h(w, q[U]);
    if (V) {
      let U = V.subTree;
      if (process.env.NODE_ENV !== "production" && U.patchFlag > 0 && U.patchFlag & 2048 && (U = hc(U.children) || U), N === U) {
        const J = V.vnode;
        x(
          w,
          J,
          J.scopeId,
          J.slotScopeIds,
          V.parent
        );
      }
    }
  }, _ = (w, N, M, q, V, U, J, G, X = 0) => {
    for (let z = X; z < w.length; z++) {
      const re = w[z] = G ? Ws(w[z]) : qt(w[z]);
      d(
        null,
        re,
        N,
        M,
        q,
        V,
        U,
        J,
        G
      );
    }
  }, T = (w, N, M, q, V, U, J) => {
    const G = N.el = w.el;
    process.env.NODE_ENV !== "production" && (G.__vnode = N);
    let { patchFlag: X, dynamicChildren: z, dirs: re } = N;
    X |= w.patchFlag & 16;
    const ce = w.props || Oe, pe = N.props || Oe;
    let ve;
    if (M && gi(M, !1), (ve = pe.onVnodeBeforeUpdate) && Kt(ve, M, N, w), re && Mr(N, w, M, "beforeUpdate"), M && gi(M, !0), process.env.NODE_ENV !== "production" && ei && (X = 0, J = !1, z = null), (ce.innerHTML && pe.innerHTML == null || ce.textContent && pe.textContent == null) && c(G, ""), z ? (P(
      w.dynamicChildren,
      z,
      G,
      M,
      q,
      Tf(N, V),
      U
    ), process.env.NODE_ENV !== "production" && $a(w, N)) : J || Ce(
      w,
      N,
      G,
      null,
      M,
      q,
      Tf(N, V),
      U,
      !1
    ), X > 0) {
      if (X & 16)
        I(G, ce, pe, M, V);
      else if (X & 2 && ce.class !== pe.class && n(G, "class", null, pe.class, V), X & 4 && n(G, "style", ce.style, pe.style, V), X & 8) {
        const xe = N.dynamicProps;
        for (let qe = 0; qe < xe.length; qe++) {
          const De = xe[qe], ut = ce[De], xr = pe[De];
          (xr !== ut || De === "value") && n(G, De, ut, xr, V, M);
        }
      }
      X & 1 && w.children !== N.children && c(G, N.children);
    } else !J && z == null && I(G, ce, pe, M, V);
    ((ve = pe.onVnodeUpdated) || re) && mt(() => {
      ve && Kt(ve, M, N, w), re && Mr(N, w, M, "updated");
    }, q);
  }, P = (w, N, M, q, V, U, J) => {
    for (let G = 0; G < N.length; G++) {
      const X = w[G], z = N[G], re = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        X.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (X.type === ct || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Pr(X, z) || // - In the case of a component, it could contain anything.
        X.shapeFlag & 70) ? f(X.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          M
        )
      );
      d(
        X,
        z,
        re,
        null,
        q,
        V,
        U,
        J,
        !0
      );
    }
  }, I = (w, N, M, q, V) => {
    if (N !== M) {
      if (N !== Oe)
        for (const U in N)
          !yn(U) && !(U in M) && n(
            w,
            U,
            N[U],
            null,
            V,
            q
          );
      for (const U in M) {
        if (yn(U)) continue;
        const J = M[U], G = N[U];
        J !== G && U !== "value" && n(w, U, G, J, V, q);
      }
      "value" in M && n(w, "value", N.value, M.value, V);
    }
  }, $ = (w, N, M, q, V, U, J, G, X) => {
    const z = N.el = w ? w.el : o(""), re = N.anchor = w ? w.anchor : o("");
    let { patchFlag: ce, dynamicChildren: pe, slotScopeIds: ve } = N;
    process.env.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (ei || ce & 2048) && (ce = 0, X = !1, pe = null), ve && (G = G ? G.concat(ve) : ve), w == null ? (s(z, M, q), s(re, M, q), _(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      N.children || [],
      M,
      re,
      V,
      U,
      J,
      G,
      X
    )) : ce > 0 && ce & 64 && pe && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    w.dynamicChildren ? (P(
      w.dynamicChildren,
      pe,
      M,
      V,
      U,
      J,
      G
    ), process.env.NODE_ENV !== "production" ? $a(w, N) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (N.key != null || V && N === V.subTree) && $a(
        w,
        N,
        !0
        /* shallow */
      )
    )) : Ce(
      w,
      N,
      M,
      re,
      V,
      U,
      J,
      G,
      X
    );
  }, Y = (w, N, M, q, V, U, J, G, X) => {
    N.slotScopeIds = G, w == null ? N.shapeFlag & 512 ? V.ctx.activate(
      N,
      M,
      q,
      J,
      X
    ) : W(
      N,
      M,
      q,
      V,
      U,
      J,
      X
    ) : F(w, N, X);
  }, W = (w, N, M, q, V, U, J) => {
    const G = w.component = eE(
      w,
      q,
      V
    );
    if (process.env.NODE_ENV !== "production" && G.type.__hmrId && gP(G), process.env.NODE_ENV !== "production" && (Da(w), as(G, "mount")), Gn(w) && (G.ctx.renderer = me), process.env.NODE_ENV !== "production" && as(G, "init"), rE(G, !1, J), process.env.NODE_ENV !== "production" && os(G, "init"), G.asyncDep) {
      if (V && V.registerDep(G, K, J), !w.el) {
        const X = G.subTree = He(Je);
        S(null, X, N, M);
      }
    } else
      K(
        G,
        w,
        N,
        M,
        V,
        U,
        J
      );
    process.env.NODE_ENV !== "production" && (La(), os(G, "mount"));
  }, F = (w, N, M) => {
    const q = N.component = w.component;
    if (G3(w, N, M))
      if (q.asyncDep && !q.asyncResolved) {
        process.env.NODE_ENV !== "production" && Da(N), Z(q, N, M), process.env.NODE_ENV !== "production" && La();
        return;
      } else
        q.next = N, dP(q.update), q.effect.dirty = !0, q.update();
    else
      N.el = w.el, q.vnode = N;
  }, K = (w, N, M, q, V, U, J) => {
    const G = () => {
      if (w.isMounted) {
        let { next: re, bu: ce, u: pe, parent: ve, vnode: xe } = w;
        {
          const un = Fv(w);
          if (un) {
            re && (re.el = xe.el, Z(w, re, J)), un.asyncDep.then(() => {
              w.isUnmounted || G();
            });
            return;
          }
        }
        let qe = re, De;
        process.env.NODE_ENV !== "production" && Da(re || w.vnode), gi(w, !1), re ? (re.el = xe.el, Z(w, re, J)) : re = xe, ce && Gs(ce), (De = re.props && re.props.onVnodeBeforeUpdate) && Kt(De, ve, re, xe), gi(w, !0), process.env.NODE_ENV !== "production" && as(w, "render");
        const ut = Nu(w);
        process.env.NODE_ENV !== "production" && os(w, "render");
        const xr = w.subTree;
        w.subTree = ut, process.env.NODE_ENV !== "production" && as(w, "patch"), d(
          xr,
          ut,
          // parent may have changed if it's in a teleport
          f(xr.el),
          // anchor may have changed if it's in a fragment
          ne(xr),
          w,
          V,
          U
        ), process.env.NODE_ENV !== "production" && os(w, "patch"), re.el = ut.el, qe === null && Id(w, ut.el), pe && mt(pe, V), (De = re.props && re.props.onVnodeUpdated) && mt(
          () => Kt(De, ve, re, xe),
          V
        ), process.env.NODE_ENV !== "production" && sv(w), process.env.NODE_ENV !== "production" && La();
      } else {
        let re;
        const { el: ce, props: pe } = N, { bm: ve, m: xe, parent: qe } = w, De = Di(N);
        if (gi(w, !1), ve && Gs(ve), !De && (re = pe && pe.onVnodeBeforeMount) && Kt(re, qe, N), gi(w, !0), ce && Ke) {
          const ut = () => {
            process.env.NODE_ENV !== "production" && as(w, "render"), w.subTree = Nu(w), process.env.NODE_ENV !== "production" && os(w, "render"), process.env.NODE_ENV !== "production" && as(w, "hydrate"), Ke(
              ce,
              w.subTree,
              w,
              V,
              null
            ), process.env.NODE_ENV !== "production" && os(w, "hydrate");
          };
          De ? N.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !w.isUnmounted && ut()
          ) : ut();
        } else {
          process.env.NODE_ENV !== "production" && as(w, "render");
          const ut = w.subTree = Nu(w);
          process.env.NODE_ENV !== "production" && os(w, "render"), process.env.NODE_ENV !== "production" && as(w, "patch"), d(
            null,
            ut,
            M,
            q,
            w,
            V,
            U
          ), process.env.NODE_ENV !== "production" && os(w, "patch"), N.el = ut.el;
        }
        if (xe && mt(xe, V), !De && (re = pe && pe.onVnodeMounted)) {
          const ut = N;
          mt(
            () => Kt(re, qe, ut),
            V
          );
        }
        (N.shapeFlag & 256 || qe && Di(qe.vnode) && qe.vnode.shapeFlag & 256) && w.a && mt(w.a, V), w.isMounted = !0, process.env.NODE_ENV !== "production" && pp(w), N = M = q = null;
      }
    }, X = w.effect = new Cn(
      G,
      Ge,
      () => No(z),
      w.scope
      // track it in component's effect scope
    ), z = w.update = () => {
      X.dirty && X.run();
    };
    z.i = w, z.id = w.uid, gi(w, !0), process.env.NODE_ENV !== "production" && (X.onTrack = w.rtc ? (re) => Gs(w.rtc, re) : void 0, X.onTrigger = w.rtg ? (re) => Gs(w.rtg, re) : void 0), z();
  }, Z = (w, N, M) => {
    N.component = w;
    const q = w.vnode.props;
    w.vnode = N, w.next = null, b3(w, N.props, q, M), C3(w, N.children, M), Os(), bg(w), Is();
  }, Ce = (w, N, M, q, V, U, J, G, X = !1) => {
    const z = w && w.children, re = w ? w.shapeFlag : 0, ce = N.children, { patchFlag: pe, shapeFlag: ve } = N;
    if (pe > 0) {
      if (pe & 128) {
        ee(
          z,
          ce,
          M,
          q,
          V,
          U,
          J,
          G,
          X
        );
        return;
      } else if (pe & 256) {
        Ve(
          z,
          ce,
          M,
          q,
          V,
          U,
          J,
          G,
          X
        );
        return;
      }
    }
    ve & 8 ? (re & 16 && L(z, V, U), ce !== z && c(M, ce)) : re & 16 ? ve & 16 ? ee(
      z,
      ce,
      M,
      q,
      V,
      U,
      J,
      G,
      X
    ) : L(z, V, U, !0) : (re & 8 && c(M, ""), ve & 16 && _(
      ce,
      M,
      q,
      V,
      U,
      J,
      G,
      X
    ));
  }, Ve = (w, N, M, q, V, U, J, G, X) => {
    w = w || gn, N = N || gn;
    const z = w.length, re = N.length, ce = Math.min(z, re);
    let pe;
    for (pe = 0; pe < ce; pe++) {
      const ve = N[pe] = X ? Ws(N[pe]) : qt(N[pe]);
      d(
        w[pe],
        ve,
        M,
        null,
        V,
        U,
        J,
        G,
        X
      );
    }
    z > re ? L(
      w,
      V,
      U,
      !0,
      !1,
      ce
    ) : _(
      N,
      M,
      q,
      V,
      U,
      J,
      G,
      X,
      ce
    );
  }, ee = (w, N, M, q, V, U, J, G, X) => {
    let z = 0;
    const re = N.length;
    let ce = w.length - 1, pe = re - 1;
    for (; z <= ce && z <= pe; ) {
      const ve = w[z], xe = N[z] = X ? Ws(N[z]) : qt(N[z]);
      if (Pr(ve, xe))
        d(
          ve,
          xe,
          M,
          null,
          V,
          U,
          J,
          G,
          X
        );
      else
        break;
      z++;
    }
    for (; z <= ce && z <= pe; ) {
      const ve = w[ce], xe = N[pe] = X ? Ws(N[pe]) : qt(N[pe]);
      if (Pr(ve, xe))
        d(
          ve,
          xe,
          M,
          null,
          V,
          U,
          J,
          G,
          X
        );
      else
        break;
      ce--, pe--;
    }
    if (z > ce) {
      if (z <= pe) {
        const ve = pe + 1, xe = ve < re ? N[ve].el : q;
        for (; z <= pe; )
          d(
            null,
            N[z] = X ? Ws(N[z]) : qt(N[z]),
            M,
            xe,
            V,
            U,
            J,
            G,
            X
          ), z++;
      }
    } else if (z > pe)
      for (; z <= ce; )
        R(w[z], V, U, !0), z++;
    else {
      const ve = z, xe = z, qe = /* @__PURE__ */ new Map();
      for (z = xe; z <= pe; z++) {
        const $t = N[z] = X ? Ws(N[z]) : qt(N[z]);
        $t.key != null && (process.env.NODE_ENV !== "production" && qe.has($t.key) && j(
          "Duplicate keys found during update:",
          JSON.stringify($t.key),
          "Make sure keys are unique."
        ), qe.set($t.key, z));
      }
      let De, ut = 0;
      const xr = pe - xe + 1;
      let un = !1, ag = 0;
      const ca = new Array(xr);
      for (z = 0; z < xr; z++) ca[z] = 0;
      for (z = ve; z <= ce; z++) {
        const $t = w[z];
        if (ut >= xr) {
          R($t, V, U, !0);
          continue;
        }
        let Dr;
        if ($t.key != null)
          Dr = qe.get($t.key);
        else
          for (De = xe; De <= pe; De++)
            if (ca[De - xe] === 0 && Pr($t, N[De])) {
              Dr = De;
              break;
            }
        Dr === void 0 ? R($t, V, U, !0) : (ca[Dr - xe] = z + 1, Dr >= ag ? ag = Dr : un = !0, d(
          $t,
          N[Dr],
          M,
          null,
          V,
          U,
          J,
          G,
          X
        ), ut++);
      }
      const og = un ? V3(ca) : gn;
      for (De = og.length - 1, z = xr - 1; z >= 0; z--) {
        const $t = xe + z, Dr = N[$t], ug = $t + 1 < re ? N[$t + 1].el : q;
        ca[z] === 0 ? d(
          null,
          Dr,
          M,
          ug,
          V,
          U,
          J,
          G,
          X
        ) : un && (De < 0 || z !== og[De] ? k(Dr, M, ug, 2) : De--);
      }
    }
  }, k = (w, N, M, q, V = null) => {
    const { el: U, type: J, transition: G, children: X, shapeFlag: z } = w;
    if (z & 6) {
      k(w.component.subTree, N, M, q);
      return;
    }
    if (z & 128) {
      w.suspense.move(N, M, q);
      return;
    }
    if (z & 64) {
      J.move(w, N, M, me);
      return;
    }
    if (J === ct) {
      s(U, N, M);
      for (let ce = 0; ce < X.length; ce++)
        k(X[ce], N, M, q);
      s(w.anchor, N, M);
      return;
    }
    if (J === Es) {
      b(w, N, M);
      return;
    }
    if (q !== 2 && z & 1 && G)
      if (q === 0)
        G.beforeEnter(U), s(U, N, M), mt(() => G.enter(U), V);
      else {
        const { leave: ce, delayLeave: pe, afterLeave: ve } = G, xe = () => s(U, N, M), qe = () => {
          ce(U, () => {
            xe(), ve && ve();
          });
        };
        pe ? pe(U, xe, qe) : qe();
      }
    else
      s(U, N, M);
  }, R = (w, N, M, q = !1, V = !1) => {
    const {
      type: U,
      props: J,
      ref: G,
      children: X,
      dynamicChildren: z,
      shapeFlag: re,
      patchFlag: ce,
      dirs: pe,
      cacheIndex: ve
    } = w;
    if (ce === -2 && (V = !1), G != null && nl(G, null, M, w, !0), ve != null && (N.renderCache[ve] = void 0), re & 256) {
      N.ctx.deactivate(w);
      return;
    }
    const xe = re & 1 && pe, qe = !Di(w);
    let De;
    if (qe && (De = J && J.onVnodeBeforeUnmount) && Kt(De, N, w), re & 6)
      ie(w.component, M, q);
    else {
      if (re & 128) {
        w.suspense.unmount(M, q);
        return;
      }
      xe && Mr(w, null, N, "beforeUnmount"), re & 64 ? w.type.remove(
        w,
        N,
        M,
        me,
        q
      ) : z && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !z.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (U !== ct || ce > 0 && ce & 64) ? L(
        z,
        N,
        M,
        !1,
        !0
      ) : (U === ct && ce & 384 || !V && re & 16) && L(X, N, M), q && D(w);
    }
    (qe && (De = J && J.onVnodeUnmounted) || xe) && mt(() => {
      De && Kt(De, N, w), xe && Mr(w, null, N, "unmounted");
    }, M);
  }, D = (w) => {
    const { type: N, el: M, anchor: q, transition: V } = w;
    if (N === ct) {
      process.env.NODE_ENV !== "production" && w.patchFlag > 0 && w.patchFlag & 2048 && V && !V.persisted ? w.children.forEach((J) => {
        J.type === Je ? i(J.el) : D(J);
      }) : B(M, q);
      return;
    }
    if (N === Es) {
      v(w);
      return;
    }
    const U = () => {
      i(M), V && !V.persisted && V.afterLeave && V.afterLeave();
    };
    if (w.shapeFlag & 1 && V && !V.persisted) {
      const { leave: J, delayLeave: G } = V, X = () => J(M, U);
      G ? G(w.el, U, X) : X();
    } else
      U();
  }, B = (w, N) => {
    let M;
    for (; w !== N; )
      M = p(w), i(w), w = M;
    i(N);
  }, ie = (w, N, M) => {
    process.env.NODE_ENV !== "production" && w.type.__hmrId && yP(w);
    const { bum: q, scope: V, update: U, subTree: J, um: G, m: X, a: z } = w;
    ol(X), ol(z), q && Gs(q), V.stop(), U && (U.active = !1, R(J, w, N, M)), G && mt(G, N), mt(() => {
      w.isUnmounted = !0;
    }, N), N && N.pendingBranch && !N.isUnmounted && w.asyncDep && !w.asyncResolved && w.suspenseId === N.pendingId && (N.deps--, N.deps === 0 && N.resolve()), process.env.NODE_ENV !== "production" && xP(w);
  }, L = (w, N, M, q = !1, V = !1, U = 0) => {
    for (let J = U; J < w.length; J++)
      R(w[J], N, M, q, V);
  }, ne = (w) => {
    if (w.shapeFlag & 6)
      return ne(w.component.subTree);
    if (w.shapeFlag & 128)
      return w.suspense.next();
    const N = p(w.anchor || w.el), M = N && N[Ov];
    return M ? p(M) : N;
  };
  let ye = !1;
  const be = (w, N, M) => {
    w == null ? N._vnode && R(N._vnode, null, null, !0) : d(
      N._vnode || null,
      w,
      N,
      null,
      null,
      null,
      M
    ), N._vnode = w, ye || (ye = !0, bg(), tl(), ye = !1);
  }, me = {
    p: d,
    um: R,
    m: k,
    r: D,
    mt: W,
    mc: _,
    pc: Ce,
    pbc: P,
    n: ne,
    o: r
  };
  let ke, Ke;
  return e && ([ke, Ke] = e(
    me
  )), {
    render: be,
    hydrate: ke,
    createApp: d3(be, ke)
  };
}
function Tf({ type: r, props: e }, t) {
  return t === "svg" && r === "foreignObject" || t === "mathml" && r === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t;
}
function gi({ effect: r, update: e }, t) {
  r.allowRecurse = e.allowRecurse = t;
}
function $v(r, e) {
  return (!r || r && !r.pendingBranch) && e && !e.persisted;
}
function $a(r, e, t = !1) {
  const s = r.children, i = e.children;
  if (se(s) && se(i))
    for (let n = 0; n < s.length; n++) {
      const a = s[n];
      let o = i[n];
      o.shapeFlag & 1 && !o.dynamicChildren && ((o.patchFlag <= 0 || o.patchFlag === 32) && (o = i[n] = Ws(i[n]), o.el = a.el), !t && o.patchFlag !== -2 && $a(a, o)), o.type === Xr && (o.el = a.el), process.env.NODE_ENV !== "production" && o.type === Je && !o.el && (o.el = a.el);
    }
}
function V3(r) {
  const e = r.slice(), t = [0];
  let s, i, n, a, o;
  const u = r.length;
  for (s = 0; s < u; s++) {
    const l = r[s];
    if (l !== 0) {
      if (i = t[t.length - 1], r[i] < l) {
        e[s] = i, t.push(s);
        continue;
      }
      for (n = 0, a = t.length - 1; n < a; )
        o = n + a >> 1, r[t[o]] < l ? n = o + 1 : a = o;
      l < r[t[n]] && (n > 0 && (e[s] = t[n - 1]), t[n] = s);
    }
  }
  for (n = t.length, a = t[n - 1]; n-- > 0; )
    t[n] = a, a = e[a];
  return t;
}
function Fv(r) {
  const e = r.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : Fv(e);
}
function ol(r) {
  if (r)
    for (let e = 0; e < r.length; e++) r[e].active = !1;
}
const ko = Symbol.for("v-scx"), Bv = () => {
  {
    const r = Ra(ko);
    return r || process.env.NODE_ENV !== "production" && j(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), r;
  }
};
function U3(r, e) {
  return Do(r, null, e);
}
function Vv(r, e) {
  return Do(
    r,
    null,
    process.env.NODE_ENV !== "production" ? Be({}, e, { flush: "post" }) : { flush: "post" }
  );
}
function Uv(r, e) {
  return Do(
    r,
    null,
    process.env.NODE_ENV !== "production" ? Be({}, e, { flush: "sync" }) : { flush: "sync" }
  );
}
const nu = {};
function Fa(r, e, t) {
  return process.env.NODE_ENV !== "production" && !fe(e) && j(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), Do(r, e, t);
}
function Do(r, e, {
  immediate: t,
  deep: s,
  flush: i,
  once: n,
  onTrack: a,
  onTrigger: o
} = Oe) {
  if (e && n) {
    const C = e;
    e = (...x) => {
      C(...x), A();
    };
  }
  process.env.NODE_ENV !== "production" && s !== void 0 && typeof s == "number" && j(
    'watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.'
  ), process.env.NODE_ENV !== "production" && !e && (t !== void 0 && j(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), s !== void 0 && j(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), n !== void 0 && j(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const u = (C) => {
    j(
      "Invalid watch source: ",
      C,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, l = nt, c = (C) => s === !0 ? C : (
    // for deep: false, only traverse root-level properties
    Xs(C, s === !1 ? 1 : void 0)
  );
  let f, p = !1, h = !1;
  if (pt(r) ? (f = () => r.value, p = Gr(r)) : Zs(r) ? (f = () => c(r), p = !0) : se(r) ? (h = !0, p = r.some((C) => Zs(C) || Gr(C)), f = () => r.map((C) => {
    if (pt(C))
      return C.value;
    if (Zs(C))
      return c(C);
    if (fe(C))
      return Kr(C, l, 2);
    process.env.NODE_ENV !== "production" && u(C);
  })) : fe(r) ? e ? f = () => Kr(r, l, 2) : f = () => (m && m(), ar(
    r,
    l,
    3,
    [d]
  )) : (f = Ge, process.env.NODE_ENV !== "production" && u(r)), e && s) {
    const C = f;
    f = () => Xs(C());
  }
  let m, d = (C) => {
    m = b.onStop = () => {
      Kr(C, l, 4), m = b.onStop = void 0;
    };
  }, y;
  if (Lo)
    if (d = Ge, e ? t && ar(e, l, 3, [
      f(),
      h ? [] : void 0,
      d
    ]) : f(), i === "sync") {
      const C = Bv();
      y = C.__watcherHandles || (C.__watcherHandles = []);
    } else
      return Ge;
  let S = h ? new Array(r.length).fill(nu) : nu;
  const E = () => {
    if (!(!b.active || !b.dirty))
      if (e) {
        const C = b.run();
        (s || p || (h ? C.some((x, _) => jt(x, S[_])) : jt(C, S))) && (m && m(), ar(e, l, 3, [
          C,
          // pass undefined as the old value when it's changed for the first time
          S === nu ? void 0 : h && S[0] === nu ? [] : S,
          d
        ]), S = C);
      } else
        b.run();
  };
  E.allowRecurse = !!e;
  let g;
  i === "sync" ? g = E : i === "post" ? g = () => mt(E, l && l.suspense) : (E.pre = !0, l && (E.id = l.uid), g = () => No(E));
  const b = new Cn(f, Ge, g), v = Ib(), A = () => {
    b.stop(), v && td(v.effects, b);
  };
  return process.env.NODE_ENV !== "production" && (b.onTrack = a, b.onTrigger = o), e ? t ? E() : S = b.run() : i === "post" ? mt(
    b.run.bind(b),
    l && l.suspense
  ) : b.run(), y && y.push(A), A;
}
function j3(r, e, t) {
  const s = this.proxy, i = _e(r) ? r.includes(".") ? jv(s, r) : () => s[r] : r.bind(s, s);
  let n;
  fe(e) ? n = e : (n = e.handler, t = e);
  const a = zi(this), o = Do(i, n.bind(s), t);
  return a(), o;
}
function jv(r, e) {
  const t = e.split(".");
  return () => {
    let s = r;
    for (let i = 0; i < t.length && s; i++)
      s = s[t[i]];
    return s;
  };
}
function Xs(r, e = 1 / 0, t) {
  if (e <= 0 || !Ae(r) || r.__v_skip || (t = t || /* @__PURE__ */ new Set(), t.has(r)))
    return r;
  if (t.add(r), e--, pt(r))
    Xs(r.value, e, t);
  else if (se(r))
    for (let s = 0; s < r.length; s++)
      Xs(r[s], e, t);
  else if (Qi(r) || Ci(r))
    r.forEach((s) => {
      Xs(s, e, t);
    });
  else if (wb(r)) {
    for (const s in r)
      Xs(r[s], e, t);
    for (const s of Object.getOwnPropertySymbols(r))
      Object.prototype.propertyIsEnumerable.call(r, s) && Xs(r[s], e, t);
  }
  return r;
}
function q3(r, e, t = Oe) {
  const s = is();
  if (process.env.NODE_ENV !== "production" && !s)
    return j("useModel() called without active instance."), Ii();
  if (process.env.NODE_ENV !== "production" && !s.propsOptions[0][e])
    return j(`useModel() called with prop "${e}" which is not declared.`), Ii();
  const i = Et(e), n = Tt(e), a = qv(r, e), o = Jb((u, l) => {
    let c, f = Oe, p;
    return Uv(() => {
      const h = r[e];
      jt(c, h) && (c = h, l());
    }), {
      get() {
        return u(), t.get ? t.get(c) : c;
      },
      set(h) {
        const m = t.set ? t.set(h) : h;
        if (!jt(m, c) && !(f !== Oe && jt(h, f)))
          return;
        const d = s.vnode.props;
        d && // check if parent has passed v-model
        (e in d || i in d || n in d) && (`onUpdate:${e}` in d || `onUpdate:${i}` in d || `onUpdate:${n}` in d) || (c = h, l()), s.emit(`update:${e}`, m), jt(h, m) && jt(h, f) && !jt(m, p) && l(), f = h, p = m;
      }
    };
  });
  return o[Symbol.iterator] = () => {
    let u = 0;
    return {
      next() {
        return u < 2 ? { value: u++ ? a || Oe : o, done: !1 } : { done: !0 };
      }
    };
  }, o;
}
const qv = (r, e) => e === "modelValue" || e === "model-value" ? r.modelModifiers : r[`${e}Modifiers`] || r[`${Et(e)}Modifiers`] || r[`${Tt(e)}Modifiers`];
function H3(r, e, ...t) {
  if (r.isUnmounted) return;
  const s = r.vnode.props || Oe;
  if (process.env.NODE_ENV !== "production") {
    const {
      emitsOptions: c,
      propsOptions: [f]
    } = r;
    if (c)
      if (!(e in c))
        (!f || !(ps(Et(e)) in f)) && j(
          `Component emitted event "${e}" but it is neither declared in the emits option nor as an "${ps(Et(e))}" prop.`
        );
      else {
        const p = c[e];
        fe(p) && (p(...t) || j(
          `Invalid event arguments: event validation failed for event "${e}".`
        ));
      }
  }
  let i = t;
  const n = e.startsWith("update:"), a = n && qv(s, e.slice(7));
  if (a && (a.trim && (i = t.map((c) => _e(c) ? c.trim() : c)), a.number && (i = t.map(Qu))), process.env.NODE_ENV !== "production" && PP(r, e, i), process.env.NODE_ENV !== "production") {
    const c = e.toLowerCase();
    c !== e && s[ps(c)] && j(
      `Event "${c}" is emitted in component ${mc(
        r,
        r.type
      )} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Tt(
        e
      )}" instead of "${e}".`
    );
  }
  let o, u = s[o = ps(e)] || // also try camelCase event handler (#2249)
  s[o = ps(Et(e))];
  !u && n && (u = s[o = ps(Tt(e))]), u && ar(
    u,
    r,
    6,
    i
  );
  const l = s[o + "Once"];
  if (l) {
    if (!r.emitted)
      r.emitted = {};
    else if (r.emitted[o])
      return;
    r.emitted[o] = !0, ar(
      l,
      r,
      6,
      i
    );
  }
}
function Hv(r, e, t = !1) {
  const s = e.emitsCache, i = s.get(r);
  if (i !== void 0)
    return i;
  const n = r.emits;
  let a = {}, o = !1;
  if (!fe(r)) {
    const u = (l) => {
      const c = Hv(l, e, !0);
      c && (o = !0, Be(a, c));
    };
    !t && e.mixins.length && e.mixins.forEach(u), r.extends && u(r.extends), r.mixins && r.mixins.forEach(u);
  }
  return !n && !o ? (Ae(r) && s.set(r, null), null) : (se(n) ? n.forEach((u) => a[u] = null) : Be(a, n), Ae(r) && s.set(r, a), a);
}
function pc(r, e) {
  return !r || !Yi(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Pe(r, e[0].toLowerCase() + e.slice(1)) || Pe(r, Tt(e)) || Pe(r, e));
}
let vp = !1;
function ul() {
  vp = !0;
}
function Nu(r) {
  const {
    type: e,
    vnode: t,
    proxy: s,
    withProxy: i,
    propsOptions: [n],
    slots: a,
    attrs: o,
    emit: u,
    render: l,
    renderCache: c,
    props: f,
    data: p,
    setupState: h,
    ctx: m,
    inheritAttrs: d
  } = r, y = so(r);
  let S, E;
  process.env.NODE_ENV !== "production" && (vp = !1);
  try {
    if (t.shapeFlag & 4) {
      const v = i || s, A = process.env.NODE_ENV !== "production" && h.__isScriptSetup ? new Proxy(v, {
        get(C, x, _) {
          return j(
            `Property '${String(
              x
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(C, x, _);
        }
      }) : v;
      S = qt(
        l.call(
          A,
          v,
          c,
          process.env.NODE_ENV !== "production" ? Ar(f) : f,
          h,
          p,
          m
        )
      ), E = o;
    } else {
      const v = e;
      process.env.NODE_ENV !== "production" && o === f && ul(), S = qt(
        v.length > 1 ? v(
          process.env.NODE_ENV !== "production" ? Ar(f) : f,
          process.env.NODE_ENV !== "production" ? {
            get attrs() {
              return ul(), Ar(o);
            },
            slots: a,
            emit: u
          } : { attrs: o, slots: a, emit: u }
        ) : v(
          process.env.NODE_ENV !== "production" ? Ar(f) : f,
          null
        )
      ), E = e.props ? o : W3(o);
    }
  } catch (v) {
    Ba.length = 0, ci(v, r, 1), S = He(Je);
  }
  let g = S, b;
  if (process.env.NODE_ENV !== "production" && S.patchFlag > 0 && S.patchFlag & 2048 && ([g, b] = Wv(S)), E && d !== !1) {
    const v = Object.keys(E), { shapeFlag: A } = g;
    if (v.length) {
      if (A & 7)
        n && v.some(Yu) && (E = z3(
          E,
          n
        )), g = yr(g, E, !1, !0);
      else if (process.env.NODE_ENV !== "production" && !vp && g.type !== Je) {
        const C = Object.keys(o), x = [], _ = [];
        for (let T = 0, P = C.length; T < P; T++) {
          const I = C[T];
          Yi(I) ? Yu(I) || x.push(I[2].toLowerCase() + I.slice(3)) : _.push(I);
        }
        _.length && j(
          `Extraneous non-props attributes (${_.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
        ), x.length && j(
          `Extraneous non-emits event listeners (${x.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return t.dirs && (process.env.NODE_ENV !== "production" && !Dg(g) && j(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), g = yr(g, null, !1, !0), g.dirs = g.dirs ? g.dirs.concat(t.dirs) : t.dirs), t.transition && (process.env.NODE_ENV !== "production" && !Dg(g) && j(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), g.transition = t.transition), process.env.NODE_ENV !== "production" && b ? b(g) : S = g, so(y), S;
}
const Wv = (r) => {
  const e = r.children, t = r.dynamicChildren, s = hc(e, !1);
  if (s) {
    if (process.env.NODE_ENV !== "production" && s.patchFlag > 0 && s.patchFlag & 2048)
      return Wv(s);
  } else return [r, void 0];
  const i = e.indexOf(s), n = t ? t.indexOf(s) : -1, a = (o) => {
    e[i] = o, t && (n > -1 ? t[n] = o : o.patchFlag > 0 && (r.dynamicChildren = [...t, o]));
  };
  return [qt(s), a];
};
function hc(r, e = !0) {
  let t;
  for (let s = 0; s < r.length; s++) {
    const i = r[s];
    if (ws(i)) {
      if (i.type !== Je || i.children === "v-if") {
        if (t)
          return;
        if (t = i, process.env.NODE_ENV !== "production" && e && t.patchFlag > 0 && t.patchFlag & 2048)
          return hc(t.children);
      }
    } else
      return;
  }
  return t;
}
const W3 = (r) => {
  let e;
  for (const t in r)
    (t === "class" || t === "style" || Yi(t)) && ((e || (e = {}))[t] = r[t]);
  return e;
}, z3 = (r, e) => {
  const t = {};
  for (const s in r)
    (!Yu(s) || !(s.slice(9) in e)) && (t[s] = r[s]);
  return t;
}, Dg = (r) => r.shapeFlag & 7 || r.type === Je;
function G3(r, e, t) {
  const { props: s, children: i, component: n } = r, { props: a, children: o, patchFlag: u } = e, l = n.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (i || o) && ei || e.dirs || e.transition)
    return !0;
  if (t && u >= 0) {
    if (u & 1024)
      return !0;
    if (u & 16)
      return s ? Lg(s, a, l) : !!a;
    if (u & 8) {
      const c = e.dynamicProps;
      for (let f = 0; f < c.length; f++) {
        const p = c[f];
        if (a[p] !== s[p] && !pc(l, p))
          return !0;
      }
    }
  } else
    return (i || o) && (!o || !o.$stable) ? !0 : s === a ? !1 : s ? a ? Lg(s, a, l) : !0 : !!a;
  return !1;
}
function Lg(r, e, t) {
  const s = Object.keys(e);
  if (s.length !== Object.keys(r).length)
    return !0;
  for (let i = 0; i < s.length; i++) {
    const n = s[i];
    if (e[n] !== r[n] && !pc(t, n))
      return !0;
  }
  return !1;
}
function Id({ vnode: r, parent: e }, t) {
  for (; e; ) {
    const s = e.subTree;
    if (s.suspense && s.suspense.activeBranch === r && (s.el = r.el), s === r)
      (r = e.vnode).el = t, e = e.parent;
    else
      break;
  }
}
const Ep = (r) => r.__isSuspense;
let Sp = 0;
const K3 = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: !0,
  process(r, e, t, s, i, n, a, o, u, l) {
    if (r == null)
      J3(
        e,
        t,
        s,
        i,
        n,
        a,
        o,
        u,
        l
      );
    else {
      if (n && n.deps > 0 && !r.suspense.isInFallback) {
        e.suspense = r.suspense, e.suspense.vnode = e, e.el = r.el;
        return;
      }
      Y3(
        r,
        e,
        t,
        s,
        i,
        a,
        o,
        u,
        l
      );
    }
  },
  hydrate: Q3,
  normalize: Z3
}, X3 = K3;
function no(r, e) {
  const t = r.props && r.props[e];
  fe(t) && t();
}
function J3(r, e, t, s, i, n, a, o, u) {
  const {
    p: l,
    o: { createElement: c }
  } = u, f = c("div"), p = r.suspense = zv(
    r,
    i,
    s,
    e,
    f,
    t,
    n,
    a,
    o,
    u
  );
  l(
    null,
    p.pendingBranch = r.ssContent,
    f,
    null,
    s,
    p,
    n,
    a
  ), p.deps > 0 ? (no(r, "onPending"), no(r, "onFallback"), l(
    null,
    r.ssFallback,
    e,
    t,
    s,
    null,
    // fallback tree will not have suspense context
    n,
    a
  ), En(p, r.ssFallback)) : p.resolve(!1, !0);
}
function Y3(r, e, t, s, i, n, a, o, { p: u, um: l, o: { createElement: c } }) {
  const f = e.suspense = r.suspense;
  f.vnode = e, e.el = r.el;
  const p = e.ssContent, h = e.ssFallback, { activeBranch: m, pendingBranch: d, isInFallback: y, isHydrating: S } = f;
  if (d)
    f.pendingBranch = p, Pr(p, d) ? (u(
      d,
      p,
      f.hiddenContainer,
      null,
      i,
      f,
      n,
      a,
      o
    ), f.deps <= 0 ? f.resolve() : y && (S || (u(
      m,
      h,
      t,
      s,
      i,
      null,
      // fallback tree will not have suspense context
      n,
      a,
      o
    ), En(f, h)))) : (f.pendingId = Sp++, S ? (f.isHydrating = !1, f.activeBranch = d) : l(d, i, f), f.deps = 0, f.effects.length = 0, f.hiddenContainer = c("div"), y ? (u(
      null,
      p,
      f.hiddenContainer,
      null,
      i,
      f,
      n,
      a,
      o
    ), f.deps <= 0 ? f.resolve() : (u(
      m,
      h,
      t,
      s,
      i,
      null,
      // fallback tree will not have suspense context
      n,
      a,
      o
    ), En(f, h))) : m && Pr(p, m) ? (u(
      m,
      p,
      t,
      s,
      i,
      f,
      n,
      a,
      o
    ), f.resolve(!0)) : (u(
      null,
      p,
      f.hiddenContainer,
      null,
      i,
      f,
      n,
      a,
      o
    ), f.deps <= 0 && f.resolve()));
  else if (m && Pr(p, m))
    u(
      m,
      p,
      t,
      s,
      i,
      f,
      n,
      a,
      o
    ), En(f, p);
  else if (no(e, "onPending"), f.pendingBranch = p, p.shapeFlag & 512 ? f.pendingId = p.component.suspenseId : f.pendingId = Sp++, u(
    null,
    p,
    f.hiddenContainer,
    null,
    i,
    f,
    n,
    a,
    o
  ), f.deps <= 0)
    f.resolve();
  else {
    const { timeout: E, pendingId: g } = f;
    E > 0 ? setTimeout(() => {
      f.pendingId === g && f.fallback(h);
    }, E) : E === 0 && f.fallback(h);
  }
}
let Mg = !1;
function zv(r, e, t, s, i, n, a, o, u, l, c = !1) {
  process.env.NODE_ENV !== "production" && !Mg && (Mg = !0, console[console.info ? "info" : "log"](
    "<Suspense> is an experimental feature and its API will likely change."
  ));
  const {
    p: f,
    m: p,
    um: h,
    n: m,
    o: { parentNode: d, remove: y }
  } = l;
  let S;
  const E = eA(r);
  E && e && e.pendingBranch && (S = e.pendingId, e.deps++);
  const g = r.props ? Zu(r.props.timeout) : void 0;
  process.env.NODE_ENV !== "production" && md(g, "Suspense timeout");
  const b = n, v = {
    vnode: r,
    parent: e,
    parentComponent: t,
    namespace: a,
    container: s,
    hiddenContainer: i,
    deps: 0,
    pendingId: Sp++,
    timeout: typeof g == "number" ? g : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !c,
    isHydrating: c,
    isUnmounted: !1,
    effects: [],
    resolve(A = !1, C = !1) {
      if (process.env.NODE_ENV !== "production") {
        if (!A && !v.pendingBranch)
          throw new Error(
            "suspense.resolve() is called without a pending branch."
          );
        if (v.isUnmounted)
          throw new Error(
            "suspense.resolve() is called on an already unmounted suspense boundary."
          );
      }
      const {
        vnode: x,
        activeBranch: _,
        pendingBranch: T,
        pendingId: P,
        effects: I,
        parentComponent: $,
        container: Y
      } = v;
      let W = !1;
      v.isHydrating ? v.isHydrating = !1 : A || (W = _ && T.transition && T.transition.mode === "out-in", W && (_.transition.afterLeave = () => {
        P === v.pendingId && (p(
          T,
          Y,
          n === b ? m(_) : n,
          0
        ), to(I));
      }), _ && (d(_.el) !== v.hiddenContainer && (n = m(_)), h(_, $, v, !0)), W || p(T, Y, n, 0)), En(v, T), v.pendingBranch = null, v.isInFallback = !1;
      let F = v.parent, K = !1;
      for (; F; ) {
        if (F.pendingBranch) {
          F.effects.push(...I), K = !0;
          break;
        }
        F = F.parent;
      }
      !K && !W && to(I), v.effects = [], E && e && e.pendingBranch && S === e.pendingId && (e.deps--, e.deps === 0 && !C && e.resolve()), no(x, "onResolve");
    },
    fallback(A) {
      if (!v.pendingBranch)
        return;
      const { vnode: C, activeBranch: x, parentComponent: _, container: T, namespace: P } = v;
      no(C, "onFallback");
      const I = m(x), $ = () => {
        v.isInFallback && (f(
          null,
          A,
          T,
          I,
          _,
          null,
          // fallback tree will not have suspense context
          P,
          o,
          u
        ), En(v, A));
      }, Y = A.transition && A.transition.mode === "out-in";
      Y && (x.transition.afterLeave = $), v.isInFallback = !0, h(
        x,
        _,
        null,
        // no suspense so unmount hooks fire now
        !0
        // shouldRemove
      ), Y || $();
    },
    move(A, C, x) {
      v.activeBranch && p(v.activeBranch, A, C, x), v.container = A;
    },
    next() {
      return v.activeBranch && m(v.activeBranch);
    },
    registerDep(A, C, x) {
      const _ = !!v.pendingBranch;
      _ && v.deps++;
      const T = A.vnode.el;
      A.asyncDep.catch((P) => {
        ci(P, A, 0);
      }).then((P) => {
        if (A.isUnmounted || v.isUnmounted || v.pendingId !== A.suspenseId)
          return;
        A.asyncResolved = !0;
        const { vnode: I } = A;
        process.env.NODE_ENV !== "production" && Da(I), Ap(A, P, !1), T && (I.el = T);
        const $ = !T && A.subTree.el;
        C(
          A,
          I,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          d(T || A.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          T ? null : m(A.subTree),
          v,
          a,
          x
        ), $ && y($), Id(A, I.el), process.env.NODE_ENV !== "production" && La(), _ && --v.deps === 0 && v.resolve();
      });
    },
    unmount(A, C) {
      v.isUnmounted = !0, v.activeBranch && h(
        v.activeBranch,
        t,
        A,
        C
      ), v.pendingBranch && h(
        v.pendingBranch,
        t,
        A,
        C
      );
    }
  };
  return v;
}
function Q3(r, e, t, s, i, n, a, o, u) {
  const l = e.suspense = zv(
    e,
    s,
    t,
    r.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    i,
    n,
    a,
    o,
    !0
  ), c = u(
    r,
    l.pendingBranch = e.ssContent,
    t,
    l,
    n,
    a
  );
  return l.deps === 0 && l.resolve(!1, !0), c;
}
function Z3(r) {
  const { shapeFlag: e, children: t } = r, s = e & 32;
  r.ssContent = Rg(
    s ? t.default : t
  ), r.ssFallback = s ? Rg(t.fallback) : He(Je);
}
function Rg(r) {
  let e;
  if (fe(r)) {
    const t = Wi && r._c;
    t && (r._d = !1, dc()), r = r(), t && (r._d = !0, e = Lt, Kv());
  }
  if (se(r)) {
    const t = hc(r);
    process.env.NODE_ENV !== "production" && !t && r.filter((s) => s !== Td).length > 0 && j("<Suspense> slots expect a single root node."), r = t;
  }
  return r = qt(r), e && !r.dynamicChildren && (r.dynamicChildren = e.filter((t) => t !== r)), r;
}
function Gv(r, e) {
  e && e.pendingBranch ? se(r) ? e.effects.push(...r) : e.effects.push(r) : to(r);
}
function En(r, e) {
  r.activeBranch = e;
  const { vnode: t, parentComponent: s } = r;
  let i = e.el;
  for (; !i && e.component; )
    e = e.component.subTree, i = e.el;
  t.el = i, s && s.subTree === t && (s.vnode.el = i, Id(s, i));
}
function eA(r) {
  const e = r.props && r.props.suspensible;
  return e != null && e !== !1;
}
const ct = Symbol.for("v-fgt"), Xr = Symbol.for("v-txt"), Je = Symbol.for("v-cmt"), Es = Symbol.for("v-stc"), Ba = [];
let Lt = null;
function dc(r = !1) {
  Ba.push(Lt = r ? null : []);
}
function Kv() {
  Ba.pop(), Lt = Ba[Ba.length - 1] || null;
}
let Wi = 1;
function _p(r) {
  Wi += r, r < 0 && Lt && (Lt.hasOnce = !0);
}
function Xv(r) {
  return r.dynamicChildren = Wi > 0 ? Lt || gn : null, Kv(), Wi > 0 && Lt && Lt.push(r), r;
}
function tA(r, e, t, s, i, n) {
  return Xv(
    Dd(
      r,
      e,
      t,
      s,
      i,
      n,
      !0
    )
  );
}
function kd(r, e, t, s, i) {
  return Xv(
    He(
      r,
      e,
      t,
      s,
      i,
      !0
    )
  );
}
function ws(r) {
  return r ? r.__v_isVNode === !0 : !1;
}
function Pr(r, e) {
  if (process.env.NODE_ENV !== "production" && e.shapeFlag & 6 && r.component) {
    const t = Cu.get(e.type);
    if (t && t.has(r.component))
      return r.shapeFlag &= -257, e.shapeFlag &= -513, !1;
  }
  return r.type === e.type && r.key === e.key;
}
let xp;
function rA(r) {
  xp = r;
}
const sA = (...r) => Yv(
  ...xp ? xp(r, st) : r
), Jv = ({ key: r }) => r ?? null, Ou = ({
  ref: r,
  ref_key: e,
  ref_for: t
}) => (typeof r == "number" && (r = "" + r), r != null ? _e(r) || pt(r) || fe(r) ? { i: st, r, k: e, f: !!t } : r : null);
function Dd(r, e = null, t = null, s = 0, i = null, n = r === ct ? 0 : 1, a = !1, o = !1) {
  const u = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r,
    props: e,
    key: e && Jv(e),
    ref: e && Ou(e),
    scopeId: ac,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: n,
    patchFlag: s,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: st
  };
  return o ? (Md(u, t), n & 128 && r.normalize(u)) : t && (u.shapeFlag |= _e(t) ? 8 : 16), process.env.NODE_ENV !== "production" && u.key !== u.key && j("VNode created with invalid key (NaN). VNode type:", u.type), Wi > 0 && // avoid a block node from tracking itself
  !a && // has current parent block
  Lt && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (u.patchFlag > 0 || n & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  u.patchFlag !== 32 && Lt.push(u), u;
}
const He = process.env.NODE_ENV !== "production" ? sA : Yv;
function Yv(r, e = null, t = null, s = 0, i = null, n = !1) {
  if ((!r || r === Td) && (process.env.NODE_ENV !== "production" && !r && j(`Invalid vnode type when creating vnode: ${r}.`), r = Je), ws(r)) {
    const o = yr(
      r,
      e,
      !0
      /* mergeRef: true */
    );
    return t && Md(o, t), Wi > 0 && !n && Lt && (o.shapeFlag & 6 ? Lt[Lt.indexOf(r)] = o : Lt.push(o)), o.patchFlag = -2, o;
  }
  if (nE(r) && (r = r.__vccOpts), e) {
    e = Qv(e);
    let { class: o, style: u } = e;
    o && !_e(o) && (e.class = en(o)), Ae(u) && (Qa(u) && !se(u) && (u = Be({}, u)), e.style = Zi(u));
  }
  const a = _e(r) ? 1 : Ep(r) ? 128 : N3(r) ? 64 : Ae(r) ? 4 : fe(r) ? 2 : 0;
  return process.env.NODE_ENV !== "production" && a & 4 && Qa(r) && (r = Ee(r), j(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    r
  )), Dd(
    r,
    e,
    t,
    s,
    i,
    a,
    n,
    !0
  );
}
function Qv(r) {
  return r ? Qa(r) || xv(r) ? Be({}, r) : r : null;
}
function yr(r, e, t = !1, s = !1) {
  const { props: i, ref: n, patchFlag: a, children: o, transition: u } = r, l = e ? Rd(i || {}, e) : i, c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r.type,
    props: l,
    key: l && Jv(l),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      t && n ? se(n) ? n.concat(Ou(e)) : [n, Ou(e)] : Ou(e)
    ) : n,
    scopeId: r.scopeId,
    slotScopeIds: r.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && a === -1 && se(o) ? o.map(Zv) : o,
    target: r.target,
    targetStart: r.targetStart,
    targetAnchor: r.targetAnchor,
    staticCount: r.staticCount,
    shapeFlag: r.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && r.type !== ct ? a === -1 ? 16 : a | 16 : a,
    dynamicProps: r.dynamicProps,
    dynamicChildren: r.dynamicChildren,
    appContext: r.appContext,
    dirs: r.dirs,
    transition: u,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: r.component,
    suspense: r.suspense,
    ssContent: r.ssContent && yr(r.ssContent),
    ssFallback: r.ssFallback && yr(r.ssFallback),
    el: r.el,
    anchor: r.anchor,
    ctx: r.ctx,
    ce: r.ce
  };
  return u && s && ni(
    c,
    u.clone(c)
  ), c;
}
function Zv(r) {
  const e = yr(r);
  return se(r.children) && (e.children = r.children.map(Zv)), e;
}
function Ld(r = " ", e = 0) {
  return He(Xr, null, r, e);
}
function iA(r, e) {
  const t = He(Es, null, r);
  return t.staticCount = e, t;
}
function nA(r = "", e = !1) {
  return e ? (dc(), kd(Je, null, r)) : He(Je, null, r);
}
function qt(r) {
  return r == null || typeof r == "boolean" ? He(Je) : se(r) ? He(
    ct,
    null,
    // #3666, avoid reference pollution when reusing vnode
    r.slice()
  ) : typeof r == "object" ? Ws(r) : He(Xr, null, String(r));
}
function Ws(r) {
  return r.el === null && r.patchFlag !== -1 || r.memo ? r : yr(r);
}
function Md(r, e) {
  let t = 0;
  const { shapeFlag: s } = r;
  if (e == null)
    e = null;
  else if (se(e))
    t = 16;
  else if (typeof e == "object")
    if (s & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), Md(r, i()), i._c && (i._d = !0));
      return;
    } else {
      t = 32;
      const i = e._;
      !i && !xv(e) ? e._ctx = st : i === 3 && st && (st.slots._ === 1 ? e._ = 1 : (e._ = 2, r.patchFlag |= 1024));
    }
  else fe(e) ? (e = { default: e, _ctx: st }, t = 32) : (e = String(e), s & 64 ? (t = 16, e = [Ld(e)]) : t = 8);
  r.children = e, r.shapeFlag |= t;
}
function Rd(...r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const s = r[t];
    for (const i in s)
      if (i === "class")
        e.class !== s.class && (e.class = en([e.class, s.class]));
      else if (i === "style")
        e.style = Zi([e.style, s.style]);
      else if (Yi(i)) {
        const n = e[i], a = s[i];
        a && n !== a && !(se(n) && n.includes(a)) && (e[i] = n ? [].concat(n, a) : a);
      } else i !== "" && (e[i] = s[i]);
  }
  return e;
}
function Kt(r, e, t, s = null) {
  ar(r, e, 7, [
    t,
    s
  ]);
}
const aA = vv();
let oA = 0;
function eE(r, e, t) {
  const s = r.type, i = (e ? e.appContext : r.appContext) || aA, n = {
    uid: oA++,
    vnode: r,
    type: s,
    parent: e,
    appContext: i,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new ad(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Tv(s, i),
    emitsOptions: Hv(s, i),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Oe,
    // inheritAttrs
    inheritAttrs: s.inheritAttrs,
    // state
    ctx: Oe,
    data: Oe,
    props: Oe,
    attrs: Oe,
    slots: Oe,
    refs: Oe,
    setupState: Oe,
    setupContext: null,
    // suspense related
    suspense: t,
    suspenseId: t ? t.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return process.env.NODE_ENV !== "production" ? n.ctx = WP(n) : n.ctx = { _: n }, n.root = e ? e.root : n, n.emit = H3.bind(null, n), r.ce && r.ce(n), n;
}
let nt = null;
const is = () => nt || st;
let ll, wp;
{
  const r = Zl(), e = (t, s) => {
    let i;
    return (i = r[t]) || (i = r[t] = []), i.push(s), (n) => {
      i.length > 1 ? i.forEach((a) => a(n)) : i[0](n);
    };
  };
  ll = e(
    "__VUE_INSTANCE_SETTERS__",
    (t) => nt = t
  ), wp = e(
    "__VUE_SSR_SETTERS__",
    (t) => Lo = t
  );
}
const zi = (r) => {
  const e = nt;
  return ll(r), r.scope.on(), () => {
    r.scope.off(), ll(e);
  };
}, Tp = () => {
  nt && nt.scope.off(), ll(null);
}, uA = /* @__PURE__ */ zt("slot,component");
function Pp(r, { isNativeTag: e }) {
  (uA(r) || e(r)) && j(
    "Do not use built-in or reserved HTML elements as component id: " + r
  );
}
function tE(r) {
  return r.vnode.shapeFlag & 4;
}
let Lo = !1;
function rE(r, e = !1, t = !1) {
  e && wp(e);
  const { props: s, children: i } = r.vnode, n = tE(r);
  g3(r, s, n, e), A3(r, i, t);
  const a = n ? lA(r, e) : void 0;
  return e && wp(!1), a;
}
function lA(r, e) {
  var t;
  const s = r.type;
  if (process.env.NODE_ENV !== "production") {
    if (s.name && Pp(s.name, r.appContext.config), s.components) {
      const n = Object.keys(s.components);
      for (let a = 0; a < n.length; a++)
        Pp(n[a], r.appContext.config);
    }
    if (s.directives) {
      const n = Object.keys(s.directives);
      for (let a = 0; a < n.length; a++)
        nv(n[a]);
    }
    s.compilerOptions && $d() && j(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  r.accessCache = /* @__PURE__ */ Object.create(null), r.proxy = new Proxy(r.ctx, Ma), process.env.NODE_ENV !== "production" && zP(r);
  const { setup: i } = s;
  if (i) {
    const n = r.setupContext = i.length > 1 ? iE(r) : null, a = zi(r);
    Os();
    const o = Kr(
      i,
      r,
      0,
      [
        process.env.NODE_ENV !== "production" ? Ar(r.props) : r.props,
        n
      ]
    );
    if (Is(), a(), es(o)) {
      if (o.then(Tp, Tp), e)
        return o.then((u) => {
          Ap(r, u, e);
        }).catch((u) => {
          ci(u, r, 0);
        });
      if (r.asyncDep = o, process.env.NODE_ENV !== "production" && !r.suspense) {
        const u = (t = s.name) != null ? t : "Anonymous";
        j(
          `Component <${u}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      Ap(r, o, e);
  } else
    sE(r, e);
}
function Ap(r, e, t) {
  fe(e) ? r.type.__ssrInlineRender ? r.ssrRender = e : r.render = e : Ae(e) ? (process.env.NODE_ENV !== "production" && ws(e) && j(
    "setup() should not return VNodes directly - return a render function instead."
  ), process.env.NODE_ENV !== "production" && (r.devtoolsRawSetupState = e), r.setupState = dd(e), process.env.NODE_ENV !== "production" && GP(r)) : process.env.NODE_ENV !== "production" && e !== void 0 && j(
    `setup() should return an object. Received: ${e === null ? "null" : typeof e}`
  ), sE(r, t);
}
let Va, Cp;
function cA(r) {
  Va = r, Cp = (e) => {
    e.render._rc && (e.withProxy = new Proxy(e.ctx, HP));
  };
}
const $d = () => !Va;
function sE(r, e, t) {
  const s = r.type;
  if (!r.render) {
    if (!e && Va && !s.render) {
      const i = s.template || Nd(r).template;
      if (i) {
        process.env.NODE_ENV !== "production" && as(r, "compile");
        const { isCustomElement: n, compilerOptions: a } = r.appContext.config, { delimiters: o, compilerOptions: u } = s, l = Be(
          Be(
            {
              isCustomElement: n,
              delimiters: o
            },
            a
          ),
          u
        );
        s.render = Va(i, l), process.env.NODE_ENV !== "production" && os(r, "compile");
      }
    }
    r.render = s.render || Ge, Cp && Cp(r);
  }
  {
    const i = zi(r);
    Os();
    try {
      u3(r);
    } finally {
      Is(), i();
    }
  }
  process.env.NODE_ENV !== "production" && !s.render && r.render === Ge && !e && (!Va && s.template ? j(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  ) : j("Component is missing template or render function: ", s));
}
const $g = process.env.NODE_ENV !== "production" ? {
  get(r, e) {
    return ul(), Ct(r, "get", ""), r[e];
  },
  set() {
    return j("setupContext.attrs is readonly."), !1;
  },
  deleteProperty() {
    return j("setupContext.attrs is readonly."), !1;
  }
} : {
  get(r, e) {
    return Ct(r, "get", ""), r[e];
  }
};
function fA(r) {
  return new Proxy(r.slots, {
    get(e, t) {
      return Ct(r, "get", "$slots"), e[t];
    }
  });
}
function iE(r) {
  const e = (t) => {
    if (process.env.NODE_ENV !== "production" && (r.exposed && j("expose() should be called only once per setup()."), t != null)) {
      let s = typeof t;
      s === "object" && (se(t) ? s = "array" : pt(t) && (s = "ref")), s !== "object" && j(
        `expose() should be passed a plain object, received ${s}.`
      );
    }
    r.exposed = t || {};
  };
  if (process.env.NODE_ENV !== "production") {
    let t, s;
    return Object.freeze({
      get attrs() {
        return t || (t = new Proxy(r.attrs, $g));
      },
      get slots() {
        return s || (s = fA(r));
      },
      get emit() {
        return (i, ...n) => r.emit(i, ...n);
      },
      expose: e
    });
  } else
    return {
      attrs: new Proxy(r.attrs, $g),
      slots: r.slots,
      emit: r.emit,
      expose: e
    };
}
function Mo(r) {
  return r.exposed ? r.exposeProxy || (r.exposeProxy = new Proxy(dd(Gb(r.exposed)), {
    get(e, t) {
      if (t in e)
        return e[t];
      if (t in Li)
        return Li[t](r);
    },
    has(e, t) {
      return t in e || t in Li;
    }
  })) : r.proxy;
}
const pA = /(?:^|[-_])(\w)/g, hA = (r) => r.replace(pA, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function ao(r, e = !0) {
  return fe(r) ? r.displayName || r.name : r.name || e && r.__name;
}
function mc(r, e, t = !1) {
  let s = ao(e);
  if (!s && e.__file) {
    const i = e.__file.match(/([^/\\]+)\.\w+$/);
    i && (s = i[1]);
  }
  if (!s && r && r.parent) {
    const i = (n) => {
      for (const a in n)
        if (n[a] === e)
          return a;
    };
    s = i(
      r.components || r.parent.type.components
    ) || i(r.appContext.components);
  }
  return s ? hA(s) : t ? "App" : "Anonymous";
}
function nE(r) {
  return fe(r) && "__vccOpts" in r;
}
const aE = (r, e) => {
  const t = GT(r, e, Lo);
  if (process.env.NODE_ENV !== "production") {
    const s = is();
    s && s.appContext.config.warnRecursiveComputed && (t._warnRecursive = !0);
  }
  return t;
};
function oE(r, e, t) {
  const s = arguments.length;
  return s === 2 ? Ae(e) && !se(e) ? ws(e) ? He(r, null, [e]) : He(r, e) : He(r, null, e) : (s > 3 ? t = Array.prototype.slice.call(arguments, 2) : s === 3 && ws(t) && (t = [t]), He(r, e, t));
}
function uE() {
  if (process.env.NODE_ENV === "production" || typeof window > "u")
    return;
  const r = { style: "color:#3ba776" }, e = { style: "color:#1677ff" }, t = { style: "color:#f5222d" }, s = { style: "color:#eb2f96" }, i = {
    __vue_custom_formatter: !0,
    header(f) {
      return Ae(f) ? f.__isVue ? ["div", r, "VueInstance"] : pt(f) ? [
        "div",
        {},
        ["span", r, c(f)],
        "<",
        o(f.value),
        ">"
      ] : Zs(f) ? [
        "div",
        {},
        ["span", r, Gr(f) ? "ShallowReactive" : "Reactive"],
        "<",
        o(f),
        `>${rs(f) ? " (readonly)" : ""}`
      ] : rs(f) ? [
        "div",
        {},
        ["span", r, Gr(f) ? "ShallowReadonly" : "Readonly"],
        "<",
        o(f),
        ">"
      ] : null : null;
    },
    hasBody(f) {
      return f && f.__isVue;
    },
    body(f) {
      if (f && f.__isVue)
        return [
          "div",
          {},
          ...n(f.$)
        ];
    }
  };
  function n(f) {
    const p = [];
    f.type.props && f.props && p.push(a("props", Ee(f.props))), f.setupState !== Oe && p.push(a("setup", f.setupState)), f.data !== Oe && p.push(a("data", Ee(f.data)));
    const h = u(f, "computed");
    h && p.push(a("computed", h));
    const m = u(f, "inject");
    return m && p.push(a("injected", m)), p.push([
      "div",
      {},
      [
        "span",
        {
          style: s.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: f }]
    ]), p;
  }
  function a(f, p) {
    return p = Be({}, p), Object.keys(p).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        f
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(p).map((h) => [
          "div",
          {},
          ["span", s, h + ": "],
          o(p[h], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function o(f, p = !0) {
    return typeof f == "number" ? ["span", e, f] : typeof f == "string" ? ["span", t, JSON.stringify(f)] : typeof f == "boolean" ? ["span", s, f] : Ae(f) ? ["object", { object: p ? Ee(f) : f }] : ["span", t, String(f)];
  }
  function u(f, p) {
    const h = f.type;
    if (fe(h))
      return;
    const m = {};
    for (const d in f.ctx)
      l(h, d, p) && (m[d] = f.ctx[d]);
    return m;
  }
  function l(f, p, h) {
    const m = f[h];
    if (se(m) && m.includes(p) || Ae(m) && p in m || f.extends && l(f.extends, p, h) || f.mixins && f.mixins.some((d) => l(d, p, h)))
      return !0;
  }
  function c(f) {
    return Gr(f) ? "ShallowRef" : f.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i];
}
function dA(r, e, t, s) {
  const i = t[s];
  if (i && lE(i, r))
    return i;
  const n = e();
  return n.memo = r.slice(), n.cacheIndex = s, t[s] = n;
}
function lE(r, e) {
  const t = r.memo;
  if (t.length != e.length)
    return !1;
  for (let s = 0; s < t.length; s++)
    if (jt(t[s], e[s]))
      return !1;
  return Wi > 0 && Lt && Lt.push(r), !0;
}
const Np = "3.4.37", ot = process.env.NODE_ENV !== "production" ? j : Ge, mA = ic, gA = (process.env.NODE_ENV, Tr), yA = (process.env.NODE_ENV, bd), bA = {
  createComponentInstance: eE,
  setupComponent: rE,
  renderComponentRoot: Nu,
  setCurrentRenderingInstance: so,
  isVNode: ws,
  normalizeVNode: qt,
  getComponentPublicInstance: Mo,
  ensureValidVNode: Ad
}, Kn = bA, vA = null, EA = null, SA = null;
/**
* @vue/runtime-dom v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const _A = "http://www.w3.org/2000/svg", xA = "http://www.w3.org/1998/Math/MathML", fs = typeof document < "u" ? document : null, Fg = fs && /* @__PURE__ */ fs.createElement("template"), wA = {
  insert: (r, e, t) => {
    e.insertBefore(r, t || null);
  },
  remove: (r) => {
    const e = r.parentNode;
    e && e.removeChild(r);
  },
  createElement: (r, e, t, s) => {
    const i = e === "svg" ? fs.createElementNS(_A, r) : e === "mathml" ? fs.createElementNS(xA, r) : t ? fs.createElement(r, { is: t }) : fs.createElement(r);
    return r === "select" && s && s.multiple != null && i.setAttribute("multiple", s.multiple), i;
  },
  createText: (r) => fs.createTextNode(r),
  createComment: (r) => fs.createComment(r),
  setText: (r, e) => {
    r.nodeValue = e;
  },
  setElementText: (r, e) => {
    r.textContent = e;
  },
  parentNode: (r) => r.parentNode,
  nextSibling: (r) => r.nextSibling,
  querySelector: (r) => fs.querySelector(r),
  setScopeId(r, e) {
    r.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(r, e, t, s, i, n) {
    const a = t ? t.previousSibling : e.lastChild;
    if (i && (i === n || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), t), !(i === n || !(i = i.nextSibling)); )
        ;
    else {
      Fg.innerHTML = s === "svg" ? `<svg>${r}</svg>` : s === "mathml" ? `<math>${r}</math>` : r;
      const o = Fg.content;
      if (s === "svg" || s === "mathml") {
        const u = o.firstChild;
        for (; u.firstChild; )
          o.appendChild(u.firstChild);
        o.removeChild(u);
      }
      e.insertBefore(o, t);
    }
    return [
      // first
      a ? a.nextSibling : e.firstChild,
      // last
      t ? t.previousSibling : e.lastChild
    ];
  }
}, Ms = "transition", ha = "animation", On = Symbol("_vtc"), Fd = (r, { slots: e }) => oE(ov, fE(r), e);
Fd.displayName = "Transition";
const cE = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, TA = Fd.props = /* @__PURE__ */ Be(
  {},
  _d,
  cE
), yi = (r, e = []) => {
  se(r) ? r.forEach((t) => t(...e)) : r && r(...e);
}, Bg = (r) => r ? se(r) ? r.some((e) => e.length > 1) : r.length > 1 : !1;
function fE(r) {
  const e = {};
  for (const I in r)
    I in cE || (e[I] = r[I]);
  if (r.css === !1)
    return e;
  const {
    name: t = "v",
    type: s,
    duration: i,
    enterFromClass: n = `${t}-enter-from`,
    enterActiveClass: a = `${t}-enter-active`,
    enterToClass: o = `${t}-enter-to`,
    appearFromClass: u = n,
    appearActiveClass: l = a,
    appearToClass: c = o,
    leaveFromClass: f = `${t}-leave-from`,
    leaveActiveClass: p = `${t}-leave-active`,
    leaveToClass: h = `${t}-leave-to`
  } = r, m = PA(i), d = m && m[0], y = m && m[1], {
    onBeforeEnter: S,
    onEnter: E,
    onEnterCancelled: g,
    onLeave: b,
    onLeaveCancelled: v,
    onBeforeAppear: A = S,
    onAppear: C = E,
    onAppearCancelled: x = g
  } = e, _ = (I, $, Y) => {
    Bs(I, $ ? c : o), Bs(I, $ ? l : a), Y && Y();
  }, T = (I, $) => {
    I._isLeaving = !1, Bs(I, f), Bs(I, h), Bs(I, p), $ && $();
  }, P = (I) => ($, Y) => {
    const W = I ? C : E, F = () => _($, I, Y);
    yi(W, [$, F]), Vg(() => {
      Bs($, I ? u : n), us($, I ? c : o), Bg(W) || Ug($, s, d, F);
    });
  };
  return Be(e, {
    onBeforeEnter(I) {
      yi(S, [I]), us(I, n), us(I, a);
    },
    onBeforeAppear(I) {
      yi(A, [I]), us(I, u), us(I, l);
    },
    onEnter: P(!1),
    onAppear: P(!0),
    onLeave(I, $) {
      I._isLeaving = !0;
      const Y = () => T(I, $);
      us(I, f), us(I, p), hE(), Vg(() => {
        I._isLeaving && (Bs(I, f), us(I, h), Bg(b) || Ug(I, s, y, Y));
      }), yi(b, [I, Y]);
    },
    onEnterCancelled(I) {
      _(I, !1), yi(g, [I]);
    },
    onAppearCancelled(I) {
      _(I, !0), yi(x, [I]);
    },
    onLeaveCancelled(I) {
      T(I), yi(v, [I]);
    }
  });
}
function PA(r) {
  if (r == null)
    return null;
  if (Ae(r))
    return [Pf(r.enter), Pf(r.leave)];
  {
    const e = Pf(r);
    return [e, e];
  }
}
function Pf(r) {
  const e = Zu(r);
  return process.env.NODE_ENV !== "production" && md(e, "<transition> explicit duration"), e;
}
function us(r, e) {
  e.split(/\s+/).forEach((t) => t && r.classList.add(t)), (r[On] || (r[On] = /* @__PURE__ */ new Set())).add(e);
}
function Bs(r, e) {
  e.split(/\s+/).forEach((s) => s && r.classList.remove(s));
  const t = r[On];
  t && (t.delete(e), t.size || (r[On] = void 0));
}
function Vg(r) {
  requestAnimationFrame(() => {
    requestAnimationFrame(r);
  });
}
let AA = 0;
function Ug(r, e, t, s) {
  const i = r._endId = ++AA, n = () => {
    i === r._endId && s();
  };
  if (t)
    return setTimeout(n, t);
  const { type: a, timeout: o, propCount: u } = pE(r, e);
  if (!a)
    return s();
  const l = a + "end";
  let c = 0;
  const f = () => {
    r.removeEventListener(l, p), n();
  }, p = (h) => {
    h.target === r && ++c >= u && f();
  };
  setTimeout(() => {
    c < u && f();
  }, o + 1), r.addEventListener(l, p);
}
function pE(r, e) {
  const t = window.getComputedStyle(r), s = (m) => (t[m] || "").split(", "), i = s(`${Ms}Delay`), n = s(`${Ms}Duration`), a = jg(i, n), o = s(`${ha}Delay`), u = s(`${ha}Duration`), l = jg(o, u);
  let c = null, f = 0, p = 0;
  e === Ms ? a > 0 && (c = Ms, f = a, p = n.length) : e === ha ? l > 0 && (c = ha, f = l, p = u.length) : (f = Math.max(a, l), c = f > 0 ? a > l ? Ms : ha : null, p = c ? c === Ms ? n.length : u.length : 0);
  const h = c === Ms && /\b(transform|all)(,|$)/.test(
    s(`${Ms}Property`).toString()
  );
  return {
    type: c,
    timeout: f,
    propCount: p,
    hasTransform: h
  };
}
function jg(r, e) {
  for (; r.length < e.length; )
    r = r.concat(r);
  return Math.max(...e.map((t, s) => qg(t) + qg(r[s])));
}
function qg(r) {
  return r === "auto" ? 0 : Number(r.slice(0, -1).replace(",", ".")) * 1e3;
}
function hE() {
  return document.body.offsetHeight;
}
function CA(r, e, t) {
  const s = r[On];
  s && (e = (e ? [e, ...s] : [...s]).join(" ")), e == null ? r.removeAttribute("class") : t ? r.setAttribute("class", e) : r.className = e;
}
const cl = Symbol("_vod"), dE = Symbol("_vsh"), Bd = {
  beforeMount(r, { value: e }, { transition: t }) {
    r[cl] = r.style.display === "none" ? "" : r.style.display, t && e ? t.beforeEnter(r) : da(r, e);
  },
  mounted(r, { value: e }, { transition: t }) {
    t && e && t.enter(r);
  },
  updated(r, { value: e, oldValue: t }, { transition: s }) {
    !e != !t && (s ? e ? (s.beforeEnter(r), da(r, !0), s.enter(r)) : s.leave(r, () => {
      da(r, !1);
    }) : da(r, e));
  },
  beforeUnmount(r, { value: e }) {
    da(r, e);
  }
};
process.env.NODE_ENV !== "production" && (Bd.name = "show");
function da(r, e) {
  r.style.display = e ? r[cl] : "none", r[dE] = !e;
}
function NA() {
  Bd.getSSRProps = ({ value: r }) => {
    if (!r)
      return { style: { display: "none" } };
  };
}
const mE = Symbol(process.env.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : "");
function OA(r) {
  const e = is();
  if (!e) {
    process.env.NODE_ENV !== "production" && ot("useCssVars is called without current active component instance.");
    return;
  }
  const t = e.ut = (i = r(e.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${e.uid}"]`)
    ).forEach((n) => Ip(n, i));
  };
  process.env.NODE_ENV !== "production" && (e.getCssVars = () => r(e.proxy));
  const s = () => {
    const i = r(e.proxy);
    Op(e.subTree, i), t(i);
  };
  wd(() => {
    Vv(s);
  }), Io(() => {
    const i = new MutationObserver(s);
    i.observe(e.subTree.el.parentNode, { childList: !0 }), fc(() => i.disconnect());
  });
}
function Op(r, e) {
  if (r.shapeFlag & 128) {
    const t = r.suspense;
    r = t.activeBranch, t.pendingBranch && !t.isHydrating && t.effects.push(() => {
      Op(t.activeBranch, e);
    });
  }
  for (; r.component; )
    r = r.component.subTree;
  if (r.shapeFlag & 1 && r.el)
    Ip(r.el, e);
  else if (r.type === ct)
    r.children.forEach((t) => Op(t, e));
  else if (r.type === Es) {
    let { el: t, anchor: s } = r;
    for (; t && (Ip(t, e), t !== s); )
      t = t.nextSibling;
  }
}
function Ip(r, e) {
  if (r.nodeType === 1) {
    const t = r.style;
    let s = "";
    for (const i in e)
      t.setProperty(`--${i}`, e[i]), s += `--${i}: ${e[i]};`;
    t[mE] = s;
  }
}
const IA = /(^|;)\s*display\s*:/;
function kA(r, e, t) {
  const s = r.style, i = _e(t);
  let n = !1;
  if (t && !i) {
    if (e)
      if (_e(e))
        for (const a of e.split(";")) {
          const o = a.slice(0, a.indexOf(":")).trim();
          t[o] == null && Iu(s, o, "");
        }
      else
        for (const a in e)
          t[a] == null && Iu(s, a, "");
    for (const a in t)
      a === "display" && (n = !0), Iu(s, a, t[a]);
  } else if (i) {
    if (e !== t) {
      const a = s[mE];
      a && (t += ";" + a), s.cssText = t, n = IA.test(t);
    }
  } else e && r.removeAttribute("style");
  cl in r && (r[cl] = n ? s.display : "", r[dE] && (s.display = "none"));
}
const DA = /[^\\];\s*$/, Hg = /\s*!important$/;
function Iu(r, e, t) {
  if (se(t))
    t.forEach((s) => Iu(r, e, s));
  else if (t == null && (t = ""), process.env.NODE_ENV !== "production" && DA.test(t) && ot(
    `Unexpected semicolon at the end of '${e}' style value: '${t}'`
  ), e.startsWith("--"))
    r.setProperty(e, t);
  else {
    const s = LA(r, e);
    Hg.test(t) ? r.setProperty(
      Tt(s),
      t.replace(Hg, ""),
      "important"
    ) : r[s] = t;
  }
}
const Wg = ["Webkit", "Moz", "ms"], Af = {};
function LA(r, e) {
  const t = Af[e];
  if (t)
    return t;
  let s = Et(e);
  if (s !== "filter" && s in r)
    return Af[e] = s;
  s = ii(s);
  for (let i = 0; i < Wg.length; i++) {
    const n = Wg[i] + s;
    if (n in r)
      return Af[e] = n;
  }
  return e;
}
const zg = "http://www.w3.org/1999/xlink";
function Gg(r, e, t, s, i, n = pT(e)) {
  s && e.startsWith("xlink:") ? t == null ? r.removeAttributeNS(zg, e.slice(6, e.length)) : r.setAttributeNS(zg, e, t) : t == null || n && !Ao(t) ? r.removeAttribute(e) : r.setAttribute(
    e,
    n ? "" : Zr(t) ? String(t) : t
  );
}
function MA(r, e, t, s) {
  if (e === "innerHTML" || e === "textContent") {
    if (t == null) return;
    r[e] = t;
    return;
  }
  const i = r.tagName;
  if (e === "value" && i !== "PROGRESS" && // custom elements may use _value internally
  !i.includes("-")) {
    const a = i === "OPTION" ? r.getAttribute("value") || "" : r.value, o = t == null ? "" : String(t);
    (a !== o || !("_value" in r)) && (r.value = o), t == null && r.removeAttribute(e), r._value = t;
    return;
  }
  let n = !1;
  if (t === "" || t == null) {
    const a = typeof r[e];
    a === "boolean" ? t = Ao(t) : t == null && a === "string" ? (t = "", n = !0) : a === "number" && (t = 0, n = !0);
  }
  try {
    r[e] = t;
  } catch (a) {
    process.env.NODE_ENV !== "production" && !n && ot(
      `Failed setting prop "${e}" on <${i.toLowerCase()}>: value ${t} is invalid.`,
      a
    );
  }
  n && r.removeAttribute(e);
}
function ds(r, e, t, s) {
  r.addEventListener(e, t, s);
}
function RA(r, e, t, s) {
  r.removeEventListener(e, t, s);
}
const Kg = Symbol("_vei");
function $A(r, e, t, s, i = null) {
  const n = r[Kg] || (r[Kg] = {}), a = n[e];
  if (s && a)
    a.value = process.env.NODE_ENV !== "production" ? Jg(s, e) : s;
  else {
    const [o, u] = FA(e);
    if (s) {
      const l = n[e] = UA(
        process.env.NODE_ENV !== "production" ? Jg(s, e) : s,
        i
      );
      ds(r, o, l, u);
    } else a && (RA(r, o, a, u), n[e] = void 0);
  }
}
const Xg = /(?:Once|Passive|Capture)$/;
function FA(r) {
  let e;
  if (Xg.test(r)) {
    e = {};
    let s;
    for (; s = r.match(Xg); )
      r = r.slice(0, r.length - s[0].length), e[s[0].toLowerCase()] = !0;
  }
  return [r[2] === ":" ? r.slice(3) : Tt(r.slice(2)), e];
}
let Cf = 0;
const BA = /* @__PURE__ */ Promise.resolve(), VA = () => Cf || (BA.then(() => Cf = 0), Cf = Date.now());
function UA(r, e) {
  const t = (s) => {
    if (!s._vts)
      s._vts = Date.now();
    else if (s._vts <= t.attached)
      return;
    ar(
      jA(s, t.value),
      e,
      5,
      [s]
    );
  };
  return t.value = r, t.attached = VA(), t;
}
function Jg(r, e) {
  return fe(r) || se(r) ? r : (ot(
    `Wrong type passed as event handler to ${e} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof r}.`
  ), Ge);
}
function jA(r, e) {
  if (se(e)) {
    const t = r.stopImmediatePropagation;
    return r.stopImmediatePropagation = () => {
      t.call(r), r._stopped = !0;
    }, e.map(
      (s) => (i) => !i._stopped && s && s(i)
    );
  } else
    return e;
}
const Yg = (r) => r.charCodeAt(0) === 111 && r.charCodeAt(1) === 110 && // lowercase letter
r.charCodeAt(2) > 96 && r.charCodeAt(2) < 123, qA = (r, e, t, s, i, n) => {
  const a = i === "svg";
  e === "class" ? CA(r, s, a) : e === "style" ? kA(r, t, s) : Yi(e) ? Yu(e) || $A(r, e, t, s, n) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : HA(r, e, s, a)) ? (MA(r, e, s), !r.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && Gg(r, e, s, a, n, e !== "value")) : (e === "true-value" ? r._trueValue = s : e === "false-value" && (r._falseValue = s), Gg(r, e, s, a));
};
function HA(r, e, t, s) {
  if (s)
    return !!(e === "innerHTML" || e === "textContent" || e in r && Yg(e) && fe(t));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && r.tagName === "INPUT" || e === "type" && r.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const i = r.tagName;
    if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
      return !1;
  }
  return Yg(e) && _e(t) ? !1 : e in r;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function gE(r, e, t) {
  const s = /* @__PURE__ */ xd(r, e);
  class i extends gc {
    constructor(a) {
      super(s, a, t);
    }
  }
  return i.def = s, i;
}
/*! #__NO_SIDE_EFFECTS__ */
const WA = /* @__NO_SIDE_EFFECTS__ */ (r, e) => /* @__PURE__ */ gE(r, e, AE), zA = typeof HTMLElement < "u" ? HTMLElement : class {
};
class gc extends zA {
  constructor(e, t = {}, s) {
    super(), this._def = e, this._props = t, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this._ob = null, this.shadowRoot && s ? s(this._createVNode(), this.shadowRoot) : (process.env.NODE_ENV !== "production" && this.shadowRoot && ot(
      "Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`."
    ), this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def));
  }
  connectedCallback() {
    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());
  }
  disconnectedCallback() {
    this._connected = !1, nc(() => {
      this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), kp(null, this.shadowRoot), this._instance = null);
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = !0;
    for (let s = 0; s < this.attributes.length; s++)
      this._setAttr(this.attributes[s].name);
    this._ob = new MutationObserver((s) => {
      for (const i of s)
        this._setAttr(i.attributeName);
    }), this._ob.observe(this, { attributes: !0 });
    const e = (s, i = !1) => {
      const { props: n, styles: a } = s;
      let o;
      if (n && !se(n))
        for (const u in n) {
          const l = n[u];
          (l === Number || l && l.type === Number) && (u in this._props && (this._props[u] = Zu(this._props[u])), (o || (o = /* @__PURE__ */ Object.create(null)))[Et(u)] = !0);
        }
      this._numberProps = o, i && this._resolveProps(s), this._applyStyles(a), this._update();
    }, t = this._def.__asyncLoader;
    t ? t().then((s) => e(s, !0)) : e(this._def);
  }
  _resolveProps(e) {
    const { props: t } = e, s = se(t) ? t : Object.keys(t || {});
    for (const i of Object.keys(this))
      i[0] !== "_" && s.includes(i) && this._setProp(i, this[i], !0, !1);
    for (const i of s.map(Et))
      Object.defineProperty(this, i, {
        get() {
          return this._getProp(i);
        },
        set(n) {
          this._setProp(i, n);
        }
      });
  }
  _setAttr(e) {
    let t = this.hasAttribute(e) ? this.getAttribute(e) : void 0;
    const s = Et(e);
    this._numberProps && this._numberProps[s] && (t = Zu(t)), this._setProp(s, t, !1);
  }
  /**
   * @internal
   */
  _getProp(e) {
    return this._props[e];
  }
  /**
   * @internal
   */
  _setProp(e, t, s = !0, i = !0) {
    t !== this._props[e] && (this._props[e] = t, i && this._instance && this._update(), s && (t === !0 ? this.setAttribute(Tt(e), "") : typeof t == "string" || typeof t == "number" ? this.setAttribute(Tt(e), t + "") : t || this.removeAttribute(Tt(e))));
  }
  _update() {
    kp(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const e = He(this._def, Be({}, this._props));
    return this._instance || (e.ce = (t) => {
      this._instance = t, t.isCE = !0, process.env.NODE_ENV !== "production" && (t.ceReload = (n) => {
        this._styles && (this._styles.forEach((a) => this.shadowRoot.removeChild(a)), this._styles.length = 0), this._applyStyles(n), this._instance = null, this._update();
      });
      const s = (n, a) => {
        this.dispatchEvent(
          new CustomEvent(n, {
            detail: a
          })
        );
      };
      t.emit = (n, ...a) => {
        s(n, a), Tt(n) !== n && s(Tt(n), a);
      };
      let i = this;
      for (; i = i && (i.parentNode || i.host); )
        if (i instanceof gc) {
          t.parent = i._instance, t.provides = i._instance.provides;
          break;
        }
    }), e;
  }
  _applyStyles(e) {
    e && e.forEach((t) => {
      const s = document.createElement("style");
      s.textContent = t, this.shadowRoot.appendChild(s), process.env.NODE_ENV !== "production" && (this._styles || (this._styles = [])).push(s);
    });
  }
}
function GA(r = "$style") {
  {
    const e = is();
    if (!e)
      return process.env.NODE_ENV !== "production" && ot("useCssModule must be called inside setup()"), Oe;
    const t = e.type.__cssModules;
    if (!t)
      return process.env.NODE_ENV !== "production" && ot("Current instance does not have CSS modules injected."), Oe;
    const s = t[r];
    return s || (process.env.NODE_ENV !== "production" && ot(`Current instance does not have CSS module named "${r}".`), Oe);
  }
}
const yE = /* @__PURE__ */ new WeakMap(), bE = /* @__PURE__ */ new WeakMap(), fl = Symbol("_moveCb"), Qg = Symbol("_enterCb"), vE = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ Be({}, TA, {
    tag: String,
    moveClass: String
  }),
  setup(r, { slots: e }) {
    const t = is(), s = Sd();
    let i, n;
    return lc(() => {
      if (!i.length)
        return;
      const a = r.moveClass || `${r.name || "v"}-move`;
      if (!ZA(
        i[0].el,
        t.vnode.el,
        a
      ))
        return;
      i.forEach(JA), i.forEach(YA);
      const o = i.filter(QA);
      hE(), o.forEach((u) => {
        const l = u.el, c = l.style;
        us(l, a), c.transform = c.webkitTransform = c.transitionDuration = "";
        const f = l[fl] = (p) => {
          p && p.target !== l || (!p || /transform$/.test(p.propertyName)) && (l.removeEventListener("transitionend", f), l[fl] = null, Bs(l, a));
        };
        l.addEventListener("transitionend", f);
      });
    }), () => {
      const a = Ee(r), o = fE(a);
      let u = a.tag || ct;
      if (i = [], n)
        for (let l = 0; l < n.length; l++) {
          const c = n[l];
          c.el && c.el instanceof Element && (i.push(c), ni(
            c,
            Nn(
              c,
              o,
              s,
              t
            )
          ), yE.set(
            c,
            c.el.getBoundingClientRect()
          ));
        }
      n = e.default ? oc(e.default()) : [];
      for (let l = 0; l < n.length; l++) {
        const c = n[l];
        c.key != null ? ni(
          c,
          Nn(c, o, s, t)
        ) : process.env.NODE_ENV !== "production" && ot("<TransitionGroup> children must be keyed.");
      }
      return He(u, null, n);
    };
  }
}, KA = (r) => delete r.mode;
vE.props;
const XA = vE;
function JA(r) {
  const e = r.el;
  e[fl] && e[fl](), e[Qg] && e[Qg]();
}
function YA(r) {
  bE.set(r, r.el.getBoundingClientRect());
}
function QA(r) {
  const e = yE.get(r), t = bE.get(r), s = e.left - t.left, i = e.top - t.top;
  if (s || i) {
    const n = r.el.style;
    return n.transform = n.webkitTransform = `translate(${s}px,${i}px)`, n.transitionDuration = "0s", r;
  }
}
function ZA(r, e, t) {
  const s = r.cloneNode(), i = r[On];
  i && i.forEach((o) => {
    o.split(/\s+/).forEach((u) => u && s.classList.remove(u));
  }), t.split(/\s+/).forEach((o) => o && s.classList.add(o)), s.style.display = "none";
  const n = e.nodeType === 1 ? e : e.parentNode;
  n.appendChild(s);
  const { hasTransform: a } = pE(s);
  return n.removeChild(s), a;
}
const ai = (r) => {
  const e = r.props["onUpdate:modelValue"] || !1;
  return se(e) ? (t) => Gs(e, t) : e;
};
function eC(r) {
  r.target.composing = !0;
}
function Zg(r) {
  const e = r.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const gr = Symbol("_assign"), pl = {
  created(r, { modifiers: { lazy: e, trim: t, number: s } }, i) {
    r[gr] = ai(i);
    const n = s || i.props && i.props.type === "number";
    ds(r, e ? "change" : "input", (a) => {
      if (a.target.composing) return;
      let o = r.value;
      t && (o = o.trim()), n && (o = Qu(o)), r[gr](o);
    }), t && ds(r, "change", () => {
      r.value = r.value.trim();
    }), e || (ds(r, "compositionstart", eC), ds(r, "compositionend", Zg), ds(r, "change", Zg));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(r, { value: e }) {
    r.value = e ?? "";
  },
  beforeUpdate(r, { value: e, oldValue: t, modifiers: { lazy: s, trim: i, number: n } }, a) {
    if (r[gr] = ai(a), r.composing) return;
    const o = (n || r.type === "number") && !/^0\d/.test(r.value) ? Qu(r.value) : r.value, u = e ?? "";
    o !== u && (document.activeElement === r && r.type !== "range" && (s && e === t || i && r.value.trim() === u) || (r.value = u));
  }
}, Vd = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(r, e, t) {
    r[gr] = ai(t), ds(r, "change", () => {
      const s = r._modelValue, i = In(r), n = r.checked, a = r[gr];
      if (se(s)) {
        const o = Co(s, i), u = o !== -1;
        if (n && !u)
          a(s.concat(i));
        else if (!n && u) {
          const l = [...s];
          l.splice(o, 1), a(l);
        }
      } else if (Qi(s)) {
        const o = new Set(s);
        n ? o.add(i) : o.delete(i), a(o);
      } else
        a(SE(r, n));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: ey,
  beforeUpdate(r, e, t) {
    r[gr] = ai(t), ey(r, e, t);
  }
};
function ey(r, { value: e, oldValue: t }, s) {
  r._modelValue = e, se(e) ? r.checked = Co(e, s.props.value) > -1 : Qi(e) ? r.checked = e.has(s.props.value) : e !== t && (r.checked = Or(e, SE(r, !0)));
}
const Ud = {
  created(r, { value: e }, t) {
    r.checked = Or(e, t.props.value), r[gr] = ai(t), ds(r, "change", () => {
      r[gr](In(r));
    });
  },
  beforeUpdate(r, { value: e, oldValue: t }, s) {
    r[gr] = ai(s), e !== t && (r.checked = Or(e, s.props.value));
  }
}, EE = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(r, { value: e, modifiers: { number: t } }, s) {
    const i = Qi(e);
    ds(r, "change", () => {
      const n = Array.prototype.filter.call(r.options, (a) => a.selected).map(
        (a) => t ? Qu(In(a)) : In(a)
      );
      r[gr](
        r.multiple ? i ? new Set(n) : n : n[0]
      ), r._assigning = !0, nc(() => {
        r._assigning = !1;
      });
    }), r[gr] = ai(s);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(r, { value: e, modifiers: { number: t } }) {
    ty(r, e);
  },
  beforeUpdate(r, e, t) {
    r[gr] = ai(t);
  },
  updated(r, { value: e, modifiers: { number: t } }) {
    r._assigning || ty(r, e);
  }
};
function ty(r, e, t) {
  const s = r.multiple, i = se(e);
  if (s && !i && !Qi(e)) {
    process.env.NODE_ENV !== "production" && ot(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8, -1)}.`
    );
    return;
  }
  for (let n = 0, a = r.options.length; n < a; n++) {
    const o = r.options[n], u = In(o);
    if (s)
      if (i) {
        const l = typeof u;
        l === "string" || l === "number" ? o.selected = e.some((c) => String(c) === String(u)) : o.selected = Co(e, u) > -1;
      } else
        o.selected = e.has(u);
    else if (Or(In(o), e)) {
      r.selectedIndex !== n && (r.selectedIndex = n);
      return;
    }
  }
  !s && r.selectedIndex !== -1 && (r.selectedIndex = -1);
}
function In(r) {
  return "_value" in r ? r._value : r.value;
}
function SE(r, e) {
  const t = e ? "_trueValue" : "_falseValue";
  return t in r ? r[t] : e;
}
const _E = {
  created(r, e, t) {
    au(r, e, t, null, "created");
  },
  mounted(r, e, t) {
    au(r, e, t, null, "mounted");
  },
  beforeUpdate(r, e, t, s) {
    au(r, e, t, s, "beforeUpdate");
  },
  updated(r, e, t, s) {
    au(r, e, t, s, "updated");
  }
};
function xE(r, e) {
  switch (r) {
    case "SELECT":
      return EE;
    case "TEXTAREA":
      return pl;
    default:
      switch (e) {
        case "checkbox":
          return Vd;
        case "radio":
          return Ud;
        default:
          return pl;
      }
  }
}
function au(r, e, t, s, i) {
  const a = xE(
    r.tagName,
    t.props && t.props.type
  )[i];
  a && a(r, e, t, s);
}
function tC() {
  pl.getSSRProps = ({ value: r }) => ({ value: r }), Ud.getSSRProps = ({ value: r }, e) => {
    if (e.props && Or(e.props.value, r))
      return { checked: !0 };
  }, Vd.getSSRProps = ({ value: r }, e) => {
    if (se(r)) {
      if (e.props && Co(r, e.props.value) > -1)
        return { checked: !0 };
    } else if (Qi(r)) {
      if (e.props && r.has(e.props.value))
        return { checked: !0 };
    } else if (r)
      return { checked: !0 };
  }, _E.getSSRProps = (r, e) => {
    if (typeof e.type != "string")
      return;
    const t = xE(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      e.type.toUpperCase(),
      e.props && e.props.type
    );
    if (t.getSSRProps)
      return t.getSSRProps(r, e);
  };
}
const rC = ["ctrl", "shift", "alt", "meta"], sC = {
  stop: (r) => r.stopPropagation(),
  prevent: (r) => r.preventDefault(),
  self: (r) => r.target !== r.currentTarget,
  ctrl: (r) => !r.ctrlKey,
  shift: (r) => !r.shiftKey,
  alt: (r) => !r.altKey,
  meta: (r) => !r.metaKey,
  left: (r) => "button" in r && r.button !== 0,
  middle: (r) => "button" in r && r.button !== 1,
  right: (r) => "button" in r && r.button !== 2,
  exact: (r, e) => rC.some((t) => r[`${t}Key`] && !e.includes(t))
}, iC = (r, e) => {
  const t = r._withMods || (r._withMods = {}), s = e.join(".");
  return t[s] || (t[s] = (i, ...n) => {
    for (let a = 0; a < e.length; a++) {
      const o = sC[e[a]];
      if (o && o(i, e)) return;
    }
    return r(i, ...n);
  });
}, nC = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, aC = (r, e) => {
  const t = r._withKeys || (r._withKeys = {}), s = e.join(".");
  return t[s] || (t[s] = (i) => {
    if (!("key" in i))
      return;
    const n = Tt(i.key);
    if (e.some((a) => a === n || nC[a] === n))
      return r(i);
  });
}, wE = /* @__PURE__ */ Be({ patchProp: qA }, wA);
let Ua, ry = !1;
function TE() {
  return Ua || (Ua = Lv(wE));
}
function PE() {
  return Ua = ry ? Ua : Mv(wE), ry = !0, Ua;
}
const kp = (...r) => {
  TE().render(...r);
}, AE = (...r) => {
  PE().hydrate(...r);
}, jd = (...r) => {
  const e = TE().createApp(...r);
  process.env.NODE_ENV !== "production" && (NE(e), OE(e));
  const { mount: t } = e;
  return e.mount = (s) => {
    const i = IE(s);
    if (!i) return;
    const n = e._component;
    !fe(n) && !n.render && !n.template && (n.template = i.innerHTML), i.innerHTML = "";
    const a = t(i, !1, CE(i));
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), a;
  }, e;
}, oC = (...r) => {
  const e = PE().createApp(...r);
  process.env.NODE_ENV !== "production" && (NE(e), OE(e));
  const { mount: t } = e;
  return e.mount = (s) => {
    const i = IE(s);
    if (i)
      return t(i, !0, CE(i));
  }, e;
};
function CE(r) {
  if (r instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && r instanceof MathMLElement)
    return "mathml";
}
function NE(r) {
  Object.defineProperty(r.config, "isNativeTag", {
    value: (e) => lT(e) || Pb(e) || cT(e),
    writable: !1
  });
}
function OE(r) {
  if ($d()) {
    const e = r.config.isCustomElement;
    Object.defineProperty(r.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        ot(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const t = r.config.compilerOptions, s = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(r.config, "compilerOptions", {
      get() {
        return ot(s), t;
      },
      set() {
        ot(s);
      }
    });
  }
}
function IE(r) {
  if (_e(r)) {
    const e = document.querySelector(r);
    return process.env.NODE_ENV !== "production" && !e && ot(
      `Failed to mount app: mount target selector "${r}" returned null.`
    ), e;
  }
  return process.env.NODE_ENV !== "production" && window.ShadowRoot && r instanceof window.ShadowRoot && r.mode === "closed" && ot(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), r;
}
let sy = !1;
const kE = () => {
  sy || (sy = !0, tC(), NA());
};
/**
* vue v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function uC() {
  uE();
}
process.env.NODE_ENV !== "production" && uC();
const lC = () => {
  process.env.NODE_ENV !== "production" && ot(
    'Runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  );
}, F7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition: ov,
  BaseTransitionPropsValidators: _d,
  Comment: Je,
  DeprecationTypes: SA,
  EffectScope: ad,
  ErrorCodes: cP,
  ErrorTypeStrings: mA,
  Fragment: ct,
  KeepAlive: LP,
  ReactiveEffect: Cn,
  Static: Es,
  Suspense: X3,
  Teleport: k3,
  Text: Xr,
  TrackOpTypes: iP,
  Transition: Fd,
  TransitionGroup: XA,
  TriggerOpTypes: nP,
  VueElement: gc,
  assertNumber: md,
  callWithAsyncErrorHandling: ar,
  callWithErrorHandling: Kr,
  camelize: Et,
  capitalize: ii,
  cloneVNode: yr,
  compatUtils: EA,
  compile: lC,
  computed: aE,
  createApp: jd,
  createBlock: kd,
  createCommentVNode: nA,
  createElementBlock: tA,
  createElementVNode: Dd,
  createHydrationRenderer: Mv,
  createPropsRestProxy: n3,
  createRenderer: Lv,
  createSSRApp: oC,
  createSlots: UP,
  createStaticVNode: iA,
  createTextVNode: Ld,
  createVNode: He,
  customRef: Jb,
  defineAsyncComponent: kP,
  defineComponent: xd,
  defineCustomElement: gE,
  defineEmits: XP,
  defineExpose: JP,
  defineModel: ZP,
  defineOptions: YP,
  defineProps: KP,
  defineSSRCustomElement: WA,
  defineSlots: QP,
  devtools: gA,
  effect: TT,
  effectScope: _T,
  getCurrentInstance: is,
  getCurrentScope: Ib,
  getTransitionRawChildren: oc,
  guardReactiveProps: Qv,
  h: oE,
  handleError: ci,
  hasInjectionContext: m3,
  hydrate: AE,
  initCustomFormatter: uE,
  initDirectivesForSSR: kE,
  inject: Ra,
  isMemoSame: lE,
  isProxy: Qa,
  isReactive: Zs,
  isReadonly: rs,
  isRef: pt,
  isRuntimeOnly: $d,
  isShallow: Gr,
  isVNode: ws,
  markRaw: Gb,
  mergeDefaults: s3,
  mergeModels: i3,
  mergeProps: Rd,
  nextTick: nc,
  normalizeClass: en,
  normalizeProps: iT,
  normalizeStyle: Zi,
  onActivated: lv,
  onBeforeMount: wd,
  onBeforeUnmount: cc,
  onBeforeUpdate: pv,
  onDeactivated: cv,
  onErrorCaptured: gv,
  onMounted: Io,
  onRenderTracked: mv,
  onRenderTriggered: dv,
  onScopeDispose: xT,
  onServerPrefetch: hv,
  onUnmounted: fc,
  onUpdated: lc,
  openBlock: dc,
  popScopeId: CP,
  provide: Ev,
  proxyRefs: dd,
  pushScopeId: AP,
  queuePostFlushCb: to,
  reactive: rc,
  readonly: cd,
  ref: Ii,
  registerRuntimeCompiler: cA,
  render: kp,
  renderList: VP,
  renderSlot: jP,
  resolveComponent: $P,
  resolveDirective: BP,
  resolveDynamicComponent: FP,
  resolveFilter: vA,
  resolveTransitionHooks: Nn,
  setBlockTracking: _p,
  setDevtoolsHook: yA,
  setTransitionHooks: ni,
  shallowReactive: zb,
  shallowReadonly: Ar,
  shallowRef: KT,
  ssrContextKey: ko,
  ssrUtils: Kn,
  stop: PT,
  toDisplayString: nd,
  toHandlerKey: ps,
  toHandlers: qP,
  toRaw: Ee,
  toRef: sP,
  toRefs: eP,
  toValue: YT,
  transformVNodeArgs: rA,
  triggerRef: JT,
  unref: hd,
  useAttrs: r3,
  useCssModule: GA,
  useCssVars: OA,
  useModel: q3,
  useSSRContext: Bv,
  useSlots: t3,
  useTransitionState: Sd,
  vModelCheckbox: Vd,
  vModelDynamic: _E,
  vModelRadio: Ud,
  vModelSelect: EE,
  vModelText: pl,
  vShow: Bd,
  version: Np,
  warn: ot,
  watch: Fa,
  watchEffect: U3,
  watchPostEffect: Vv,
  watchSyncEffect: Uv,
  withAsyncContext: a3,
  withCtx: Ed,
  withDefaults: e3,
  withDirectives: OP,
  withKeys: aC,
  withMemo: dA,
  withModifiers: iC,
  withScopeId: NP
}, Symbol.toStringTag, { value: "Module" }));
/**
* @vue/compiler-sfc v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Rt(r, e) {
  const t = new Set(r.split(","));
  return e ? (s) => t.has(s.toLowerCase()) : (s) => t.has(s);
}
const cC = Object.freeze({}), Nf = () => {
}, ku = () => !1, DE = (r) => r.charCodeAt(0) === 111 && r.charCodeAt(1) === 110 && // uppercase letter
(r.charCodeAt(2) > 122 || r.charCodeAt(2) < 97), Jr = Object.assign, fC = Object.prototype.hasOwnProperty, qd = (r, e) => fC.call(r, e), er = Array.isArray, pC = (r) => Hd(r) === "[object Map]", hC = (r) => Hd(r) === "[object Set]", LE = (r) => typeof r == "function", Ie = (r) => typeof r == "string", fi = (r) => typeof r == "symbol", pi = (r) => r !== null && typeof r == "object", ME = Object.prototype.toString, Hd = (r) => ME.call(r), RE = (r) => Hd(r) === "[object Object]", iy = /* @__PURE__ */ Rt(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Wd = /* @__PURE__ */ Rt(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), yc = (r) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = r(t));
}, dC = /-(\w)/g, or = yc((r) => r.replace(dC, (e, t) => t ? t.toUpperCase() : "")), mC = /\B([A-Z])/g, gC = yc(
  (r) => r.replace(mC, "-$1").toLowerCase()
), oi = yc((r) => r.charAt(0).toUpperCase() + r.slice(1)), yC = yc((r) => r ? `on${oi(r)}` : ""), bC = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function hl(r) {
  return bC.test(r) ? `__props.${r}` : `__props[${JSON.stringify(r)}]`;
}
const ti = {
  1: "TEXT",
  2: "CLASS",
  4: "STYLE",
  8: "PROPS",
  16: "FULL_PROPS",
  32: "NEED_HYDRATION",
  64: "STABLE_FRAGMENT",
  128: "KEYED_FRAGMENT",
  256: "UNKEYED_FRAGMENT",
  512: "NEED_PATCH",
  1024: "DYNAMIC_SLOTS",
  2048: "DEV_ROOT_FRAGMENT",
  [-1]: "HOISTED",
  [-2]: "BAIL"
}, vC = {
  1: "STABLE",
  2: "DYNAMIC",
  3: "FORWARDED"
}, EC = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error", $E = /* @__PURE__ */ Rt(EC), ny = 2;
function kn(r, e = 0, t = r.length) {
  if (e = Math.max(0, Math.min(e, r.length)), t = Math.max(0, Math.min(t, r.length)), e > t) return "";
  let s = r.split(/(\r?\n)/);
  const i = s.filter((o, u) => u % 2 === 1);
  s = s.filter((o, u) => u % 2 === 0);
  let n = 0;
  const a = [];
  for (let o = 0; o < s.length; o++)
    if (n += s[o].length + (i[o] && i[o].length || 0), n >= e) {
      for (let u = o - ny; u <= o + ny || t > n; u++) {
        if (u < 0 || u >= s.length) continue;
        const l = u + 1;
        a.push(
          `${l}${" ".repeat(Math.max(3 - String(l).length, 0))}|  ${s[u]}`
        );
        const c = s[u].length, f = i[u] && i[u].length || 0;
        if (u === o) {
          const p = e - (n - (c + f)), h = Math.max(
            1,
            t > n ? c - p : t - e
          );
          a.push("   |  " + " ".repeat(p) + "^".repeat(h));
        } else if (u > o) {
          if (t > n) {
            const p = Math.max(Math.min(t - n, c), 1);
            a.push("   |  " + "^".repeat(p));
          }
          n += c + f;
        }
      }
      break;
    }
  return a.join(`
`);
}
function FE(r) {
  if (er(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
      const s = r[t], i = Ie(s) ? BE(s) : FE(s);
      if (i)
        for (const n in i)
          e[n] = i[n];
    }
    return e;
  } else if (Ie(r) || pi(r))
    return r;
}
const SC = /;(?![^(]*\))/g, _C = /:([^]+)/, xC = /\/\*[^]*?\*\//g;
function BE(r) {
  const e = {};
  return r.replace(xC, "").split(SC).forEach((t) => {
    if (t) {
      const s = t.split(_C);
      s.length > 1 && (e[s[0].trim()] = s[1].trim());
    }
  }), e;
}
function wC(r) {
  let e = "";
  if (!r || Ie(r))
    return e;
  for (const t in r) {
    const s = r[t];
    if (Ie(s) || typeof s == "number") {
      const i = t.startsWith("--") ? t : gC(t);
      e += `${i}:${s};`;
    }
  }
  return e;
}
function VE(r) {
  let e = "";
  if (Ie(r))
    e = r;
  else if (er(r))
    for (let t = 0; t < r.length; t++) {
      const s = VE(r[t]);
      s && (e += s + " ");
    }
  else if (pi(r))
    for (const t in r)
      r[t] && (e += t + " ");
  return e.trim();
}
const TC = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", PC = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", AC = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", CC = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr", NC = /* @__PURE__ */ Rt(TC), OC = /* @__PURE__ */ Rt(PC), IC = /* @__PURE__ */ Rt(AC), UE = /* @__PURE__ */ Rt(CC), kC = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", jE = /* @__PURE__ */ Rt(
  kC + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"
), DC = /[>/="'\u0009\u000a\u000c\u0020]/, Of = {};
function LC(r) {
  if (Of.hasOwnProperty(r))
    return Of[r];
  const e = DC.test(r);
  return e && console.error(`unsafe attribute name: ${r}`), Of[r] = !e;
}
const MC = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
}, RC = /* @__PURE__ */ Rt(
  "accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"
), $C = /* @__PURE__ */ Rt(
  "xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"
), FC = /["'&<>]/;
function Ur(r) {
  const e = "" + r, t = FC.exec(e);
  if (!t)
    return e;
  let s = "", i, n, a = 0;
  for (n = t.index; n < e.length; n++) {
    switch (e.charCodeAt(n)) {
      case 34:
        i = "&quot;";
        break;
      case 38:
        i = "&amp;";
        break;
      case 39:
        i = "&#39;";
        break;
      case 60:
        i = "&lt;";
        break;
      case 62:
        i = "&gt;";
        break;
      default:
        continue;
    }
    a !== n && (s += e.slice(a, n)), a = n + 1, s += i;
  }
  return a !== n ? s + e.slice(a, n) : s;
}
const qE = (r) => !!(r && r.__v_isRef === !0), bc = (r) => Ie(r) ? r : r == null ? "" : er(r) || pi(r) && (r.toString === ME || !LE(r.toString)) ? qE(r) ? bc(r.value) : JSON.stringify(r, HE, 2) : String(r), HE = (r, e) => qE(e) ? HE(r, e.value) : pC(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (t, [s, i], n) => (t[If(s, n) + " =>"] = i, t),
    {}
  )
} : hC(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((t) => If(t))
} : fi(e) ? If(e) : pi(e) && !er(e) && !RE(e) ? String(e) : e, If = (r, e = "") => {
  var t;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    fi(r) ? `Symbol(${(t = r.description) != null ? t : e})` : r
  );
}, Dn = Symbol("Fragment"), $i = Symbol("Teleport"), Xn = Symbol("Suspense"), oo = Symbol("KeepAlive"), zd = Symbol("BaseTransition"), ui = Symbol("openBlock"), Gd = Symbol("createBlock"), Kd = Symbol("createElementBlock"), Ro = Symbol("createVNode"), vc = Symbol("createElementVNode"), Jn = Symbol("createCommentVNode"), Ec = Symbol("createTextVNode"), Sc = Symbol("createStaticVNode"), uo = Symbol("resolveComponent"), $o = Symbol(
  "resolveDynamicComponent"
), _c = Symbol("resolveDirective"), WE = Symbol("resolveFilter"), xc = Symbol("withDirectives"), wc = Symbol("renderList"), Xd = Symbol("renderSlot"), Jd = Symbol("createSlots"), Fo = Symbol("toDisplayString"), Gi = Symbol("mergeProps"), Tc = Symbol("normalizeClass"), Pc = Symbol("normalizeStyle"), Ln = Symbol("normalizeProps"), Yn = Symbol("guardReactiveProps"), Ac = Symbol("toHandlers"), dl = Symbol("camelize"), zE = Symbol("capitalize"), ml = Symbol("toHandlerKey"), lo = Symbol("setBlockTracking"), Cc = Symbol("pushScopeId"), Nc = Symbol("popScopeId"), Oc = Symbol("withCtx"), Mn = Symbol("unref"), co = Symbol("isRef"), Ic = Symbol("withMemo"), Yd = Symbol("isMemoSame"), Jt = {
  [Dn]: "Fragment",
  [$i]: "Teleport",
  [Xn]: "Suspense",
  [oo]: "KeepAlive",
  [zd]: "BaseTransition",
  [ui]: "openBlock",
  [Gd]: "createBlock",
  [Kd]: "createElementBlock",
  [Ro]: "createVNode",
  [vc]: "createElementVNode",
  [Jn]: "createCommentVNode",
  [Ec]: "createTextVNode",
  [Sc]: "createStaticVNode",
  [uo]: "resolveComponent",
  [$o]: "resolveDynamicComponent",
  [_c]: "resolveDirective",
  [WE]: "resolveFilter",
  [xc]: "withDirectives",
  [wc]: "renderList",
  [Xd]: "renderSlot",
  [Jd]: "createSlots",
  [Fo]: "toDisplayString",
  [Gi]: "mergeProps",
  [Tc]: "normalizeClass",
  [Pc]: "normalizeStyle",
  [Ln]: "normalizeProps",
  [Yn]: "guardReactiveProps",
  [Ac]: "toHandlers",
  [dl]: "camelize",
  [zE]: "capitalize",
  [ml]: "toHandlerKey",
  [lo]: "setBlockTracking",
  [Cc]: "pushScopeId",
  [Nc]: "popScopeId",
  [Oc]: "withCtx",
  [Mn]: "unref",
  [co]: "isRef",
  [Ic]: "withMemo",
  [Yd]: "isMemoSame"
};
function Qd(r) {
  Object.getOwnPropertySymbols(r).forEach((e) => {
    Jt[e] = r[e];
  });
}
const BC = {
  HTML: 0,
  0: "HTML",
  SVG: 1,
  1: "SVG",
  MATH_ML: 2,
  2: "MATH_ML"
}, VC = {
  ROOT: 0,
  0: "ROOT",
  ELEMENT: 1,
  1: "ELEMENT",
  TEXT: 2,
  2: "TEXT",
  COMMENT: 3,
  3: "COMMENT",
  SIMPLE_EXPRESSION: 4,
  4: "SIMPLE_EXPRESSION",
  INTERPOLATION: 5,
  5: "INTERPOLATION",
  ATTRIBUTE: 6,
  6: "ATTRIBUTE",
  DIRECTIVE: 7,
  7: "DIRECTIVE",
  COMPOUND_EXPRESSION: 8,
  8: "COMPOUND_EXPRESSION",
  IF: 9,
  9: "IF",
  IF_BRANCH: 10,
  10: "IF_BRANCH",
  FOR: 11,
  11: "FOR",
  TEXT_CALL: 12,
  12: "TEXT_CALL",
  VNODE_CALL: 13,
  13: "VNODE_CALL",
  JS_CALL_EXPRESSION: 14,
  14: "JS_CALL_EXPRESSION",
  JS_OBJECT_EXPRESSION: 15,
  15: "JS_OBJECT_EXPRESSION",
  JS_PROPERTY: 16,
  16: "JS_PROPERTY",
  JS_ARRAY_EXPRESSION: 17,
  17: "JS_ARRAY_EXPRESSION",
  JS_FUNCTION_EXPRESSION: 18,
  18: "JS_FUNCTION_EXPRESSION",
  JS_CONDITIONAL_EXPRESSION: 19,
  19: "JS_CONDITIONAL_EXPRESSION",
  JS_CACHE_EXPRESSION: 20,
  20: "JS_CACHE_EXPRESSION",
  JS_BLOCK_STATEMENT: 21,
  21: "JS_BLOCK_STATEMENT",
  JS_TEMPLATE_LITERAL: 22,
  22: "JS_TEMPLATE_LITERAL",
  JS_IF_STATEMENT: 23,
  23: "JS_IF_STATEMENT",
  JS_ASSIGNMENT_EXPRESSION: 24,
  24: "JS_ASSIGNMENT_EXPRESSION",
  JS_SEQUENCE_EXPRESSION: 25,
  25: "JS_SEQUENCE_EXPRESSION",
  JS_RETURN_STATEMENT: 26,
  26: "JS_RETURN_STATEMENT"
}, UC = {
  ELEMENT: 0,
  0: "ELEMENT",
  COMPONENT: 1,
  1: "COMPONENT",
  SLOT: 2,
  2: "SLOT",
  TEMPLATE: 3,
  3: "TEMPLATE"
}, jC = {
  NOT_CONSTANT: 0,
  0: "NOT_CONSTANT",
  CAN_SKIP_PATCH: 1,
  1: "CAN_SKIP_PATCH",
  CAN_HOIST: 2,
  2: "CAN_HOIST",
  CAN_STRINGIFY: 3,
  3: "CAN_STRINGIFY"
}, rt = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 },
  source: ""
};
function rn(r, e = "") {
  return {
    type: 0,
    source: e,
    children: r,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc: rt
  };
}
function Rn(r, e, t, s, i, n, a, o = !1, u = !1, l = !1, c = rt) {
  return r && (o ? (r.helper(ui), r.helper(Xi(r.inSSR, l))) : r.helper(Ki(r.inSSR, l)), a && r.helper(xc)), {
    type: 13,
    tag: e,
    props: t,
    children: s,
    patchFlag: i,
    dynamicProps: n,
    directives: a,
    isBlock: o,
    disableTracking: u,
    isComponent: l,
    loc: c
  };
}
function sn(r, e = rt) {
  return {
    type: 17,
    loc: e,
    elements: r
  };
}
function Yt(r, e = rt) {
  return {
    type: 15,
    loc: e,
    properties: r
  };
}
function Fe(r, e) {
  return {
    type: 16,
    loc: rt,
    key: Ie(r) ? Q(r, !0) : r,
    value: e
  };
}
function Q(r, e = !1, t = rt, s = 0) {
  return {
    type: 4,
    loc: t,
    content: r,
    isStatic: e,
    constType: e ? 3 : s
  };
}
function gl(r, e) {
  return {
    type: 5,
    loc: e,
    content: Ie(r) ? Q(r, !1, e) : r
  };
}
function yt(r, e = rt) {
  return {
    type: 8,
    loc: e,
    children: r
  };
}
function ge(r, e = [], t = rt) {
  return {
    type: 14,
    loc: t,
    callee: r,
    arguments: e
  };
}
function fr(r, e = void 0, t = !1, s = !1, i = rt) {
  return {
    type: 18,
    params: r,
    returns: e,
    newline: t,
    isSlot: s,
    loc: i
  };
}
function Nr(r, e, t, s = !0) {
  return {
    type: 19,
    test: r,
    consequent: e,
    alternate: t,
    newline: s,
    loc: rt
  };
}
function GE(r, e, t = !1) {
  return {
    type: 20,
    index: r,
    value: e,
    isVOnce: t,
    loc: rt
  };
}
function Bo(r) {
  return {
    type: 21,
    body: r,
    loc: rt
  };
}
function Zd(r) {
  return {
    type: 22,
    elements: r,
    loc: rt
  };
}
function yl(r, e, t) {
  return {
    type: 23,
    test: r,
    consequent: e,
    alternate: t,
    loc: rt
  };
}
function Du(r, e) {
  return {
    type: 24,
    left: r,
    right: e,
    loc: rt
  };
}
function KE(r) {
  return {
    type: 25,
    expressions: r,
    loc: rt
  };
}
function XE(r) {
  return {
    type: 26,
    returns: r,
    loc: rt
  };
}
function Ki(r, e) {
  return r || e ? Ro : vc;
}
function Xi(r, e) {
  return r || e ? Gd : Kd;
}
function kc(r, { helper: e, removeHelper: t, inSSR: s }) {
  r.isBlock || (r.isBlock = !0, t(Ki(s, r.isComponent)), e(ui), e(Xi(s, r.isComponent)));
}
var JE = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((r) => r.charCodeAt(0))
), qC = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((r) => r.charCodeAt(0))
), kf;
const HC = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), Dp = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
  (kf = String.fromCodePoint) !== null && kf !== void 0 ? kf : function(r) {
    let e = "";
    return r > 65535 && (r -= 65536, e += String.fromCharCode(r >>> 10 & 1023 | 55296), r = 56320 | r & 1023), e += String.fromCharCode(r), e;
  }
);
function WC(r) {
  var e;
  return r >= 55296 && r <= 57343 || r > 1114111 ? 65533 : (e = HC.get(r)) !== null && e !== void 0 ? e : r;
}
var bt;
(function(r) {
  r[r.NUM = 35] = "NUM", r[r.SEMI = 59] = "SEMI", r[r.EQUALS = 61] = "EQUALS", r[r.ZERO = 48] = "ZERO", r[r.NINE = 57] = "NINE", r[r.LOWER_A = 97] = "LOWER_A", r[r.LOWER_F = 102] = "LOWER_F", r[r.LOWER_X = 120] = "LOWER_X", r[r.LOWER_Z = 122] = "LOWER_Z", r[r.UPPER_A = 65] = "UPPER_A", r[r.UPPER_F = 70] = "UPPER_F", r[r.UPPER_Z = 90] = "UPPER_Z";
})(bt || (bt = {}));
const zC = 32;
var Js;
(function(r) {
  r[r.VALUE_LENGTH = 49152] = "VALUE_LENGTH", r[r.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", r[r.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Js || (Js = {}));
function Lp(r) {
  return r >= bt.ZERO && r <= bt.NINE;
}
function GC(r) {
  return r >= bt.UPPER_A && r <= bt.UPPER_F || r >= bt.LOWER_A && r <= bt.LOWER_F;
}
function KC(r) {
  return r >= bt.UPPER_A && r <= bt.UPPER_Z || r >= bt.LOWER_A && r <= bt.LOWER_Z || Lp(r);
}
function XC(r) {
  return r === bt.EQUALS || KC(r);
}
var dt;
(function(r) {
  r[r.EntityStart = 0] = "EntityStart", r[r.NumericStart = 1] = "NumericStart", r[r.NumericDecimal = 2] = "NumericDecimal", r[r.NumericHex = 3] = "NumericHex", r[r.NamedEntity = 4] = "NamedEntity";
})(dt || (dt = {}));
var Br;
(function(r) {
  r[r.Legacy = 0] = "Legacy", r[r.Strict = 1] = "Strict", r[r.Attribute = 2] = "Attribute";
})(Br || (Br = {}));
class YE {
  constructor(e, t, s) {
    this.decodeTree = e, this.emitCodePoint = t, this.errors = s, this.state = dt.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Br.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = dt.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, t) {
    switch (this.state) {
      case dt.EntityStart:
        return e.charCodeAt(t) === bt.NUM ? (this.state = dt.NumericStart, this.consumed += 1, this.stateNumericStart(e, t + 1)) : (this.state = dt.NamedEntity, this.stateNamedEntity(e, t));
      case dt.NumericStart:
        return this.stateNumericStart(e, t);
      case dt.NumericDecimal:
        return this.stateNumericDecimal(e, t);
      case dt.NumericHex:
        return this.stateNumericHex(e, t);
      case dt.NamedEntity:
        return this.stateNamedEntity(e, t);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, t) {
    return t >= e.length ? -1 : (e.charCodeAt(t) | zC) === bt.LOWER_X ? (this.state = dt.NumericHex, this.consumed += 1, this.stateNumericHex(e, t + 1)) : (this.state = dt.NumericDecimal, this.stateNumericDecimal(e, t));
  }
  addToNumericResult(e, t, s, i) {
    if (t !== s) {
      const n = s - t;
      this.result = this.result * Math.pow(i, n) + Number.parseInt(e.substr(t, n), i), this.consumed += n;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, t) {
    const s = t;
    for (; t < e.length; ) {
      const i = e.charCodeAt(t);
      if (Lp(i) || GC(i))
        t += 1;
      else
        return this.addToNumericResult(e, s, t, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(e, s, t, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, t) {
    const s = t;
    for (; t < e.length; ) {
      const i = e.charCodeAt(t);
      if (Lp(i))
        t += 1;
      else
        return this.addToNumericResult(e, s, t, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(e, s, t, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, t) {
    var s;
    if (this.consumed <= t)
      return (s = this.errors) === null || s === void 0 || s.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === bt.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Br.Strict)
      return 0;
    return this.emitCodePoint(WC(this.result), this.consumed), this.errors && (e !== bt.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, t) {
    const { decodeTree: s } = this;
    let i = s[this.treeIndex], n = (i & Js.VALUE_LENGTH) >> 14;
    for (; t < e.length; t++, this.excess++) {
      const a = e.charCodeAt(t);
      if (this.treeIndex = JC(s, i, this.treeIndex + Math.max(1, n), a), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Br.Attribute && // We shouldn't have consumed any characters after the entity,
        (n === 0 || // And there should be no invalid characters.
        XC(a)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = s[this.treeIndex], n = (i & Js.VALUE_LENGTH) >> 14, n !== 0) {
        if (a === bt.SEMI)
          return this.emitNamedEntityData(this.treeIndex, n, this.consumed + this.excess);
        this.decodeMode !== Br.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: t, decodeTree: s } = this, i = (s[t] & Js.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(t, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, t, s) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(t === 1 ? i[e] & ~Js.VALUE_LENGTH : i[e + 1], s), t === 3 && this.emitCodePoint(i[e + 2], s), s;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case dt.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Br.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case dt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case dt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case dt.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case dt.EntityStart:
        return 0;
    }
  }
}
function QE(r) {
  let e = "";
  const t = new YE(r, (s) => e += Dp(s));
  return function(i, n) {
    let a = 0, o = 0;
    for (; (o = i.indexOf("&", o)) >= 0; ) {
      e += i.slice(a, o), t.startEntity(n);
      const l = t.write(
        i,
        // Skip the "&"
        o + 1
      );
      if (l < 0) {
        a = o + t.end();
        break;
      }
      a = o + l, o = l === 0 ? a + 1 : a;
    }
    const u = e + i.slice(a);
    return e = "", u;
  };
}
function JC(r, e, t, s) {
  const i = (e & Js.BRANCH_LENGTH) >> 7, n = e & Js.JUMP_TABLE;
  if (i === 0)
    return n !== 0 && s === n ? t : -1;
  if (n) {
    const u = s - n;
    return u < 0 || u >= i ? -1 : r[t + u] - 1;
  }
  let a = t, o = a + i - 1;
  for (; a <= o; ) {
    const u = a + o >>> 1, l = r[u];
    if (l < s)
      a = u + 1;
    else if (l > s)
      o = u - 1;
    else
      return r[u + i];
  }
  return -1;
}
const YC = QE(JE);
QE(qC);
function QC(r, e = Br.Legacy) {
  return YC(r, e);
}
const ay = new Uint8Array([123, 123]), oy = new Uint8Array([125, 125]);
function uy(r) {
  return r >= 97 && r <= 122 || r >= 65 && r <= 90;
}
function sr(r) {
  return r === 32 || r === 10 || r === 9 || r === 12 || r === 13;
}
function Rs(r) {
  return r === 47 || r === 62 || sr(r);
}
function bl(r) {
  const e = new Uint8Array(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
}
const _t = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea
};
let ZC = class {
  constructor(e, t) {
    this.stack = e, this.cbs = t, this.state = 1, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = 1, this.inRCDATA = !1, this.inXML = !1, this.inVPre = !1, this.newlines = [], this.mode = 0, this.delimiterOpen = ay, this.delimiterClose = oy, this.delimiterIndex = -1, this.currentSequence = void 0, this.sequenceIndex = 0, this.entityDecoder = new YE(
      JE,
      (s, i) => this.emitCodePoint(s, i)
    );
  }
  get inSFCRoot() {
    return this.mode === 2 && this.stack.length === 0;
  }
  reset() {
    this.state = 1, this.mode = 0, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = 1, this.inRCDATA = !1, this.currentSequence = void 0, this.newlines.length = 0, this.delimiterOpen = ay, this.delimiterClose = oy;
  }
  /**
   * Generate Position object with line / column information using recorded
   * newline positions. We know the index is always going to be an already
   * processed index, so all the newlines up to this index should have been
   * recorded.
   */
  getPos(e) {
    let t = 1, s = e + 1;
    for (let i = this.newlines.length - 1; i >= 0; i--) {
      const n = this.newlines[i];
      if (e > n) {
        t = i + 2, s = e - n;
        break;
      }
    }
    return {
      column: s,
      line: t,
      offset: e
    };
  }
  peek() {
    return this.buffer.charCodeAt(this.index + 1);
  }
  stateText(e) {
    e === 60 ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = 5, this.sectionStart = this.index) : e === 38 ? this.startEntity() : !this.inVPre && e === this.delimiterOpen[0] && (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e));
  }
  stateInterpolationOpen(e) {
    if (e === this.delimiterOpen[this.delimiterIndex])
      if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const t = this.index + 1 - this.delimiterOpen.length;
        t > this.sectionStart && this.cbs.ontext(this.sectionStart, t), this.state = 3, this.sectionStart = t;
      } else
        this.delimiterIndex++;
    else this.inRCDATA ? (this.state = 32, this.stateInRCDATA(e)) : (this.state = 1, this.stateText(e));
  }
  stateInterpolation(e) {
    e === this.delimiterClose[0] && (this.state = 4, this.delimiterIndex = 0, this.stateInterpolationClose(e));
  }
  stateInterpolationClose(e) {
    e === this.delimiterClose[this.delimiterIndex] ? this.delimiterIndex === this.delimiterClose.length - 1 ? (this.cbs.oninterpolation(this.sectionStart, this.index + 1), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : this.delimiterIndex++ : (this.state = 3, this.stateInterpolation(e));
  }
  stateSpecialStartSequence(e) {
    const t = this.sequenceIndex === this.currentSequence.length;
    if (!(t ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      Rs(e)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (e | 32) === this.currentSequence[this.sequenceIndex]
    )))
      this.inRCDATA = !1;
    else if (!t) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0, this.state = 6, this.stateInTagName(e);
  }
  /** Look for an end tag. For <title> and <textarea>, also decode entities. */
  stateInRCDATA(e) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (e === 62 || sr(e)) {
        const t = this.index - this.currentSequence.length;
        if (this.sectionStart < t) {
          const s = this.index;
          this.index = t, this.cbs.ontext(this.sectionStart, t), this.index = s;
        }
        this.sectionStart = t + 2, this.stateInClosingTagName(e), this.inRCDATA = !1;
        return;
      }
      this.sequenceIndex = 0;
    }
    (e | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === _t.TitleEnd || this.currentSequence === _t.TextareaEnd && !this.inSFCRoot ? e === 38 ? this.startEntity() : e === this.delimiterOpen[0] && (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e)) : this.fastForwardTo(60) && (this.sequenceIndex = 1) : this.sequenceIndex = +(e === 60);
  }
  stateCDATASequence(e) {
    e === _t.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === _t.Cdata.length && (this.state = 28, this.currentSequence = _t.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = 23, this.stateInDeclaration(e));
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(e) {
    for (; ++this.index < this.buffer.length; ) {
      const t = this.buffer.charCodeAt(this.index);
      if (t === 10 && this.newlines.push(this.index), t === e)
        return !0;
    }
    return this.index = this.buffer.length - 1, !1;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(e) {
    e === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === _t.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index - 2) : this.cbs.oncomment(this.sectionStart, this.index - 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = 1) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  startSpecial(e, t) {
    this.enterRCDATA(e, t), this.state = 31;
  }
  enterRCDATA(e, t) {
    this.inRCDATA = !0, this.currentSequence = e, this.sequenceIndex = t;
  }
  stateBeforeTagName(e) {
    e === 33 ? (this.state = 22, this.sectionStart = this.index + 1) : e === 63 ? (this.state = 24, this.sectionStart = this.index + 1) : uy(e) ? (this.sectionStart = this.index, this.mode === 0 ? this.state = 6 : this.inSFCRoot ? this.state = 34 : this.inXML ? this.state = 6 : e === 116 ? this.state = 30 : this.state = e === 115 ? 29 : 6) : e === 47 ? this.state = 8 : (this.state = 1, this.stateText(e));
  }
  stateInTagName(e) {
    Rs(e) && this.handleTagName(e);
  }
  stateInSFCRootTagName(e) {
    if (Rs(e)) {
      const t = this.buffer.slice(this.sectionStart, this.index);
      t !== "template" && this.enterRCDATA(bl("</" + t), 0), this.handleTagName(e);
    }
  }
  handleTagName(e) {
    this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e);
  }
  stateBeforeClosingTagName(e) {
    sr(e) || (e === 62 ? (this.cbs.onerr(14, this.index), this.state = 1, this.sectionStart = this.index + 1) : (this.state = uy(e) ? 9 : 27, this.sectionStart = this.index));
  }
  stateInClosingTagName(e) {
    (e === 62 || sr(e)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = 10, this.stateAfterClosingTagName(e));
  }
  stateAfterClosingTagName(e) {
    e === 62 && (this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeAttrName(e) {
    e === 62 ? (this.cbs.onopentagend(this.index), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : e === 47 ? (this.state = 7, this.peek() !== 62 && this.cbs.onerr(22, this.index)) : e === 60 && this.peek() === 47 ? (this.cbs.onopentagend(this.index), this.state = 5, this.sectionStart = this.index) : sr(e) || (e === 61 && this.cbs.onerr(
      19,
      this.index
    ), this.handleAttrStart(e));
  }
  handleAttrStart(e) {
    e === 118 && this.peek() === 45 ? (this.state = 13, this.sectionStart = this.index) : e === 46 || e === 58 || e === 64 || e === 35 ? (this.cbs.ondirname(this.index, this.index + 1), this.state = 14, this.sectionStart = this.index + 1) : (this.state = 12, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(e) {
    e === 62 ? (this.cbs.onselfclosingtag(this.index), this.state = 1, this.sectionStart = this.index + 1, this.inRCDATA = !1) : sr(e) || (this.state = 11, this.stateBeforeAttrName(e));
  }
  stateInAttrName(e) {
    e === 61 || Rs(e) ? (this.cbs.onattribname(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : (e === 34 || e === 39 || e === 60) && this.cbs.onerr(
      17,
      this.index
    );
  }
  stateInDirName(e) {
    e === 61 || Rs(e) ? (this.cbs.ondirname(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 58 ? (this.cbs.ondirname(this.sectionStart, this.index), this.state = 14, this.sectionStart = this.index + 1) : e === 46 && (this.cbs.ondirname(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
  }
  stateInDirArg(e) {
    e === 61 || Rs(e) ? (this.cbs.ondirarg(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 91 ? this.state = 15 : e === 46 && (this.cbs.ondirarg(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
  }
  stateInDynamicDirArg(e) {
    e === 93 ? this.state = 14 : (e === 61 || Rs(e)) && (this.cbs.ondirarg(this.sectionStart, this.index + 1), this.handleAttrNameEnd(e), this.cbs.onerr(
      27,
      this.index
    ));
  }
  stateInDirModifier(e) {
    e === 61 || Rs(e) ? (this.cbs.ondirmodifier(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 46 && (this.cbs.ondirmodifier(this.sectionStart, this.index), this.sectionStart = this.index + 1);
  }
  handleAttrNameEnd(e) {
    this.sectionStart = this.index, this.state = 17, this.cbs.onattribnameend(this.index), this.stateAfterAttrName(e);
  }
  stateAfterAttrName(e) {
    e === 61 ? this.state = 18 : e === 47 || e === 62 ? (this.cbs.onattribend(0, this.sectionStart), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e)) : sr(e) || (this.cbs.onattribend(0, this.sectionStart), this.handleAttrStart(e));
  }
  stateBeforeAttrValue(e) {
    e === 34 ? (this.state = 19, this.sectionStart = this.index + 1) : e === 39 ? (this.state = 20, this.sectionStart = this.index + 1) : sr(e) || (this.sectionStart = this.index, this.state = 21, this.stateInAttrValueNoQuotes(e));
  }
  handleInAttrValue(e, t) {
    e === t ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(
      t === 34 ? 3 : 2,
      this.index + 1
    ), this.state = 11) : e === 38 && this.startEntity();
  }
  stateInAttrValueDoubleQuotes(e) {
    this.handleInAttrValue(e, 34);
  }
  stateInAttrValueSingleQuotes(e) {
    this.handleInAttrValue(e, 39);
  }
  stateInAttrValueNoQuotes(e) {
    sr(e) || e === 62 ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(1, this.index), this.state = 11, this.stateBeforeAttrName(e)) : e === 34 || e === 39 || e === 60 || e === 61 || e === 96 ? this.cbs.onerr(
      18,
      this.index
    ) : e === 38 && this.startEntity();
  }
  stateBeforeDeclaration(e) {
    e === 91 ? (this.state = 26, this.sequenceIndex = 0) : this.state = e === 45 ? 25 : 23;
  }
  stateInDeclaration(e) {
    (e === 62 || this.fastForwardTo(62)) && (this.state = 1, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(e) {
    (e === 62 || this.fastForwardTo(62)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(e) {
    e === 45 ? (this.state = 28, this.currentSequence = _t.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = 23;
  }
  stateInSpecialComment(e) {
    (e === 62 || this.fastForwardTo(62)) && (this.cbs.oncomment(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(e) {
    e === _t.ScriptEnd[3] ? this.startSpecial(_t.ScriptEnd, 4) : e === _t.StyleEnd[3] ? this.startSpecial(_t.StyleEnd, 4) : (this.state = 6, this.stateInTagName(e));
  }
  stateBeforeSpecialT(e) {
    e === _t.TitleEnd[3] ? this.startSpecial(_t.TitleEnd, 4) : e === _t.TextareaEnd[3] ? this.startSpecial(_t.TextareaEnd, 4) : (this.state = 6, this.stateInTagName(e));
  }
  startEntity() {
    this.baseState = this.state, this.state = 33, this.entityStart = this.index, this.entityDecoder.startEntity(
      this.baseState === 1 || this.baseState === 32 ? Br.Legacy : Br.Attribute
    );
  }
  stateInEntity() {
    {
      const e = this.entityDecoder.write(this.buffer, this.index);
      e >= 0 ? (this.state = this.baseState, e === 0 && (this.index = this.entityStart)) : this.index = this.buffer.length - 1;
    }
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse(e) {
    for (this.buffer = e; this.index < this.buffer.length; ) {
      const t = this.buffer.charCodeAt(this.index);
      switch (t === 10 && this.newlines.push(this.index), this.state) {
        case 1: {
          this.stateText(t);
          break;
        }
        case 2: {
          this.stateInterpolationOpen(t);
          break;
        }
        case 3: {
          this.stateInterpolation(t);
          break;
        }
        case 4: {
          this.stateInterpolationClose(t);
          break;
        }
        case 31: {
          this.stateSpecialStartSequence(t);
          break;
        }
        case 32: {
          this.stateInRCDATA(t);
          break;
        }
        case 26: {
          this.stateCDATASequence(t);
          break;
        }
        case 19: {
          this.stateInAttrValueDoubleQuotes(t);
          break;
        }
        case 12: {
          this.stateInAttrName(t);
          break;
        }
        case 13: {
          this.stateInDirName(t);
          break;
        }
        case 14: {
          this.stateInDirArg(t);
          break;
        }
        case 15: {
          this.stateInDynamicDirArg(t);
          break;
        }
        case 16: {
          this.stateInDirModifier(t);
          break;
        }
        case 28: {
          this.stateInCommentLike(t);
          break;
        }
        case 27: {
          this.stateInSpecialComment(t);
          break;
        }
        case 11: {
          this.stateBeforeAttrName(t);
          break;
        }
        case 6: {
          this.stateInTagName(t);
          break;
        }
        case 34: {
          this.stateInSFCRootTagName(t);
          break;
        }
        case 9: {
          this.stateInClosingTagName(t);
          break;
        }
        case 5: {
          this.stateBeforeTagName(t);
          break;
        }
        case 17: {
          this.stateAfterAttrName(t);
          break;
        }
        case 20: {
          this.stateInAttrValueSingleQuotes(t);
          break;
        }
        case 18: {
          this.stateBeforeAttrValue(t);
          break;
        }
        case 8: {
          this.stateBeforeClosingTagName(t);
          break;
        }
        case 10: {
          this.stateAfterClosingTagName(t);
          break;
        }
        case 29: {
          this.stateBeforeSpecialS(t);
          break;
        }
        case 30: {
          this.stateBeforeSpecialT(t);
          break;
        }
        case 21: {
          this.stateInAttrValueNoQuotes(t);
          break;
        }
        case 7: {
          this.stateInSelfClosingTag(t);
          break;
        }
        case 23: {
          this.stateInDeclaration(t);
          break;
        }
        case 22: {
          this.stateBeforeDeclaration(t);
          break;
        }
        case 25: {
          this.stateBeforeComment(t);
          break;
        }
        case 24: {
          this.stateInProcessingInstruction(t);
          break;
        }
        case 33: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup(), this.finish();
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    this.sectionStart !== this.index && (this.state === 1 || this.state === 32 && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === 19 || this.state === 20 || this.state === 21) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  finish() {
    this.state === 33 && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const e = this.buffer.length;
    this.sectionStart >= e || (this.state === 28 ? this.currentSequence === _t.CdataEnd ? this.cbs.oncdata(this.sectionStart, e) : this.cbs.oncomment(this.sectionStart, e) : this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9 || this.cbs.ontext(this.sectionStart, e));
  }
  emitCodePoint(e, t) {
    this.baseState !== 1 && this.baseState !== 32 ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + t, this.index = this.sectionStart - 1, this.cbs.onattribentity(
      Dp(e),
      this.entityStart,
      this.sectionStart
    )) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + t, this.index = this.sectionStart - 1, this.cbs.ontextentity(
      Dp(e),
      this.entityStart,
      this.sectionStart
    ));
  }
};
const eN = {
  COMPILER_IS_ON_ELEMENT: "COMPILER_IS_ON_ELEMENT",
  COMPILER_V_BIND_SYNC: "COMPILER_V_BIND_SYNC",
  COMPILER_V_BIND_OBJECT_ORDER: "COMPILER_V_BIND_OBJECT_ORDER",
  COMPILER_V_ON_NATIVE: "COMPILER_V_ON_NATIVE",
  COMPILER_V_IF_V_FOR_PRECEDENCE: "COMPILER_V_IF_V_FOR_PRECEDENCE",
  COMPILER_NATIVE_TEMPLATE: "COMPILER_NATIVE_TEMPLATE",
  COMPILER_INLINE_TEMPLATE: "COMPILER_INLINE_TEMPLATE",
  COMPILER_FILTERS: "COMPILER_FILTERS"
}, tN = {
  COMPILER_IS_ON_ELEMENT: {
    message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
    link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"
  },
  COMPILER_V_BIND_SYNC: {
    message: (r) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${r}.sync\` should be changed to \`v-model:${r}\`.`,
    link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html"
  },
  COMPILER_V_BIND_OBJECT_ORDER: {
    message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
    link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html"
  },
  COMPILER_V_ON_NATIVE: {
    message: ".native modifier for v-on has been removed as is no longer necessary.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"
  },
  COMPILER_V_IF_V_FOR_PRECEDENCE: {
    message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"
  },
  COMPILER_NATIVE_TEMPLATE: {
    message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3."
  },
  COMPILER_INLINE_TEMPLATE: {
    message: '"inline-template" has been removed in Vue 3.',
    link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"
  },
  COMPILER_FILTERS: {
    message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
    link: "https://v3-migration.vuejs.org/breaking-changes/filters.html"
  }
};
function Mp(r, { compatConfig: e }) {
  const t = e && e[r];
  return r === "MODE" ? t || 3 : t;
}
function rN(r, e) {
  const t = Mp("MODE", e), s = Mp(r, e);
  return t === 3 ? s === !0 : s !== !1;
}
function sN(r, e, t, ...s) {
  const i = rN(r, e);
  return i && ZE(r, e, t, ...s), i;
}
function ZE(r, e, t, ...s) {
  if (Mp(r, e) === "suppress-warning")
    return;
  const { message: n, link: a } = tN[r], o = `(deprecation ${r}) ${typeof n == "function" ? n(...s) : n}${a ? `
  Details: ${a}` : ""}`, u = new SyntaxError(o);
  u.code = r, t && (u.loc = t), e.onWarn(u);
}
function em(r) {
  throw r;
}
function eS(r) {
  console.warn(`[Vue warn] ${r.message}`);
}
function Me(r, e, t, s) {
  const i = (t || tm)[r] + (s || ""), n = new SyntaxError(String(i));
  return n.code = r, n.loc = e, n;
}
const iN = {
  ABRUPT_CLOSING_OF_EMPTY_COMMENT: 0,
  0: "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
  CDATA_IN_HTML_CONTENT: 1,
  1: "CDATA_IN_HTML_CONTENT",
  DUPLICATE_ATTRIBUTE: 2,
  2: "DUPLICATE_ATTRIBUTE",
  END_TAG_WITH_ATTRIBUTES: 3,
  3: "END_TAG_WITH_ATTRIBUTES",
  END_TAG_WITH_TRAILING_SOLIDUS: 4,
  4: "END_TAG_WITH_TRAILING_SOLIDUS",
  EOF_BEFORE_TAG_NAME: 5,
  5: "EOF_BEFORE_TAG_NAME",
  EOF_IN_CDATA: 6,
  6: "EOF_IN_CDATA",
  EOF_IN_COMMENT: 7,
  7: "EOF_IN_COMMENT",
  EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT: 8,
  8: "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
  EOF_IN_TAG: 9,
  9: "EOF_IN_TAG",
  INCORRECTLY_CLOSED_COMMENT: 10,
  10: "INCORRECTLY_CLOSED_COMMENT",
  INCORRECTLY_OPENED_COMMENT: 11,
  11: "INCORRECTLY_OPENED_COMMENT",
  INVALID_FIRST_CHARACTER_OF_TAG_NAME: 12,
  12: "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
  MISSING_ATTRIBUTE_VALUE: 13,
  13: "MISSING_ATTRIBUTE_VALUE",
  MISSING_END_TAG_NAME: 14,
  14: "MISSING_END_TAG_NAME",
  MISSING_WHITESPACE_BETWEEN_ATTRIBUTES: 15,
  15: "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
  NESTED_COMMENT: 16,
  16: "NESTED_COMMENT",
  UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME: 17,
  17: "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
  UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE: 18,
  18: "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
  UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME: 19,
  19: "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
  UNEXPECTED_NULL_CHARACTER: 20,
  20: "UNEXPECTED_NULL_CHARACTER",
  UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME: 21,
  21: "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
  UNEXPECTED_SOLIDUS_IN_TAG: 22,
  22: "UNEXPECTED_SOLIDUS_IN_TAG",
  X_INVALID_END_TAG: 23,
  23: "X_INVALID_END_TAG",
  X_MISSING_END_TAG: 24,
  24: "X_MISSING_END_TAG",
  X_MISSING_INTERPOLATION_END: 25,
  25: "X_MISSING_INTERPOLATION_END",
  X_MISSING_DIRECTIVE_NAME: 26,
  26: "X_MISSING_DIRECTIVE_NAME",
  X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END: 27,
  27: "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
  X_V_IF_NO_EXPRESSION: 28,
  28: "X_V_IF_NO_EXPRESSION",
  X_V_IF_SAME_KEY: 29,
  29: "X_V_IF_SAME_KEY",
  X_V_ELSE_NO_ADJACENT_IF: 30,
  30: "X_V_ELSE_NO_ADJACENT_IF",
  X_V_FOR_NO_EXPRESSION: 31,
  31: "X_V_FOR_NO_EXPRESSION",
  X_V_FOR_MALFORMED_EXPRESSION: 32,
  32: "X_V_FOR_MALFORMED_EXPRESSION",
  X_V_FOR_TEMPLATE_KEY_PLACEMENT: 33,
  33: "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
  X_V_BIND_NO_EXPRESSION: 34,
  34: "X_V_BIND_NO_EXPRESSION",
  X_V_ON_NO_EXPRESSION: 35,
  35: "X_V_ON_NO_EXPRESSION",
  X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET: 36,
  36: "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
  X_V_SLOT_MIXED_SLOT_USAGE: 37,
  37: "X_V_SLOT_MIXED_SLOT_USAGE",
  X_V_SLOT_DUPLICATE_SLOT_NAMES: 38,
  38: "X_V_SLOT_DUPLICATE_SLOT_NAMES",
  X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN: 39,
  39: "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
  X_V_SLOT_MISPLACED: 40,
  40: "X_V_SLOT_MISPLACED",
  X_V_MODEL_NO_EXPRESSION: 41,
  41: "X_V_MODEL_NO_EXPRESSION",
  X_V_MODEL_MALFORMED_EXPRESSION: 42,
  42: "X_V_MODEL_MALFORMED_EXPRESSION",
  X_V_MODEL_ON_SCOPE_VARIABLE: 43,
  43: "X_V_MODEL_ON_SCOPE_VARIABLE",
  X_V_MODEL_ON_PROPS: 44,
  44: "X_V_MODEL_ON_PROPS",
  X_INVALID_EXPRESSION: 45,
  45: "X_INVALID_EXPRESSION",
  X_KEEP_ALIVE_INVALID_CHILDREN: 46,
  46: "X_KEEP_ALIVE_INVALID_CHILDREN",
  X_PREFIX_ID_NOT_SUPPORTED: 47,
  47: "X_PREFIX_ID_NOT_SUPPORTED",
  X_MODULE_MODE_NOT_SUPPORTED: 48,
  48: "X_MODULE_MODE_NOT_SUPPORTED",
  X_CACHE_HANDLER_NOT_SUPPORTED: 49,
  49: "X_CACHE_HANDLER_NOT_SUPPORTED",
  X_SCOPE_ID_NOT_SUPPORTED: 50,
  50: "X_SCOPE_ID_NOT_SUPPORTED",
  X_VNODE_HOOKS: 51,
  51: "X_VNODE_HOOKS",
  X_V_BIND_INVALID_SAME_NAME_ARGUMENT: 52,
  52: "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
  __EXTEND_POINT__: 53,
  53: "__EXTEND_POINT__"
}, tm = {
  // parse errors
  0: "Illegal comment.",
  1: "CDATA section is allowed only in XML context.",
  2: "Duplicate attribute.",
  3: "End tag cannot have attributes.",
  4: "Illegal '/' in tags.",
  5: "Unexpected EOF in tag.",
  6: "Unexpected EOF in CDATA section.",
  7: "Unexpected EOF in comment.",
  8: "Unexpected EOF in script.",
  9: "Unexpected EOF in tag.",
  10: "Incorrectly closed comment.",
  11: "Incorrectly opened comment.",
  12: "Illegal tag name. Use '&lt;' to print '<'.",
  13: "Attribute value was expected.",
  14: "End tag name was expected.",
  15: "Whitespace was expected.",
  16: "Unexpected '<!--' in comment.",
  17: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  19: "Attribute name cannot start with '='.",
  21: "'<?' is allowed only in XML context.",
  20: "Unexpected null character.",
  22: "Illegal '/' in tags.",
  // Vue-specific parse errors
  23: "Invalid end tag.",
  24: "Element is missing end tag.",
  25: "Interpolation end sign was not found.",
  27: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  26: "Legal directive name was expected.",
  // transform errors
  28: "v-if/v-else-if is missing expression.",
  29: "v-if/else branches must use unique keys.",
  30: "v-else/v-else-if has no adjacent v-if or v-else-if.",
  31: "v-for is missing expression.",
  32: "v-for has invalid expression.",
  33: "<template v-for> key should be placed on the <template> tag.",
  34: "v-bind is missing expression.",
  52: "v-bind with same-name shorthand only allows static argument.",
  35: "v-on is missing expression.",
  36: "Unexpected custom directive on <slot> outlet.",
  37: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",
  38: "Duplicate slot names found. ",
  39: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.",
  40: "v-slot can only be used on components or <template> tags.",
  41: "v-model is missing expression.",
  42: "v-model value must be a valid JavaScript member expression.",
  43: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.",
  44: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  45: "Error parsing JavaScript expression: ",
  46: "<KeepAlive> expects exactly one child component.",
  51: "@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.",
  // generic errors
  47: '"prefixIdentifiers" option is not supported in this build of compiler.',
  48: "ES module mode is not supported in this build of compiler.",
  49: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',
  50: '"scopeId" option is only supported in module mode.',
  // just to fulfill types
  53: ""
};
function Dc(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function Vo(r) {
  if (r.__esModule) return r;
  var e = r.default;
  if (typeof e == "function") {
    var t = function s() {
      return this instanceof s ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(r).forEach(function(s) {
    var i = Object.getOwnPropertyDescriptor(r, s);
    Object.defineProperty(t, s, i.get ? i : {
      enumerable: !0,
      get: function() {
        return r[s];
      }
    });
  }), t;
}
var Lc = {};
Object.defineProperty(Lc, "__esModule", {
  value: !0
});
function tS(r, e) {
  if (r == null) return {};
  var t = {}, s = Object.keys(r), i, n;
  for (n = 0; n < s.length; n++)
    i = s[n], !(e.indexOf(i) >= 0) && (t[i] = r[i]);
  return t;
}
class ri {
  constructor(e, t, s) {
    this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = t, this.index = s;
  }
}
class vl {
  constructor(e, t) {
    this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = t;
  }
}
function Ht(r, e) {
  const {
    line: t,
    column: s,
    index: i
  } = r;
  return new ri(t, s + e, i + e);
}
const ly = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
var nN = {
  ImportMetaOutsideModule: {
    message: `import.meta may appear only with 'sourceType: "module"'`,
    code: ly
  },
  ImportOutsideModule: {
    message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
    code: ly
  }
};
const cy = {
  ArrayPattern: "array destructuring pattern",
  AssignmentExpression: "assignment expression",
  AssignmentPattern: "assignment expression",
  ArrowFunctionExpression: "arrow function expression",
  ConditionalExpression: "conditional expression",
  CatchClause: "catch clause",
  ForOfStatement: "for-of statement",
  ForInStatement: "for-in statement",
  ForStatement: "for-loop",
  FormalParameters: "function parameter list",
  Identifier: "identifier",
  ImportSpecifier: "import specifier",
  ImportDefaultSpecifier: "import default specifier",
  ImportNamespaceSpecifier: "import namespace specifier",
  ObjectPattern: "object destructuring pattern",
  ParenthesizedExpression: "parenthesized expression",
  RestElement: "rest element",
  UpdateExpression: {
    true: "prefix operation",
    false: "postfix operation"
  },
  VariableDeclarator: "variable declaration",
  YieldExpression: "yield expression"
}, Lu = (r) => r.type === "UpdateExpression" ? cy.UpdateExpression[`${r.prefix}`] : cy[r.type];
var aN = {
  AccessorIsGenerator: ({
    kind: r
  }) => `A ${r}ter cannot be a generator.`,
  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
  AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
  BadGetterArity: "A 'get' accessor must not have any formal parameters.",
  BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
  BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
  ConstructorClassField: "Classes may not have a field named 'constructor'.",
  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
  ConstructorIsAccessor: "Class constructor may not be an accessor.",
  ConstructorIsAsync: "Constructor can't be an async function.",
  ConstructorIsGenerator: "Constructor can't be a generator.",
  DeclarationMissingInitializer: ({
    kind: r
  }) => `Missing initializer in ${r} declaration.`,
  DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
  DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
  DecoratorStaticBlock: "Decorators can't be used with a static block.",
  DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
  DeletePrivateField: "Deleting a private field is not allowed.",
  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
  DuplicateConstructor: "Duplicate constructor in the same class.",
  DuplicateDefaultExport: "Only one default export allowed per module.",
  DuplicateExport: ({
    exportName: r
  }) => `\`${r}\` has already been exported. Exported identifiers must be unique.`,
  DuplicateProto: "Redefinition of __proto__ property.",
  DuplicateRegExpFlags: "Duplicate regular expression flag.",
  DynamicImportPhaseRequiresImportExpressions: ({
    phase: r
  }) => `'import.${r}(...)' can only be parsed when using the 'createImportExpressions' option.`,
  ElementAfterRest: "Rest element must be last element.",
  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
  ExportBindingIsString: ({
    localName: r,
    exportName: e
  }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${r}' as '${e}' } from 'some-module'\`?`,
  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
  ForInOfLoopInitializer: ({
    type: r
  }) => `'${r === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
  ForInUsing: "For-in loop may not start with 'using' declaration.",
  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
  IllegalBreakContinue: ({
    type: r
  }) => `Unsyntactic ${r === "BreakStatement" ? "break" : "continue"}.`,
  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
  IllegalReturn: "'return' outside of function.",
  ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
  ImportBindingIsString: ({
    importName: r
  }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${r}" as foo }\`?`,
  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
  ImportCallArity: ({
    maxArgumentCount: r
  }) => `\`import()\` requires exactly ${r === 1 ? "one argument" : "one or two arguments"}.`,
  ImportCallNotNewExpression: "Cannot use new with import(...).",
  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
  ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
  ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
  ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
  IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
  InvalidCodePoint: "Code point out of bounds.",
  InvalidCoverInitializedName: "Invalid shorthand property initializer.",
  InvalidDecimal: "Invalid decimal.",
  InvalidDigit: ({
    radix: r
  }) => `Expected number in radix ${r}.`,
  InvalidEscapeSequence: "Bad character escape sequence.",
  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
  InvalidEscapedReservedWord: ({
    reservedWord: r
  }) => `Escape sequence in keyword ${r}.`,
  InvalidIdentifier: ({
    identifierName: r
  }) => `Invalid identifier ${r}.`,
  InvalidLhs: ({
    ancestor: r
  }) => `Invalid left-hand side in ${Lu(r)}.`,
  InvalidLhsBinding: ({
    ancestor: r
  }) => `Binding invalid left-hand side in ${Lu(r)}.`,
  InvalidLhsOptionalChaining: ({
    ancestor: r
  }) => `Invalid optional chaining in the left-hand side of ${Lu(r)}.`,
  InvalidNumber: "Invalid number.",
  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
  InvalidOrUnexpectedToken: ({
    unexpected: r
  }) => `Unexpected character '${r}'.`,
  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
  InvalidPrivateFieldResolution: ({
    identifierName: r
  }) => `Private name #${r} is not defined.`,
  InvalidPropertyBindingPattern: "Binding member expression.",
  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
  LabelRedeclaration: ({
    labelName: r
  }) => `Label '${r}' is already declared.`,
  LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
  MalformedRegExpFlags: "Invalid regular expression flag.",
  MissingClassName: "A class name is required.",
  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
  MissingSemicolon: "Missing semicolon.",
  MissingPlugin: ({
    missingPlugin: r
  }) => `This experimental syntax requires enabling the parser plugin: ${r.map((e) => JSON.stringify(e)).join(", ")}.`,
  MissingOneOfPlugins: ({
    missingPlugin: r
  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${r.map((e) => JSON.stringify(e)).join(", ")}.`,
  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
  ModuleAttributesWithDuplicateKeys: ({
    key: r
  }) => `Duplicate key "${r}" is not allowed in module attributes.`,
  ModuleExportNameHasLoneSurrogate: ({
    surrogateCharCode: r
  }) => `An export name cannot include a lone surrogate, found '\\u${r.toString(16)}'.`,
  ModuleExportUndefined: ({
    localName: r
  }) => `Export '${r}' is not defined.`,
  MultipleDefaultsInSwitch: "Multiple default clauses.",
  NewlineAfterThrow: "Illegal newline after throw.",
  NoCatchOrFinally: "Missing catch or finally clause.",
  NumberIdentifier: "Identifier directly after number.",
  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
  ParamDupe: "Argument name clash.",
  PatternHasAccessor: "Object pattern can't contain getter or setter.",
  PatternHasMethod: "Object pattern can't contain methods.",
  PrivateInExpectedIn: ({
    identifierName: r
  }) => `Private names are only allowed in property accesses (\`obj.#${r}\`) or in \`in\` expressions (\`#${r} in obj\`).`,
  PrivateNameRedeclaration: ({
    identifierName: r
  }) => `Duplicate private name #${r}.`,
  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
  RestTrailingComma: "Unexpected trailing comma after rest element.",
  SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
  SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
  SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
  StaticPrototype: "Classes may not have static property named prototype.",
  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
  SuperPrivateField: "Private fields can't be accessed on super.",
  TrailingDecorator: "Decorators must be attached to a class element.",
  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
  UnexpectedKeyword: ({
    keyword: r
  }) => `Unexpected keyword '${r}'.`,
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
  UnexpectedPrivateField: "Unexpected private name.",
  UnexpectedReservedWord: ({
    reservedWord: r
  }) => `Unexpected reserved word '${r}'.`,
  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
  UnexpectedToken: ({
    expected: r,
    unexpected: e
  }) => `Unexpected token${e ? ` '${e}'.` : ""}${r ? `, expected "${r}"` : ""}`,
  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
  UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
  UnsupportedBind: "Binding should be performed on object property.",
  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
  UnsupportedMetaProperty: ({
    target: r,
    onlyValidPropertyName: e
  }) => `The only valid meta property for ${r} is ${r}.${e}.`,
  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
  UnterminatedComment: "Unterminated comment.",
  UnterminatedRegExp: "Unterminated regular expression.",
  UnterminatedString: "Unterminated string constant.",
  UnterminatedTemplate: "Unterminated template.",
  UsingDeclarationExport: "Using declaration cannot be exported.",
  UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
  VarRedeclaration: ({
    identifierName: r
  }) => `Identifier '${r}' has already been declared.`,
  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
  YieldInParameter: "Yield expression is not allowed in formal parameters.",
  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
}, oN = {
  StrictDelete: "Deleting local variable in strict mode.",
  StrictEvalArguments: ({
    referenceName: r
  }) => `Assigning to '${r}' in strict mode.`,
  StrictEvalArgumentsBinding: ({
    bindingName: r
  }) => `Binding '${r}' in strict mode.`,
  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
  StrictWith: "'with' in strict mode."
};
const uN = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
var lN = {
  PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
  PipeTopicUnconfiguredToken: ({
    token: r
  }) => `Invalid topic token ${r}. In order to use ${r} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${r}" }.`,
  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
  PipeUnparenthesizedBody: ({
    type: r
  }) => `Hack-style pipe body cannot be an unparenthesized ${Lu({
    type: r
  })}; please wrap it in parentheses.`,
  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
};
const cN = ["toMessage"], fN = ["message"];
function fy(r, e, t) {
  Object.defineProperty(r, e, {
    enumerable: !1,
    configurable: !0,
    value: t
  });
}
function pN(r) {
  let {
    toMessage: e
  } = r, t = tS(r, cN);
  return function s(i, n) {
    const a = new SyntaxError();
    return Object.assign(a, t, {
      loc: i,
      pos: i.index
    }), "missingPlugin" in n && Object.assign(a, {
      missingPlugin: n.missingPlugin
    }), fy(a, "clone", function(u = {}) {
      var l;
      const {
        line: c,
        column: f,
        index: p
      } = (l = u.loc) != null ? l : i;
      return s(new ri(c, f, p), Object.assign({}, n, u.details));
    }), fy(a, "details", n), Object.defineProperty(a, "message", {
      configurable: !0,
      get() {
        const o = `${e(n)} (${i.line}:${i.column})`;
        return this.message = o, o;
      },
      set(o) {
        Object.defineProperty(this, "message", {
          value: o,
          writable: !0
        });
      }
    }), a;
  };
}
function gs(r, e) {
  if (Array.isArray(r))
    return (s) => gs(s, r[0]);
  const t = {};
  for (const s of Object.keys(r)) {
    const i = r[s], n = typeof i == "string" ? {
      message: () => i
    } : typeof i == "function" ? {
      message: i
    } : i, {
      message: a
    } = n, o = tS(n, fN), u = typeof a == "string" ? () => a : a;
    t[s] = pN(Object.assign({
      code: "BABEL_PARSER_SYNTAX_ERROR",
      reasonCode: s,
      toMessage: u
    }, e ? {
      syntaxPlugin: e
    } : {}, o));
  }
  return t;
}
const O = Object.assign({}, gs(nN), gs(aN), gs(oN), gs`pipelineOperator`(lN)), {
  defineProperty: hN
} = Object, py = (r, e) => hN(r, e, {
  enumerable: !1,
  value: r[e]
});
function ma(r) {
  return r.loc.start && py(r.loc.start, "index"), r.loc.end && py(r.loc.end, "index"), r;
}
var dN = (r) => class extends r {
  parse() {
    const t = ma(super.parse());
    return this.options.tokens && (t.tokens = t.tokens.map(ma)), t;
  }
  parseRegExpLiteral({
    pattern: t,
    flags: s
  }) {
    let i = null;
    try {
      i = new RegExp(t, s);
    } catch {
    }
    const n = this.estreeParseLiteral(i);
    return n.regex = {
      pattern: t,
      flags: s
    }, n;
  }
  parseBigIntLiteral(t) {
    let s;
    try {
      s = BigInt(t);
    } catch {
      s = null;
    }
    const i = this.estreeParseLiteral(s);
    return i.bigint = String(i.value || t), i;
  }
  parseDecimalLiteral(t) {
    const i = this.estreeParseLiteral(null);
    return i.decimal = String(i.value || t), i;
  }
  estreeParseLiteral(t) {
    return this.parseLiteral(t, "Literal");
  }
  parseStringLiteral(t) {
    return this.estreeParseLiteral(t);
  }
  parseNumericLiteral(t) {
    return this.estreeParseLiteral(t);
  }
  parseNullLiteral() {
    return this.estreeParseLiteral(null);
  }
  parseBooleanLiteral(t) {
    return this.estreeParseLiteral(t);
  }
  directiveToStmt(t) {
    const s = t.value;
    delete t.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
    const i = t;
    return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
  }
  initFunction(t, s) {
    super.initFunction(t, s), t.expression = !1;
  }
  checkDeclaration(t) {
    t != null && this.isObjectProperty(t) ? this.checkDeclaration(t.value) : super.checkDeclaration(t);
  }
  getObjectOrClassMethodParams(t) {
    return t.value.params;
  }
  isValidDirective(t) {
    var s;
    return t.type === "ExpressionStatement" && t.expression.type === "Literal" && typeof t.expression.value == "string" && !((s = t.expression.extra) != null && s.parenthesized);
  }
  parseBlockBody(t, s, i, n, a) {
    super.parseBlockBody(t, s, i, n, a);
    const o = t.directives.map((u) => this.directiveToStmt(u));
    t.body = o.concat(t.body), delete t.directives;
  }
  pushClassMethod(t, s, i, n, a, o) {
    this.parseMethod(s, i, n, a, o, "ClassMethod", !0), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters), t.body.push(s);
  }
  parsePrivateName() {
    const t = super.parsePrivateName();
    return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(t) : t;
  }
  convertPrivateNameToPrivateIdentifier(t) {
    const s = super.getPrivateNameSV(t);
    return t = t, delete t.id, t.name = s, t.type = "PrivateIdentifier", t;
  }
  isPrivateName(t) {
    return this.getPluginOption("estree", "classFeatures") ? t.type === "PrivateIdentifier" : super.isPrivateName(t);
  }
  getPrivateNameSV(t) {
    return this.getPluginOption("estree", "classFeatures") ? t.name : super.getPrivateNameSV(t);
  }
  parseLiteral(t, s) {
    const i = super.parseLiteral(t, s);
    return i.raw = i.extra.raw, delete i.extra, i;
  }
  parseFunctionBody(t, s, i = !1) {
    super.parseFunctionBody(t, s, i), t.expression = t.body.type !== "BlockStatement";
  }
  parseMethod(t, s, i, n, a, o, u = !1) {
    let l = this.startNode();
    return l.kind = t.kind, l = super.parseMethod(l, s, i, n, a, o, u), l.type = "FunctionExpression", delete l.kind, t.value = l, o === "ClassPrivateMethod" && (t.computed = !1), this.finishNode(t, "MethodDefinition");
  }
  nameIsConstructor(t) {
    return t.type === "Literal" ? t.value === "constructor" : super.nameIsConstructor(t);
  }
  parseClassProperty(...t) {
    const s = super.parseClassProperty(...t);
    return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition"), s;
  }
  parseClassPrivateProperty(...t) {
    const s = super.parseClassPrivateProperty(...t);
    return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition", s.computed = !1), s;
  }
  parseObjectMethod(t, s, i, n, a) {
    const o = super.parseObjectMethod(t, s, i, n, a);
    return o && (o.type = "Property", o.kind === "method" && (o.kind = "init"), o.shorthand = !1), o;
  }
  parseObjectProperty(t, s, i, n) {
    const a = super.parseObjectProperty(t, s, i, n);
    return a && (a.kind = "init", a.type = "Property"), a;
  }
  isValidLVal(t, s, i) {
    return t === "Property" ? "value" : super.isValidLVal(t, s, i);
  }
  isAssignable(t, s) {
    return t != null && this.isObjectProperty(t) ? this.isAssignable(t.value, s) : super.isAssignable(t, s);
  }
  toAssignable(t, s = !1) {
    if (t != null && this.isObjectProperty(t)) {
      const {
        key: i,
        value: n
      } = t;
      this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(n, s);
    } else
      super.toAssignable(t, s);
  }
  toAssignableObjectExpressionProp(t, s, i) {
    t.type === "Property" && (t.kind === "get" || t.kind === "set") ? this.raise(O.PatternHasAccessor, t.key) : t.type === "Property" && t.method ? this.raise(O.PatternHasMethod, t.key) : super.toAssignableObjectExpressionProp(t, s, i);
  }
  finishCallExpression(t, s) {
    const i = super.finishCallExpression(t, s);
    if (i.callee.type === "Import") {
      if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
        var n, a;
        i.options = (n = i.arguments[1]) != null ? n : null, i.attributes = (a = i.arguments[1]) != null ? a : null;
      }
      delete i.arguments, delete i.callee;
    }
    return i;
  }
  toReferencedArguments(t) {
    t.type !== "ImportExpression" && super.toReferencedArguments(t);
  }
  parseExport(t, s) {
    const i = this.state.lastTokStartLoc, n = super.parseExport(t, s);
    switch (n.type) {
      case "ExportAllDeclaration":
        n.exported = null;
        break;
      case "ExportNamedDeclaration":
        n.specifiers.length === 1 && n.specifiers[0].type === "ExportNamespaceSpecifier" && (n.type = "ExportAllDeclaration", n.exported = n.specifiers[0].exported, delete n.specifiers);
      case "ExportDefaultDeclaration":
        {
          var a;
          const {
            declaration: o
          } = n;
          (o == null ? void 0 : o.type) === "ClassDeclaration" && ((a = o.decorators) == null ? void 0 : a.length) > 0 && o.start === n.start && this.resetStartLocation(n, i);
        }
        break;
    }
    return n;
  }
  parseSubscript(t, s, i, n) {
    const a = super.parseSubscript(t, s, i, n);
    if (n.optionalChainMember) {
      if ((a.type === "OptionalMemberExpression" || a.type === "OptionalCallExpression") && (a.type = a.type.substring(8)), n.stop) {
        const o = this.startNodeAtNode(a);
        return o.expression = a, this.finishNode(o, "ChainExpression");
      }
    } else (a.type === "MemberExpression" || a.type === "CallExpression") && (a.optional = !1);
    return a;
  }
  isOptionalMemberExpression(t) {
    return t.type === "ChainExpression" ? t.expression.type === "MemberExpression" : super.isOptionalMemberExpression(t);
  }
  hasPropertyAsPrivateName(t) {
    return t.type === "ChainExpression" && (t = t.expression), super.hasPropertyAsPrivateName(t);
  }
  isObjectProperty(t) {
    return t.type === "Property" && t.kind === "init" && !t.method;
  }
  isObjectMethod(t) {
    return t.type === "Property" && (t.method || t.kind === "get" || t.kind === "set");
  }
  finishNodeAt(t, s, i) {
    return ma(super.finishNodeAt(t, s, i));
  }
  resetStartLocation(t, s) {
    super.resetStartLocation(t, s), ma(t);
  }
  resetEndLocation(t, s = this.state.lastTokEndLoc) {
    super.resetEndLocation(t, s), ma(t);
  }
};
class Oa {
  constructor(e, t) {
    this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!t;
  }
}
const Ue = {
  brace: new Oa("{"),
  j_oTag: new Oa("<tag"),
  j_cTag: new Oa("</tag"),
  j_expr: new Oa("<tag>...</tag>", !0)
};
Ue.template = new Oa("`", !0);
const Te = !0, te = !0, Df = !0, ga = !0, $s = !0, mN = !0;
class rS {
  constructor(e, t = {}) {
    this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = t.keyword, this.beforeExpr = !!t.beforeExpr, this.startsExpr = !!t.startsExpr, this.rightAssociative = !!t.rightAssociative, this.isLoop = !!t.isLoop, this.isAssign = !!t.isAssign, this.prefix = !!t.prefix, this.postfix = !!t.postfix, this.binop = t.binop != null ? t.binop : null, this.updateContext = null;
  }
}
const rm = /* @__PURE__ */ new Map();
function Ne(r, e = {}) {
  e.keyword = r;
  const t = he(r, e);
  return rm.set(r, t), t;
}
function Ft(r, e) {
  return he(r, {
    beforeExpr: Te,
    binop: e
  });
}
let ja = -1;
const hs = [], sm = [], im = [], nm = [], am = [], om = [];
function he(r, e = {}) {
  var t, s, i, n;
  return ++ja, sm.push(r), im.push((t = e.binop) != null ? t : -1), nm.push((s = e.beforeExpr) != null ? s : !1), am.push((i = e.startsExpr) != null ? i : !1), om.push((n = e.prefix) != null ? n : !1), hs.push(new rS(r, e)), ja;
}
function we(r, e = {}) {
  var t, s, i, n;
  return ++ja, rm.set(r, ja), sm.push(r), im.push((t = e.binop) != null ? t : -1), nm.push((s = e.beforeExpr) != null ? s : !1), am.push((i = e.startsExpr) != null ? i : !1), om.push((n = e.prefix) != null ? n : !1), hs.push(new rS("name", e)), ja;
}
const gN = {
  bracketL: he("[", {
    beforeExpr: Te,
    startsExpr: te
  }),
  bracketHashL: he("#[", {
    beforeExpr: Te,
    startsExpr: te
  }),
  bracketBarL: he("[|", {
    beforeExpr: Te,
    startsExpr: te
  }),
  bracketR: he("]"),
  bracketBarR: he("|]"),
  braceL: he("{", {
    beforeExpr: Te,
    startsExpr: te
  }),
  braceBarL: he("{|", {
    beforeExpr: Te,
    startsExpr: te
  }),
  braceHashL: he("#{", {
    beforeExpr: Te,
    startsExpr: te
  }),
  braceR: he("}"),
  braceBarR: he("|}"),
  parenL: he("(", {
    beforeExpr: Te,
    startsExpr: te
  }),
  parenR: he(")"),
  comma: he(",", {
    beforeExpr: Te
  }),
  semi: he(";", {
    beforeExpr: Te
  }),
  colon: he(":", {
    beforeExpr: Te
  }),
  doubleColon: he("::", {
    beforeExpr: Te
  }),
  dot: he("."),
  question: he("?", {
    beforeExpr: Te
  }),
  questionDot: he("?."),
  arrow: he("=>", {
    beforeExpr: Te
  }),
  template: he("template"),
  ellipsis: he("...", {
    beforeExpr: Te
  }),
  backQuote: he("`", {
    startsExpr: te
  }),
  dollarBraceL: he("${", {
    beforeExpr: Te,
    startsExpr: te
  }),
  templateTail: he("...`", {
    startsExpr: te
  }),
  templateNonTail: he("...${", {
    beforeExpr: Te,
    startsExpr: te
  }),
  at: he("@"),
  hash: he("#", {
    startsExpr: te
  }),
  interpreterDirective: he("#!..."),
  eq: he("=", {
    beforeExpr: Te,
    isAssign: ga
  }),
  assign: he("_=", {
    beforeExpr: Te,
    isAssign: ga
  }),
  slashAssign: he("_=", {
    beforeExpr: Te,
    isAssign: ga
  }),
  xorAssign: he("_=", {
    beforeExpr: Te,
    isAssign: ga
  }),
  moduloAssign: he("_=", {
    beforeExpr: Te,
    isAssign: ga
  }),
  incDec: he("++/--", {
    prefix: $s,
    postfix: mN,
    startsExpr: te
  }),
  bang: he("!", {
    beforeExpr: Te,
    prefix: $s,
    startsExpr: te
  }),
  tilde: he("~", {
    beforeExpr: Te,
    prefix: $s,
    startsExpr: te
  }),
  doubleCaret: he("^^", {
    startsExpr: te
  }),
  doubleAt: he("@@", {
    startsExpr: te
  }),
  pipeline: Ft("|>", 0),
  nullishCoalescing: Ft("??", 1),
  logicalOR: Ft("||", 1),
  logicalAND: Ft("&&", 2),
  bitwiseOR: Ft("|", 3),
  bitwiseXOR: Ft("^", 4),
  bitwiseAND: Ft("&", 5),
  equality: Ft("==/!=/===/!==", 6),
  lt: Ft("</>/<=/>=", 7),
  gt: Ft("</>/<=/>=", 7),
  relational: Ft("</>/<=/>=", 7),
  bitShift: Ft("<</>>/>>>", 8),
  bitShiftL: Ft("<</>>/>>>", 8),
  bitShiftR: Ft("<</>>/>>>", 8),
  plusMin: he("+/-", {
    beforeExpr: Te,
    binop: 9,
    prefix: $s,
    startsExpr: te
  }),
  modulo: he("%", {
    binop: 10,
    startsExpr: te
  }),
  star: he("*", {
    binop: 10
  }),
  slash: Ft("/", 10),
  exponent: he("**", {
    beforeExpr: Te,
    binop: 11,
    rightAssociative: !0
  }),
  _in: Ne("in", {
    beforeExpr: Te,
    binop: 7
  }),
  _instanceof: Ne("instanceof", {
    beforeExpr: Te,
    binop: 7
  }),
  _break: Ne("break"),
  _case: Ne("case", {
    beforeExpr: Te
  }),
  _catch: Ne("catch"),
  _continue: Ne("continue"),
  _debugger: Ne("debugger"),
  _default: Ne("default", {
    beforeExpr: Te
  }),
  _else: Ne("else", {
    beforeExpr: Te
  }),
  _finally: Ne("finally"),
  _function: Ne("function", {
    startsExpr: te
  }),
  _if: Ne("if"),
  _return: Ne("return", {
    beforeExpr: Te
  }),
  _switch: Ne("switch"),
  _throw: Ne("throw", {
    beforeExpr: Te,
    prefix: $s,
    startsExpr: te
  }),
  _try: Ne("try"),
  _var: Ne("var"),
  _const: Ne("const"),
  _with: Ne("with"),
  _new: Ne("new", {
    beforeExpr: Te,
    startsExpr: te
  }),
  _this: Ne("this", {
    startsExpr: te
  }),
  _super: Ne("super", {
    startsExpr: te
  }),
  _class: Ne("class", {
    startsExpr: te
  }),
  _extends: Ne("extends", {
    beforeExpr: Te
  }),
  _export: Ne("export"),
  _import: Ne("import", {
    startsExpr: te
  }),
  _null: Ne("null", {
    startsExpr: te
  }),
  _true: Ne("true", {
    startsExpr: te
  }),
  _false: Ne("false", {
    startsExpr: te
  }),
  _typeof: Ne("typeof", {
    beforeExpr: Te,
    prefix: $s,
    startsExpr: te
  }),
  _void: Ne("void", {
    beforeExpr: Te,
    prefix: $s,
    startsExpr: te
  }),
  _delete: Ne("delete", {
    beforeExpr: Te,
    prefix: $s,
    startsExpr: te
  }),
  _do: Ne("do", {
    isLoop: Df,
    beforeExpr: Te
  }),
  _for: Ne("for", {
    isLoop: Df
  }),
  _while: Ne("while", {
    isLoop: Df
  }),
  _as: we("as", {
    startsExpr: te
  }),
  _assert: we("assert", {
    startsExpr: te
  }),
  _async: we("async", {
    startsExpr: te
  }),
  _await: we("await", {
    startsExpr: te
  }),
  _defer: we("defer", {
    startsExpr: te
  }),
  _from: we("from", {
    startsExpr: te
  }),
  _get: we("get", {
    startsExpr: te
  }),
  _let: we("let", {
    startsExpr: te
  }),
  _meta: we("meta", {
    startsExpr: te
  }),
  _of: we("of", {
    startsExpr: te
  }),
  _sent: we("sent", {
    startsExpr: te
  }),
  _set: we("set", {
    startsExpr: te
  }),
  _source: we("source", {
    startsExpr: te
  }),
  _static: we("static", {
    startsExpr: te
  }),
  _using: we("using", {
    startsExpr: te
  }),
  _yield: we("yield", {
    startsExpr: te
  }),
  _asserts: we("asserts", {
    startsExpr: te
  }),
  _checks: we("checks", {
    startsExpr: te
  }),
  _exports: we("exports", {
    startsExpr: te
  }),
  _global: we("global", {
    startsExpr: te
  }),
  _implements: we("implements", {
    startsExpr: te
  }),
  _intrinsic: we("intrinsic", {
    startsExpr: te
  }),
  _infer: we("infer", {
    startsExpr: te
  }),
  _is: we("is", {
    startsExpr: te
  }),
  _mixins: we("mixins", {
    startsExpr: te
  }),
  _proto: we("proto", {
    startsExpr: te
  }),
  _require: we("require", {
    startsExpr: te
  }),
  _satisfies: we("satisfies", {
    startsExpr: te
  }),
  _keyof: we("keyof", {
    startsExpr: te
  }),
  _readonly: we("readonly", {
    startsExpr: te
  }),
  _unique: we("unique", {
    startsExpr: te
  }),
  _abstract: we("abstract", {
    startsExpr: te
  }),
  _declare: we("declare", {
    startsExpr: te
  }),
  _enum: we("enum", {
    startsExpr: te
  }),
  _module: we("module", {
    startsExpr: te
  }),
  _namespace: we("namespace", {
    startsExpr: te
  }),
  _interface: we("interface", {
    startsExpr: te
  }),
  _type: we("type", {
    startsExpr: te
  }),
  _opaque: we("opaque", {
    startsExpr: te
  }),
  name: he("name", {
    startsExpr: te
  }),
  string: he("string", {
    startsExpr: te
  }),
  num: he("num", {
    startsExpr: te
  }),
  bigint: he("bigint", {
    startsExpr: te
  }),
  decimal: he("decimal", {
    startsExpr: te
  }),
  regexp: he("regexp", {
    startsExpr: te
  }),
  privateName: he("#name", {
    startsExpr: te
  }),
  eof: he("eof"),
  jsxName: he("jsxName"),
  jsxText: he("jsxText", {
    beforeExpr: !0
  }),
  jsxTagStart: he("jsxTagStart", {
    startsExpr: !0
  }),
  jsxTagEnd: he("jsxTagEnd"),
  placeholder: he("%%", {
    startsExpr: !0
  })
};
function Le(r) {
  return r >= 93 && r <= 132;
}
function yN(r) {
  return r <= 92;
}
function Cr(r) {
  return r >= 58 && r <= 132;
}
function sS(r) {
  return r >= 58 && r <= 136;
}
function bN(r) {
  return nm[r];
}
function Rp(r) {
  return am[r];
}
function vN(r) {
  return r >= 29 && r <= 33;
}
function hy(r) {
  return r >= 129 && r <= 131;
}
function EN(r) {
  return r >= 90 && r <= 92;
}
function um(r) {
  return r >= 58 && r <= 92;
}
function SN(r) {
  return r >= 39 && r <= 59;
}
function _N(r) {
  return r === 34;
}
function xN(r) {
  return om[r];
}
function wN(r) {
  return r >= 121 && r <= 123;
}
function TN(r) {
  return r >= 124 && r <= 130;
}
function si(r) {
  return sm[r];
}
function Mu(r) {
  return im[r];
}
function PN(r) {
  return r === 57;
}
function El(r) {
  return r >= 24 && r <= 25;
}
function ls(r) {
  return hs[r];
}
hs[8].updateContext = (r) => {
  r.pop();
}, hs[5].updateContext = hs[7].updateContext = hs[23].updateContext = (r) => {
  r.push(Ue.brace);
}, hs[22].updateContext = (r) => {
  r[r.length - 1] === Ue.template ? r.pop() : r.push(Ue.template);
}, hs[142].updateContext = (r) => {
  r.push(Ue.j_expr, Ue.j_oTag);
};
let lm = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", iS = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
const AN = new RegExp("[" + lm + "]"), CN = new RegExp("[" + lm + iS + "]");
lm = iS = null;
const nS = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], NN = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function $p(r, e) {
  let t = 65536;
  for (let s = 0, i = e.length; s < i; s += 2) {
    if (t += e[s], t > r) return !1;
    if (t += e[s + 1], t >= r) return !0;
  }
  return !1;
}
function ms(r) {
  return r < 65 ? r === 36 : r <= 90 ? !0 : r < 97 ? r === 95 : r <= 122 ? !0 : r <= 65535 ? r >= 170 && AN.test(String.fromCharCode(r)) : $p(r, nS);
}
function Sn(r) {
  return r < 48 ? r === 36 : r < 58 ? !0 : r < 65 ? !1 : r <= 90 ? !0 : r < 97 ? r === 95 : r <= 122 ? !0 : r <= 65535 ? r >= 170 && CN.test(String.fromCharCode(r)) : $p(r, nS) || $p(r, NN);
}
const cm = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
}, ON = new Set(cm.keyword), IN = new Set(cm.strict), kN = new Set(cm.strictBind);
function aS(r, e) {
  return e && r === "await" || r === "enum";
}
function oS(r, e) {
  return aS(r, e) || IN.has(r);
}
function uS(r) {
  return kN.has(r);
}
function lS(r, e) {
  return oS(r, e) || uS(r);
}
function DN(r) {
  return ON.has(r);
}
function LN(r, e, t) {
  return r === 64 && e === 64 && ms(t);
}
const MN = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
function RN(r) {
  return MN.has(r);
}
class fm {
  constructor(e) {
    this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
  }
}
class pm {
  constructor(e, t) {
    this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e, this.inModule = t;
  }
  get inTopLevel() {
    return (this.currentScope().flags & 1) > 0;
  }
  get inFunction() {
    return (this.currentVarScopeFlags() & 2) > 0;
  }
  get allowSuper() {
    return (this.currentThisScopeFlags() & 16) > 0;
  }
  get allowDirectSuper() {
    return (this.currentThisScopeFlags() & 32) > 0;
  }
  get inClass() {
    return (this.currentThisScopeFlags() & 64) > 0;
  }
  get inClassAndNotInNonArrowFunction() {
    const e = this.currentThisScopeFlags();
    return (e & 64) > 0 && (e & 2) === 0;
  }
  get inStaticBlock() {
    for (let e = this.scopeStack.length - 1; ; e--) {
      const {
        flags: t
      } = this.scopeStack[e];
      if (t & 128)
        return !0;
      if (t & 451)
        return !1;
    }
  }
  get inNonArrowFunction() {
    return (this.currentThisScopeFlags() & 2) > 0;
  }
  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }
  createScope(e) {
    return new fm(e);
  }
  enter(e) {
    this.scopeStack.push(this.createScope(e));
  }
  exit() {
    return this.scopeStack.pop().flags;
  }
  treatFunctionsAsVarInScope(e) {
    return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
  }
  declareName(e, t, s) {
    let i = this.currentScope();
    if (t & 8 || t & 16) {
      this.checkRedeclarationInScope(i, e, t, s);
      let n = i.names.get(e) || 0;
      t & 16 ? n = n | 4 : (i.firstLexicalName || (i.firstLexicalName = e), n = n | 2), i.names.set(e, n), t & 8 && this.maybeExportDefined(i, e);
    } else if (t & 4)
      for (let n = this.scopeStack.length - 1; n >= 0 && (i = this.scopeStack[n], this.checkRedeclarationInScope(i, e, t, s), i.names.set(e, (i.names.get(e) || 0) | 1), this.maybeExportDefined(i, e), !(i.flags & 387)); --n)
        ;
    this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(e);
  }
  maybeExportDefined(e, t) {
    this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(t);
  }
  checkRedeclarationInScope(e, t, s, i) {
    this.isRedeclaredInScope(e, t, s) && this.parser.raise(O.VarRedeclaration, i, {
      identifierName: t
    });
  }
  isRedeclaredInScope(e, t, s) {
    if (!(s & 1)) return !1;
    if (s & 8)
      return e.names.has(t);
    const i = e.names.get(t);
    return s & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (i & 1) > 0 : (i & 2) > 0 && !(e.flags & 8 && e.firstLexicalName === t) || !this.treatFunctionsAsVarInScope(e) && (i & 4) > 0;
  }
  checkLocalExport(e) {
    const {
      name: t
    } = e;
    this.scopeStack[0].names.has(t) || this.undefinedExports.set(t, e.loc.start);
  }
  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1];
  }
  currentVarScopeFlags() {
    for (let e = this.scopeStack.length - 1; ; e--) {
      const {
        flags: t
      } = this.scopeStack[e];
      if (t & 387)
        return t;
    }
  }
  currentThisScopeFlags() {
    for (let e = this.scopeStack.length - 1; ; e--) {
      const {
        flags: t
      } = this.scopeStack[e];
      if (t & 451 && !(t & 4))
        return t;
    }
  }
}
class $N extends fm {
  constructor(...e) {
    super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
  }
}
class FN extends pm {
  createScope(e) {
    return new $N(e);
  }
  declareName(e, t, s) {
    const i = this.currentScope();
    if (t & 2048) {
      this.checkRedeclarationInScope(i, e, t, s), this.maybeExportDefined(i, e), i.declareFunctions.add(e);
      return;
    }
    super.declareName(e, t, s);
  }
  isRedeclaredInScope(e, t, s) {
    if (super.isRedeclaredInScope(e, t, s)) return !0;
    if (s & 2048 && !e.declareFunctions.has(t)) {
      const i = e.names.get(t);
      return (i & 4) > 0 || (i & 2) > 0;
    }
    return !1;
  }
  checkLocalExport(e) {
    this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
  }
}
class BN {
  constructor() {
    this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
  }
  hasPlugin(e) {
    if (typeof e == "string")
      return this.plugins.has(e);
    {
      const [t, s] = e;
      if (!this.hasPlugin(t))
        return !1;
      const i = this.plugins.get(t);
      for (const n of Object.keys(s))
        if ((i == null ? void 0 : i[n]) !== s[n])
          return !1;
      return !0;
    }
  }
  getPluginOption(e, t) {
    var s;
    return (s = this.plugins.get(e)) == null ? void 0 : s[t];
  }
}
function cS(r, e) {
  r.trailingComments === void 0 ? r.trailingComments = e : r.trailingComments.unshift(...e);
}
function VN(r, e) {
  r.leadingComments === void 0 ? r.leadingComments = e : r.leadingComments.unshift(...e);
}
function fo(r, e) {
  r.innerComments === void 0 ? r.innerComments = e : r.innerComments.unshift(...e);
}
function ya(r, e, t) {
  let s = null, i = e.length;
  for (; s === null && i > 0; )
    s = e[--i];
  s === null || s.start > t.start ? fo(r, t.comments) : cS(s, t.comments);
}
class UN extends BN {
  addComment(e) {
    this.filename && (e.loc.filename = this.filename);
    const {
      commentsLen: t
    } = this.state;
    this.comments.length !== t && (this.comments.length = t), this.comments.push(e), this.state.commentsLen++;
  }
  processComment(e) {
    const {
      commentStack: t
    } = this.state, s = t.length;
    if (s === 0) return;
    let i = s - 1;
    const n = t[i];
    n.start === e.end && (n.leadingNode = e, i--);
    const {
      start: a
    } = e;
    for (; i >= 0; i--) {
      const o = t[i], u = o.end;
      if (u > a)
        o.containingNode = e, this.finalizeComment(o), t.splice(i, 1);
      else {
        u === a && (o.trailingNode = e);
        break;
      }
    }
  }
  finalizeComment(e) {
    const {
      comments: t
    } = e;
    if (e.leadingNode !== null || e.trailingNode !== null)
      e.leadingNode !== null && cS(e.leadingNode, t), e.trailingNode !== null && VN(e.trailingNode, t);
    else {
      const {
        containingNode: s,
        start: i
      } = e;
      if (this.input.charCodeAt(i - 1) === 44)
        switch (s.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            ya(s, s.properties, e);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            ya(s, s.arguments, e);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            ya(s, s.params, e);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            ya(s, s.elements, e);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            ya(s, s.specifiers, e);
            break;
          default:
            fo(s, t);
        }
      else
        fo(s, t);
    }
  }
  finalizeRemainingComments() {
    const {
      commentStack: e
    } = this.state;
    for (let t = e.length - 1; t >= 0; t--)
      this.finalizeComment(e[t]);
    this.state.commentStack = [];
  }
  resetPreviousNodeTrailingComments(e) {
    const {
      commentStack: t
    } = this.state, {
      length: s
    } = t;
    if (s === 0) return;
    const i = t[s - 1];
    i.leadingNode === e && (i.leadingNode = null);
  }
  resetPreviousIdentifierLeadingComments(e) {
    const {
      commentStack: t
    } = this.state, {
      length: s
    } = t;
    s !== 0 && (t[s - 1].trailingNode === e ? t[s - 1].trailingNode = null : s >= 2 && t[s - 2].trailingNode === e && (t[s - 2].trailingNode = null));
  }
  takeSurroundingComments(e, t, s) {
    const {
      commentStack: i
    } = this.state, n = i.length;
    if (n === 0) return;
    let a = n - 1;
    for (; a >= 0; a--) {
      const o = i[a], u = o.end;
      if (o.start === s)
        o.leadingNode = e;
      else if (u === t)
        o.trailingNode = e;
      else if (u < t)
        break;
    }
  }
}
const fS = /\r\n?|[\n\u2028\u2029]/, ou = new RegExp(fS.source, "g");
function qa(r) {
  switch (r) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return !0;
    default:
      return !1;
  }
}
const Lf = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ru = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, dy = new RegExp("(?=(" + Ru.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
function jN(r) {
  switch (r) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return !0;
    default:
      return !1;
  }
}
class hm {
  constructor() {
    this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [Ue.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
  }
  get strict() {
    return (this.flags & 1) > 0;
  }
  set strict(e) {
    e ? this.flags |= 1 : this.flags &= -2;
  }
  init({
    strictMode: e,
    sourceType: t,
    startLine: s,
    startColumn: i
  }) {
    this.strict = e === !1 ? !1 : e === !0 ? !0 : t === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new ri(s, i, 0);
  }
  get maybeInArrowParameters() {
    return (this.flags & 2) > 0;
  }
  set maybeInArrowParameters(e) {
    e ? this.flags |= 2 : this.flags &= -3;
  }
  get inType() {
    return (this.flags & 4) > 0;
  }
  set inType(e) {
    e ? this.flags |= 4 : this.flags &= -5;
  }
  get noAnonFunctionType() {
    return (this.flags & 8) > 0;
  }
  set noAnonFunctionType(e) {
    e ? this.flags |= 8 : this.flags &= -9;
  }
  get hasFlowComment() {
    return (this.flags & 16) > 0;
  }
  set hasFlowComment(e) {
    e ? this.flags |= 16 : this.flags &= -17;
  }
  get isAmbientContext() {
    return (this.flags & 32) > 0;
  }
  set isAmbientContext(e) {
    e ? this.flags |= 32 : this.flags &= -33;
  }
  get inAbstractClass() {
    return (this.flags & 64) > 0;
  }
  set inAbstractClass(e) {
    e ? this.flags |= 64 : this.flags &= -65;
  }
  get inDisallowConditionalTypesContext() {
    return (this.flags & 128) > 0;
  }
  set inDisallowConditionalTypesContext(e) {
    e ? this.flags |= 128 : this.flags &= -129;
  }
  get soloAwait() {
    return (this.flags & 256) > 0;
  }
  set soloAwait(e) {
    e ? this.flags |= 256 : this.flags &= -257;
  }
  get inFSharpPipelineDirectBody() {
    return (this.flags & 512) > 0;
  }
  set inFSharpPipelineDirectBody(e) {
    e ? this.flags |= 512 : this.flags &= -513;
  }
  get canStartJSXElement() {
    return (this.flags & 1024) > 0;
  }
  set canStartJSXElement(e) {
    e ? this.flags |= 1024 : this.flags &= -1025;
  }
  get containsEsc() {
    return (this.flags & 2048) > 0;
  }
  set containsEsc(e) {
    e ? this.flags |= 2048 : this.flags &= -2049;
  }
  curPosition() {
    return new ri(this.curLine, this.pos - this.lineStart, this.pos);
  }
  clone() {
    const e = new hm();
    return e.flags = this.flags, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.startLoc, e.endLoc = this.endLoc, e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.slice(), e.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.slice(), e.commentsLen = this.commentsLen, e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value = this.value, e.start = this.start, e.end = this.end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.context = this.context.slice(), e.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors, e.tokensLength = this.tokensLength, e;
  }
}
var qN = function(e) {
  return e >= 48 && e <= 57;
};
const my = {
  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
}, uu = {
  bin: (r) => r === 48 || r === 49,
  oct: (r) => r >= 48 && r <= 55,
  dec: (r) => r >= 48 && r <= 57,
  hex: (r) => r >= 48 && r <= 57 || r >= 65 && r <= 70 || r >= 97 && r <= 102
};
function gy(r, e, t, s, i, n) {
  const a = t, o = s, u = i;
  let l = "", c = null, f = t;
  const {
    length: p
  } = e;
  for (; ; ) {
    if (t >= p) {
      n.unterminated(a, o, u), l += e.slice(f, t);
      break;
    }
    const h = e.charCodeAt(t);
    if (HN(r, h, e, t)) {
      l += e.slice(f, t);
      break;
    }
    if (h === 92) {
      l += e.slice(f, t);
      const m = WN(e, t, s, i, r === "template", n);
      m.ch === null && !c ? c = {
        pos: t,
        lineStart: s,
        curLine: i
      } : l += m.ch, {
        pos: t,
        lineStart: s,
        curLine: i
      } = m, f = t;
    } else h === 8232 || h === 8233 ? (++t, ++i, s = t) : h === 10 || h === 13 ? r === "template" ? (l += e.slice(f, t) + `
`, ++t, h === 13 && e.charCodeAt(t) === 10 && ++t, ++i, f = s = t) : n.unterminated(a, o, u) : ++t;
  }
  return {
    pos: t,
    str: l,
    firstInvalidLoc: c,
    lineStart: s,
    curLine: i,
    containsInvalid: !!c
  };
}
function HN(r, e, t, s) {
  return r === "template" ? e === 96 || e === 36 && t.charCodeAt(s + 1) === 123 : e === (r === "double" ? 34 : 39);
}
function WN(r, e, t, s, i, n) {
  const a = !i;
  e++;
  const o = (l) => ({
    pos: e,
    ch: l,
    lineStart: t,
    curLine: s
  }), u = r.charCodeAt(e++);
  switch (u) {
    case 110:
      return o(`
`);
    case 114:
      return o("\r");
    case 120: {
      let l;
      return {
        code: l,
        pos: e
      } = Fp(r, e, t, s, 2, !1, a, n), o(l === null ? null : String.fromCharCode(l));
    }
    case 117: {
      let l;
      return {
        code: l,
        pos: e
      } = hS(r, e, t, s, a, n), o(l === null ? null : String.fromCodePoint(l));
    }
    case 116:
      return o("	");
    case 98:
      return o("\b");
    case 118:
      return o("\v");
    case 102:
      return o("\f");
    case 13:
      r.charCodeAt(e) === 10 && ++e;
    case 10:
      t = e, ++s;
    case 8232:
    case 8233:
      return o("");
    case 56:
    case 57:
      if (i)
        return o(null);
      n.strictNumericEscape(e - 1, t, s);
    default:
      if (u >= 48 && u <= 55) {
        const l = e - 1;
        let f = r.slice(l, e + 2).match(/^[0-7]+/)[0], p = parseInt(f, 8);
        p > 255 && (f = f.slice(0, -1), p = parseInt(f, 8)), e += f.length - 1;
        const h = r.charCodeAt(e);
        if (f !== "0" || h === 56 || h === 57) {
          if (i)
            return o(null);
          n.strictNumericEscape(l, t, s);
        }
        return o(String.fromCharCode(p));
      }
      return o(String.fromCharCode(u));
  }
}
function Fp(r, e, t, s, i, n, a, o) {
  const u = e;
  let l;
  return {
    n: l,
    pos: e
  } = pS(r, e, t, s, 16, i, n, !1, o, !a), l === null && (a ? o.invalidEscapeSequence(u, t, s) : e = u - 1), {
    code: l,
    pos: e
  };
}
function pS(r, e, t, s, i, n, a, o, u, l) {
  const c = e, f = i === 16 ? my.hex : my.decBinOct, p = i === 16 ? uu.hex : i === 10 ? uu.dec : i === 8 ? uu.oct : uu.bin;
  let h = !1, m = 0;
  for (let d = 0, y = n ?? 1 / 0; d < y; ++d) {
    const S = r.charCodeAt(e);
    let E;
    if (S === 95 && o !== "bail") {
      const g = r.charCodeAt(e - 1), b = r.charCodeAt(e + 1);
      if (o) {
        if (Number.isNaN(b) || !p(b) || f.has(g) || f.has(b)) {
          if (l) return {
            n: null,
            pos: e
          };
          u.unexpectedNumericSeparator(e, t, s);
        }
      } else {
        if (l) return {
          n: null,
          pos: e
        };
        u.numericSeparatorInEscapeSequence(e, t, s);
      }
      ++e;
      continue;
    }
    if (S >= 97 ? E = S - 97 + 10 : S >= 65 ? E = S - 65 + 10 : qN(S) ? E = S - 48 : E = 1 / 0, E >= i) {
      if (E <= 9 && l)
        return {
          n: null,
          pos: e
        };
      if (E <= 9 && u.invalidDigit(e, t, s, i))
        E = 0;
      else if (a)
        E = 0, h = !0;
      else
        break;
    }
    ++e, m = m * i + E;
  }
  return e === c || n != null && e - c !== n || h ? {
    n: null,
    pos: e
  } : {
    n: m,
    pos: e
  };
}
function hS(r, e, t, s, i, n) {
  const a = r.charCodeAt(e);
  let o;
  if (a === 123) {
    if (++e, {
      code: o,
      pos: e
    } = Fp(r, e, t, s, r.indexOf("}", e) - e, !0, i, n), ++e, o !== null && o > 1114111)
      if (i)
        n.invalidCodePoint(e, t, s);
      else
        return {
          code: null,
          pos: e
        };
  } else
    ({
      code: o,
      pos: e
    } = Fp(r, e, t, s, 4, !1, i, n));
  return {
    code: o,
    pos: e
  };
}
function ba(r, e, t) {
  return new ri(t, r - e, r);
}
const zN = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
class Vs {
  constructor(e) {
    this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, this.loc = new vl(e.startLoc, e.endLoc);
  }
}
class GN extends UN {
  constructor(e, t) {
    super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
      invalidDigit: (s, i, n, a) => this.options.errorRecovery ? (this.raise(O.InvalidDigit, ba(s, i, n), {
        radix: a
      }), !0) : !1,
      numericSeparatorInEscapeSequence: this.errorBuilder(O.NumericSeparatorInEscapeSequence),
      unexpectedNumericSeparator: this.errorBuilder(O.UnexpectedNumericSeparator)
    }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
      invalidEscapeSequence: this.errorBuilder(O.InvalidEscapeSequence),
      invalidCodePoint: this.errorBuilder(O.InvalidCodePoint)
    }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: (s, i, n) => {
        this.recordStrictModeErrors(O.StrictNumericEscape, ba(s, i, n));
      },
      unterminated: (s, i, n) => {
        throw this.raise(O.UnterminatedString, ba(s - 1, i, n));
      }
    }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: this.errorBuilder(O.StrictNumericEscape),
      unterminated: (s, i, n) => {
        throw this.raise(O.UnterminatedTemplate, ba(s, i, n));
      }
    }), this.state = new hm(), this.state.init(e), this.input = t, this.length = t.length, this.comments = [], this.isLookahead = !1;
  }
  pushToken(e) {
    this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
  }
  next() {
    this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Vs(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
  }
  eat(e) {
    return this.match(e) ? (this.next(), !0) : !1;
  }
  match(e) {
    return this.state.type === e;
  }
  createLookaheadState(e) {
    return {
      pos: e.pos,
      value: null,
      type: e.type,
      start: e.start,
      end: e.end,
      context: [this.curContext()],
      inType: e.inType,
      startLoc: e.startLoc,
      lastTokEndLoc: e.lastTokEndLoc,
      curLine: e.curLine,
      lineStart: e.lineStart,
      curPosition: e.curPosition
    };
  }
  lookahead() {
    const e = this.state;
    this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
    const t = this.state;
    return this.state = e, t;
  }
  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos);
  }
  nextTokenStartSince(e) {
    return Lf.lastIndex = e, Lf.test(this.input) ? Lf.lastIndex : e;
  }
  lookaheadCharCode() {
    return this.input.charCodeAt(this.nextTokenStart());
  }
  nextTokenInLineStart() {
    return this.nextTokenInLineStartSince(this.state.pos);
  }
  nextTokenInLineStartSince(e) {
    return Ru.lastIndex = e, Ru.test(this.input) ? Ru.lastIndex : e;
  }
  lookaheadInLineCharCode() {
    return this.input.charCodeAt(this.nextTokenInLineStart());
  }
  codePointAtPos(e) {
    let t = this.input.charCodeAt(e);
    if ((t & 64512) === 55296 && ++e < this.input.length) {
      const s = this.input.charCodeAt(e);
      (s & 64512) === 56320 && (t = 65536 + ((t & 1023) << 10) + (s & 1023));
    }
    return t;
  }
  setStrict(e) {
    this.state.strict = e, e && (this.state.strictErrors.forEach(([t, s]) => this.raise(t, s)), this.state.strictErrors.clear());
  }
  curContext() {
    return this.state.context[this.state.context.length - 1];
  }
  nextToken() {
    if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
      this.finishToken(139);
      return;
    }
    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
  }
  skipBlockComment(e) {
    let t;
    this.isLookahead || (t = this.state.curPosition());
    const s = this.state.pos, i = this.input.indexOf(e, s + 2);
    if (i === -1)
      throw this.raise(O.UnterminatedComment, this.state.curPosition());
    for (this.state.pos = i + e.length, ou.lastIndex = s + 2; ou.test(this.input) && ou.lastIndex <= i; )
      ++this.state.curLine, this.state.lineStart = ou.lastIndex;
    if (this.isLookahead) return;
    const n = {
      type: "CommentBlock",
      value: this.input.slice(s + 2, i),
      start: s,
      end: i + e.length,
      loc: new vl(t, this.state.curPosition())
    };
    return this.options.tokens && this.pushToken(n), n;
  }
  skipLineComment(e) {
    const t = this.state.pos;
    let s;
    this.isLookahead || (s = this.state.curPosition());
    let i = this.input.charCodeAt(this.state.pos += e);
    if (this.state.pos < this.length)
      for (; !qa(i) && ++this.state.pos < this.length; )
        i = this.input.charCodeAt(this.state.pos);
    if (this.isLookahead) return;
    const n = this.state.pos, o = {
      type: "CommentLine",
      value: this.input.slice(t + e, n),
      start: t,
      end: n,
      loc: new vl(s, this.state.curPosition())
    };
    return this.options.tokens && this.pushToken(o), o;
  }
  skipSpace() {
    const e = this.state.pos, t = [];
    e: for (; this.state.pos < this.length; ) {
      const s = this.input.charCodeAt(this.state.pos);
      switch (s) {
        case 32:
        case 160:
        case 9:
          ++this.state.pos;
          break;
        case 13:
          this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
          break;
        case 47:
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42: {
              const i = this.skipBlockComment("*/");
              i !== void 0 && (this.addComment(i), this.options.attachComment && t.push(i));
              break;
            }
            case 47: {
              const i = this.skipLineComment(2);
              i !== void 0 && (this.addComment(i), this.options.attachComment && t.push(i));
              break;
            }
            default:
              break e;
          }
          break;
        default:
          if (jN(s))
            ++this.state.pos;
          else if (s === 45 && !this.inModule && this.options.annexB) {
            const i = this.state.pos;
            if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
              const n = this.skipLineComment(3);
              n !== void 0 && (this.addComment(n), this.options.attachComment && t.push(n));
            } else
              break e;
          } else if (s === 60 && !this.inModule && this.options.annexB) {
            const i = this.state.pos;
            if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
              const n = this.skipLineComment(4);
              n !== void 0 && (this.addComment(n), this.options.attachComment && t.push(n));
            } else
              break e;
          } else
            break e;
      }
    }
    if (t.length > 0) {
      const s = this.state.pos, i = {
        start: e,
        end: s,
        comments: t,
        leadingNode: null,
        trailingNode: null,
        containingNode: null
      };
      this.state.commentStack.push(i);
    }
  }
  finishToken(e, t) {
    this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
    const s = this.state.type;
    this.state.type = e, this.state.value = t, this.isLookahead || this.updateContext(s);
  }
  replaceToken(e) {
    this.state.type = e, this.updateContext();
  }
  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter())
      return;
    const e = this.state.pos + 1, t = this.codePointAtPos(e);
    if (t >= 48 && t <= 57)
      throw this.raise(O.UnexpectedDigitAfterHash, this.state.curPosition());
    if (t === 123 || t === 91 && this.hasPlugin("recordAndTuple")) {
      if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
        throw this.raise(t === 123 ? O.RecordExpressionHashIncorrectStartSyntaxType : O.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
      this.state.pos += 2, t === 123 ? this.finishToken(7) : this.finishToken(1);
    } else ms(t) ? (++this.state.pos, this.finishToken(138, this.readWord1(t))) : t === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
  }
  readToken_dot() {
    const e = this.input.charCodeAt(this.state.pos + 1);
    if (e >= 48 && e <= 57) {
      this.readNumber(!0);
      return;
    }
    e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
  }
  readToken_slash() {
    this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
  }
  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2) return !1;
    let e = this.input.charCodeAt(this.state.pos + 1);
    if (e !== 33) return !1;
    const t = this.state.pos;
    for (this.state.pos += 1; !qa(e) && ++this.state.pos < this.length; )
      e = this.input.charCodeAt(this.state.pos);
    const s = this.input.slice(t + 2, this.state.pos);
    return this.finishToken(28, s), !0;
  }
  readToken_mult_modulo(e) {
    let t = e === 42 ? 55 : 54, s = 1, i = this.input.charCodeAt(this.state.pos + 1);
    e === 42 && i === 42 && (s++, i = this.input.charCodeAt(this.state.pos + 2), t = 57), i === 61 && !this.state.inType && (s++, t = e === 37 ? 33 : 30), this.finishOp(t, s);
  }
  readToken_pipe_amp(e) {
    const t = this.input.charCodeAt(this.state.pos + 1);
    if (t === e) {
      this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
      return;
    }
    if (e === 124) {
      if (t === 62) {
        this.finishOp(39, 2);
        return;
      }
      if (this.hasPlugin("recordAndTuple") && t === 125) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
          throw this.raise(O.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
        this.state.pos += 2, this.finishToken(9);
        return;
      }
      if (this.hasPlugin("recordAndTuple") && t === 93) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
          throw this.raise(O.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
        this.state.pos += 2, this.finishToken(4);
        return;
      }
    }
    if (t === 61) {
      this.finishOp(30, 2);
      return;
    }
    this.finishOp(e === 124 ? 43 : 45, 1);
  }
  readToken_caret() {
    const e = this.input.charCodeAt(this.state.pos + 1);
    e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
      proposal: "hack",
      topicToken: "^^"
    }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
  }
  readToken_atSign() {
    this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
      proposal: "hack",
      topicToken: "@@"
    }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
  }
  readToken_plus_min(e) {
    const t = this.input.charCodeAt(this.state.pos + 1);
    if (t === e) {
      this.finishOp(34, 2);
      return;
    }
    t === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
  }
  readToken_lt() {
    const {
      pos: e
    } = this.state, t = this.input.charCodeAt(e + 1);
    if (t === 60) {
      if (this.input.charCodeAt(e + 2) === 61) {
        this.finishOp(30, 3);
        return;
      }
      this.finishOp(51, 2);
      return;
    }
    if (t === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(47, 1);
  }
  readToken_gt() {
    const {
      pos: e
    } = this.state, t = this.input.charCodeAt(e + 1);
    if (t === 62) {
      const s = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(e + s) === 61) {
        this.finishOp(30, s + 1);
        return;
      }
      this.finishOp(52, s);
      return;
    }
    if (t === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(48, 1);
  }
  readToken_eq_excl(e) {
    const t = this.input.charCodeAt(this.state.pos + 1);
    if (t === 61) {
      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
      return;
    }
    if (e === 61 && t === 62) {
      this.state.pos += 2, this.finishToken(19);
      return;
    }
    this.finishOp(e === 61 ? 29 : 35, 1);
  }
  readToken_question() {
    const e = this.input.charCodeAt(this.state.pos + 1), t = this.input.charCodeAt(this.state.pos + 2);
    e === 63 ? t === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(t >= 48 && t <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
  }
  getTokenFromCode(e) {
    switch (e) {
      case 46:
        this.readToken_dot();
        return;
      case 40:
        ++this.state.pos, this.finishToken(10);
        return;
      case 41:
        ++this.state.pos, this.finishToken(11);
        return;
      case 59:
        ++this.state.pos, this.finishToken(13);
        return;
      case 44:
        ++this.state.pos, this.finishToken(12);
        return;
      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(O.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(2);
        } else
          ++this.state.pos, this.finishToken(0);
        return;
      case 93:
        ++this.state.pos, this.finishToken(3);
        return;
      case 123:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(O.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(6);
        } else
          ++this.state.pos, this.finishToken(5);
        return;
      case 125:
        ++this.state.pos, this.finishToken(8);
        return;
      case 58:
        this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
        return;
      case 63:
        this.readToken_question();
        return;
      case 96:
        this.readTemplateToken();
        return;
      case 48: {
        const t = this.input.charCodeAt(this.state.pos + 1);
        if (t === 120 || t === 88) {
          this.readRadixNumber(16);
          return;
        }
        if (t === 111 || t === 79) {
          this.readRadixNumber(8);
          return;
        }
        if (t === 98 || t === 66) {
          this.readRadixNumber(2);
          return;
        }
      }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        this.readNumber(!1);
        return;
      case 34:
      case 39:
        this.readString(e);
        return;
      case 47:
        this.readToken_slash();
        return;
      case 37:
      case 42:
        this.readToken_mult_modulo(e);
        return;
      case 124:
      case 38:
        this.readToken_pipe_amp(e);
        return;
      case 94:
        this.readToken_caret();
        return;
      case 43:
      case 45:
        this.readToken_plus_min(e);
        return;
      case 60:
        this.readToken_lt();
        return;
      case 62:
        this.readToken_gt();
        return;
      case 61:
      case 33:
        this.readToken_eq_excl(e);
        return;
      case 126:
        this.finishOp(36, 1);
        return;
      case 64:
        this.readToken_atSign();
        return;
      case 35:
        this.readToken_numberSign();
        return;
      case 92:
        this.readWord();
        return;
      default:
        if (ms(e)) {
          this.readWord(e);
          return;
        }
    }
    throw this.raise(O.InvalidOrUnexpectedToken, this.state.curPosition(), {
      unexpected: String.fromCodePoint(e)
    });
  }
  finishOp(e, t) {
    const s = this.input.slice(this.state.pos, this.state.pos + t);
    this.state.pos += t, this.finishToken(e, s);
  }
  readRegexp() {
    const e = this.state.startLoc, t = this.state.start + 1;
    let s, i, {
      pos: n
    } = this.state;
    for (; ; ++n) {
      if (n >= this.length)
        throw this.raise(O.UnterminatedRegExp, Ht(e, 1));
      const l = this.input.charCodeAt(n);
      if (qa(l))
        throw this.raise(O.UnterminatedRegExp, Ht(e, 1));
      if (s)
        s = !1;
      else {
        if (l === 91)
          i = !0;
        else if (l === 93 && i)
          i = !1;
        else if (l === 47 && !i)
          break;
        s = l === 92;
      }
    }
    const a = this.input.slice(t, n);
    ++n;
    let o = "";
    const u = () => Ht(e, n + 2 - t);
    for (; n < this.length; ) {
      const l = this.codePointAtPos(n), c = String.fromCharCode(l);
      if (zN.has(l))
        l === 118 ? o.includes("u") && this.raise(O.IncompatibleRegExpUVFlags, u()) : l === 117 && o.includes("v") && this.raise(O.IncompatibleRegExpUVFlags, u()), o.includes(c) && this.raise(O.DuplicateRegExpFlags, u());
      else if (Sn(l) || l === 92)
        this.raise(O.MalformedRegExpFlags, u());
      else
        break;
      ++n, o += c;
    }
    this.state.pos = n, this.finishToken(137, {
      pattern: a,
      flags: o
    });
  }
  readInt(e, t, s = !1, i = !0) {
    const {
      n,
      pos: a
    } = pS(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, t, s, i, this.errorHandlers_readInt, !1);
    return this.state.pos = a, n;
  }
  readRadixNumber(e) {
    const t = this.state.curPosition();
    let s = !1;
    this.state.pos += 2;
    const i = this.readInt(e);
    i == null && this.raise(O.InvalidDigit, Ht(t, 2), {
      radix: e
    });
    const n = this.input.charCodeAt(this.state.pos);
    if (n === 110)
      ++this.state.pos, s = !0;
    else if (n === 109)
      throw this.raise(O.InvalidDecimal, t);
    if (ms(this.codePointAtPos(this.state.pos)))
      throw this.raise(O.NumberIdentifier, this.state.curPosition());
    if (s) {
      const a = this.input.slice(t.index, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(135, a);
      return;
    }
    this.finishToken(134, i);
  }
  readNumber(e) {
    const t = this.state.pos, s = this.state.curPosition();
    let i = !1, n = !1, a = !1, o = !1, u = !1;
    !e && this.readInt(10) === null && this.raise(O.InvalidNumber, this.state.curPosition());
    const l = this.state.pos - t >= 2 && this.input.charCodeAt(t) === 48;
    if (l) {
      const h = this.input.slice(t, this.state.pos);
      if (this.recordStrictModeErrors(O.StrictOctalLiteral, s), !this.state.strict) {
        const m = h.indexOf("_");
        m > 0 && this.raise(O.ZeroDigitNumericSeparator, Ht(s, m));
      }
      u = l && !/[89]/.test(h);
    }
    let c = this.input.charCodeAt(this.state.pos);
    if (c === 46 && !u && (++this.state.pos, this.readInt(10), i = !0, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) && !u && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(O.InvalidOrMissingExponent, s), i = !0, o = !0, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((i || l) && this.raise(O.InvalidBigIntLiteral, s), ++this.state.pos, n = !0), c === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (o || l) && this.raise(O.InvalidDecimal, s), ++this.state.pos, a = !0), ms(this.codePointAtPos(this.state.pos)))
      throw this.raise(O.NumberIdentifier, this.state.curPosition());
    const f = this.input.slice(t, this.state.pos).replace(/[_mn]/g, "");
    if (n) {
      this.finishToken(135, f);
      return;
    }
    if (a) {
      this.finishToken(136, f);
      return;
    }
    const p = u ? parseInt(f, 8) : parseFloat(f);
    this.finishToken(134, p);
  }
  readCodePoint(e) {
    const {
      code: t,
      pos: s
    } = hS(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
    return this.state.pos = s, t;
  }
  readString(e) {
    const {
      str: t,
      pos: s,
      curLine: i,
      lineStart: n
    } = gy(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
    this.state.pos = s + 1, this.state.lineStart = n, this.state.curLine = i, this.finishToken(133, t);
  }
  readTemplateContinuation() {
    this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
  }
  readTemplateToken() {
    const e = this.input[this.state.pos], {
      str: t,
      firstInvalidLoc: s,
      pos: i,
      curLine: n,
      lineStart: a
    } = gy("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
    this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = n, s && (this.state.firstInvalidTemplateEscapePos = new ri(s.curLine, s.pos - s.lineStart, s.pos)), this.input.codePointAt(i) === 96 ? this.finishToken(24, s ? null : e + t + "`") : (this.state.pos++, this.finishToken(25, s ? null : e + t + "${"));
  }
  recordStrictModeErrors(e, t) {
    const s = t.index;
    this.state.strict && !this.state.strictErrors.has(s) ? this.raise(e, t) : this.state.strictErrors.set(s, [e, t]);
  }
  readWord1(e) {
    this.state.containsEsc = !1;
    let t = "";
    const s = this.state.pos;
    let i = this.state.pos;
    for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
      const n = this.codePointAtPos(this.state.pos);
      if (Sn(n))
        this.state.pos += n <= 65535 ? 1 : 2;
      else if (n === 92) {
        this.state.containsEsc = !0, t += this.input.slice(i, this.state.pos);
        const a = this.state.curPosition(), o = this.state.pos === s ? ms : Sn;
        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          this.raise(O.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
          continue;
        }
        ++this.state.pos;
        const u = this.readCodePoint(!0);
        u !== null && (o(u) || this.raise(O.EscapedCharNotAnIdentifier, a), t += String.fromCodePoint(u)), i = this.state.pos;
      } else
        break;
    }
    return t + this.input.slice(i, this.state.pos);
  }
  readWord(e) {
    const t = this.readWord1(e), s = rm.get(t);
    s !== void 0 ? this.finishToken(s, si(s)) : this.finishToken(132, t);
  }
  checkKeywordEscapes() {
    const {
      type: e
    } = this.state;
    um(e) && this.state.containsEsc && this.raise(O.InvalidEscapedReservedWord, this.state.startLoc, {
      reservedWord: si(e)
    });
  }
  raise(e, t, s = {}) {
    const i = t instanceof ri ? t : t.loc.start, n = e(i, s);
    if (!this.options.errorRecovery) throw n;
    return this.isLookahead || this.state.errors.push(n), n;
  }
  raiseOverwrite(e, t, s = {}) {
    const i = t instanceof ri ? t : t.loc.start, n = i.index, a = this.state.errors;
    for (let o = a.length - 1; o >= 0; o--) {
      const u = a[o];
      if (u.loc.index === n)
        return a[o] = e(i, s);
      if (u.loc.index < n) break;
    }
    return this.raise(e, t, s);
  }
  updateContext(e) {
  }
  unexpected(e, t) {
    throw this.raise(O.UnexpectedToken, e ?? this.state.startLoc, {
      expected: t ? si(t) : null
    });
  }
  expectPlugin(e, t) {
    if (this.hasPlugin(e))
      return !0;
    throw this.raise(O.MissingPlugin, t ?? this.state.startLoc, {
      missingPlugin: [e]
    });
  }
  expectOnePlugin(e) {
    if (!e.some((t) => this.hasPlugin(t)))
      throw this.raise(O.MissingOneOfPlugins, this.state.startLoc, {
        missingPlugin: e
      });
  }
  errorBuilder(e) {
    return (t, s, i) => {
      this.raise(e, ba(t, s, i));
    };
  }
}
class KN {
  constructor() {
    this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
  }
}
class XN {
  constructor(e) {
    this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  enter() {
    this.stack.push(new KN());
  }
  exit() {
    const e = this.stack.pop(), t = this.current();
    for (const [s, i] of Array.from(e.undefinedPrivateNames))
      t ? t.undefinedPrivateNames.has(s) || t.undefinedPrivateNames.set(s, i) : this.parser.raise(O.InvalidPrivateFieldResolution, i, {
        identifierName: s
      });
  }
  declarePrivateName(e, t, s) {
    const {
      privateNames: i,
      loneAccessors: n,
      undefinedPrivateNames: a
    } = this.current();
    let o = i.has(e);
    if (t & 3) {
      const u = o && n.get(e);
      if (u) {
        const l = u & 4, c = t & 4, f = u & 3, p = t & 3;
        o = f === p || l !== c, o || n.delete(e);
      } else o || n.set(e, t);
    }
    o && this.parser.raise(O.PrivateNameRedeclaration, s, {
      identifierName: e
    }), i.add(e), a.delete(e);
  }
  usePrivateName(e, t) {
    let s;
    for (s of this.stack)
      if (s.privateNames.has(e)) return;
    s ? s.undefinedPrivateNames.set(e, t) : this.parser.raise(O.InvalidPrivateFieldResolution, t, {
      identifierName: e
    });
  }
}
class Mc {
  constructor(e = 0) {
    this.type = e;
  }
  canBeArrowParameterDeclaration() {
    return this.type === 2 || this.type === 1;
  }
  isCertainlyParameterDeclaration() {
    return this.type === 3;
  }
}
class dS extends Mc {
  constructor(e) {
    super(e), this.declarationErrors = /* @__PURE__ */ new Map();
  }
  recordDeclarationError(e, t) {
    const s = t.index;
    this.declarationErrors.set(s, [e, t]);
  }
  clearDeclarationError(e) {
    this.declarationErrors.delete(e);
  }
  iterateErrors(e) {
    this.declarationErrors.forEach(e);
  }
}
class JN {
  constructor(e) {
    this.parser = void 0, this.stack = [new Mc()], this.parser = e;
  }
  enter(e) {
    this.stack.push(e);
  }
  exit() {
    this.stack.pop();
  }
  recordParameterInitializerError(e, t) {
    const s = t.loc.start, {
      stack: i
    } = this;
    let n = i.length - 1, a = i[n];
    for (; !a.isCertainlyParameterDeclaration(); ) {
      if (a.canBeArrowParameterDeclaration())
        a.recordDeclarationError(e, s);
      else
        return;
      a = i[--n];
    }
    this.parser.raise(e, s);
  }
  recordArrowParameterBindingError(e, t) {
    const {
      stack: s
    } = this, i = s[s.length - 1], n = t.loc.start;
    if (i.isCertainlyParameterDeclaration())
      this.parser.raise(e, n);
    else if (i.canBeArrowParameterDeclaration())
      i.recordDeclarationError(e, n);
    else
      return;
  }
  recordAsyncArrowParametersError(e) {
    const {
      stack: t
    } = this;
    let s = t.length - 1, i = t[s];
    for (; i.canBeArrowParameterDeclaration(); )
      i.type === 2 && i.recordDeclarationError(O.AwaitBindingIdentifier, e), i = t[--s];
  }
  validateAsPattern() {
    const {
      stack: e
    } = this, t = e[e.length - 1];
    t.canBeArrowParameterDeclaration() && t.iterateErrors(([s, i]) => {
      this.parser.raise(s, i);
      let n = e.length - 2, a = e[n];
      for (; a.canBeArrowParameterDeclaration(); )
        a.clearDeclarationError(i.index), a = e[--n];
    });
  }
}
function YN() {
  return new Mc(3);
}
function QN() {
  return new dS(1);
}
function ZN() {
  return new dS(2);
}
function mS() {
  return new Mc();
}
class eO {
  constructor() {
    this.stacks = [];
  }
  enter(e) {
    this.stacks.push(e);
  }
  exit() {
    this.stacks.pop();
  }
  currentFlags() {
    return this.stacks[this.stacks.length - 1];
  }
  get hasAwait() {
    return (this.currentFlags() & 2) > 0;
  }
  get hasYield() {
    return (this.currentFlags() & 1) > 0;
  }
  get hasReturn() {
    return (this.currentFlags() & 4) > 0;
  }
  get hasIn() {
    return (this.currentFlags() & 8) > 0;
  }
}
function $u(r, e) {
  return (r ? 2 : 0) | (e ? 1 : 0);
}
class tO extends GN {
  addExtra(e, t, s, i = !0) {
    if (!e) return;
    const n = e.extra = e.extra || {};
    i ? n[t] = s : Object.defineProperty(n, t, {
      enumerable: i,
      value: s
    });
  }
  isContextual(e) {
    return this.state.type === e && !this.state.containsEsc;
  }
  isUnparsedContextual(e, t) {
    const s = e + t.length;
    if (this.input.slice(e, s) === t) {
      const i = this.input.charCodeAt(s);
      return !(Sn(i) || (i & 64512) === 55296);
    }
    return !1;
  }
  isLookaheadContextual(e) {
    const t = this.nextTokenStart();
    return this.isUnparsedContextual(t, e);
  }
  eatContextual(e) {
    return this.isContextual(e) ? (this.next(), !0) : !1;
  }
  expectContextual(e, t) {
    if (!this.eatContextual(e)) {
      if (t != null)
        throw this.raise(t, this.state.startLoc);
      this.unexpected(null, e);
    }
  }
  canInsertSemicolon() {
    return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
  }
  hasPrecedingLineBreak() {
    return fS.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
  }
  hasFollowingLineBreak() {
    return dy.lastIndex = this.state.end, dy.test(this.input);
  }
  isLineTerminator() {
    return this.eat(13) || this.canInsertSemicolon();
  }
  semicolon(e = !0) {
    (e ? this.isLineTerminator() : this.eat(13)) || this.raise(O.MissingSemicolon, this.state.lastTokEndLoc);
  }
  expect(e, t) {
    this.eat(e) || this.unexpected(t, e);
  }
  tryParse(e, t = this.state.clone()) {
    const s = {
      node: null
    };
    try {
      const i = e((n = null) => {
        throw s.node = n, s;
      });
      if (this.state.errors.length > t.errors.length) {
        const n = this.state;
        return this.state = t, this.state.tokensLength = n.tokensLength, {
          node: i,
          error: n.errors[t.errors.length],
          thrown: !1,
          aborted: !1,
          failState: n
        };
      }
      return {
        node: i,
        error: null,
        thrown: !1,
        aborted: !1,
        failState: null
      };
    } catch (i) {
      const n = this.state;
      if (this.state = t, i instanceof SyntaxError)
        return {
          node: null,
          error: i,
          thrown: !0,
          aborted: !1,
          failState: n
        };
      if (i === s)
        return {
          node: s.node,
          error: null,
          thrown: !1,
          aborted: !0,
          failState: n
        };
      throw i;
    }
  }
  checkExpressionErrors(e, t) {
    if (!e) return !1;
    const {
      shorthandAssignLoc: s,
      doubleProtoLoc: i,
      privateKeyLoc: n,
      optionalParametersLoc: a
    } = e, o = !!s || !!i || !!a || !!n;
    if (!t)
      return o;
    s != null && this.raise(O.InvalidCoverInitializedName, s), i != null && this.raise(O.DuplicateProto, i), n != null && this.raise(O.UnexpectedPrivateField, n), a != null && this.unexpected(a);
  }
  isLiteralPropertyName() {
    return sS(this.state.type);
  }
  isPrivateName(e) {
    return e.type === "PrivateName";
  }
  getPrivateNameSV(e) {
    return e.id.name;
  }
  hasPropertyAsPrivateName(e) {
    return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
  }
  isObjectProperty(e) {
    return e.type === "ObjectProperty";
  }
  isObjectMethod(e) {
    return e.type === "ObjectMethod";
  }
  initializeScopes(e = this.options.sourceType === "module") {
    const t = this.state.labels;
    this.state.labels = [];
    const s = this.exportedIdentifiers;
    this.exportedIdentifiers = /* @__PURE__ */ new Set();
    const i = this.inModule;
    this.inModule = e;
    const n = this.scope, a = this.getScopeHandler();
    this.scope = new a(this, e);
    const o = this.prodParam;
    this.prodParam = new eO();
    const u = this.classScope;
    this.classScope = new XN(this);
    const l = this.expressionScope;
    return this.expressionScope = new JN(this), () => {
      this.state.labels = t, this.exportedIdentifiers = s, this.inModule = i, this.scope = n, this.prodParam = o, this.classScope = u, this.expressionScope = l;
    };
  }
  enterInitialScopes() {
    let e = 0;
    this.inModule && (e |= 2), this.scope.enter(1), this.prodParam.enter(e);
  }
  checkDestructuringPrivate(e) {
    const {
      privateKeyLoc: t
    } = e;
    t !== null && this.expectPlugin("destructuringPrivate", t);
  }
}
class Fu {
  constructor() {
    this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
  }
}
let Sl = class {
  constructor(e, t, s) {
    this.type = "", this.start = t, this.end = 0, this.loc = new vl(s), e != null && e.options.ranges && (this.range = [t, 0]), e != null && e.filename && (this.loc.filename = e.filename);
  }
};
const dm = Sl.prototype;
dm.__clone = function() {
  const r = new Sl(void 0, this.start, this.loc.start), e = Object.keys(this);
  for (let t = 0, s = e.length; t < s; t++) {
    const i = e[t];
    i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (r[i] = this[i]);
  }
  return r;
};
function rO(r) {
  return Ss(r);
}
function Ss(r) {
  const {
    type: e,
    start: t,
    end: s,
    loc: i,
    range: n,
    extra: a,
    name: o
  } = r, u = Object.create(dm);
  return u.type = e, u.start = t, u.end = s, u.loc = i, u.range = n, u.extra = a, u.name = o, e === "Placeholder" && (u.expectedNode = r.expectedNode), u;
}
function sO(r) {
  const {
    type: e,
    start: t,
    end: s,
    loc: i,
    range: n,
    extra: a
  } = r;
  if (e === "Placeholder")
    return rO(r);
  const o = Object.create(dm);
  return o.type = e, o.start = t, o.end = s, o.loc = i, o.range = n, r.raw !== void 0 ? o.raw = r.raw : o.extra = a, o.value = r.value, o;
}
class iO extends tO {
  startNode() {
    const e = this.state.startLoc;
    return new Sl(this, e.index, e);
  }
  startNodeAt(e) {
    return new Sl(this, e.index, e);
  }
  startNodeAtNode(e) {
    return this.startNodeAt(e.loc.start);
  }
  finishNode(e, t) {
    return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
  }
  finishNodeAt(e, t, s) {
    return e.type = t, e.end = s.index, e.loc.end = s, this.options.ranges && (e.range[1] = s.index), this.options.attachComment && this.processComment(e), e;
  }
  resetStartLocation(e, t) {
    e.start = t.index, e.loc.start = t, this.options.ranges && (e.range[0] = t.index);
  }
  resetEndLocation(e, t = this.state.lastTokEndLoc) {
    e.end = t.index, e.loc.end = t, this.options.ranges && (e.range[1] = t.index);
  }
  resetStartLocationFromNode(e, t) {
    this.resetStartLocation(e, t.loc.start);
  }
}
const nO = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), de = gs`flow`({
  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
  AssignReservedType: ({
    reservedType: r
  }) => `Cannot overwrite reserved type ${r}.`,
  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
  EnumBooleanMemberNotInitialized: ({
    memberName: r,
    enumName: e
  }) => `Boolean enum members need to be initialized. Use either \`${r} = true,\` or \`${r} = false,\` in enum \`${e}\`.`,
  EnumDuplicateMemberName: ({
    memberName: r,
    enumName: e
  }) => `Enum member names need to be unique, but the name \`${r}\` has already been used before in enum \`${e}\`.`,
  EnumInconsistentMemberValues: ({
    enumName: r
  }) => `Enum \`${r}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
  EnumInvalidExplicitType: ({
    invalidEnumType: r,
    enumName: e
  }) => `Enum type \`${r}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`,
  EnumInvalidExplicitTypeUnknownSupplied: ({
    enumName: r
  }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${r}\`.`,
  EnumInvalidMemberInitializerPrimaryType: ({
    enumName: r,
    memberName: e,
    explicitType: t
  }) => `Enum \`${r}\` has type \`${t}\`, so the initializer of \`${e}\` needs to be a ${t} literal.`,
  EnumInvalidMemberInitializerSymbolType: ({
    enumName: r,
    memberName: e
  }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${r}\`.`,
  EnumInvalidMemberInitializerUnknownType: ({
    enumName: r,
    memberName: e
  }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${r}\`.`,
  EnumInvalidMemberName: ({
    enumName: r,
    memberName: e,
    suggestion: t
  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${t}\`, in enum \`${r}\`.`,
  EnumNumberMemberNotInitialized: ({
    enumName: r,
    memberName: e
  }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${r}\`.`,
  EnumStringMemberInconsistentlyInitialized: ({
    enumName: r
  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${r}\`.`,
  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
  ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
  InexactVariance: "Explicit inexact syntax cannot have variance.",
  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
  PatternIsOptional: Object.assign({
    message: "A binding pattern parameter cannot be optional in an implementation signature."
  }, {
    reasonCode: "OptionalBindingPattern"
  }),
  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
  SpreadVariance: "Spread properties cannot have variance.",
  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
  ThisParamNoDefault: "The `this` parameter may not have a default value.",
  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
  UnexpectedReservedType: ({
    reservedType: r
  }) => `Unexpected reserved type ${r}.`,
  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
  UnsupportedDeclareExportKind: ({
    unsupportedExportKind: r,
    suggestion: e
  }) => `\`declare export ${r}\` is not supported. Use \`${e}\` instead.`,
  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
  UnterminatedFlowComment: "Unterminated flow-comment."
});
function aO(r) {
  return r.type === "DeclareExportAllDeclaration" || r.type === "DeclareExportDeclaration" && (!r.declaration || r.declaration.type !== "TypeAlias" && r.declaration.type !== "InterfaceDeclaration");
}
function yy(r) {
  return r.importKind === "type" || r.importKind === "typeof";
}
const oO = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface"
};
function uO(r, e) {
  const t = [], s = [];
  for (let i = 0; i < r.length; i++)
    (e(r[i], i, r) ? t : s).push(r[i]);
  return [t, s];
}
const lO = /\*?\s*@((?:no)?flow)\b/;
var cO = (r) => class extends r {
  constructor(...t) {
    super(...t), this.flowPragma = void 0;
  }
  getScopeHandler() {
    return FN;
  }
  shouldParseTypes() {
    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
  }
  shouldParseEnums() {
    return !!this.getPluginOption("flow", "enums");
  }
  finishToken(t, s) {
    t !== 133 && t !== 13 && t !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(t, s);
  }
  addComment(t) {
    if (this.flowPragma === void 0) {
      const s = lO.exec(t.value);
      if (s) if (s[1] === "flow")
        this.flowPragma = "flow";
      else if (s[1] === "noflow")
        this.flowPragma = "noflow";
      else
        throw new Error("Unexpected flow pragma");
    }
    super.addComment(t);
  }
  flowParseTypeInitialiser(t) {
    const s = this.state.inType;
    this.state.inType = !0, this.expect(t || 14);
    const i = this.flowParseType();
    return this.state.inType = s, i;
  }
  flowParsePredicate() {
    const t = this.startNode(), s = this.state.startLoc;
    return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(de.UnexpectedSpaceBetweenModuloChecks, s), this.eat(10) ? (t.value = super.parseExpression(), this.expect(11), this.finishNode(t, "DeclaredPredicate")) : this.finishNode(t, "InferredPredicate");
  }
  flowParseTypeAndPredicateInitialiser() {
    const t = this.state.inType;
    this.state.inType = !0, this.expect(14);
    let s = null, i = null;
    return this.match(54) ? (this.state.inType = t, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = t, this.match(54) && (i = this.flowParsePredicate())), [s, i];
  }
  flowParseDeclareClass(t) {
    return this.next(), this.flowParseInterfaceish(t, !0), this.finishNode(t, "DeclareClass");
  }
  flowParseDeclareFunction(t) {
    this.next();
    const s = t.id = this.parseIdentifier(), i = this.startNode(), n = this.startNode();
    this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
    const a = this.flowParseFunctionTypeParams();
    return i.params = a.params, i.rest = a.rest, i.this = a._this, this.expect(11), [i.returnType, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), n.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(n, "TypeAnnotation"), this.resetEndLocation(s), this.semicolon(), this.scope.declareName(t.id.name, 2048, t.id.loc.start), this.finishNode(t, "DeclareFunction");
  }
  flowParseDeclare(t, s) {
    if (this.match(80))
      return this.flowParseDeclareClass(t);
    if (this.match(68))
      return this.flowParseDeclareFunction(t);
    if (this.match(74))
      return this.flowParseDeclareVariable(t);
    if (this.eatContextual(127))
      return this.match(16) ? this.flowParseDeclareModuleExports(t) : (s && this.raise(de.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(t));
    if (this.isContextual(130))
      return this.flowParseDeclareTypeAlias(t);
    if (this.isContextual(131))
      return this.flowParseDeclareOpaqueType(t);
    if (this.isContextual(129))
      return this.flowParseDeclareInterface(t);
    if (this.match(82))
      return this.flowParseDeclareExportDeclaration(t, s);
    this.unexpected();
  }
  flowParseDeclareVariable(t) {
    return this.next(), t.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(t.id.name, 5, t.id.loc.start), this.semicolon(), this.finishNode(t, "DeclareVariable");
  }
  flowParseDeclareModule(t) {
    this.scope.enter(0), this.match(133) ? t.id = super.parseExprAtom() : t.id = this.parseIdentifier();
    const s = t.body = this.startNode(), i = s.body = [];
    for (this.expect(5); !this.match(8); ) {
      let o = this.startNode();
      this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(de.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(o)) : (this.expectContextual(125, de.UnsupportedStatementInDeclareModule), o = this.flowParseDeclare(o, !0)), i.push(o);
    }
    this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
    let n = null, a = !1;
    return i.forEach((o) => {
      aO(o) ? (n === "CommonJS" && this.raise(de.AmbiguousDeclareModuleKind, o), n = "ES") : o.type === "DeclareModuleExports" && (a && this.raise(de.DuplicateDeclareModuleExports, o), n === "ES" && this.raise(de.AmbiguousDeclareModuleKind, o), n = "CommonJS", a = !0);
    }), t.kind = n || "CommonJS", this.finishNode(t, "DeclareModule");
  }
  flowParseDeclareExportDeclaration(t, s) {
    if (this.expect(82), this.eat(65))
      return this.match(68) || this.match(80) ? t.declaration = this.flowParseDeclare(this.startNode()) : (t.declaration = this.flowParseType(), this.semicolon()), t.default = !0, this.finishNode(t, "DeclareExportDeclaration");
    if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
      const i = this.state.value;
      throw this.raise(de.UnsupportedDeclareExportKind, this.state.startLoc, {
        unsupportedExportKind: i,
        suggestion: oO[i]
      });
    }
    if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
      return t.declaration = this.flowParseDeclare(this.startNode()), t.default = !1, this.finishNode(t, "DeclareExportDeclaration");
    if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
      return t = this.parseExport(t, null), t.type === "ExportNamedDeclaration" && (t.type = "ExportDeclaration", t.default = !1, delete t.exportKind), t.type = "Declare" + t.type, t;
    this.unexpected();
  }
  flowParseDeclareModuleExports(t) {
    return this.next(), this.expectContextual(111), t.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(t, "DeclareModuleExports");
  }
  flowParseDeclareTypeAlias(t) {
    this.next();
    const s = this.flowParseTypeAlias(t);
    return s.type = "DeclareTypeAlias", s;
  }
  flowParseDeclareOpaqueType(t) {
    this.next();
    const s = this.flowParseOpaqueType(t, !0);
    return s.type = "DeclareOpaqueType", s;
  }
  flowParseDeclareInterface(t) {
    return this.next(), this.flowParseInterfaceish(t, !1), this.finishNode(t, "DeclareInterface");
  }
  flowParseInterfaceish(t, s) {
    if (t.id = this.flowParseRestrictedIdentifier(!s, !0), this.scope.declareName(t.id.name, s ? 17 : 8201, t.id.loc.start), this.match(47) ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.extends = [], this.eat(81))
      do
        t.extends.push(this.flowParseInterfaceExtends());
      while (!s && this.eat(12));
    if (s) {
      if (t.implements = [], t.mixins = [], this.eatContextual(117))
        do
          t.mixins.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      if (this.eatContextual(113))
        do
          t.implements.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
    }
    t.body = this.flowParseObjectType({
      allowStatic: s,
      allowExact: !1,
      allowSpread: !1,
      allowProto: s,
      allowInexact: !1
    });
  }
  flowParseInterfaceExtends() {
    const t = this.startNode();
    return t.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? t.typeParameters = this.flowParseTypeParameterInstantiation() : t.typeParameters = null, this.finishNode(t, "InterfaceExtends");
  }
  flowParseInterface(t) {
    return this.flowParseInterfaceish(t, !1), this.finishNode(t, "InterfaceDeclaration");
  }
  checkNotUnderscore(t) {
    t === "_" && this.raise(de.UnexpectedReservedUnderscore, this.state.startLoc);
  }
  checkReservedType(t, s, i) {
    nO.has(t) && this.raise(i ? de.AssignReservedType : de.UnexpectedReservedType, s, {
      reservedType: t
    });
  }
  flowParseRestrictedIdentifier(t, s) {
    return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(t);
  }
  flowParseTypeAlias(t) {
    return t.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(t.id.name, 8201, t.id.loc.start), this.match(47) ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(t, "TypeAlias");
  }
  flowParseOpaqueType(t, s) {
    return this.expectContextual(130), t.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(t.id.name, 8201, t.id.loc.start), this.match(47) ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.supertype = null, this.match(14) && (t.supertype = this.flowParseTypeInitialiser(14)), t.impltype = null, s || (t.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(t, "OpaqueType");
  }
  flowParseTypeParameter(t = !1) {
    const s = this.state.startLoc, i = this.startNode(), n = this.flowParseVariance(), a = this.flowParseTypeAnnotatableIdentifier();
    return i.name = a.name, i.variance = n, i.bound = a.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) : t && this.raise(de.MissingTypeParamDefault, s), this.finishNode(i, "TypeParameter");
  }
  flowParseTypeParameterDeclaration() {
    const t = this.state.inType, s = this.startNode();
    s.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
    let i = !1;
    do {
      const n = this.flowParseTypeParameter(i);
      s.params.push(n), n.default && (i = !0), this.match(48) || this.expect(12);
    } while (!this.match(48));
    return this.expect(48), this.state.inType = t, this.finishNode(s, "TypeParameterDeclaration");
  }
  flowParseTypeParameterInstantiation() {
    const t = this.startNode(), s = this.state.inType;
    t.params = [], this.state.inType = !0, this.expect(47);
    const i = this.state.noAnonFunctionType;
    for (this.state.noAnonFunctionType = !1; !this.match(48); )
      t.params.push(this.flowParseType()), this.match(48) || this.expect(12);
    return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(t, "TypeParameterInstantiation");
  }
  flowParseTypeParameterInstantiationCallOrNew() {
    const t = this.startNode(), s = this.state.inType;
    for (t.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
      t.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
    return this.expect(48), this.state.inType = s, this.finishNode(t, "TypeParameterInstantiation");
  }
  flowParseInterfaceType() {
    const t = this.startNode();
    if (this.expectContextual(129), t.extends = [], this.eat(81))
      do
        t.extends.push(this.flowParseInterfaceExtends());
      while (this.eat(12));
    return t.body = this.flowParseObjectType({
      allowStatic: !1,
      allowExact: !1,
      allowSpread: !1,
      allowProto: !1,
      allowInexact: !1
    }), this.finishNode(t, "InterfaceTypeAnnotation");
  }
  flowParseObjectPropertyKey() {
    return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
  }
  flowParseObjectTypeIndexer(t, s, i) {
    return t.static = s, this.lookahead().type === 14 ? (t.id = this.flowParseObjectPropertyKey(), t.key = this.flowParseTypeInitialiser()) : (t.id = null, t.key = this.flowParseType()), this.expect(3), t.value = this.flowParseTypeInitialiser(), t.variance = i, this.finishNode(t, "ObjectTypeIndexer");
  }
  flowParseObjectTypeInternalSlot(t, s) {
    return t.static = s, t.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (t.method = !0, t.optional = !1, t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.loc.start))) : (t.method = !1, this.eat(17) && (t.optional = !0), t.value = this.flowParseTypeInitialiser()), this.finishNode(t, "ObjectTypeInternalSlot");
  }
  flowParseObjectTypeMethodish(t) {
    for (t.params = [], t.rest = null, t.typeParameters = null, t.this = null, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (t.this = this.flowParseFunctionTypeParam(!0), t.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
      t.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
    return this.eat(21) && (t.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), t.returnType = this.flowParseTypeInitialiser(), this.finishNode(t, "FunctionTypeAnnotation");
  }
  flowParseObjectTypeCallProperty(t, s) {
    const i = this.startNode();
    return t.static = s, t.value = this.flowParseObjectTypeMethodish(i), this.finishNode(t, "ObjectTypeCallProperty");
  }
  flowParseObjectType({
    allowStatic: t,
    allowExact: s,
    allowSpread: i,
    allowProto: n,
    allowInexact: a
  }) {
    const o = this.state.inType;
    this.state.inType = !0;
    const u = this.startNode();
    u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
    let l, c, f = !1;
    for (s && this.match(6) ? (this.expect(6), l = 9, c = !0) : (this.expect(5), l = 8, c = !1), u.exact = c; !this.match(l); ) {
      let h = !1, m = null, d = null;
      const y = this.startNode();
      if (n && this.isContextual(118)) {
        const E = this.lookahead();
        E.type !== 14 && E.type !== 17 && (this.next(), m = this.state.startLoc, t = !1);
      }
      if (t && this.isContextual(106)) {
        const E = this.lookahead();
        E.type !== 14 && E.type !== 17 && (this.next(), h = !0);
      }
      const S = this.flowParseVariance();
      if (this.eat(0))
        m != null && this.unexpected(m), this.eat(0) ? (S && this.unexpected(S.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(y, h))) : u.indexers.push(this.flowParseObjectTypeIndexer(y, h, S));
      else if (this.match(10) || this.match(47))
        m != null && this.unexpected(m), S && this.unexpected(S.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(y, h));
      else {
        let E = "init";
        if (this.isContextual(99) || this.isContextual(104)) {
          const b = this.lookahead();
          sS(b.type) && (E = this.state.value, this.next());
        }
        const g = this.flowParseObjectTypeProperty(y, h, m, S, E, i, a ?? !c);
        g === null ? (f = !0, d = this.state.lastTokStartLoc) : u.properties.push(g);
      }
      this.flowObjectTypeSemicolon(), d && !this.match(8) && !this.match(9) && this.raise(de.UnexpectedExplicitInexactInObject, d);
    }
    this.expect(l), i && (u.inexact = f);
    const p = this.finishNode(u, "ObjectTypeAnnotation");
    return this.state.inType = o, p;
  }
  flowParseObjectTypeProperty(t, s, i, n, a, o, u) {
    if (this.eat(21))
      return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? u || this.raise(de.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(de.InexactInsideNonObject, this.state.lastTokStartLoc), n && this.raise(de.InexactVariance, n), null) : (o || this.raise(de.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), n && this.raise(de.SpreadVariance, n), t.argument = this.flowParseType(), this.finishNode(t, "ObjectTypeSpreadProperty"));
    {
      t.key = this.flowParseObjectPropertyKey(), t.static = s, t.proto = i != null, t.kind = a;
      let l = !1;
      return this.match(47) || this.match(10) ? (t.method = !0, i != null && this.unexpected(i), n && this.unexpected(n.loc.start), t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.loc.start)), (a === "get" || a === "set") && this.flowCheckGetterSetterParams(t), !o && t.key.name === "constructor" && t.value.this && this.raise(de.ThisParamBannedInConstructor, t.value.this)) : (a !== "init" && this.unexpected(), t.method = !1, this.eat(17) && (l = !0), t.value = this.flowParseTypeInitialiser(), t.variance = n), t.optional = l, this.finishNode(t, "ObjectTypeProperty");
    }
  }
  flowCheckGetterSetterParams(t) {
    const s = t.kind === "get" ? 0 : 1, i = t.value.params.length + (t.value.rest ? 1 : 0);
    t.value.this && this.raise(t.kind === "get" ? de.GetterMayNotHaveThisParam : de.SetterMayNotHaveThisParam, t.value.this), i !== s && this.raise(t.kind === "get" ? O.BadGetterArity : O.BadSetterArity, t), t.kind === "set" && t.value.rest && this.raise(O.BadSetterRestParameter, t);
  }
  flowObjectTypeSemicolon() {
    !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
  }
  flowParseQualifiedTypeIdentifier(t, s) {
    var i;
    (i = t) != null || (t = this.state.startLoc);
    let n = s || this.flowParseRestrictedIdentifier(!0);
    for (; this.eat(16); ) {
      const a = this.startNodeAt(t);
      a.qualification = n, a.id = this.flowParseRestrictedIdentifier(!0), n = this.finishNode(a, "QualifiedTypeIdentifier");
    }
    return n;
  }
  flowParseGenericType(t, s) {
    const i = this.startNodeAt(t);
    return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(t, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
  }
  flowParseTypeofType() {
    const t = this.startNode();
    return this.expect(87), t.argument = this.flowParsePrimaryType(), this.finishNode(t, "TypeofTypeAnnotation");
  }
  flowParseTupleType() {
    const t = this.startNode();
    for (t.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (t.types.push(this.flowParseType()), !this.match(3)); )
      this.expect(12);
    return this.expect(3), this.finishNode(t, "TupleTypeAnnotation");
  }
  flowParseFunctionTypeParam(t) {
    let s = null, i = !1, n = null;
    const a = this.startNode(), o = this.lookahead(), u = this.state.type === 78;
    return o.type === 14 || o.type === 17 ? (u && !t && this.raise(de.ThisParamMustBeFirst, a), s = this.parseIdentifier(u), this.eat(17) && (i = !0, u && this.raise(de.ThisParamMayNotBeOptional, a)), n = this.flowParseTypeInitialiser()) : n = this.flowParseType(), a.name = s, a.optional = i, a.typeAnnotation = n, this.finishNode(a, "FunctionTypeParam");
  }
  reinterpretTypeAsFunctionTypeParam(t) {
    const s = this.startNodeAt(t.loc.start);
    return s.name = null, s.optional = !1, s.typeAnnotation = t, this.finishNode(s, "FunctionTypeParam");
  }
  flowParseFunctionTypeParams(t = []) {
    let s = null, i = null;
    for (this.match(78) && (i = this.flowParseFunctionTypeParam(!0), i.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
      t.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
    return this.eat(21) && (s = this.flowParseFunctionTypeParam(!1)), {
      params: t,
      rest: s,
      _this: i
    };
  }
  flowIdentToTypeAnnotation(t, s, i) {
    switch (i.name) {
      case "any":
        return this.finishNode(s, "AnyTypeAnnotation");
      case "bool":
      case "boolean":
        return this.finishNode(s, "BooleanTypeAnnotation");
      case "mixed":
        return this.finishNode(s, "MixedTypeAnnotation");
      case "empty":
        return this.finishNode(s, "EmptyTypeAnnotation");
      case "number":
        return this.finishNode(s, "NumberTypeAnnotation");
      case "string":
        return this.finishNode(s, "StringTypeAnnotation");
      case "symbol":
        return this.finishNode(s, "SymbolTypeAnnotation");
      default:
        return this.checkNotUnderscore(i.name), this.flowParseGenericType(t, i);
    }
  }
  flowParsePrimaryType() {
    const t = this.state.startLoc, s = this.startNode();
    let i, n, a = !1;
    const o = this.state.noAnonFunctionType;
    switch (this.state.type) {
      case 5:
        return this.flowParseObjectType({
          allowStatic: !1,
          allowExact: !1,
          allowSpread: !0,
          allowProto: !1,
          allowInexact: !0
        });
      case 6:
        return this.flowParseObjectType({
          allowStatic: !1,
          allowExact: !0,
          allowSpread: !0,
          allowProto: !1,
          allowInexact: !1
        });
      case 0:
        return this.state.noAnonFunctionType = !1, n = this.flowParseTupleType(), this.state.noAnonFunctionType = o, n;
      case 47: {
        const u = this.startNode();
        return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), u.params = i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(u, "FunctionTypeAnnotation");
      }
      case 10: {
        const u = this.startNode();
        if (this.next(), !this.match(11) && !this.match(21))
          if (Le(this.state.type) || this.match(78)) {
            const l = this.lookahead().type;
            a = l !== 17 && l !== 14;
          } else
            a = !0;
        if (a) {
          if (this.state.noAnonFunctionType = !1, n = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
            return this.expect(11), n;
          this.eat(12);
        }
        return n ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(n)]) : i = this.flowParseFunctionTypeParams(), u.params = i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters = null, this.finishNode(u, "FunctionTypeAnnotation");
      }
      case 133:
        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
      case 85:
      case 86:
        return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
      case 53:
        if (this.state.value === "-") {
          if (this.next(), this.match(134))
            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
          if (this.match(135))
            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
          throw this.raise(de.UnexpectedSubtractionOperand, this.state.startLoc);
        }
        this.unexpected();
        return;
      case 134:
        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
      case 135:
        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
      case 88:
        return this.next(), this.finishNode(s, "VoidTypeAnnotation");
      case 84:
        return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
      case 78:
        return this.next(), this.finishNode(s, "ThisTypeAnnotation");
      case 55:
        return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
      case 87:
        return this.flowParseTypeofType();
      default:
        if (um(this.state.type)) {
          const u = si(this.state.type);
          return this.next(), super.createIdentifier(s, u);
        } else if (Le(this.state.type))
          return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(t, s, this.parseIdentifier());
    }
    this.unexpected();
  }
  flowParsePostfixType() {
    const t = this.state.startLoc;
    let s = this.flowParsePrimaryType(), i = !1;
    for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
      const n = this.startNodeAt(t), a = this.eat(18);
      i = i || a, this.expect(0), !a && this.match(3) ? (n.elementType = s, this.next(), s = this.finishNode(n, "ArrayTypeAnnotation")) : (n.objectType = s, n.indexType = this.flowParseType(), this.expect(3), i ? (n.optional = a, s = this.finishNode(n, "OptionalIndexedAccessType")) : s = this.finishNode(n, "IndexedAccessType"));
    }
    return s;
  }
  flowParsePrefixType() {
    const t = this.startNode();
    return this.eat(17) ? (t.typeAnnotation = this.flowParsePrefixType(), this.finishNode(t, "NullableTypeAnnotation")) : this.flowParsePostfixType();
  }
  flowParseAnonFunctionWithoutParens() {
    const t = this.flowParsePrefixType();
    if (!this.state.noAnonFunctionType && this.eat(19)) {
      const s = this.startNodeAt(t.loc.start);
      return s.params = [this.reinterpretTypeAsFunctionTypeParam(t)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
    }
    return t;
  }
  flowParseIntersectionType() {
    const t = this.startNode();
    this.eat(45);
    const s = this.flowParseAnonFunctionWithoutParens();
    for (t.types = [s]; this.eat(45); )
      t.types.push(this.flowParseAnonFunctionWithoutParens());
    return t.types.length === 1 ? s : this.finishNode(t, "IntersectionTypeAnnotation");
  }
  flowParseUnionType() {
    const t = this.startNode();
    this.eat(43);
    const s = this.flowParseIntersectionType();
    for (t.types = [s]; this.eat(43); )
      t.types.push(this.flowParseIntersectionType());
    return t.types.length === 1 ? s : this.finishNode(t, "UnionTypeAnnotation");
  }
  flowParseType() {
    const t = this.state.inType;
    this.state.inType = !0;
    const s = this.flowParseUnionType();
    return this.state.inType = t, s;
  }
  flowParseTypeOrImplicitInstantiation() {
    if (this.state.type === 132 && this.state.value === "_") {
      const t = this.state.startLoc, s = this.parseIdentifier();
      return this.flowParseGenericType(t, s);
    } else
      return this.flowParseType();
  }
  flowParseTypeAnnotation() {
    const t = this.startNode();
    return t.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(t, "TypeAnnotation");
  }
  flowParseTypeAnnotatableIdentifier(t) {
    const s = t ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
    return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
  }
  typeCastToParameter(t) {
    return t.expression.typeAnnotation = t.typeAnnotation, this.resetEndLocation(t.expression, t.typeAnnotation.loc.end), t.expression;
  }
  flowParseVariance() {
    let t = null;
    return this.match(53) ? (t = this.startNode(), this.state.value === "+" ? t.kind = "plus" : t.kind = "minus", this.next(), this.finishNode(t, "Variance")) : t;
  }
  parseFunctionBody(t, s, i = !1) {
    if (s) {
      this.forwardNoArrowParamsConversionAt(t, () => super.parseFunctionBody(t, !0, i));
      return;
    }
    super.parseFunctionBody(t, !1, i);
  }
  parseFunctionBodyAndFinish(t, s, i = !1) {
    if (this.match(14)) {
      const n = this.startNode();
      [n.typeAnnotation, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), t.returnType = n.typeAnnotation ? this.finishNode(n, "TypeAnnotation") : null;
    }
    return super.parseFunctionBodyAndFinish(t, s, i);
  }
  parseStatementLike(t) {
    if (this.state.strict && this.isContextual(129)) {
      const i = this.lookahead();
      if (Cr(i.type)) {
        const n = this.startNode();
        return this.next(), this.flowParseInterface(n);
      }
    } else if (this.shouldParseEnums() && this.isContextual(126)) {
      const i = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(i);
    }
    const s = super.parseStatementLike(t);
    return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
  }
  parseExpressionStatement(t, s, i) {
    if (s.type === "Identifier") {
      if (s.name === "declare") {
        if (this.match(80) || Le(this.state.type) || this.match(68) || this.match(74) || this.match(82))
          return this.flowParseDeclare(t);
      } else if (Le(this.state.type)) {
        if (s.name === "interface")
          return this.flowParseInterface(t);
        if (s.name === "type")
          return this.flowParseTypeAlias(t);
        if (s.name === "opaque")
          return this.flowParseOpaqueType(t, !1);
      }
    }
    return super.parseExpressionStatement(t, s, i);
  }
  shouldParseExportDeclaration() {
    const {
      type: t
    } = this.state;
    return hy(t) || this.shouldParseEnums() && t === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
  }
  isExportDefaultSpecifier() {
    const {
      type: t
    } = this.state;
    return hy(t) || this.shouldParseEnums() && t === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
  }
  parseExportDefaultExpression() {
    if (this.shouldParseEnums() && this.isContextual(126)) {
      const t = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(t);
    }
    return super.parseExportDefaultExpression();
  }
  parseConditional(t, s, i) {
    if (!this.match(17)) return t;
    if (this.state.maybeInArrowParameters) {
      const p = this.lookaheadCharCode();
      if (p === 44 || p === 61 || p === 58 || p === 41)
        return this.setOptionalParametersError(i), t;
    }
    this.expect(17);
    const n = this.state.clone(), a = this.state.noArrowAt, o = this.startNodeAt(s);
    let {
      consequent: u,
      failed: l
    } = this.tryParseConditionalConsequent(), [c, f] = this.getArrowLikeExpressions(u);
    if (l || f.length > 0) {
      const p = [...a];
      if (f.length > 0) {
        this.state = n, this.state.noArrowAt = p;
        for (let h = 0; h < f.length; h++)
          p.push(f[h].start);
        ({
          consequent: u,
          failed: l
        } = this.tryParseConditionalConsequent()), [c, f] = this.getArrowLikeExpressions(u);
      }
      l && c.length > 1 && this.raise(de.AmbiguousConditionalArrow, n.startLoc), l && c.length === 1 && (this.state = n, p.push(c[0].start), this.state.noArrowAt = p, {
        consequent: u,
        failed: l
      } = this.tryParseConditionalConsequent());
    }
    return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = a, this.expect(14), o.test = t, o.consequent = u, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
  }
  tryParseConditionalConsequent() {
    this.state.noArrowParamsConversionAt.push(this.state.start);
    const t = this.parseMaybeAssignAllowIn(), s = !this.match(14);
    return this.state.noArrowParamsConversionAt.pop(), {
      consequent: t,
      failed: s
    };
  }
  getArrowLikeExpressions(t, s) {
    const i = [t], n = [];
    for (; i.length !== 0; ) {
      const a = i.pop();
      a.type === "ArrowFunctionExpression" && a.body.type !== "BlockStatement" ? (a.typeParameters || !a.returnType ? this.finishArrowValidation(a) : n.push(a), i.push(a.body)) : a.type === "ConditionalExpression" && (i.push(a.consequent), i.push(a.alternate));
    }
    return s ? (n.forEach((a) => this.finishArrowValidation(a)), [n, []]) : uO(n, (a) => a.params.every((o) => this.isAssignable(o, !0)));
  }
  finishArrowValidation(t) {
    var s;
    this.toAssignableList(t.params, (s = t.extra) == null ? void 0 : s.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(t, !1, !0), this.scope.exit();
  }
  forwardNoArrowParamsConversionAt(t, s) {
    let i;
    return this.state.noArrowParamsConversionAt.indexOf(t.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i = s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
  }
  parseParenItem(t, s) {
    const i = super.parseParenItem(t, s);
    if (this.eat(17) && (i.optional = !0, this.resetEndLocation(t)), this.match(14)) {
      const n = this.startNodeAt(s);
      return n.expression = i, n.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(n, "TypeCastExpression");
    }
    return i;
  }
  assertModuleNodeAllowed(t) {
    t.type === "ImportDeclaration" && (t.importKind === "type" || t.importKind === "typeof") || t.type === "ExportNamedDeclaration" && t.exportKind === "type" || t.type === "ExportAllDeclaration" && t.exportKind === "type" || super.assertModuleNodeAllowed(t);
  }
  parseExportDeclaration(t) {
    if (this.isContextual(130)) {
      t.exportKind = "type";
      const s = this.startNode();
      return this.next(), this.match(5) ? (t.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(t), null) : this.flowParseTypeAlias(s);
    } else if (this.isContextual(131)) {
      t.exportKind = "type";
      const s = this.startNode();
      return this.next(), this.flowParseOpaqueType(s, !1);
    } else if (this.isContextual(129)) {
      t.exportKind = "type";
      const s = this.startNode();
      return this.next(), this.flowParseInterface(s);
    } else if (this.shouldParseEnums() && this.isContextual(126)) {
      t.exportKind = "value";
      const s = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(s);
    } else
      return super.parseExportDeclaration(t);
  }
  eatExportStar(t) {
    return super.eatExportStar(t) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (t.exportKind = "type", this.next(), this.next(), !0) : !1;
  }
  maybeParseExportNamespaceSpecifier(t) {
    const {
      startLoc: s
    } = this.state, i = super.maybeParseExportNamespaceSpecifier(t);
    return i && t.exportKind === "type" && this.unexpected(s), i;
  }
  parseClassId(t, s, i) {
    super.parseClassId(t, s, i), this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration());
  }
  parseClassMember(t, s, i) {
    const {
      startLoc: n
    } = this.state;
    if (this.isContextual(125)) {
      if (super.parseClassMemberFromModifier(t, s))
        return;
      s.declare = !0;
    }
    super.parseClassMember(t, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "PropertyDefinition" ? this.raise(de.DeclareClassElement, n) : s.value && this.raise(de.DeclareClassFieldInitializer, s.value));
  }
  isIterator(t) {
    return t === "iterator" || t === "asyncIterator";
  }
  readIterator() {
    const t = super.readWord1(), s = "@@" + t;
    (!this.isIterator(t) || !this.state.inType) && this.raise(O.InvalidIdentifier, this.state.curPosition(), {
      identifierName: s
    }), this.finishToken(132, s);
  }
  getTokenFromCode(t) {
    const s = this.input.charCodeAt(this.state.pos + 1);
    t === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (t === 62 || t === 60) ? this.finishOp(t === 62 ? 48 : 47, 1) : this.state.inType && t === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : LN(t, s, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(t);
  }
  isAssignable(t, s) {
    return t.type === "TypeCastExpression" ? this.isAssignable(t.expression, s) : super.isAssignable(t, s);
  }
  toAssignable(t, s = !1) {
    !s && t.type === "AssignmentExpression" && t.left.type === "TypeCastExpression" && (t.left = this.typeCastToParameter(t.left)), super.toAssignable(t, s);
  }
  toAssignableList(t, s, i) {
    for (let n = 0; n < t.length; n++) {
      const a = t[n];
      (a == null ? void 0 : a.type) === "TypeCastExpression" && (t[n] = this.typeCastToParameter(a));
    }
    super.toAssignableList(t, s, i);
  }
  toReferencedList(t, s) {
    for (let n = 0; n < t.length; n++) {
      var i;
      const a = t[n];
      a && a.type === "TypeCastExpression" && !((i = a.extra) != null && i.parenthesized) && (t.length > 1 || !s) && this.raise(de.TypeCastInPattern, a.typeAnnotation);
    }
    return t;
  }
  parseArrayLike(t, s, i, n) {
    const a = super.parseArrayLike(t, s, i, n);
    return s && !this.state.maybeInArrowParameters && this.toReferencedList(a.elements), a;
  }
  isValidLVal(t, s, i) {
    return t === "TypeCastExpression" || super.isValidLVal(t, s, i);
  }
  parseClassProperty(t) {
    return this.match(14) && (t.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(t);
  }
  parseClassPrivateProperty(t) {
    return this.match(14) && (t.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(t);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(14) || super.isClassProperty();
  }
  isNonstaticConstructor(t) {
    return !this.match(14) && super.isNonstaticConstructor(t);
  }
  pushClassMethod(t, s, i, n, a, o) {
    if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(t, s, i, n, a, o), s.params && a) {
      const u = s.params;
      u.length > 0 && this.isThisParam(u[0]) && this.raise(de.ThisParamBannedInConstructor, s);
    } else if (s.type === "MethodDefinition" && a && s.value.params) {
      const u = s.value.params;
      u.length > 0 && this.isThisParam(u[0]) && this.raise(de.ThisParamBannedInConstructor, s);
    }
  }
  pushClassPrivateMethod(t, s, i, n) {
    s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(t, s, i, n);
  }
  parseClassSuper(t) {
    if (super.parseClassSuper(t), t.superClass && this.match(47) && (t.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
      this.next();
      const s = t.implements = [];
      do {
        const i = this.startNode();
        i.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
      } while (this.eat(12));
    }
  }
  checkGetterSetterParams(t) {
    super.checkGetterSetterParams(t);
    const s = this.getObjectOrClassMethodParams(t);
    if (s.length > 0) {
      const i = s[0];
      this.isThisParam(i) && t.kind === "get" ? this.raise(de.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(de.SetterMayNotHaveThisParam, i);
    }
  }
  parsePropertyNamePrefixOperator(t) {
    t.variance = this.flowParseVariance();
  }
  parseObjPropValue(t, s, i, n, a, o, u) {
    t.variance && this.unexpected(t.variance.loc.start), delete t.variance;
    let l;
    this.match(47) && !o && (l = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
    const c = super.parseObjPropValue(t, s, i, n, a, o, u);
    return l && ((c.value || c).typeParameters = l), c;
  }
  parseAssignableListItemTypes(t) {
    return this.eat(17) && (t.type !== "Identifier" && this.raise(de.PatternIsOptional, t), this.isThisParam(t) && this.raise(de.ThisParamMayNotBeOptional, t), t.optional = !0), this.match(14) ? t.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(t) && this.raise(de.ThisParamAnnotationRequired, t), this.match(29) && this.isThisParam(t) && this.raise(de.ThisParamNoDefault, t), this.resetEndLocation(t), t;
  }
  parseMaybeDefault(t, s) {
    const i = super.parseMaybeDefault(t, s);
    return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(de.TypeBeforeInitializer, i.typeAnnotation), i;
  }
  checkImportReflection(t) {
    super.checkImportReflection(t), t.module && t.importKind !== "value" && this.raise(de.ImportReflectionHasImportType, t.specifiers[0].loc.start);
  }
  parseImportSpecifierLocal(t, s, i) {
    s.local = yy(t) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(s, i));
  }
  isPotentialImportPhase(t) {
    if (super.isPotentialImportPhase(t)) return !0;
    if (this.isContextual(130)) {
      if (!t) return !0;
      const s = this.lookaheadCharCode();
      return s === 123 || s === 42;
    }
    return !t && this.isContextual(87);
  }
  applyImportPhase(t, s, i, n) {
    if (super.applyImportPhase(t, s, i, n), s) {
      if (!i && this.match(65))
        return;
      t.exportKind = i === "type" ? i : "value";
    } else
      i === "type" && this.match(55) && this.unexpected(), t.importKind = i === "type" || i === "typeof" ? i : "value";
  }
  parseImportSpecifier(t, s, i, n, a) {
    const o = t.imported;
    let u = null;
    o.type === "Identifier" && (o.name === "type" ? u = "type" : o.name === "typeof" && (u = "typeof"));
    let l = !1;
    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
      const f = this.parseIdentifier(!0);
      u !== null && !Cr(this.state.type) ? (t.imported = f, t.importKind = u, t.local = Ss(f)) : (t.imported = o, t.importKind = null, t.local = this.parseIdentifier());
    } else {
      if (u !== null && Cr(this.state.type))
        t.imported = this.parseIdentifier(!0), t.importKind = u;
      else {
        if (s)
          throw this.raise(O.ImportBindingIsString, t, {
            importName: o.value
          });
        t.imported = o, t.importKind = null;
      }
      this.eatContextual(93) ? t.local = this.parseIdentifier() : (l = !0, t.local = Ss(t.imported));
    }
    const c = yy(t);
    return i && c && this.raise(de.ImportTypeShorthandOnlyInPureImport, t), (i || c) && this.checkReservedType(t.local.name, t.local.loc.start, !0), l && !i && !c && this.checkReservedWord(t.local.name, t.loc.start, !0, !0), this.finishImportSpecifier(t, "ImportSpecifier");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 78:
        return this.parseIdentifier(!0);
      default:
        return super.parseBindingAtom();
    }
  }
  parseFunctionParams(t, s) {
    const i = t.kind;
    i !== "get" && i !== "set" && this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(t, s);
  }
  parseVarId(t, s) {
    super.parseVarId(t, s), this.match(14) && (t.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t.id));
  }
  parseAsyncArrowFromCallExpression(t, s) {
    if (this.match(14)) {
      const i = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = !0, t.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
    }
    return super.parseAsyncArrowFromCallExpression(t, s);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  parseMaybeAssign(t, s) {
    var i;
    let n = null, a;
    if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
      if (n = this.state.clone(), a = this.tryParse(() => super.parseMaybeAssign(t, s), n), !a.error) return a.node;
      const {
        context: l
      } = this.state, c = l[l.length - 1];
      (c === Ue.j_oTag || c === Ue.j_expr) && l.pop();
    }
    if ((i = a) != null && i.error || this.match(47)) {
      var o, u;
      n = n || this.state.clone();
      let l;
      const c = this.tryParse((p) => {
        var h;
        l = this.flowParseTypeParameterDeclaration();
        const m = this.forwardNoArrowParamsConversionAt(l, () => {
          const y = super.parseMaybeAssign(t, s);
          return this.resetStartLocationFromNode(y, l), y;
        });
        (h = m.extra) != null && h.parenthesized && p();
        const d = this.maybeUnwrapTypeCastExpression(m);
        return d.type !== "ArrowFunctionExpression" && p(), d.typeParameters = l, this.resetStartLocationFromNode(d, l), m;
      }, n);
      let f = null;
      if (c.node && this.maybeUnwrapTypeCastExpression(c.node).type === "ArrowFunctionExpression") {
        if (!c.error && !c.aborted)
          return c.node.async && this.raise(de.UnexpectedTypeParameterBeforeAsyncArrowFunction, l), c.node;
        f = c.node;
      }
      if ((o = a) != null && o.node)
        return this.state = a.failState, a.node;
      if (f)
        return this.state = c.failState, f;
      throw (u = a) != null && u.thrown ? a.error : c.thrown ? c.error : this.raise(de.UnexpectedTokenAfterTypeParameter, l);
    }
    return super.parseMaybeAssign(t, s);
  }
  parseArrow(t) {
    if (this.match(14)) {
      const s = this.tryParse(() => {
        const i = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0;
        const n = this.startNode();
        return [n.typeAnnotation, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), n;
      });
      if (s.thrown) return null;
      s.error && (this.state = s.failState), t.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
    }
    return super.parseArrow(t);
  }
  shouldParseArrow(t) {
    return this.match(14) || super.shouldParseArrow(t);
  }
  setArrowFunctionParameters(t, s) {
    this.state.noArrowParamsConversionAt.indexOf(t.start) !== -1 ? t.params = s : super.setArrowFunctionParameters(t, s);
  }
  checkParams(t, s, i, n = !0) {
    if (!(i && this.state.noArrowParamsConversionAt.indexOf(t.start) !== -1)) {
      for (let a = 0; a < t.params.length; a++)
        this.isThisParam(t.params[a]) && a > 0 && this.raise(de.ThisParamMustBeFirst, t.params[a]);
      super.checkParams(t, s, i, n);
    }
  }
  parseParenAndDistinguishExpression(t) {
    return super.parseParenAndDistinguishExpression(t && this.state.noArrowAt.indexOf(this.state.start) === -1);
  }
  parseSubscripts(t, s, i) {
    if (t.type === "Identifier" && t.name === "async" && this.state.noArrowAt.indexOf(s.index) !== -1) {
      this.next();
      const n = this.startNodeAt(s);
      n.callee = t, n.arguments = super.parseCallExpressionArguments(11, !1), t = this.finishNode(n, "CallExpression");
    } else if (t.type === "Identifier" && t.name === "async" && this.match(47)) {
      const n = this.state.clone(), a = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s) || u(), n);
      if (!a.error && !a.aborted) return a.node;
      const o = this.tryParse(() => super.parseSubscripts(t, s, i), n);
      if (o.node && !o.error) return o.node;
      if (a.node)
        return this.state = a.failState, a.node;
      if (o.node)
        return this.state = o.failState, o.node;
      throw a.error || o.error;
    }
    return super.parseSubscripts(t, s, i);
  }
  parseSubscript(t, s, i, n) {
    if (this.match(18) && this.isLookaheadToken_lt()) {
      if (n.optionalChainMember = !0, i)
        return n.stop = !0, t;
      this.next();
      const a = this.startNodeAt(s);
      return a.callee = t, a.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), a.arguments = this.parseCallExpressionArguments(11, !1), a.optional = !0, this.finishCallExpression(a, !0);
    } else if (!i && this.shouldParseTypes() && this.match(47)) {
      const a = this.startNodeAt(s);
      a.callee = t;
      const o = this.tryParse(() => (a.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), a.arguments = super.parseCallExpressionArguments(11, !1), n.optionalChainMember && (a.optional = !1), this.finishCallExpression(a, n.optionalChainMember)));
      if (o.node)
        return o.error && (this.state = o.failState), o.node;
    }
    return super.parseSubscript(t, s, i, n);
  }
  parseNewCallee(t) {
    super.parseNewCallee(t);
    let s = null;
    this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), t.typeArguments = s;
  }
  parseAsyncArrowWithTypeParameters(t) {
    const s = this.startNodeAt(t);
    if (this.parseFunctionParams(s, !1), !!this.parseArrow(s))
      return super.parseArrowExpression(s, void 0, !0);
  }
  readToken_mult_modulo(t) {
    const s = this.input.charCodeAt(this.state.pos + 1);
    if (t === 42 && s === 47 && this.state.hasFlowComment) {
      this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
      return;
    }
    super.readToken_mult_modulo(t);
  }
  readToken_pipe_amp(t) {
    const s = this.input.charCodeAt(this.state.pos + 1);
    if (t === 124 && s === 125) {
      this.finishOp(9, 2);
      return;
    }
    super.readToken_pipe_amp(t);
  }
  parseTopLevel(t, s) {
    const i = super.parseTopLevel(t, s);
    return this.state.hasFlowComment && this.raise(de.UnterminatedFlowComment, this.state.curPosition()), i;
  }
  skipBlockComment() {
    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
      if (this.state.hasFlowComment)
        throw this.raise(de.NestedFlowComment, this.state.startLoc);
      this.hasFlowCommentCompletion();
      const t = this.skipFlowComment();
      t && (this.state.pos += t, this.state.hasFlowComment = !0);
      return;
    }
    return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
  }
  skipFlowComment() {
    const {
      pos: t
    } = this.state;
    let s = 2;
    for (; [32, 9].includes(this.input.charCodeAt(t + s)); )
      s++;
    const i = this.input.charCodeAt(s + t), n = this.input.charCodeAt(s + t + 1);
    return i === 58 && n === 58 ? s + 2 : this.input.slice(s + t, s + t + 12) === "flow-include" ? s + 12 : i === 58 && n !== 58 ? s : !1;
  }
  hasFlowCommentCompletion() {
    if (this.input.indexOf("*/", this.state.pos) === -1)
      throw this.raise(O.UnterminatedComment, this.state.curPosition());
  }
  flowEnumErrorBooleanMemberNotInitialized(t, {
    enumName: s,
    memberName: i
  }) {
    this.raise(de.EnumBooleanMemberNotInitialized, t, {
      memberName: i,
      enumName: s
    });
  }
  flowEnumErrorInvalidMemberInitializer(t, s) {
    return this.raise(s.explicitType ? s.explicitType === "symbol" ? de.EnumInvalidMemberInitializerSymbolType : de.EnumInvalidMemberInitializerPrimaryType : de.EnumInvalidMemberInitializerUnknownType, t, s);
  }
  flowEnumErrorNumberMemberNotInitialized(t, s) {
    this.raise(de.EnumNumberMemberNotInitialized, t, s);
  }
  flowEnumErrorStringMemberInconsistentlyInitialized(t, s) {
    this.raise(de.EnumStringMemberInconsistentlyInitialized, t, s);
  }
  flowEnumMemberInit() {
    const t = this.state.startLoc, s = () => this.match(12) || this.match(8);
    switch (this.state.type) {
      case 134: {
        const i = this.parseNumericLiteral(this.state.value);
        return s() ? {
          type: "number",
          loc: i.loc.start,
          value: i
        } : {
          type: "invalid",
          loc: t
        };
      }
      case 133: {
        const i = this.parseStringLiteral(this.state.value);
        return s() ? {
          type: "string",
          loc: i.loc.start,
          value: i
        } : {
          type: "invalid",
          loc: t
        };
      }
      case 85:
      case 86: {
        const i = this.parseBooleanLiteral(this.match(85));
        return s() ? {
          type: "boolean",
          loc: i.loc.start,
          value: i
        } : {
          type: "invalid",
          loc: t
        };
      }
      default:
        return {
          type: "invalid",
          loc: t
        };
    }
  }
  flowEnumMemberRaw() {
    const t = this.state.startLoc, s = this.parseIdentifier(!0), i = this.eat(29) ? this.flowEnumMemberInit() : {
      type: "none",
      loc: t
    };
    return {
      id: s,
      init: i
    };
  }
  flowEnumCheckExplicitTypeMismatch(t, s, i) {
    const {
      explicitType: n
    } = s;
    n !== null && n !== i && this.flowEnumErrorInvalidMemberInitializer(t, s);
  }
  flowEnumMembers({
    enumName: t,
    explicitType: s
  }) {
    const i = /* @__PURE__ */ new Set(), n = {
      booleanMembers: [],
      numberMembers: [],
      stringMembers: [],
      defaultedMembers: []
    };
    let a = !1;
    for (; !this.match(8); ) {
      if (this.eat(21)) {
        a = !0;
        break;
      }
      const o = this.startNode(), {
        id: u,
        init: l
      } = this.flowEnumMemberRaw(), c = u.name;
      if (c === "")
        continue;
      /^[a-z]/.test(c) && this.raise(de.EnumInvalidMemberName, u, {
        memberName: c,
        suggestion: c[0].toUpperCase() + c.slice(1),
        enumName: t
      }), i.has(c) && this.raise(de.EnumDuplicateMemberName, u, {
        memberName: c,
        enumName: t
      }), i.add(c);
      const f = {
        enumName: t,
        explicitType: s,
        memberName: c
      };
      switch (o.id = u, l.type) {
        case "boolean": {
          this.flowEnumCheckExplicitTypeMismatch(l.loc, f, "boolean"), o.init = l.value, n.booleanMembers.push(this.finishNode(o, "EnumBooleanMember"));
          break;
        }
        case "number": {
          this.flowEnumCheckExplicitTypeMismatch(l.loc, f, "number"), o.init = l.value, n.numberMembers.push(this.finishNode(o, "EnumNumberMember"));
          break;
        }
        case "string": {
          this.flowEnumCheckExplicitTypeMismatch(l.loc, f, "string"), o.init = l.value, n.stringMembers.push(this.finishNode(o, "EnumStringMember"));
          break;
        }
        case "invalid":
          throw this.flowEnumErrorInvalidMemberInitializer(l.loc, f);
        case "none":
          switch (s) {
            case "boolean":
              this.flowEnumErrorBooleanMemberNotInitialized(l.loc, f);
              break;
            case "number":
              this.flowEnumErrorNumberMemberNotInitialized(l.loc, f);
              break;
            default:
              n.defaultedMembers.push(this.finishNode(o, "EnumDefaultedMember"));
          }
      }
      this.match(8) || this.expect(12);
    }
    return {
      members: n,
      hasUnknownMembers: a
    };
  }
  flowEnumStringMembers(t, s, {
    enumName: i
  }) {
    if (t.length === 0)
      return s;
    if (s.length === 0)
      return t;
    if (s.length > t.length) {
      for (const n of t)
        this.flowEnumErrorStringMemberInconsistentlyInitialized(n, {
          enumName: i
        });
      return s;
    } else {
      for (const n of s)
        this.flowEnumErrorStringMemberInconsistentlyInitialized(n, {
          enumName: i
        });
      return t;
    }
  }
  flowEnumParseExplicitType({
    enumName: t
  }) {
    if (!this.eatContextual(102)) return null;
    if (!Le(this.state.type))
      throw this.raise(de.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
        enumName: t
      });
    const {
      value: s
    } = this.state;
    return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(de.EnumInvalidExplicitType, this.state.startLoc, {
      enumName: t,
      invalidEnumType: s
    }), s;
  }
  flowEnumBody(t, s) {
    const i = s.name, n = s.loc.start, a = this.flowEnumParseExplicitType({
      enumName: i
    });
    this.expect(5);
    const {
      members: o,
      hasUnknownMembers: u
    } = this.flowEnumMembers({
      enumName: i,
      explicitType: a
    });
    switch (t.hasUnknownMembers = u, a) {
      case "boolean":
        return t.explicitType = !0, t.members = o.booleanMembers, this.expect(8), this.finishNode(t, "EnumBooleanBody");
      case "number":
        return t.explicitType = !0, t.members = o.numberMembers, this.expect(8), this.finishNode(t, "EnumNumberBody");
      case "string":
        return t.explicitType = !0, t.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, {
          enumName: i
        }), this.expect(8), this.finishNode(t, "EnumStringBody");
      case "symbol":
        return t.members = o.defaultedMembers, this.expect(8), this.finishNode(t, "EnumSymbolBody");
      default: {
        const l = () => (t.members = [], this.expect(8), this.finishNode(t, "EnumStringBody"));
        t.explicitType = !1;
        const c = o.booleanMembers.length, f = o.numberMembers.length, p = o.stringMembers.length, h = o.defaultedMembers.length;
        if (!c && !f && !p && !h)
          return l();
        if (!c && !f)
          return t.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, {
            enumName: i
          }), this.expect(8), this.finishNode(t, "EnumStringBody");
        if (!f && !p && c >= h) {
          for (const m of o.defaultedMembers)
            this.flowEnumErrorBooleanMemberNotInitialized(m.loc.start, {
              enumName: i,
              memberName: m.id.name
            });
          return t.members = o.booleanMembers, this.expect(8), this.finishNode(t, "EnumBooleanBody");
        } else if (!c && !p && f >= h) {
          for (const m of o.defaultedMembers)
            this.flowEnumErrorNumberMemberNotInitialized(m.loc.start, {
              enumName: i,
              memberName: m.id.name
            });
          return t.members = o.numberMembers, this.expect(8), this.finishNode(t, "EnumNumberBody");
        } else
          return this.raise(de.EnumInconsistentMemberValues, n, {
            enumName: i
          }), l();
      }
    }
  }
  flowParseEnumDeclaration(t) {
    const s = this.parseIdentifier();
    return t.id = s, t.body = this.flowEnumBody(this.startNode(), s), this.finishNode(t, "EnumDeclaration");
  }
  isLookaheadToken_lt() {
    const t = this.nextTokenStart();
    if (this.input.charCodeAt(t) === 60) {
      const s = this.input.charCodeAt(t + 1);
      return s !== 60 && s !== 61;
    }
    return !1;
  }
  maybeUnwrapTypeCastExpression(t) {
    return t.type === "TypeCastExpression" ? t.expression : t;
  }
};
const fO = {
  __proto__: null,
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  fnof: "ƒ",
  circ: "ˆ",
  tilde: "˜",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  bull: "•",
  hellip: "…",
  permil: "‰",
  prime: "′",
  Prime: "″",
  lsaquo: "‹",
  rsaquo: "›",
  oline: "‾",
  frasl: "⁄",
  euro: "€",
  image: "ℑ",
  weierp: "℘",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦"
}, bi = gs`jsx`({
  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
  MissingClosingTagElement: ({
    openingTagName: r
  }) => `Expected corresponding JSX closing tag for <${r}>.`,
  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
  UnexpectedToken: ({
    unexpected: r,
    HTMLEntity: e
  }) => `Unexpected token \`${r}\`. Did you mean \`${e}\` or \`{'${r}'}\`?`,
  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
  UnterminatedJsxContent: "Unterminated JSX contents.",
  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
});
function Fs(r) {
  return r ? r.type === "JSXOpeningFragment" || r.type === "JSXClosingFragment" : !1;
}
function hn(r) {
  if (r.type === "JSXIdentifier")
    return r.name;
  if (r.type === "JSXNamespacedName")
    return r.namespace.name + ":" + r.name.name;
  if (r.type === "JSXMemberExpression")
    return hn(r.object) + "." + hn(r.property);
  throw new Error("Node had unexpected type: " + r.type);
}
var pO = (r) => class extends r {
  jsxReadToken() {
    let t = "", s = this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(bi.UnterminatedJsxContent, this.state.startLoc);
      const i = this.input.charCodeAt(this.state.pos);
      switch (i) {
        case 60:
        case 123:
          if (this.state.pos === this.state.start) {
            i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i);
            return;
          }
          t += this.input.slice(s, this.state.pos), this.finishToken(141, t);
          return;
        case 38:
          t += this.input.slice(s, this.state.pos), t += this.jsxReadEntity(), s = this.state.pos;
          break;
        case 62:
        case 125:
        default:
          qa(i) ? (t += this.input.slice(s, this.state.pos), t += this.jsxReadNewLine(!0), s = this.state.pos) : ++this.state.pos;
      }
    }
  }
  jsxReadNewLine(t) {
    const s = this.input.charCodeAt(this.state.pos);
    let i;
    return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = t ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
  }
  jsxReadString(t) {
    let s = "", i = ++this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(O.UnterminatedString, this.state.startLoc);
      const n = this.input.charCodeAt(this.state.pos);
      if (n === t) break;
      n === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : qa(n) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(!1), i = this.state.pos) : ++this.state.pos;
    }
    s += this.input.slice(i, this.state.pos++), this.finishToken(133, s);
  }
  jsxReadEntity() {
    const t = ++this.state.pos;
    if (this.codePointAtPos(this.state.pos) === 35) {
      ++this.state.pos;
      let s = 10;
      this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
      const i = this.readInt(s, void 0, !1, "bail");
      if (i !== null && this.codePointAtPos(this.state.pos) === 59)
        return ++this.state.pos, String.fromCodePoint(i);
    } else {
      let s = 0, i = !1;
      for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) === 59); )
        ++this.state.pos;
      if (i) {
        const n = this.input.slice(t, this.state.pos), a = fO[n];
        if (++this.state.pos, a)
          return a;
      }
    }
    return this.state.pos = t, "&";
  }
  jsxReadWord() {
    let t;
    const s = this.state.pos;
    do
      t = this.input.charCodeAt(++this.state.pos);
    while (Sn(t) || t === 45);
    this.finishToken(140, this.input.slice(s, this.state.pos));
  }
  jsxParseIdentifier() {
    const t = this.startNode();
    return this.match(140) ? t.name = this.state.value : um(this.state.type) ? t.name = si(this.state.type) : this.unexpected(), this.next(), this.finishNode(t, "JSXIdentifier");
  }
  jsxParseNamespacedName() {
    const t = this.state.startLoc, s = this.jsxParseIdentifier();
    if (!this.eat(14)) return s;
    const i = this.startNodeAt(t);
    return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
  }
  jsxParseElementName() {
    const t = this.state.startLoc;
    let s = this.jsxParseNamespacedName();
    if (s.type === "JSXNamespacedName")
      return s;
    for (; this.eat(16); ) {
      const i = this.startNodeAt(t);
      i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
    }
    return s;
  }
  jsxParseAttributeValue() {
    let t;
    switch (this.state.type) {
      case 5:
        return t = this.startNode(), this.setContext(Ue.brace), this.next(), t = this.jsxParseExpressionContainer(t, Ue.j_oTag), t.expression.type === "JSXEmptyExpression" && this.raise(bi.AttributeIsEmpty, t), t;
      case 142:
      case 133:
        return this.parseExprAtom();
      default:
        throw this.raise(bi.UnsupportedJsxValue, this.state.startLoc);
    }
  }
  jsxParseEmptyExpression() {
    const t = this.startNodeAt(this.state.lastTokEndLoc);
    return this.finishNodeAt(t, "JSXEmptyExpression", this.state.startLoc);
  }
  jsxParseSpreadChild(t) {
    return this.next(), t.expression = this.parseExpression(), this.setContext(Ue.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(t, "JSXSpreadChild");
  }
  jsxParseExpressionContainer(t, s) {
    if (this.match(8))
      t.expression = this.jsxParseEmptyExpression();
    else {
      const i = this.parseExpression();
      t.expression = i;
    }
    return this.setContext(s), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(t, "JSXExpressionContainer");
  }
  jsxParseAttribute() {
    const t = this.startNode();
    return this.match(5) ? (this.setContext(Ue.brace), this.next(), this.expect(21), t.argument = this.parseMaybeAssignAllowIn(), this.setContext(Ue.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(t, "JSXSpreadAttribute")) : (t.name = this.jsxParseNamespacedName(), t.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(t, "JSXAttribute"));
  }
  jsxParseOpeningElementAt(t) {
    const s = this.startNodeAt(t);
    return this.eat(143) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s));
  }
  jsxParseOpeningElementAfterName(t) {
    const s = [];
    for (; !this.match(56) && !this.match(143); )
      s.push(this.jsxParseAttribute());
    return t.attributes = s, t.selfClosing = this.eat(56), this.expect(143), this.finishNode(t, "JSXOpeningElement");
  }
  jsxParseClosingElementAt(t) {
    const s = this.startNodeAt(t);
    return this.eat(143) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(143), this.finishNode(s, "JSXClosingElement"));
  }
  jsxParseElementAt(t) {
    const s = this.startNodeAt(t), i = [], n = this.jsxParseOpeningElementAt(t);
    let a = null;
    if (!n.selfClosing) {
      e: for (; ; )
        switch (this.state.type) {
          case 142:
            if (t = this.state.startLoc, this.next(), this.eat(56)) {
              a = this.jsxParseClosingElementAt(t);
              break e;
            }
            i.push(this.jsxParseElementAt(t));
            break;
          case 141:
            i.push(this.parseLiteral(this.state.value, "JSXText"));
            break;
          case 5: {
            const o = this.startNode();
            this.setContext(Ue.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(o)) : i.push(this.jsxParseExpressionContainer(o, Ue.j_expr));
            break;
          }
          default:
            this.unexpected();
        }
      Fs(n) && !Fs(a) && a !== null ? this.raise(bi.MissingClosingTagFragment, a) : !Fs(n) && Fs(a) ? this.raise(bi.MissingClosingTagElement, a, {
        openingTagName: hn(n.name)
      }) : !Fs(n) && !Fs(a) && hn(a.name) !== hn(n.name) && this.raise(bi.MissingClosingTagElement, a, {
        openingTagName: hn(n.name)
      });
    }
    if (Fs(n) ? (s.openingFragment = n, s.closingFragment = a) : (s.openingElement = n, s.closingElement = a), s.children = i, this.match(47))
      throw this.raise(bi.UnwrappedAdjacentJSXElements, this.state.startLoc);
    return Fs(n) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
  }
  jsxParseElement() {
    const t = this.state.startLoc;
    return this.next(), this.jsxParseElementAt(t);
  }
  setContext(t) {
    const {
      context: s
    } = this.state;
    s[s.length - 1] = t;
  }
  parseExprAtom(t) {
    return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(t);
  }
  skipSpace() {
    this.curContext().preserveSpace || super.skipSpace();
  }
  getTokenFromCode(t) {
    const s = this.curContext();
    if (s === Ue.j_expr) {
      this.jsxReadToken();
      return;
    }
    if (s === Ue.j_oTag || s === Ue.j_cTag) {
      if (ms(t)) {
        this.jsxReadWord();
        return;
      }
      if (t === 62) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      if ((t === 34 || t === 39) && s === Ue.j_oTag) {
        this.jsxReadString(t);
        return;
      }
    }
    if (t === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
      ++this.state.pos, this.finishToken(142);
      return;
    }
    super.getTokenFromCode(t);
  }
  updateContext(t) {
    const {
      context: s,
      type: i
    } = this.state;
    if (i === 56 && t === 142)
      s.splice(-2, 2, Ue.j_cTag), this.state.canStartJSXElement = !1;
    else if (i === 142)
      s.push(Ue.j_oTag);
    else if (i === 143) {
      const n = s[s.length - 1];
      n === Ue.j_oTag && t === 56 || n === Ue.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === Ue.j_expr) : (this.setContext(Ue.j_expr), this.state.canStartJSXElement = !0);
    } else
      this.state.canStartJSXElement = bN(i);
  }
};
class hO extends fm {
  constructor(...e) {
    super(...e), this.tsNames = /* @__PURE__ */ new Map();
  }
}
class dO extends pm {
  constructor(...e) {
    super(...e), this.importsStack = [];
  }
  createScope(e) {
    return this.importsStack.push(/* @__PURE__ */ new Set()), new hO(e);
  }
  enter(e) {
    e === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
  }
  exit() {
    const e = super.exit();
    return e === 256 && this.importsStack.pop(), e;
  }
  hasImport(e, t) {
    const s = this.importsStack.length;
    if (this.importsStack[s - 1].has(e))
      return !0;
    if (!t && s > 1) {
      for (let i = 0; i < s - 1; i++)
        if (this.importsStack[i].has(e)) return !0;
    }
    return !1;
  }
  declareName(e, t, s) {
    if (t & 4096) {
      this.hasImport(e, !0) && this.parser.raise(O.VarRedeclaration, s, {
        identifierName: e
      }), this.importsStack[this.importsStack.length - 1].add(e);
      return;
    }
    const i = this.currentScope();
    let n = i.tsNames.get(e) || 0;
    if (t & 1024) {
      this.maybeExportDefined(i, e), i.tsNames.set(e, n | 16);
      return;
    }
    super.declareName(e, t, s), t & 2 && (t & 1 || (this.checkRedeclarationInScope(i, e, t, s), this.maybeExportDefined(i, e)), n = n | 1), t & 256 && (n = n | 2), t & 512 && (n = n | 4), t & 128 && (n = n | 8), n && i.tsNames.set(e, n);
  }
  isRedeclaredInScope(e, t, s) {
    const i = e.tsNames.get(t);
    if ((i & 2) > 0) {
      if (s & 256) {
        const n = !!(s & 512), a = (i & 4) > 0;
        return n !== a;
      }
      return !0;
    }
    return s & 128 && (i & 8) > 0 ? e.names.get(t) & 2 ? !!(s & 1) : !1 : s & 2 && (i & 1) > 0 ? !0 : super.isRedeclaredInScope(e, t, s);
  }
  checkLocalExport(e) {
    const {
      name: t
    } = e;
    if (this.hasImport(t)) return;
    const s = this.scopeStack.length;
    for (let i = s - 1; i >= 0; i--) {
      const a = this.scopeStack[i].tsNames.get(t);
      if ((a & 1) > 0 || (a & 16) > 0)
        return;
    }
    super.checkLocalExport(e);
  }
}
const mO = (r, e) => hasOwnProperty.call(r, e) && r[e], gS = (r) => r.type === "ParenthesizedExpression" ? gS(r.expression) : r;
class gO extends iO {
  toAssignable(e, t = !1) {
    var s, i;
    let n;
    switch ((e.type === "ParenthesizedExpression" || (s = e.extra) != null && s.parenthesized) && (n = gS(e), t ? n.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(O.InvalidParenthesizedAssignment, e) : n.type !== "MemberExpression" && !this.isOptionalMemberExpression(n) && this.raise(O.InvalidParenthesizedAssignment, e) : this.raise(O.InvalidParenthesizedAssignment, e)), e.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e.type = "ObjectPattern";
        for (let o = 0, u = e.properties.length, l = u - 1; o < u; o++) {
          var a;
          const c = e.properties[o], f = o === l;
          this.toAssignableObjectExpressionProp(c, f, t), f && c.type === "RestElement" && (a = e.extra) != null && a.trailingCommaLoc && this.raise(O.RestTrailingComma, e.extra.trailingCommaLoc);
        }
        break;
      case "ObjectProperty": {
        const {
          key: o,
          value: u
        } = e;
        this.isPrivateName(o) && this.classScope.usePrivateName(this.getPrivateNameSV(o), o.loc.start), this.toAssignable(u, t);
        break;
      }
      case "SpreadElement":
        throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
      case "ArrayExpression":
        e.type = "ArrayPattern", this.toAssignableList(e.elements, (i = e.extra) == null ? void 0 : i.trailingCommaLoc, t);
        break;
      case "AssignmentExpression":
        e.operator !== "=" && this.raise(O.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(n, t);
        break;
    }
  }
  toAssignableObjectExpressionProp(e, t, s) {
    if (e.type === "ObjectMethod")
      this.raise(e.kind === "get" || e.kind === "set" ? O.PatternHasAccessor : O.PatternHasMethod, e.key);
    else if (e.type === "SpreadElement") {
      e.type = "RestElement";
      const i = e.argument;
      this.checkToRestConversion(i, !1), this.toAssignable(i, s), t || this.raise(O.RestTrailingComma, e);
    } else
      this.toAssignable(e, s);
  }
  toAssignableList(e, t, s) {
    const i = e.length - 1;
    for (let n = 0; n <= i; n++) {
      const a = e[n];
      if (a) {
        if (a.type === "SpreadElement") {
          a.type = "RestElement";
          const o = a.argument;
          this.checkToRestConversion(o, !0), this.toAssignable(o, s);
        } else
          this.toAssignable(a, s);
        a.type === "RestElement" && (n < i ? this.raise(O.RestTrailingComma, a) : t && this.raise(O.RestTrailingComma, t));
      }
    }
  }
  isAssignable(e, t) {
    switch (e.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        return !0;
      case "ObjectExpression": {
        const s = e.properties.length - 1;
        return e.properties.every((i, n) => i.type !== "ObjectMethod" && (n === s || i.type !== "SpreadElement") && this.isAssignable(i));
      }
      case "ObjectProperty":
        return this.isAssignable(e.value);
      case "SpreadElement":
        return this.isAssignable(e.argument);
      case "ArrayExpression":
        return e.elements.every((s) => s === null || this.isAssignable(s));
      case "AssignmentExpression":
        return e.operator === "=";
      case "ParenthesizedExpression":
        return this.isAssignable(e.expression);
      case "MemberExpression":
      case "OptionalMemberExpression":
        return !t;
      default:
        return !1;
    }
  }
  toReferencedList(e, t) {
    return e;
  }
  toReferencedListDeep(e, t) {
    this.toReferencedList(e, t);
    for (const s of e)
      (s == null ? void 0 : s.type) === "ArrayExpression" && this.toReferencedListDeep(s.elements);
  }
  parseSpread(e) {
    const t = this.startNode();
    return this.next(), t.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(t, "SpreadElement");
  }
  parseRestBinding() {
    const e = this.startNode();
    return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 0: {
        const e = this.startNode();
        return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
      }
      case 5:
        return this.parseObjectLike(8, !0);
    }
    return this.parseIdentifier();
  }
  parseBindingList(e, t, s) {
    const i = s & 1, n = [];
    let a = !0;
    for (; !this.eat(e); )
      if (a ? a = !1 : this.expect(12), i && this.match(12))
        n.push(null);
      else {
        if (this.eat(e))
          break;
        if (this.match(21)) {
          if (n.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s)), !this.checkCommaAfterRest(t)) {
            this.expect(e);
            break;
          }
        } else {
          const o = [];
          for (this.match(26) && this.hasPlugin("decorators") && this.raise(O.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
            o.push(this.parseDecorator());
          n.push(this.parseAssignableListItem(s, o));
        }
      }
    return n;
  }
  parseBindingRestProperty(e) {
    return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
  }
  parseBindingProperty() {
    const {
      type: e,
      startLoc: t
    } = this.state;
    if (e === 21)
      return this.parseBindingRestProperty(this.startNode());
    const s = this.startNode();
    return e === 138 ? (this.expectPlugin("destructuringPrivate", t), this.classScope.usePrivateName(this.state.value, t), s.key = this.parsePrivateName()) : this.parsePropertyName(s), s.method = !1, this.parseObjPropValue(s, t, !1, !1, !0, !1);
  }
  parseAssignableListItem(e, t) {
    const s = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(s, e);
    const i = this.parseMaybeDefault(s.loc.start, s);
    return t.length && (s.decorators = t), i;
  }
  parseAssignableListItemTypes(e, t) {
    return e;
  }
  parseMaybeDefault(e, t) {
    var s, i;
    if ((s = e) != null || (e = this.state.startLoc), t = (i = t) != null ? i : this.parseBindingAtom(), !this.eat(29)) return t;
    const n = this.startNodeAt(e);
    return n.left = t, n.right = this.parseMaybeAssignAllowIn(), this.finishNode(n, "AssignmentPattern");
  }
  isValidLVal(e, t, s) {
    return mO({
      AssignmentPattern: "left",
      RestElement: "argument",
      ObjectProperty: "value",
      ParenthesizedExpression: "expression",
      ArrayPattern: "elements",
      ObjectPattern: "properties"
    }, e);
  }
  isOptionalMemberExpression(e) {
    return e.type === "OptionalMemberExpression";
  }
  checkLVal(e, {
    in: t,
    binding: s = 64,
    checkClashes: i = !1,
    strictModeChanged: n = !1,
    hasParenthesizedAncestor: a = !1
  }) {
    var o;
    const u = e.type;
    if (this.isObjectMethod(e)) return;
    const l = this.isOptionalMemberExpression(e);
    if (l || u === "MemberExpression") {
      l && (this.expectPlugin("optionalChainingAssign", e.loc.start), t.type !== "AssignmentExpression" && this.raise(O.InvalidLhsOptionalChaining, e, {
        ancestor: t
      })), s !== 64 && this.raise(O.InvalidPropertyBindingPattern, e);
      return;
    }
    if (u === "Identifier") {
      this.checkIdentifier(e, s, n);
      const {
        name: m
      } = e;
      i && (i.has(m) ? this.raise(O.ParamDupe, e) : i.add(m));
      return;
    }
    const c = this.isValidLVal(u, !(a || (o = e.extra) != null && o.parenthesized) && t.type === "AssignmentExpression", s);
    if (c === !0) return;
    if (c === !1) {
      const m = s === 64 ? O.InvalidLhs : O.InvalidLhsBinding;
      this.raise(m, e, {
        ancestor: t
      });
      return;
    }
    const [f, p] = Array.isArray(c) ? c : [c, u === "ParenthesizedExpression"], h = u === "ArrayPattern" || u === "ObjectPattern" ? {
      type: u
    } : t;
    for (const m of [].concat(e[f]))
      m && this.checkLVal(m, {
        in: h,
        binding: s,
        checkClashes: i,
        strictModeChanged: n,
        hasParenthesizedAncestor: p
      });
  }
  checkIdentifier(e, t, s = !1) {
    this.state.strict && (s ? lS(e.name, this.inModule) : uS(e.name)) && (t === 64 ? this.raise(O.StrictEvalArguments, e, {
      referenceName: e.name
    }) : this.raise(O.StrictEvalArgumentsBinding, e, {
      bindingName: e.name
    })), t & 8192 && e.name === "let" && this.raise(O.LetInLexicalBinding, e), t & 64 || this.declareNameFromIdentifier(e, t);
  }
  declareNameFromIdentifier(e, t) {
    this.scope.declareName(e.name, t, e.loc.start);
  }
  checkToRestConversion(e, t) {
    switch (e.type) {
      case "ParenthesizedExpression":
        this.checkToRestConversion(e.expression, t);
        break;
      case "Identifier":
      case "MemberExpression":
        break;
      case "ArrayExpression":
      case "ObjectExpression":
        if (t) break;
      default:
        this.raise(O.InvalidRestAssignmentPattern, e);
    }
  }
  checkCommaAfterRest(e) {
    return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? O.RestTrailingComma : O.ElementAfterRest, this.state.startLoc), !0) : !1;
  }
}
const yO = (r, e) => hasOwnProperty.call(r, e) && r[e];
function bO(r) {
  if (r == null)
    throw new Error(`Unexpected ${r} value.`);
  return r;
}
function by(r) {
  if (!r)
    throw new Error("Assert fail");
}
const oe = gs`typescript`({
  AbstractMethodHasImplementation: ({
    methodName: r
  }) => `Method '${r}' cannot have an implementation because it is marked abstract.`,
  AbstractPropertyHasInitializer: ({
    propertyName: r
  }) => `Property '${r}' cannot have an initializer because it is marked abstract.`,
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: ({
    kind: r
  }) => `'declare' is not allowed in ${r}ters.`,
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: ({
    modifier: r
  }) => "Accessibility modifier already seen.",
  DuplicateModifier: ({
    modifier: r
  }) => `Duplicate modifier: '${r}'.`,
  EmptyHeritageClauseType: ({
    token: r
  }) => `'${r}' list cannot be empty.`,
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
  IncompatibleModifiers: ({
    modifiers: r
  }) => `'${r[0]}' modifier cannot be used with '${r[1]}' modifier.`,
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: ({
    modifier: r
  }) => `Index signatures cannot have an accessibility modifier ('${r}').`,
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
  InvalidModifierOnTypeMember: ({
    modifier: r
  }) => `'${r}' modifier cannot appear on a type member.`,
  InvalidModifierOnTypeParameter: ({
    modifier: r
  }) => `'${r}' modifier cannot appear on a type parameter.`,
  InvalidModifierOnTypeParameterPositions: ({
    modifier: r
  }) => `'${r}' modifier can only appear on a type parameter of a class, interface or type alias.`,
  InvalidModifiersOrder: ({
    orderedModifiers: r
  }) => `'${r[0]}' modifier must precede '${r[1]}' modifier.`,
  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: ({
    modifier: r
  }) => `Private elements cannot have an accessibility modifier ('${r}').`,
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  SingleTypeParameterWithoutTrailingComma: ({
    typeParameterName: r
  }) => `Single type parameter ${r} should have a trailing comma. Example usage: <${r},>.`,
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: ({
    type: r
  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${r}.`
});
function vO(r) {
  switch (r) {
    case "any":
      return "TSAnyKeyword";
    case "boolean":
      return "TSBooleanKeyword";
    case "bigint":
      return "TSBigIntKeyword";
    case "never":
      return "TSNeverKeyword";
    case "number":
      return "TSNumberKeyword";
    case "object":
      return "TSObjectKeyword";
    case "string":
      return "TSStringKeyword";
    case "symbol":
      return "TSSymbolKeyword";
    case "undefined":
      return "TSUndefinedKeyword";
    case "unknown":
      return "TSUnknownKeyword";
    default:
      return;
  }
}
function vy(r) {
  return r === "private" || r === "public" || r === "protected";
}
function EO(r) {
  return r === "in" || r === "out";
}
var SO = (r) => class extends r {
  constructor(...t) {
    super(...t), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["in", "out"],
      disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
      errorTemplate: oe.InvalidModifierOnTypeParameter
    }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["const"],
      disallowedModifiers: ["in", "out"],
      errorTemplate: oe.InvalidModifierOnTypeParameterPositions
    }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["in", "out", "const"],
      disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
      errorTemplate: oe.InvalidModifierOnTypeParameter
    });
  }
  getScopeHandler() {
    return dO;
  }
  tsIsIdentifier() {
    return Le(this.state.type);
  }
  tsTokenCanFollowModifier() {
    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
  }
  tsNextTokenCanFollowModifier() {
    return this.next(), this.tsTokenCanFollowModifier();
  }
  tsParseModifier(t, s) {
    if (!Le(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
      return;
    const i = this.state.value;
    if (t.indexOf(i) !== -1) {
      if (s && this.tsIsStartOfStaticBlocks())
        return;
      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
        return i;
    }
  }
  tsParseModifiers({
    allowedModifiers: t,
    disallowedModifiers: s,
    stopOnStartOfClassStaticBlock: i,
    errorTemplate: n = oe.InvalidModifierOnTypeMember
  }, a) {
    const o = (l, c, f, p) => {
      c === f && a[p] && this.raise(oe.InvalidModifiersOrder, l, {
        orderedModifiers: [f, p]
      });
    }, u = (l, c, f, p) => {
      (a[f] && c === p || a[p] && c === f) && this.raise(oe.IncompatibleModifiers, l, {
        modifiers: [f, p]
      });
    };
    for (; ; ) {
      const {
        startLoc: l
      } = this.state, c = this.tsParseModifier(t.concat(s ?? []), i);
      if (!c) break;
      vy(c) ? a.accessibility ? this.raise(oe.DuplicateAccessibilityModifier, l, {
        modifier: c
      }) : (o(l, c, c, "override"), o(l, c, c, "static"), o(l, c, c, "readonly"), a.accessibility = c) : EO(c) ? (a[c] && this.raise(oe.DuplicateModifier, l, {
        modifier: c
      }), a[c] = !0, o(l, c, "in", "out")) : (hasOwnProperty.call(a, c) ? this.raise(oe.DuplicateModifier, l, {
        modifier: c
      }) : (o(l, c, "static", "readonly"), o(l, c, "static", "override"), o(l, c, "override", "readonly"), o(l, c, "abstract", "override"), u(l, c, "declare", "override"), u(l, c, "static", "abstract")), a[c] = !0), s != null && s.includes(c) && this.raise(n, l, {
        modifier: c
      });
    }
  }
  tsIsListTerminator(t) {
    switch (t) {
      case "EnumMembers":
      case "TypeMembers":
        return this.match(8);
      case "HeritageClauseElement":
        return this.match(5);
      case "TupleElementTypes":
        return this.match(3);
      case "TypeParametersOrArguments":
        return this.match(48);
    }
  }
  tsParseList(t, s) {
    const i = [];
    for (; !this.tsIsListTerminator(t); )
      i.push(s());
    return i;
  }
  tsParseDelimitedList(t, s, i) {
    return bO(this.tsParseDelimitedListWorker(t, s, !0, i));
  }
  tsParseDelimitedListWorker(t, s, i, n) {
    const a = [];
    let o = -1;
    for (; !this.tsIsListTerminator(t); ) {
      o = -1;
      const u = s();
      if (u == null)
        return;
      if (a.push(u), this.eat(12)) {
        o = this.state.lastTokStartLoc.index;
        continue;
      }
      if (this.tsIsListTerminator(t))
        break;
      i && this.expect(12);
      return;
    }
    return n && (n.value = o), a;
  }
  tsParseBracketedList(t, s, i, n, a) {
    n || (i ? this.expect(0) : this.expect(47));
    const o = this.tsParseDelimitedList(t, s, a);
    return i ? this.expect(3) : this.expect(48), o;
  }
  tsParseImportType() {
    const t = this.startNode();
    return this.expect(83), this.expect(10), this.match(133) || this.raise(oe.UnsupportedImportTypeArgument, this.state.startLoc), t.argument = super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (t.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.eat(16) && (t.qualifier = this.tsParseEntityName()), this.match(47) && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, "TSImportType");
  }
  tsParseEntityName(t = !0) {
    let s = this.parseIdentifier(t);
    for (; this.eat(16); ) {
      const i = this.startNodeAtNode(s);
      i.left = s, i.right = this.parseIdentifier(t), s = this.finishNode(i, "TSQualifiedName");
    }
    return s;
  }
  tsParseTypeReference() {
    const t = this.startNode();
    return t.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, "TSTypeReference");
  }
  tsParseThisTypePredicate(t) {
    this.next();
    const s = this.startNodeAtNode(t);
    return s.parameterName = t, s.typeAnnotation = this.tsParseTypeAnnotation(!1), s.asserts = !1, this.finishNode(s, "TSTypePredicate");
  }
  tsParseThisTypeNode() {
    const t = this.startNode();
    return this.next(), this.finishNode(t, "TSThisType");
  }
  tsParseTypeQuery() {
    const t = this.startNode();
    return this.expect(87), this.match(83) ? t.exprName = this.tsParseImportType() : t.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, "TSTypeQuery");
  }
  tsParseTypeParameter(t) {
    const s = this.startNode();
    return t(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(29), this.finishNode(s, "TSTypeParameter");
  }
  tsTryParseTypeParameters(t) {
    if (this.match(47))
      return this.tsParseTypeParameters(t);
  }
  tsParseTypeParameters(t) {
    const s = this.startNode();
    this.match(47) || this.match(142) ? this.next() : this.unexpected();
    const i = {
      value: -1
    };
    return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, t), !1, !0, i), s.params.length === 0 && this.raise(oe.EmptyTypeParameters, s), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s, "TSTypeParameterDeclaration");
  }
  tsFillSignature(t, s) {
    const i = t === 19, n = "parameters", a = "typeAnnotation";
    s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[n] = this.tsParseBindingListForSignature(), i ? s[a] = this.tsParseTypeOrTypePredicateAnnotation(t) : this.match(t) && (s[a] = this.tsParseTypeOrTypePredicateAnnotation(t));
  }
  tsParseBindingListForSignature() {
    const t = super.parseBindingList(11, 41, 2);
    for (const s of t) {
      const {
        type: i
      } = s;
      (i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(oe.UnsupportedSignatureParameterKind, s, {
        type: i
      });
    }
    return t;
  }
  tsParseTypeMemberSemicolon() {
    !this.eat(12) && !this.isLineTerminator() && this.expect(13);
  }
  tsParseSignatureMember(t, s) {
    return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, t);
  }
  tsIsUnambiguouslyIndexSignature() {
    return this.next(), Le(this.state.type) ? (this.next(), this.match(14)) : !1;
  }
  tsTryParseIndexSignature(t) {
    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
      return;
    this.expect(0);
    const s = this.parseIdentifier();
    s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), t.parameters = [s];
    const i = this.tsTryParseTypeAnnotation();
    return i && (t.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(t, "TSIndexSignature");
  }
  tsParsePropertyOrMethodSignature(t, s) {
    this.eat(17) && (t.optional = !0);
    const i = t;
    if (this.match(10) || this.match(47)) {
      s && this.raise(oe.ReadonlyForMethodSignature, t);
      const n = i;
      n.kind && this.match(47) && this.raise(oe.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, n), this.tsParseTypeMemberSemicolon();
      const a = "parameters", o = "typeAnnotation";
      if (n.kind === "get")
        n[a].length > 0 && (this.raise(O.BadGetterArity, this.state.curPosition()), this.isThisParam(n[a][0]) && this.raise(oe.AccesorCannotDeclareThisParameter, this.state.curPosition()));
      else if (n.kind === "set") {
        if (n[a].length !== 1)
          this.raise(O.BadSetterArity, this.state.curPosition());
        else {
          const u = n[a][0];
          this.isThisParam(u) && this.raise(oe.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.optional && this.raise(oe.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(oe.SetAccesorCannotHaveRestParameter, this.state.curPosition());
        }
        n[o] && this.raise(oe.SetAccesorCannotHaveReturnType, n[o]);
      } else
        n.kind = "method";
      return this.finishNode(n, "TSMethodSignature");
    } else {
      const n = i;
      s && (n.readonly = !0);
      const a = this.tsTryParseTypeAnnotation();
      return a && (n.typeAnnotation = a), this.tsParseTypeMemberSemicolon(), this.finishNode(n, "TSPropertySignature");
    }
  }
  tsParseTypeMember() {
    const t = this.startNode();
    if (this.match(10) || this.match(47))
      return this.tsParseSignatureMember("TSCallSignatureDeclaration", t);
    if (this.match(77)) {
      const i = this.startNode();
      return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", t) : (t.key = this.createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(t, !1));
    }
    this.tsParseModifiers({
      allowedModifiers: ["readonly"],
      disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
    }, t);
    const s = this.tsTryParseIndexSignature(t);
    return s || (super.parsePropertyName(t), !t.computed && t.key.type === "Identifier" && (t.key.name === "get" || t.key.name === "set") && this.tsTokenCanFollowModifier() && (t.kind = t.key.name, super.parsePropertyName(t)), this.tsParsePropertyOrMethodSignature(t, !!t.readonly));
  }
  tsParseTypeLiteral() {
    const t = this.startNode();
    return t.members = this.tsParseObjectTypeMembers(), this.finishNode(t, "TSTypeLiteral");
  }
  tsParseObjectTypeMembers() {
    this.expect(5);
    const t = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
    return this.expect(8), t;
  }
  tsIsStartOfMappedType() {
    return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
  }
  tsParseMappedTypeParameter() {
    const t = this.startNode();
    return t.name = this.tsParseTypeParameterName(), t.constraint = this.tsExpectThenParseType(58), this.finishNode(t, "TSTypeParameter");
  }
  tsParseMappedType() {
    const t = this.startNode();
    return this.expect(5), this.match(53) ? (t.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (t.readonly = !0), this.expect(0), t.typeParameter = this.tsParseMappedTypeParameter(), t.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (t.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (t.optional = !0), t.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(t, "TSMappedType");
  }
  tsParseTupleType() {
    const t = this.startNode();
    t.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
    let s = !1;
    return t.elementTypes.forEach((i) => {
      const {
        type: n
      } = i;
      s && n !== "TSRestType" && n !== "TSOptionalType" && !(n === "TSNamedTupleMember" && i.optional) && this.raise(oe.OptionalTypeBeforeRequired, i), s || (s = n === "TSNamedTupleMember" && i.optional || n === "TSOptionalType");
    }), this.finishNode(t, "TSTupleType");
  }
  tsParseTupleElementType() {
    const {
      startLoc: t
    } = this.state, s = this.eat(21);
    let i, n, a, o;
    const l = Cr(this.state.type) ? this.lookaheadCharCode() : null;
    if (l === 58)
      i = !0, a = !1, n = this.parseIdentifier(!0), this.expect(14), o = this.tsParseType();
    else if (l === 63) {
      a = !0;
      const c = this.state.startLoc, f = this.state.value, p = this.tsParseNonArrayType();
      this.lookaheadCharCode() === 58 ? (i = !0, n = this.createIdentifier(this.startNodeAt(c), f), this.expect(17), this.expect(14), o = this.tsParseType()) : (i = !1, o = p, this.expect(17));
    } else
      o = this.tsParseType(), a = this.eat(17), i = this.eat(14);
    if (i) {
      let c;
      n ? (c = this.startNodeAtNode(n), c.optional = a, c.label = n, c.elementType = o, this.eat(17) && (c.optional = !0, this.raise(oe.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (c = this.startNodeAtNode(o), c.optional = a, this.raise(oe.InvalidTupleMemberLabel, o), c.label = o, c.elementType = this.tsParseType()), o = this.finishNode(c, "TSNamedTupleMember");
    } else if (a) {
      const c = this.startNodeAtNode(o);
      c.typeAnnotation = o, o = this.finishNode(c, "TSOptionalType");
    }
    if (s) {
      const c = this.startNodeAt(t);
      c.typeAnnotation = o, o = this.finishNode(c, "TSRestType");
    }
    return o;
  }
  tsParseParenthesizedType() {
    const t = this.startNode();
    return this.expect(10), t.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(t, "TSParenthesizedType");
  }
  tsParseFunctionOrConstructorType(t, s) {
    const i = this.startNode();
    return t === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i)), this.finishNode(i, t);
  }
  tsParseLiteralTypeNode() {
    const t = this.startNode();
    switch (this.state.type) {
      case 134:
      case 135:
      case 133:
      case 85:
      case 86:
        t.literal = super.parseExprAtom();
        break;
      default:
        this.unexpected();
    }
    return this.finishNode(t, "TSLiteralType");
  }
  tsParseTemplateLiteralType() {
    const t = this.startNode();
    return t.literal = super.parseTemplate(!1), this.finishNode(t, "TSLiteralType");
  }
  parseTemplateSubstitution() {
    return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
  }
  tsParseThisTypeOrThisTypePredicate() {
    const t = this.tsParseThisTypeNode();
    return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(t) : t;
  }
  tsParseNonArrayType() {
    switch (this.state.type) {
      case 133:
      case 134:
      case 135:
      case 85:
      case 86:
        return this.tsParseLiteralTypeNode();
      case 53:
        if (this.state.value === "-") {
          const t = this.startNode(), s = this.lookahead();
          return s.type !== 134 && s.type !== 135 && this.unexpected(), t.literal = this.parseMaybeUnary(), this.finishNode(t, "TSLiteralType");
        }
        break;
      case 78:
        return this.tsParseThisTypeOrThisTypePredicate();
      case 87:
        return this.tsParseTypeQuery();
      case 83:
        return this.tsParseImportType();
      case 5:
        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
      case 0:
        return this.tsParseTupleType();
      case 10:
        return this.tsParseParenthesizedType();
      case 25:
      case 24:
        return this.tsParseTemplateLiteralType();
      default: {
        const {
          type: t
        } = this.state;
        if (Le(t) || t === 88 || t === 84) {
          const s = t === 88 ? "TSVoidKeyword" : t === 84 ? "TSNullKeyword" : vO(this.state.value);
          if (s !== void 0 && this.lookaheadCharCode() !== 46) {
            const i = this.startNode();
            return this.next(), this.finishNode(i, s);
          }
          return this.tsParseTypeReference();
        }
      }
    }
    this.unexpected();
  }
  tsParseArrayTypeOrHigher() {
    let t = this.tsParseNonArrayType();
    for (; !this.hasPrecedingLineBreak() && this.eat(0); )
      if (this.match(3)) {
        const s = this.startNodeAtNode(t);
        s.elementType = t, this.expect(3), t = this.finishNode(s, "TSArrayType");
      } else {
        const s = this.startNodeAtNode(t);
        s.objectType = t, s.indexType = this.tsParseType(), this.expect(3), t = this.finishNode(s, "TSIndexedAccessType");
      }
    return t;
  }
  tsParseTypeOperator() {
    const t = this.startNode(), s = this.state.value;
    return this.next(), t.operator = s, t.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(t), this.finishNode(t, "TSTypeOperator");
  }
  tsCheckTypeAnnotationForReadOnly(t) {
    switch (t.typeAnnotation.type) {
      case "TSTupleType":
      case "TSArrayType":
        return;
      default:
        this.raise(oe.UnexpectedReadonly, t);
    }
  }
  tsParseInferType() {
    const t = this.startNode();
    this.expectContextual(115);
    const s = this.startNode();
    return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), t.typeParameter = this.finishNode(s, "TSTypeParameter"), this.finishNode(t, "TSInferType");
  }
  tsParseConstraintForInferType() {
    if (this.eat(81)) {
      const t = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
      if (this.state.inDisallowConditionalTypesContext || !this.match(17))
        return t;
    }
  }
  tsParseTypeOperatorOrHigher() {
    return wN(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
  }
  tsParseUnionOrIntersectionType(t, s, i) {
    const n = this.startNode(), a = this.eat(i), o = [];
    do
      o.push(s());
    while (this.eat(i));
    return o.length === 1 && !a ? o[0] : (n.types = o, this.finishNode(n, t));
  }
  tsParseIntersectionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
  }
  tsParseUnionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
  }
  tsIsStartOfFunctionType() {
    return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
  }
  tsSkipParameterStart() {
    if (Le(this.state.type) || this.match(78))
      return this.next(), !0;
    if (this.match(5)) {
      const {
        errors: t
      } = this.state, s = t.length;
      try {
        return this.parseObjectLike(8, !0), t.length === s;
      } catch {
        return !1;
      }
    }
    if (this.match(0)) {
      this.next();
      const {
        errors: t
      } = this.state, s = t.length;
      try {
        return super.parseBindingList(3, 93, 1), t.length === s;
      } catch {
        return !1;
      }
    }
    return !1;
  }
  tsIsUnambiguouslyStartOfFunctionType() {
    return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
  }
  tsParseTypeOrTypePredicateAnnotation(t) {
    return this.tsInType(() => {
      const s = this.startNode();
      this.expect(t);
      const i = this.startNode(), n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
      if (n && this.match(78)) {
        let u = this.tsParseThisTypeOrThisTypePredicate();
        return u.type === "TSThisType" ? (i.parameterName = u, i.asserts = !0, i.typeAnnotation = null, u = this.finishNode(i, "TSTypePredicate")) : (this.resetStartLocationFromNode(u, i), u.asserts = !0), s.typeAnnotation = u, this.finishNode(s, "TSTypeAnnotation");
      }
      const a = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
      if (!a)
        return n ? (i.parameterName = this.parseIdentifier(), i.asserts = n, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, s);
      const o = this.tsParseTypeAnnotation(!1);
      return i.parameterName = a, i.typeAnnotation = o, i.asserts = n, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation");
    });
  }
  tsTryParseTypeOrTypePredicateAnnotation() {
    if (this.match(14))
      return this.tsParseTypeOrTypePredicateAnnotation(14);
  }
  tsTryParseTypeAnnotation() {
    if (this.match(14))
      return this.tsParseTypeAnnotation();
  }
  tsTryParseType() {
    return this.tsEatThenParseType(14);
  }
  tsParseTypePredicatePrefix() {
    const t = this.parseIdentifier();
    if (this.isContextual(116) && !this.hasPrecedingLineBreak())
      return this.next(), t;
  }
  tsParseTypePredicateAsserts() {
    if (this.state.type !== 109)
      return !1;
    const t = this.state.containsEsc;
    return this.next(), !Le(this.state.type) && !this.match(78) ? !1 : (t && this.raise(O.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
      reservedWord: "asserts"
    }), !0);
  }
  tsParseTypeAnnotation(t = !0, s = this.startNode()) {
    return this.tsInType(() => {
      t && this.expect(14), s.typeAnnotation = this.tsParseType();
    }), this.finishNode(s, "TSTypeAnnotation");
  }
  tsParseType() {
    by(this.state.inType);
    const t = this.tsParseNonConditionalType();
    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
      return t;
    const s = this.startNodeAtNode(t);
    return s.checkType = t, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s, "TSConditionalType");
  }
  isAbstractConstructorSignature() {
    return this.isContextual(124) && this.lookahead().type === 77;
  }
  tsParseNonConditionalType() {
    return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
  }
  tsParseTypeAssertion() {
    this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(oe.ReservedTypeAssertion, this.state.startLoc);
    const t = this.startNode();
    return t.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), t.expression = this.parseMaybeUnary(), this.finishNode(t, "TSTypeAssertion");
  }
  tsParseHeritageClause(t) {
    const s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
      const n = this.startNode();
      return n.expression = this.tsParseEntityName(), this.match(47) && (n.typeParameters = this.tsParseTypeArguments()), this.finishNode(n, "TSExpressionWithTypeArguments");
    });
    return i.length || this.raise(oe.EmptyHeritageClauseType, s, {
      token: t
    }), i;
  }
  tsParseInterfaceDeclaration(t, s = {}) {
    if (this.hasFollowingLineBreak()) return null;
    this.expectContextual(129), s.declare && (t.declare = !0), Le(this.state.type) ? (t.id = this.parseIdentifier(), this.checkIdentifier(t.id, 130)) : (t.id = null, this.raise(oe.MissingInterfaceName, this.state.startLoc)), t.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (t.extends = this.tsParseHeritageClause("extends"));
    const i = this.startNode();
    return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), t.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(t, "TSInterfaceDeclaration");
  }
  tsParseTypeAliasDeclaration(t) {
    return t.id = this.parseIdentifier(), this.checkIdentifier(t.id, 2), t.typeAnnotation = this.tsInType(() => {
      if (t.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
        const s = this.startNode();
        return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
      }
      return this.tsParseType();
    }), this.semicolon(), this.finishNode(t, "TSTypeAliasDeclaration");
  }
  tsInNoContext(t) {
    const s = this.state.context;
    this.state.context = [s[0]];
    try {
      return t();
    } finally {
      this.state.context = s;
    }
  }
  tsInType(t) {
    const s = this.state.inType;
    this.state.inType = !0;
    try {
      return t();
    } finally {
      this.state.inType = s;
    }
  }
  tsInDisallowConditionalTypesContext(t) {
    const s = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = !0;
    try {
      return t();
    } finally {
      this.state.inDisallowConditionalTypesContext = s;
    }
  }
  tsInAllowConditionalTypesContext(t) {
    const s = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = !1;
    try {
      return t();
    } finally {
      this.state.inDisallowConditionalTypesContext = s;
    }
  }
  tsEatThenParseType(t) {
    if (this.match(t))
      return this.tsNextThenParseType();
  }
  tsExpectThenParseType(t) {
    return this.tsInType(() => (this.expect(t), this.tsParseType()));
  }
  tsNextThenParseType() {
    return this.tsInType(() => (this.next(), this.tsParseType()));
  }
  tsParseEnumMember() {
    const t = this.startNode();
    return t.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (t.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(t, "TSEnumMember");
  }
  tsParseEnumDeclaration(t, s = {}) {
    return s.const && (t.const = !0), s.declare && (t.declare = !0), this.expectContextual(126), t.id = this.parseIdentifier(), this.checkIdentifier(t.id, t.const ? 8971 : 8459), this.expect(5), t.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(t, "TSEnumDeclaration");
  }
  tsParseModuleBlock() {
    const t = this.startNode();
    return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(t.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(t, "TSModuleBlock");
  }
  tsParseModuleOrNamespaceDeclaration(t, s = !1) {
    if (t.id = this.parseIdentifier(), s || this.checkIdentifier(t.id, 1024), this.eat(16)) {
      const i = this.startNode();
      this.tsParseModuleOrNamespaceDeclaration(i, !0), t.body = i;
    } else
      this.scope.enter(256), this.prodParam.enter(0), t.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
    return this.finishNode(t, "TSModuleDeclaration");
  }
  tsParseAmbientExternalModuleDeclaration(t) {
    return this.isContextual(112) ? (t.global = !0, t.id = this.parseIdentifier()) : this.match(133) ? t.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), t.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(t, "TSModuleDeclaration");
  }
  tsParseImportEqualsDeclaration(t, s, i) {
    t.isExport = i || !1, t.id = s || this.parseIdentifier(), this.checkIdentifier(t.id, 4096), this.expect(29);
    const n = this.tsParseModuleReference();
    return t.importKind === "type" && n.type !== "TSExternalModuleReference" && this.raise(oe.ImportAliasHasImportType, n), t.moduleReference = n, this.semicolon(), this.finishNode(t, "TSImportEqualsDeclaration");
  }
  tsIsExternalModuleReference() {
    return this.isContextual(119) && this.lookaheadCharCode() === 40;
  }
  tsParseModuleReference() {
    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
  }
  tsParseExternalModuleReference() {
    const t = this.startNode();
    return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), t.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(t, "TSExternalModuleReference");
  }
  tsLookAhead(t) {
    const s = this.state.clone(), i = t();
    return this.state = s, i;
  }
  tsTryParseAndCatch(t) {
    const s = this.tryParse((i) => t() || i());
    if (!(s.aborted || !s.node))
      return s.error && (this.state = s.failState), s.node;
  }
  tsTryParse(t) {
    const s = this.state.clone(), i = t();
    if (i !== void 0 && i !== !1)
      return i;
    this.state = s;
  }
  tsTryParseDeclare(t) {
    if (this.isLineTerminator())
      return;
    let s = this.state.type, i;
    return this.isContextual(100) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
      switch (s) {
        case 68:
          return t.declare = !0, super.parseFunctionStatement(t, !1, !1);
        case 80:
          return t.declare = !0, this.parseClass(t, !0, !1);
        case 126:
          return this.tsParseEnumDeclaration(t, {
            declare: !0
          });
        case 112:
          return this.tsParseAmbientExternalModuleDeclaration(t);
        case 75:
        case 74:
          return !this.match(75) || !this.isLookaheadContextual("enum") ? (t.declare = !0, this.parseVarStatement(t, i || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(t, {
            const: !0,
            declare: !0
          }));
        case 129: {
          const n = this.tsParseInterfaceDeclaration(t, {
            declare: !0
          });
          if (n) return n;
        }
        default:
          if (Le(s))
            return this.tsParseDeclaration(t, this.state.value, !0, null);
      }
    });
  }
  tsTryParseExportDeclaration() {
    return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
  }
  tsParseExpressionStatement(t, s, i) {
    switch (s.name) {
      case "declare": {
        const n = this.tsTryParseDeclare(t);
        return n && (n.declare = !0), n;
      }
      case "global":
        if (this.match(5)) {
          this.scope.enter(256), this.prodParam.enter(0);
          const n = t;
          return n.global = !0, n.id = s, n.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(n, "TSModuleDeclaration");
        }
        break;
      default:
        return this.tsParseDeclaration(t, s.name, !1, i);
    }
  }
  tsParseDeclaration(t, s, i, n) {
    switch (s) {
      case "abstract":
        if (this.tsCheckLineTerminator(i) && (this.match(80) || Le(this.state.type)))
          return this.tsParseAbstractDeclaration(t, n);
        break;
      case "module":
        if (this.tsCheckLineTerminator(i)) {
          if (this.match(133))
            return this.tsParseAmbientExternalModuleDeclaration(t);
          if (Le(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(t);
        }
        break;
      case "namespace":
        if (this.tsCheckLineTerminator(i) && Le(this.state.type))
          return this.tsParseModuleOrNamespaceDeclaration(t);
        break;
      case "type":
        if (this.tsCheckLineTerminator(i) && Le(this.state.type))
          return this.tsParseTypeAliasDeclaration(t);
        break;
    }
  }
  tsCheckLineTerminator(t) {
    return t ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
  }
  tsTryParseGenericAsyncArrowFunction(t) {
    if (!this.match(47)) return;
    const s = this.state.maybeInArrowParameters;
    this.state.maybeInArrowParameters = !0;
    const i = this.tsTryParseAndCatch(() => {
      const n = this.startNodeAt(t);
      return n.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(n), n.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), n;
    });
    if (this.state.maybeInArrowParameters = s, !!i)
      return super.parseArrowExpression(i, null, !0);
  }
  tsParseTypeArgumentsInExpression() {
    if (this.reScan_lt() === 47)
      return this.tsParseTypeArguments();
  }
  tsParseTypeArguments() {
    const t = this.startNode();
    return t.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), t.params.length === 0 ? this.raise(oe.EmptyTypeArguments, t) : !this.state.inType && this.curContext() === Ue.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(t, "TSTypeParameterInstantiation");
  }
  tsIsDeclarationStart() {
    return TN(this.state.type);
  }
  isExportDefaultSpecifier() {
    return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
  }
  parseAssignableListItem(t, s) {
    const i = this.state.startLoc, n = {};
    this.tsParseModifiers({
      allowedModifiers: ["public", "private", "protected", "override", "readonly"]
    }, n);
    const a = n.accessibility, o = n.override, u = n.readonly;
    !(t & 4) && (a || u || o) && this.raise(oe.UnexpectedParameterModifier, i);
    const l = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(l, t);
    const c = this.parseMaybeDefault(l.loc.start, l);
    if (a || u || o) {
      const f = this.startNodeAt(i);
      return s.length && (f.decorators = s), a && (f.accessibility = a), u && (f.readonly = u), o && (f.override = o), c.type !== "Identifier" && c.type !== "AssignmentPattern" && this.raise(oe.UnsupportedParameterPropertyKind, f), f.parameter = c, this.finishNode(f, "TSParameterProperty");
    }
    return s.length && (l.decorators = s), c;
  }
  isSimpleParameter(t) {
    return t.type === "TSParameterProperty" && super.isSimpleParameter(t.parameter) || super.isSimpleParameter(t);
  }
  tsDisallowOptionalPattern(t) {
    for (const s of t.params)
      s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(oe.PatternIsOptional, s);
  }
  setArrowFunctionParameters(t, s, i) {
    super.setArrowFunctionParameters(t, s, i), this.tsDisallowOptionalPattern(t);
  }
  parseFunctionBodyAndFinish(t, s, i = !1) {
    this.match(14) && (t.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
    const n = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
    return n && !this.match(5) && this.isLineTerminator() ? this.finishNode(t, n) : n === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(oe.DeclareFunctionHasImplementation, t), t.declare) ? super.parseFunctionBodyAndFinish(t, n, i) : (this.tsDisallowOptionalPattern(t), super.parseFunctionBodyAndFinish(t, s, i));
  }
  registerFunctionStatementId(t) {
    !t.body && t.id ? this.checkIdentifier(t.id, 1024) : super.registerFunctionStatementId(t);
  }
  tsCheckForInvalidTypeCasts(t) {
    t.forEach((s) => {
      (s == null ? void 0 : s.type) === "TSTypeCastExpression" && this.raise(oe.UnexpectedTypeAnnotation, s.typeAnnotation);
    });
  }
  toReferencedList(t, s) {
    return this.tsCheckForInvalidTypeCasts(t), t;
  }
  parseArrayLike(t, s, i, n) {
    const a = super.parseArrayLike(t, s, i, n);
    return a.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(a.elements), a;
  }
  parseSubscript(t, s, i, n) {
    if (!this.hasPrecedingLineBreak() && this.match(35)) {
      this.state.canStartJSXElement = !1, this.next();
      const o = this.startNodeAt(s);
      return o.expression = t, this.finishNode(o, "TSNonNullExpression");
    }
    let a = !1;
    if (this.match(18) && this.lookaheadCharCode() === 60) {
      if (i)
        return n.stop = !0, t;
      n.optionalChainMember = a = !0, this.next();
    }
    if (this.match(47) || this.match(51)) {
      let o;
      const u = this.tsTryParseAndCatch(() => {
        if (!i && this.atPossibleAsyncArrow(t)) {
          const p = this.tsTryParseGenericAsyncArrowFunction(s);
          if (p)
            return p;
        }
        const l = this.tsParseTypeArgumentsInExpression();
        if (!l) return;
        if (a && !this.match(10)) {
          o = this.state.curPosition();
          return;
        }
        if (El(this.state.type)) {
          const p = super.parseTaggedTemplateExpression(t, s, n);
          return p.typeParameters = l, p;
        }
        if (!i && this.eat(10)) {
          const p = this.startNodeAt(s);
          return p.callee = t, p.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(p.arguments), p.typeParameters = l, n.optionalChainMember && (p.optional = a), this.finishCallExpression(p, n.optionalChainMember);
        }
        const c = this.state.type;
        if (c === 48 || c === 52 || c !== 10 && Rp(c) && !this.hasPrecedingLineBreak())
          return;
        const f = this.startNodeAt(s);
        return f.expression = t, f.typeParameters = l, this.finishNode(f, "TSInstantiationExpression");
      });
      if (o && this.unexpected(o, 10), u)
        return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(oe.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
    }
    return super.parseSubscript(t, s, i, n);
  }
  parseNewCallee(t) {
    var s;
    super.parseNewCallee(t);
    const {
      callee: i
    } = t;
    i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (t.typeParameters = i.typeParameters, t.callee = i.expression);
  }
  parseExprOp(t, s, i) {
    let n;
    if (Mu(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n = this.isContextual(120)))) {
      const a = this.startNodeAt(s);
      return a.expression = t, a.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (n && this.raise(O.UnexpectedKeyword, this.state.startLoc, {
        keyword: "const"
      }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(a, n ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(a, s, i);
    }
    return super.parseExprOp(t, s, i);
  }
  checkReservedWord(t, s, i, n) {
    this.state.isAmbientContext || super.checkReservedWord(t, s, i, n);
  }
  checkImportReflection(t) {
    super.checkImportReflection(t), t.module && t.importKind !== "value" && this.raise(oe.ImportReflectionHasImportType, t.specifiers[0].loc.start);
  }
  checkDuplicateExports() {
  }
  isPotentialImportPhase(t) {
    if (super.isPotentialImportPhase(t)) return !0;
    if (this.isContextual(130)) {
      const s = this.lookaheadCharCode();
      return t ? s === 123 || s === 42 : s !== 61;
    }
    return !t && this.isContextual(87);
  }
  applyImportPhase(t, s, i, n) {
    super.applyImportPhase(t, s, i, n), s ? t.exportKind = i === "type" ? "type" : "value" : t.importKind = i === "type" || i === "typeof" ? i : "value";
  }
  parseImport(t) {
    if (this.match(133))
      return t.importKind = "value", super.parseImport(t);
    let s;
    if (Le(this.state.type) && this.lookaheadCharCode() === 61)
      return t.importKind = "value", this.tsParseImportEqualsDeclaration(t);
    if (this.isContextual(130)) {
      const i = this.parseMaybeImportPhase(t, !1);
      if (this.lookaheadCharCode() === 61)
        return this.tsParseImportEqualsDeclaration(t, i);
      s = super.parseImportSpecifiersAndAfter(t, i);
    } else
      s = super.parseImport(t);
    return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(oe.TypeImportCannotSpecifyDefaultAndNamed, s), s;
  }
  parseExport(t, s) {
    if (this.match(83)) {
      this.next();
      const i = t;
      let n = null;
      return this.isContextual(130) && this.isPotentialImportPhase(!1) ? n = this.parseMaybeImportPhase(i, !1) : i.importKind = "value", this.tsParseImportEqualsDeclaration(i, n, !0);
    } else if (this.eat(29)) {
      const i = t;
      return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(i, "TSExportAssignment");
    } else if (this.eatContextual(93)) {
      const i = t;
      return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
    } else
      return super.parseExport(t, s);
  }
  isAbstractClass() {
    return this.isContextual(124) && this.lookahead().type === 80;
  }
  parseExportDefaultExpression() {
    if (this.isAbstractClass()) {
      const t = this.startNode();
      return this.next(), t.abstract = !0, this.parseClass(t, !0, !0);
    }
    if (this.match(129)) {
      const t = this.tsParseInterfaceDeclaration(this.startNode());
      if (t) return t;
    }
    return super.parseExportDefaultExpression();
  }
  parseVarStatement(t, s, i = !1) {
    const {
      isAmbientContext: n
    } = this.state, a = super.parseVarStatement(t, s, i || n);
    if (!n) return a;
    for (const {
      id: o,
      init: u
    } of a.declarations)
      u && (s !== "const" || o.typeAnnotation ? this.raise(oe.InitializerNotAllowedInAmbientContext, u) : xO(u, this.hasPlugin("estree")) || this.raise(oe.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
    return a;
  }
  parseStatementContent(t, s) {
    if (this.match(75) && this.isLookaheadContextual("enum")) {
      const i = this.startNode();
      return this.expect(75), this.tsParseEnumDeclaration(i, {
        const: !0
      });
    }
    if (this.isContextual(126))
      return this.tsParseEnumDeclaration(this.startNode());
    if (this.isContextual(129)) {
      const i = this.tsParseInterfaceDeclaration(this.startNode());
      if (i) return i;
    }
    return super.parseStatementContent(t, s);
  }
  parseAccessModifier() {
    return this.tsParseModifier(["public", "protected", "private"]);
  }
  tsHasSomeModifiers(t, s) {
    return s.some((i) => vy(i) ? t.accessibility === i : !!t[i]);
  }
  tsIsStartOfStaticBlocks() {
    return this.isContextual(106) && this.lookaheadCharCode() === 123;
  }
  parseClassMember(t, s, i) {
    const n = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
    this.tsParseModifiers({
      allowedModifiers: n,
      disallowedModifiers: ["in", "out"],
      stopOnStartOfClassStaticBlock: !0,
      errorTemplate: oe.InvalidModifierOnTypeParameterPositions
    }, s);
    const a = () => {
      this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, n) && this.raise(oe.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(t, s)) : this.parseClassMemberWithIsStatic(t, s, i, !!s.static);
    };
    s.declare ? this.tsInAmbientContext(a) : a();
  }
  parseClassMemberWithIsStatic(t, s, i, n) {
    const a = this.tsTryParseIndexSignature(s);
    if (a) {
      t.body.push(a), s.abstract && this.raise(oe.IndexSignatureHasAbstract, s), s.accessibility && this.raise(oe.IndexSignatureHasAccessibility, s, {
        modifier: s.accessibility
      }), s.declare && this.raise(oe.IndexSignatureHasDeclare, s), s.override && this.raise(oe.IndexSignatureHasOverride, s);
      return;
    }
    !this.state.inAbstractClass && s.abstract && this.raise(oe.NonAbstractClassHasAbstractMethod, s), s.override && (i.hadSuperClass || this.raise(oe.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(t, s, i, n);
  }
  parsePostMemberNameModifiers(t) {
    this.eat(17) && (t.optional = !0), t.readonly && this.match(10) && this.raise(oe.ClassMethodHasReadonly, t), t.declare && this.match(10) && this.raise(oe.ClassMethodHasDeclare, t);
  }
  parseExpressionStatement(t, s, i) {
    return (s.type === "Identifier" ? this.tsParseExpressionStatement(t, s, i) : void 0) || super.parseExpressionStatement(t, s, i);
  }
  shouldParseExportDeclaration() {
    return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
  }
  parseConditional(t, s, i) {
    if (!this.state.maybeInArrowParameters || !this.match(17))
      return super.parseConditional(t, s, i);
    const n = this.tryParse(() => super.parseConditional(t, s));
    return n.node ? (n.error && (this.state = n.failState), n.node) : (n.error && super.setOptionalParametersError(i, n.error), t);
  }
  parseParenItem(t, s) {
    const i = super.parseParenItem(t, s);
    if (this.eat(17) && (i.optional = !0, this.resetEndLocation(t)), this.match(14)) {
      const n = this.startNodeAt(s);
      return n.expression = t, n.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(n, "TSTypeCastExpression");
    }
    return t;
  }
  parseExportDeclaration(t) {
    if (!this.state.isAmbientContext && this.isContextual(125))
      return this.tsInAmbientContext(() => this.parseExportDeclaration(t));
    const s = this.state.startLoc, i = this.eatContextual(125);
    if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
      throw this.raise(oe.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
    const a = Le(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(t);
    return a ? ((a.type === "TSInterfaceDeclaration" || a.type === "TSTypeAliasDeclaration" || i) && (t.exportKind = "type"), i && (this.resetStartLocation(a, s), a.declare = !0), a) : null;
  }
  parseClassId(t, s, i, n) {
    if ((!s || i) && this.isContextual(113))
      return;
    super.parseClassId(t, s, i, t.declare ? 1024 : 8331);
    const a = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
    a && (t.typeParameters = a);
  }
  parseClassPropertyAnnotation(t) {
    t.optional || (this.eat(35) ? t.definite = !0 : this.eat(17) && (t.optional = !0));
    const s = this.tsTryParseTypeAnnotation();
    s && (t.typeAnnotation = s);
  }
  parseClassProperty(t) {
    if (this.parseClassPropertyAnnotation(t), this.state.isAmbientContext && !(t.readonly && !t.typeAnnotation) && this.match(29) && this.raise(oe.DeclareClassFieldHasInitializer, this.state.startLoc), t.abstract && this.match(29)) {
      const {
        key: s
      } = t;
      this.raise(oe.AbstractPropertyHasInitializer, this.state.startLoc, {
        propertyName: s.type === "Identifier" && !t.computed ? s.name : `[${this.input.slice(s.start, s.end)}]`
      });
    }
    return super.parseClassProperty(t);
  }
  parseClassPrivateProperty(t) {
    return t.abstract && this.raise(oe.PrivateElementHasAbstract, t), t.accessibility && this.raise(oe.PrivateElementHasAccessibility, t, {
      modifier: t.accessibility
    }), this.parseClassPropertyAnnotation(t), super.parseClassPrivateProperty(t);
  }
  parseClassAccessorProperty(t) {
    return this.parseClassPropertyAnnotation(t), t.optional && this.raise(oe.AccessorCannotBeOptional, t), super.parseClassAccessorProperty(t);
  }
  pushClassMethod(t, s, i, n, a, o) {
    const u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    u && a && this.raise(oe.ConstructorHasTypeParameters, u);
    const {
      declare: l = !1,
      kind: c
    } = s;
    l && (c === "get" || c === "set") && this.raise(oe.DeclareAccessor, s, {
      kind: c
    }), u && (s.typeParameters = u), super.pushClassMethod(t, s, i, n, a, o);
  }
  pushClassPrivateMethod(t, s, i, n) {
    const a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    a && (s.typeParameters = a), super.pushClassPrivateMethod(t, s, i, n);
  }
  declareClassPrivateMethodInScope(t, s) {
    t.type !== "TSDeclareMethod" && (t.type === "MethodDefinition" && !hasOwnProperty.call(t.value, "body") || super.declareClassPrivateMethodInScope(t, s));
  }
  parseClassSuper(t) {
    super.parseClassSuper(t), t.superClass && (this.match(47) || this.match(51)) && (t.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (t.implements = this.tsParseHeritageClause("implements"));
  }
  parseObjPropValue(t, s, i, n, a, o, u) {
    const l = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    return l && (t.typeParameters = l), super.parseObjPropValue(t, s, i, n, a, o, u);
  }
  parseFunctionParams(t, s) {
    const i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    i && (t.typeParameters = i), super.parseFunctionParams(t, s);
  }
  parseVarId(t, s) {
    super.parseVarId(t, s), t.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (t.definite = !0);
    const i = this.tsTryParseTypeAnnotation();
    i && (t.id.typeAnnotation = i, this.resetEndLocation(t.id));
  }
  parseAsyncArrowFromCallExpression(t, s) {
    return this.match(14) && (t.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(t, s);
  }
  parseMaybeAssign(t, s) {
    var i, n, a, o, u;
    let l, c, f;
    if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
      if (l = this.state.clone(), c = this.tryParse(() => super.parseMaybeAssign(t, s), l), !c.error) return c.node;
      const {
        context: m
      } = this.state, d = m[m.length - 1];
      (d === Ue.j_oTag || d === Ue.j_expr) && m.pop();
    }
    if (!((i = c) != null && i.error) && !this.match(47))
      return super.parseMaybeAssign(t, s);
    (!l || l === this.state) && (l = this.state.clone());
    let p;
    const h = this.tryParse((m) => {
      var d, y;
      p = this.tsParseTypeParameters(this.tsParseConstModifier);
      const S = super.parseMaybeAssign(t, s);
      return (S.type !== "ArrowFunctionExpression" || (d = S.extra) != null && d.parenthesized) && m(), ((y = p) == null ? void 0 : y.params.length) !== 0 && this.resetStartLocationFromNode(S, p), S.typeParameters = p, S;
    }, l);
    if (!h.error && !h.aborted)
      return p && this.reportReservedArrowTypeParam(p), h.node;
    if (!c && (by(!this.hasPlugin("jsx")), f = this.tryParse(() => super.parseMaybeAssign(t, s), l), !f.error))
      return f.node;
    if ((n = c) != null && n.node)
      return this.state = c.failState, c.node;
    if (h.node)
      return this.state = h.failState, p && this.reportReservedArrowTypeParam(p), h.node;
    if ((a = f) != null && a.node)
      return this.state = f.failState, f.node;
    throw ((o = c) == null ? void 0 : o.error) || h.error || ((u = f) == null ? void 0 : u.error);
  }
  reportReservedArrowTypeParam(t) {
    var s;
    t.params.length === 1 && !t.params[0].constraint && !((s = t.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(oe.ReservedArrowTypeParam, t);
  }
  parseMaybeUnary(t, s) {
    return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(t, s);
  }
  parseArrow(t) {
    if (this.match(14)) {
      const s = this.tryParse((i) => {
        const n = this.tsParseTypeOrTypePredicateAnnotation(14);
        return (this.canInsertSemicolon() || !this.match(19)) && i(), n;
      });
      if (s.aborted) return;
      s.thrown || (s.error && (this.state = s.failState), t.returnType = s.node);
    }
    return super.parseArrow(t);
  }
  parseAssignableListItemTypes(t, s) {
    if (!(s & 2)) return t;
    this.eat(17) && (t.optional = !0);
    const i = this.tsTryParseTypeAnnotation();
    return i && (t.typeAnnotation = i), this.resetEndLocation(t), t;
  }
  isAssignable(t, s) {
    switch (t.type) {
      case "TSTypeCastExpression":
        return this.isAssignable(t.expression, s);
      case "TSParameterProperty":
        return !0;
      default:
        return super.isAssignable(t, s);
    }
  }
  toAssignable(t, s = !1) {
    switch (t.type) {
      case "ParenthesizedExpression":
        this.toAssignableParenthesizedExpression(t, s);
        break;
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        s ? this.expressionScope.recordArrowParameterBindingError(oe.UnexpectedTypeCastInParameter, t) : this.raise(oe.UnexpectedTypeCastInParameter, t), this.toAssignable(t.expression, s);
        break;
      case "AssignmentExpression":
        !s && t.left.type === "TSTypeCastExpression" && (t.left = this.typeCastToParameter(t.left));
      default:
        super.toAssignable(t, s);
    }
  }
  toAssignableParenthesizedExpression(t, s) {
    switch (t.expression.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
      case "ParenthesizedExpression":
        this.toAssignable(t.expression, s);
        break;
      default:
        super.toAssignable(t, s);
    }
  }
  checkToRestConversion(t, s) {
    switch (t.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        this.checkToRestConversion(t.expression, !1);
        break;
      default:
        super.checkToRestConversion(t, s);
    }
  }
  isValidLVal(t, s, i) {
    return yO({
      TSTypeCastExpression: !0,
      TSParameterProperty: "parameter",
      TSNonNullExpression: "expression",
      TSInstantiationExpression: "expression",
      TSAsExpression: (i !== 64 || !s) && ["expression", !0],
      TSSatisfiesExpression: (i !== 64 || !s) && ["expression", !0],
      TSTypeAssertion: (i !== 64 || !s) && ["expression", !0]
    }, t) || super.isValidLVal(t, s, i);
  }
  parseBindingAtom() {
    return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
  }
  parseMaybeDecoratorArguments(t) {
    if (this.match(47) || this.match(51)) {
      const s = this.tsParseTypeArgumentsInExpression();
      if (this.match(10)) {
        const i = super.parseMaybeDecoratorArguments(t);
        return i.typeParameters = s, i;
      }
      this.unexpected(null, 10);
    }
    return super.parseMaybeDecoratorArguments(t);
  }
  checkCommaAfterRest(t) {
    return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === t ? (this.next(), !1) : super.checkCommaAfterRest(t);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(35) || this.match(14) || super.isClassProperty();
  }
  parseMaybeDefault(t, s) {
    const i = super.parseMaybeDefault(t, s);
    return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(oe.TypeAnnotationAfterAssign, i.typeAnnotation), i;
  }
  getTokenFromCode(t) {
    if (this.state.inType) {
      if (t === 62) {
        this.finishOp(48, 1);
        return;
      }
      if (t === 60) {
        this.finishOp(47, 1);
        return;
      }
    }
    super.getTokenFromCode(t);
  }
  reScan_lt_gt() {
    const {
      type: t
    } = this.state;
    t === 47 ? (this.state.pos -= 1, this.readToken_lt()) : t === 48 && (this.state.pos -= 1, this.readToken_gt());
  }
  reScan_lt() {
    const {
      type: t
    } = this.state;
    return t === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : t;
  }
  toAssignableList(t, s, i) {
    for (let n = 0; n < t.length; n++) {
      const a = t[n];
      (a == null ? void 0 : a.type) === "TSTypeCastExpression" && (t[n] = this.typeCastToParameter(a));
    }
    super.toAssignableList(t, s, i);
  }
  typeCastToParameter(t) {
    return t.expression.typeAnnotation = t.typeAnnotation, this.resetEndLocation(t.expression, t.typeAnnotation.loc.end), t.expression;
  }
  shouldParseArrow(t) {
    return this.match(14) ? t.every((s) => this.isAssignable(s, !0)) : super.shouldParseArrow(t);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  canHaveLeadingDecorator() {
    return super.canHaveLeadingDecorator() || this.isAbstractClass();
  }
  jsxParseOpeningElementAfterName(t) {
    if (this.match(47) || this.match(51)) {
      const s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
      s && (t.typeParameters = s);
    }
    return super.jsxParseOpeningElementAfterName(t);
  }
  getGetterSetterExpectedParamCount(t) {
    const s = super.getGetterSetterExpectedParamCount(t), n = this.getObjectOrClassMethodParams(t)[0];
    return n && this.isThisParam(n) ? s + 1 : s;
  }
  parseCatchClauseParam() {
    const t = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
    return s && (t.typeAnnotation = s, this.resetEndLocation(t)), t;
  }
  tsInAmbientContext(t) {
    const s = this.state.isAmbientContext;
    this.state.isAmbientContext = !0;
    try {
      return t();
    } finally {
      this.state.isAmbientContext = s;
    }
  }
  parseClass(t, s, i) {
    const n = this.state.inAbstractClass;
    this.state.inAbstractClass = !!t.abstract;
    try {
      return super.parseClass(t, s, i);
    } finally {
      this.state.inAbstractClass = n;
    }
  }
  tsParseAbstractDeclaration(t, s) {
    if (this.match(80))
      return t.abstract = !0, this.maybeTakeDecorators(s, this.parseClass(t, !0, !1));
    if (this.isContextual(129)) {
      if (!this.hasFollowingLineBreak())
        return t.abstract = !0, this.raise(oe.NonClassMethodPropertyHasAbstractModifer, t), this.tsParseInterfaceDeclaration(t);
    } else
      this.unexpected(null, 80);
  }
  parseMethod(t, s, i, n, a, o, u) {
    const l = super.parseMethod(t, s, i, n, a, o, u);
    if (l.abstract && (this.hasPlugin("estree") ? !!l.value.body : !!l.body)) {
      const {
        key: f
      } = l;
      this.raise(oe.AbstractMethodHasImplementation, l, {
        methodName: f.type === "Identifier" && !l.computed ? f.name : `[${this.input.slice(f.start, f.end)}]`
      });
    }
    return l;
  }
  tsParseTypeParameterName() {
    return this.parseIdentifier().name;
  }
  shouldParseAsAmbientContext() {
    return !!this.getPluginOption("typescript", "dts");
  }
  parse() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
  }
  getExpression() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
  }
  parseExportSpecifier(t, s, i, n) {
    return !s && n ? (this.parseTypeOnlyImportExportSpecifier(t, !1, i), this.finishNode(t, "ExportSpecifier")) : (t.exportKind = "value", super.parseExportSpecifier(t, s, i, n));
  }
  parseImportSpecifier(t, s, i, n, a) {
    return !s && n ? (this.parseTypeOnlyImportExportSpecifier(t, !0, i), this.finishNode(t, "ImportSpecifier")) : (t.importKind = "value", super.parseImportSpecifier(t, s, i, n, i ? 4098 : 4096));
  }
  parseTypeOnlyImportExportSpecifier(t, s, i) {
    const n = s ? "imported" : "local", a = s ? "local" : "exported";
    let o = t[n], u, l = !1, c = !0;
    const f = o.loc.start;
    if (this.isContextual(93)) {
      const h = this.parseIdentifier();
      if (this.isContextual(93)) {
        const m = this.parseIdentifier();
        Cr(this.state.type) ? (l = !0, o = h, u = s ? this.parseIdentifier() : this.parseModuleExportName(), c = !1) : (u = m, c = !1);
      } else Cr(this.state.type) ? (c = !1, u = s ? this.parseIdentifier() : this.parseModuleExportName()) : (l = !0, o = h);
    } else Cr(this.state.type) && (l = !0, s ? (o = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, !0, !0)) : o = this.parseModuleExportName());
    l && i && this.raise(s ? oe.TypeModifierIsUsedInTypeImports : oe.TypeModifierIsUsedInTypeExports, f), t[n] = o, t[a] = u;
    const p = s ? "importKind" : "exportKind";
    t[p] = l ? "type" : "value", c && this.eatContextual(93) && (t[a] = s ? this.parseIdentifier() : this.parseModuleExportName()), t[a] || (t[a] = Ss(t[n])), s && this.checkIdentifier(t[a], l ? 4098 : 4096);
  }
};
function _O(r) {
  if (r.type !== "MemberExpression") return !1;
  const {
    computed: e,
    property: t
  } = r;
  return e && t.type !== "StringLiteral" && (t.type !== "TemplateLiteral" || t.expressions.length > 0) ? !1 : bS(r.object);
}
function xO(r, e) {
  var t;
  const {
    type: s
  } = r;
  if ((t = r.extra) != null && t.parenthesized)
    return !1;
  if (e) {
    if (s === "Literal") {
      const {
        value: i
      } = r;
      if (typeof i == "string" || typeof i == "boolean")
        return !0;
    }
  } else if (s === "StringLiteral" || s === "BooleanLiteral")
    return !0;
  return !!(yS(r, e) || wO(r, e) || s === "TemplateLiteral" && r.expressions.length === 0 || _O(r));
}
function yS(r, e) {
  return e ? r.type === "Literal" && (typeof r.value == "number" || "bigint" in r) : r.type === "NumericLiteral" || r.type === "BigIntLiteral";
}
function wO(r, e) {
  if (r.type === "UnaryExpression") {
    const {
      operator: t,
      argument: s
    } = r;
    if (t === "-" && yS(s, e))
      return !0;
  }
  return !1;
}
function bS(r) {
  return r.type === "Identifier" ? !0 : r.type !== "MemberExpression" || r.computed ? !1 : bS(r.object);
}
const Ey = gs`placeholders`({
  ClassNameIsRequired: "A class name is required.",
  UnexpectedSpace: "Unexpected space in placeholder."
});
var TO = (r) => class extends r {
  parsePlaceholder(t) {
    if (this.match(144)) {
      const s = this.startNode();
      return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(s, t);
    }
  }
  finishPlaceholder(t, s) {
    let i = t;
    return (!i.expectedNode || !i.type) && (i = this.finishNode(i, "Placeholder")), i.expectedNode = s, i;
  }
  getTokenFromCode(t) {
    t === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(t);
  }
  parseExprAtom(t) {
    return this.parsePlaceholder("Expression") || super.parseExprAtom(t);
  }
  parseIdentifier(t) {
    return this.parsePlaceholder("Identifier") || super.parseIdentifier(t);
  }
  checkReservedWord(t, s, i, n) {
    t !== void 0 && super.checkReservedWord(t, s, i, n);
  }
  parseBindingAtom() {
    return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
  }
  isValidLVal(t, s, i) {
    return t === "Placeholder" || super.isValidLVal(t, s, i);
  }
  toAssignable(t, s) {
    t && t.type === "Placeholder" && t.expectedNode === "Expression" ? t.expectedNode = "Pattern" : super.toAssignable(t, s);
  }
  chStartsBindingIdentifier(t, s) {
    return !!(super.chStartsBindingIdentifier(t, s) || this.lookahead().type === 144);
  }
  verifyBreakContinue(t, s) {
    t.label && t.label.type === "Placeholder" || super.verifyBreakContinue(t, s);
  }
  parseExpressionStatement(t, s) {
    var i;
    if (s.type !== "Placeholder" || (i = s.extra) != null && i.parenthesized)
      return super.parseExpressionStatement(t, s);
    if (this.match(14)) {
      const a = t;
      return a.label = this.finishPlaceholder(s, "Identifier"), this.next(), a.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(a, "LabeledStatement");
    }
    this.semicolon();
    const n = t;
    return n.name = s.name, this.finishPlaceholder(n, "Statement");
  }
  parseBlock(t, s, i) {
    return this.parsePlaceholder("BlockStatement") || super.parseBlock(t, s, i);
  }
  parseFunctionId(t) {
    return this.parsePlaceholder("Identifier") || super.parseFunctionId(t);
  }
  parseClass(t, s, i) {
    const n = s ? "ClassDeclaration" : "ClassExpression";
    this.next();
    const a = this.state.strict, o = this.parsePlaceholder("Identifier");
    if (o)
      if (this.match(81) || this.match(144) || this.match(5))
        t.id = o;
      else {
        if (i || !s)
          return t.id = null, t.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(t, n);
        throw this.raise(Ey.ClassNameIsRequired, this.state.startLoc);
      }
    else
      this.parseClassId(t, s, i);
    return super.parseClassSuper(t), t.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!t.superClass, a), this.finishNode(t, n);
  }
  parseExport(t, s) {
    const i = this.parsePlaceholder("Identifier");
    if (!i) return super.parseExport(t, s);
    const n = t;
    if (!this.isContextual(98) && !this.match(12))
      return n.specifiers = [], n.source = null, n.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(n, "ExportNamedDeclaration");
    this.expectPlugin("exportDefaultFrom");
    const a = this.startNode();
    return a.exported = i, n.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(n, s);
  }
  isExportDefaultSpecifier() {
    if (this.match(65)) {
      const t = this.nextTokenStart();
      if (this.isUnparsedContextual(t, "from") && this.input.startsWith(si(144), this.nextTokenStartSince(t + 4)))
        return !0;
    }
    return super.isExportDefaultSpecifier();
  }
  maybeParseExportDefaultSpecifier(t, s) {
    var i;
    return (i = t.specifiers) != null && i.length ? !0 : super.maybeParseExportDefaultSpecifier(t, s);
  }
  checkExport(t) {
    const {
      specifiers: s
    } = t;
    s != null && s.length && (t.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(t), t.specifiers = s;
  }
  parseImport(t) {
    const s = this.parsePlaceholder("Identifier");
    if (!s) return super.parseImport(t);
    if (t.specifiers = [], !this.isContextual(98) && !this.match(12))
      return t.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(t, "ImportDeclaration");
    const i = this.startNodeAtNode(s);
    return i.local = s, t.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(t) || this.parseNamedImportSpecifiers(t)), this.expectContextual(98), t.source = this.parseImportSource(), this.semicolon(), this.finishNode(t, "ImportDeclaration");
  }
  parseImportSource() {
    return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
  }
  assertNoSpace() {
    this.state.start > this.state.lastTokEndLoc.index && this.raise(Ey.UnexpectedSpace, this.state.lastTokEndLoc);
  }
}, PO = (r) => class extends r {
  parseV8Intrinsic() {
    if (this.match(54)) {
      const t = this.state.startLoc, s = this.startNode();
      if (this.next(), Le(this.state.type)) {
        const i = this.parseIdentifierName(), n = this.createIdentifier(s, i);
        if (n.type = "V8IntrinsicIdentifier", this.match(10))
          return n;
      }
      this.unexpected(t);
    }
  }
  parseExprAtom(t) {
    return this.parseV8Intrinsic() || super.parseExprAtom(t);
  }
};
function lt(r, e) {
  const [t, s] = typeof e == "string" ? [e, {}] : e, i = Object.keys(s), n = i.length === 0;
  return r.some((a) => {
    if (typeof a == "string")
      return n && a === t;
    {
      const [o, u] = a;
      if (o !== t)
        return !1;
      for (const l of i)
        if (u[l] !== s[l])
          return !1;
      return !0;
    }
  });
}
function vi(r, e, t) {
  const s = r.find((i) => Array.isArray(i) ? i[0] === e : i === e);
  return s && Array.isArray(s) && s.length > 1 ? s[1][t] : null;
}
const Sy = ["minimal", "fsharp", "hack", "smart"], _y = ["^^", "@@", "^", "%", "#"];
function AO(r) {
  if (lt(r, "decorators")) {
    if (lt(r, "decorators-legacy"))
      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    const e = vi(r, "decorators", "decoratorsBeforeExport");
    if (e != null && typeof e != "boolean")
      throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
    const t = vi(r, "decorators", "allowCallParenthesized");
    if (t != null && typeof t != "boolean")
      throw new Error("'allowCallParenthesized' must be a boolean.");
  }
  if (lt(r, "flow") && lt(r, "typescript"))
    throw new Error("Cannot combine flow and typescript plugins.");
  if (lt(r, "placeholders") && lt(r, "v8intrinsic"))
    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
  if (lt(r, "pipelineOperator")) {
    const e = vi(r, "pipelineOperator", "proposal");
    if (!Sy.includes(e)) {
      const i = Sy.map((n) => `"${n}"`).join(", ");
      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
    }
    const t = ["recordAndTuple", {
      syntaxType: "hash"
    }], s = lt(r, t);
    if (e === "hack") {
      if (lt(r, "placeholders"))
        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
      if (lt(r, "v8intrinsic"))
        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
      const i = vi(r, "pipelineOperator", "topicToken");
      if (!_y.includes(i)) {
        const n = _y.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${n}.`);
      }
      if (i === "#" && s)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(t)}\`.`);
    } else if (e === "smart" && s)
      throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(t)}\`.`);
  }
  if (lt(r, "moduleAttributes")) {
    if (lt(r, "importAssertions") || lt(r, "importAttributes"))
      throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
    if (vi(r, "moduleAttributes", "version") !== "may-2020")
      throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
  }
  if (lt(r, "importAssertions") && lt(r, "importAttributes"))
    throw new Error("Cannot combine importAssertions and importAttributes plugins.");
  if (lt(r, "recordAndTuple")) {
    const e = vi(r, "recordAndTuple", "syntaxType");
    if (e != null) {
      const t = ["hash", "bar"];
      if (!t.includes(e))
        throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + t.map((s) => `'${s}'`).join(", "));
    }
  }
  if (lt(r, "asyncDoExpressions") && !lt(r, "doExpressions")) {
    const e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
    throw e.missingPlugins = "doExpressions", e;
  }
  if (lt(r, "optionalChainingAssign") && vi(r, "optionalChainingAssign", "version") !== "2023-07")
    throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
}
const vS = {
  estree: dN,
  jsx: pO,
  flow: cO,
  typescript: SO,
  v8intrinsic: PO,
  placeholders: TO
}, CO = Object.keys(vS), Mf = {
  sourceType: "script",
  sourceFilename: void 0,
  startColumn: 0,
  startLine: 1,
  allowAwaitOutsideFunction: !1,
  allowReturnOutsideFunction: !1,
  allowNewTargetOutsideFunction: !1,
  allowImportExportEverywhere: !1,
  allowSuperOutsideMethod: !1,
  allowUndeclaredExports: !1,
  plugins: [],
  strictMode: null,
  ranges: !1,
  tokens: !1,
  createImportExpressions: !1,
  createParenthesizedExpressions: !1,
  errorRecovery: !1,
  attachComment: !0,
  annexB: !0
};
function NO(r) {
  if (r == null)
    return Object.assign({}, Mf);
  if (r.annexB != null && r.annexB !== !1)
    throw new Error("The `annexB` option can only be set to `false`.");
  const e = {};
  for (const s of Object.keys(Mf)) {
    var t;
    e[s] = (t = r[s]) != null ? t : Mf[s];
  }
  return e;
}
class OO extends gO {
  checkProto(e, t, s, i) {
    if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
      return;
    const n = e.key;
    if ((n.type === "Identifier" ? n.name : n.value) === "__proto__") {
      if (t) {
        this.raise(O.RecordNoProto, n);
        return;
      }
      s.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = n.loc.start) : this.raise(O.DuplicateProto, n)), s.used = !0;
    }
  }
  shouldExitDescending(e, t) {
    return e.type === "ArrowFunctionExpression" && e.start === t;
  }
  getExpression() {
    this.enterInitialScopes(), this.nextToken();
    const e = this.parseExpression();
    return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors, this.options.tokens && (e.tokens = this.tokens), e;
  }
  parseExpression(e, t) {
    return e ? this.disallowInAnd(() => this.parseExpressionBase(t)) : this.allowInAnd(() => this.parseExpressionBase(t));
  }
  parseExpressionBase(e) {
    const t = this.state.startLoc, s = this.parseMaybeAssign(e);
    if (this.match(12)) {
      const i = this.startNodeAt(t);
      for (i.expressions = [s]; this.eat(12); )
        i.expressions.push(this.parseMaybeAssign(e));
      return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
    }
    return s;
  }
  parseMaybeAssignDisallowIn(e, t) {
    return this.disallowInAnd(() => this.parseMaybeAssign(e, t));
  }
  parseMaybeAssignAllowIn(e, t) {
    return this.allowInAnd(() => this.parseMaybeAssign(e, t));
  }
  setOptionalParametersError(e, t) {
    var s;
    e.optionalParametersLoc = (s = t == null ? void 0 : t.loc) != null ? s : this.state.startLoc;
  }
  parseMaybeAssign(e, t) {
    const s = this.state.startLoc;
    if (this.isContextual(108) && this.prodParam.hasYield) {
      let o = this.parseYield();
      return t && (o = t.call(this, o, s)), o;
    }
    let i;
    e ? i = !1 : (e = new Fu(), i = !0);
    const {
      type: n
    } = this.state;
    (n === 10 || Le(n)) && (this.state.potentialArrowAt = this.state.start);
    let a = this.parseMaybeConditional(e);
    if (t && (a = t.call(this, a, s)), vN(this.state.type)) {
      const o = this.startNodeAt(s), u = this.state.value;
      if (o.operator = u, this.match(29)) {
        this.toAssignable(a, !0), o.left = a;
        const l = s.index;
        e.doubleProtoLoc != null && e.doubleProtoLoc.index >= l && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.index >= l && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= l && (this.checkDestructuringPrivate(e), e.privateKeyLoc = null);
      } else
        o.left = a;
      return this.next(), o.right = this.parseMaybeAssign(), this.checkLVal(a, {
        in: this.finishNode(o, "AssignmentExpression")
      }), o;
    } else i && this.checkExpressionErrors(e, !0);
    return a;
  }
  parseMaybeConditional(e) {
    const t = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprOps(e);
    return this.shouldExitDescending(i, s) ? i : this.parseConditional(i, t, e);
  }
  parseConditional(e, t, s) {
    if (this.eat(17)) {
      const i = this.startNodeAt(t);
      return i.test = e, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(i, "ConditionalExpression");
    }
    return e;
  }
  parseMaybeUnaryOrPrivate(e) {
    return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(e);
  }
  parseExprOps(e) {
    const t = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(e);
    return this.shouldExitDescending(i, s) ? i : this.parseExprOp(i, t, -1);
  }
  parseExprOp(e, t, s) {
    if (this.isPrivateName(e)) {
      const n = this.getPrivateNameSV(e);
      (s >= Mu(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(O.PrivateInExpectedIn, e, {
        identifierName: n
      }), this.classScope.usePrivateName(n, e.loc.start);
    }
    const i = this.state.type;
    if (SN(i) && (this.prodParam.hasIn || !this.match(58))) {
      let n = Mu(i);
      if (n > s) {
        if (i === 39) {
          if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
            return e;
          this.checkPipelineAtInfixOperator(e, t);
        }
        const a = this.startNodeAt(t);
        a.left = e, a.operator = this.state.value;
        const o = i === 41 || i === 42, u = i === 40;
        if (u && (n = Mu(42)), this.next(), i === 39 && this.hasPlugin(["pipelineOperator", {
          proposal: "minimal"
        }]) && this.state.type === 96 && this.prodParam.hasAwait)
          throw this.raise(O.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
        a.right = this.parseExprOpRightExpr(i, n);
        const l = this.finishNode(a, o || u ? "LogicalExpression" : "BinaryExpression"), c = this.state.type;
        if (u && (c === 41 || c === 42) || o && c === 40)
          throw this.raise(O.MixingCoalesceWithLogical, this.state.startLoc);
        return this.parseExprOp(l, t, s);
      }
    }
    return e;
  }
  parseExprOpRightExpr(e, t) {
    const s = this.state.startLoc;
    switch (e) {
      case 39:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
            return this.withTopicBindingContext(() => this.parseHackPipeBody());
          case "smart":
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(O.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, t), s);
            });
          case "fsharp":
            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t));
        }
      default:
        return this.parseExprOpBaseRightExpr(e, t);
    }
  }
  parseExprOpBaseRightExpr(e, t) {
    const s = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, PN(e) ? t - 1 : t);
  }
  parseHackPipeBody() {
    var e;
    const {
      startLoc: t
    } = this.state, s = this.parseMaybeAssign();
    return uN.has(s.type) && !((e = s.extra) != null && e.parenthesized) && this.raise(O.PipeUnparenthesizedBody, t, {
      type: s.type
    }), this.topicReferenceWasUsedInCurrentContext() || this.raise(O.PipeTopicUnused, t), s;
  }
  checkExponentialAfterUnary(e) {
    this.match(57) && this.raise(O.UnexpectedTokenUnaryExponentiation, e.argument);
  }
  parseMaybeUnary(e, t) {
    const s = this.state.startLoc, i = this.isContextual(96);
    if (i && this.isAwaitAllowed()) {
      this.next();
      const u = this.parseAwait(s);
      return t || this.checkExponentialAfterUnary(u), u;
    }
    const n = this.match(34), a = this.startNode();
    if (xN(this.state.type)) {
      a.operator = this.state.value, a.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
      const u = this.match(89);
      if (this.next(), a.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
        const l = a.argument;
        l.type === "Identifier" ? this.raise(O.StrictDelete, a) : this.hasPropertyAsPrivateName(l) && this.raise(O.DeletePrivateField, a);
      }
      if (!n)
        return t || this.checkExponentialAfterUnary(a), this.finishNode(a, "UnaryExpression");
    }
    const o = this.parseUpdate(a, n, e);
    if (i) {
      const {
        type: u
      } = this.state;
      if ((this.hasPlugin("v8intrinsic") ? Rp(u) : Rp(u) && !this.match(54)) && !this.isAmbiguousAwait())
        return this.raiseOverwrite(O.AwaitNotInAsyncContext, s), this.parseAwait(s);
    }
    return o;
  }
  parseUpdate(e, t, s) {
    if (t) {
      const a = e;
      return this.checkLVal(a.argument, {
        in: this.finishNode(a, "UpdateExpression")
      }), e;
    }
    const i = this.state.startLoc;
    let n = this.parseExprSubscripts(s);
    if (this.checkExpressionErrors(s, !1)) return n;
    for (; _N(this.state.type) && !this.canInsertSemicolon(); ) {
      const a = this.startNodeAt(i);
      a.operator = this.state.value, a.prefix = !1, a.argument = n, this.next(), this.checkLVal(n, {
        in: n = this.finishNode(a, "UpdateExpression")
      });
    }
    return n;
  }
  parseExprSubscripts(e) {
    const t = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprAtom(e);
    return this.shouldExitDescending(i, s) ? i : this.parseSubscripts(i, t);
  }
  parseSubscripts(e, t, s) {
    const i = {
      optionalChainMember: !1,
      maybeAsyncArrow: this.atPossibleAsyncArrow(e),
      stop: !1
    };
    do
      e = this.parseSubscript(e, t, s, i), i.maybeAsyncArrow = !1;
    while (!i.stop);
    return e;
  }
  parseSubscript(e, t, s, i) {
    const {
      type: n
    } = this.state;
    if (!s && n === 15)
      return this.parseBind(e, t, s, i);
    if (El(n))
      return this.parseTaggedTemplateExpression(e, t, i);
    let a = !1;
    if (n === 18) {
      if (s && (this.raise(O.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
        return i.stop = !0, e;
      i.optionalChainMember = a = !0, this.next();
    }
    if (!s && this.match(10))
      return this.parseCoverCallAndAsyncArrowHead(e, t, i, a);
    {
      const o = this.eat(0);
      return o || a || this.eat(16) ? this.parseMember(e, t, i, o, a) : (i.stop = !0, e);
    }
  }
  parseMember(e, t, s, i, n) {
    const a = this.startNodeAt(t);
    return a.object = e, a.computed = i, i ? (a.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (e.type === "Super" && this.raise(O.SuperPrivateField, t), this.classScope.usePrivateName(this.state.value, this.state.startLoc), a.property = this.parsePrivateName()) : a.property = this.parseIdentifier(!0), s.optionalChainMember ? (a.optional = n, this.finishNode(a, "OptionalMemberExpression")) : this.finishNode(a, "MemberExpression");
  }
  parseBind(e, t, s, i) {
    const n = this.startNodeAt(t);
    return n.object = e, this.next(), n.callee = this.parseNoCallExpr(), i.stop = !0, this.parseSubscripts(this.finishNode(n, "BindExpression"), t, s);
  }
  parseCoverCallAndAsyncArrowHead(e, t, s, i) {
    const n = this.state.maybeInArrowParameters;
    let a = null;
    this.state.maybeInArrowParameters = !0, this.next();
    const o = this.startNodeAt(t);
    o.callee = e;
    const {
      maybeAsyncArrow: u,
      optionalChainMember: l
    } = s;
    u && (this.expressionScope.enter(ZN()), a = new Fu()), l && (o.optional = i), i ? o.arguments = this.parseCallExpressionArguments(11) : o.arguments = this.parseCallExpressionArguments(11, e.type === "Import", e.type !== "Super", o, a);
    let c = this.finishCallExpression(o, l);
    return u && this.shouldParseAsyncArrow() && !i ? (s.stop = !0, this.checkDestructuringPrivate(a), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t), c)) : (u && (this.checkExpressionErrors(a, !0), this.expressionScope.exit()), this.toReferencedArguments(c)), this.state.maybeInArrowParameters = n, c;
  }
  toReferencedArguments(e, t) {
    this.toReferencedListDeep(e.arguments, t);
  }
  parseTaggedTemplateExpression(e, t, s) {
    const i = this.startNodeAt(t);
    return i.tag = e, i.quasi = this.parseTemplate(!0), s.optionalChainMember && this.raise(O.OptionalChainingNoTemplate, t), this.finishNode(i, "TaggedTemplateExpression");
  }
  atPossibleAsyncArrow(e) {
    return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end - e.start === 5 && e.start === this.state.potentialArrowAt;
  }
  expectImportAttributesPlugin() {
    this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
  }
  finishCallExpression(e, t) {
    if (e.callee.type === "Import")
      if (e.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), e.arguments.length === 0 || e.arguments.length > 2)
        this.raise(O.ImportCallArity, e, {
          maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
        });
      else
        for (const s of e.arguments)
          s.type === "SpreadElement" && this.raise(O.ImportCallSpreadArgument, s);
    return this.finishNode(e, t ? "OptionalCallExpression" : "CallExpression");
  }
  parseCallExpressionArguments(e, t, s, i, n) {
    const a = [];
    let o = !0;
    const u = this.state.inFSharpPipelineDirectBody;
    for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
      if (o)
        o = !1;
      else if (this.expect(12), this.match(e)) {
        t && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(O.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i && this.addTrailingCommaExtraToNode(i), this.next();
        break;
      }
      a.push(this.parseExprListItem(!1, n, s));
    }
    return this.state.inFSharpPipelineDirectBody = u, a;
  }
  shouldParseAsyncArrow() {
    return this.match(19) && !this.canInsertSemicolon();
  }
  parseAsyncArrowFromCallExpression(e, t) {
    var s;
    return this.resetPreviousNodeTrailingComments(t), this.expect(19), this.parseArrowExpression(e, t.arguments, !0, (s = t.extra) == null ? void 0 : s.trailingCommaLoc), t.innerComments && fo(e, t.innerComments), t.callee.trailingComments && fo(e, t.callee.trailingComments), e;
  }
  parseNoCallExpr() {
    const e = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), e, !0);
  }
  parseExprAtom(e) {
    let t, s = null;
    const {
      type: i
    } = this.state;
    switch (i) {
      case 79:
        return this.parseSuper();
      case 83:
        return t = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(t) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(t) : this.finishNode(t, "Import") : (this.raise(O.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(t, "Import"));
      case 78:
        return t = this.startNode(), this.next(), this.finishNode(t, "ThisExpression");
      case 90:
        return this.parseDo(this.startNode(), !1);
      case 56:
      case 31:
        return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
      case 134:
        return this.parseNumericLiteral(this.state.value);
      case 135:
        return this.parseBigIntLiteral(this.state.value);
      case 136:
        return this.parseDecimalLiteral(this.state.value);
      case 133:
        return this.parseStringLiteral(this.state.value);
      case 84:
        return this.parseNullLiteral();
      case 85:
        return this.parseBooleanLiteral(!0);
      case 86:
        return this.parseBooleanLiteral(!1);
      case 10: {
        const n = this.state.potentialArrowAt === this.state.start;
        return this.parseParenAndDistinguishExpression(n);
      }
      case 2:
      case 1:
        return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
      case 0:
        return this.parseArrayLike(3, !0, !1, e);
      case 6:
      case 7:
        return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
      case 5:
        return this.parseObjectLike(8, !1, !1, e);
      case 68:
        return this.parseFunctionOrFunctionSent();
      case 26:
        s = this.parseDecorators();
      case 80:
        return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), !1);
      case 77:
        return this.parseNewOrNewTarget();
      case 25:
      case 24:
        return this.parseTemplate(!1);
      case 15: {
        t = this.startNode(), this.next(), t.object = null;
        const n = t.callee = this.parseNoCallExpr();
        if (n.type === "MemberExpression")
          return this.finishNode(t, "BindExpression");
        throw this.raise(O.UnsupportedBind, n);
      }
      case 138:
        return this.raise(O.PrivateInExpectedIn, this.state.startLoc, {
          identifierName: this.state.value
        }), this.parsePrivateName();
      case 33:
        return this.parseTopicReferenceThenEqualsSign(54, "%");
      case 32:
        return this.parseTopicReferenceThenEqualsSign(44, "^");
      case 37:
      case 38:
        return this.parseTopicReference("hack");
      case 44:
      case 54:
      case 27: {
        const n = this.getPluginOption("pipelineOperator", "proposal");
        if (n)
          return this.parseTopicReference(n);
        this.unexpected();
        break;
      }
      case 47: {
        const n = this.input.codePointAt(this.nextTokenStart());
        ms(n) || n === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
        break;
      }
      default:
        if (Le(i)) {
          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
            return this.parseModuleExpression();
          const n = this.state.potentialArrowAt === this.state.start, a = this.state.containsEsc, o = this.parseIdentifier();
          if (!a && o.name === "async" && !this.canInsertSemicolon()) {
            const {
              type: u
            } = this.state;
            if (u === 68)
              return this.resetPreviousNodeTrailingComments(o), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(o));
            if (Le(u))
              return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(o)) : o;
            if (u === 90)
              return this.resetPreviousNodeTrailingComments(o), this.parseDo(this.startNodeAtNode(o), !0);
          }
          return n && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(o), [o], !1)) : o;
        } else
          this.unexpected();
    }
  }
  parseTopicReferenceThenEqualsSign(e, t) {
    const s = this.getPluginOption("pipelineOperator", "proposal");
    if (s)
      return this.state.type = e, this.state.value = t, this.state.pos--, this.state.end--, this.state.endLoc = Ht(this.state.endLoc, -1), this.parseTopicReference(s);
    this.unexpected();
  }
  parseTopicReference(e) {
    const t = this.startNode(), s = this.state.startLoc, i = this.state.type;
    return this.next(), this.finishTopicReference(t, s, e, i);
  }
  finishTopicReference(e, t, s, i) {
    if (this.testTopicReferenceConfiguration(s, t, i)) {
      const n = s === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
      return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s === "smart" ? O.PrimaryTopicNotAllowed : O.PipeTopicUnbound, t), this.registerTopicReference(), this.finishNode(e, n);
    } else
      throw this.raise(O.PipeTopicUnconfiguredToken, t, {
        token: si(i)
      });
  }
  testTopicReferenceConfiguration(e, t, s) {
    switch (e) {
      case "hack":
        return this.hasPlugin(["pipelineOperator", {
          topicToken: si(s)
        }]);
      case "smart":
        return s === 27;
      default:
        throw this.raise(O.PipeTopicRequiresHackPipes, t);
    }
  }
  parseAsyncArrowUnaryFunction(e) {
    this.prodParam.enter($u(!0, this.prodParam.hasYield));
    const t = [this.parseIdentifier()];
    return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(O.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(e, t, !0);
  }
  parseDo(e, t) {
    this.expectPlugin("doExpressions"), t && this.expectPlugin("asyncDoExpressions"), e.async = t, this.next();
    const s = this.state.labels;
    return this.state.labels = [], t ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(), this.state.labels = s, this.finishNode(e, "DoExpression");
  }
  parseSuper() {
    const e = this.startNode();
    return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(O.SuperNotAllowed, e) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(O.UnexpectedSuper, e), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(O.UnsupportedSuper, e), this.finishNode(e, "Super");
  }
  parsePrivateName() {
    const e = this.startNode(), t = this.startNodeAt(Ht(this.state.startLoc, 1)), s = this.state.value;
    return this.next(), e.id = this.createIdentifier(t, s), this.finishNode(e, "PrivateName");
  }
  parseFunctionOrFunctionSent() {
    const e = this.startNode();
    if (this.next(), this.prodParam.hasYield && this.match(16)) {
      const t = this.createIdentifier(this.startNodeAtNode(e), "function");
      return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(e, t, "sent");
    }
    return this.parseFunction(e);
  }
  parseMetaProperty(e, t, s) {
    e.meta = t;
    const i = this.state.containsEsc;
    return e.property = this.parseIdentifier(!0), (e.property.name !== s || i) && this.raise(O.UnsupportedMetaProperty, e.property, {
      target: t.name,
      onlyValidPropertyName: s
    }), this.finishNode(e, "MetaProperty");
  }
  parseImportMetaProperty(e) {
    const t = this.createIdentifier(this.startNodeAtNode(e), "import");
    if (this.next(), this.isContextual(101))
      this.inModule || this.raise(O.ImportMetaOutsideModule, t), this.sawUnambiguousESM = !0;
    else if (this.isContextual(105) || this.isContextual(97)) {
      const s = this.isContextual(105);
      if (s || this.unexpected(), this.expectPlugin(s ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
        throw this.raise(O.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
          phase: this.state.value
        });
      return this.next(), e.phase = s ? "source" : "defer", this.parseImportCall(e);
    }
    return this.parseMetaProperty(e, t, "meta");
  }
  parseLiteralAtNode(e, t, s) {
    return this.addExtra(s, "rawValue", e), this.addExtra(s, "raw", this.input.slice(s.start, this.state.end)), s.value = e, this.next(), this.finishNode(s, t);
  }
  parseLiteral(e, t) {
    const s = this.startNode();
    return this.parseLiteralAtNode(e, t, s);
  }
  parseStringLiteral(e) {
    return this.parseLiteral(e, "StringLiteral");
  }
  parseNumericLiteral(e) {
    return this.parseLiteral(e, "NumericLiteral");
  }
  parseBigIntLiteral(e) {
    return this.parseLiteral(e, "BigIntLiteral");
  }
  parseDecimalLiteral(e) {
    return this.parseLiteral(e, "DecimalLiteral");
  }
  parseRegExpLiteral(e) {
    const t = this.parseLiteral(e.value, "RegExpLiteral");
    return t.pattern = e.pattern, t.flags = e.flags, t;
  }
  parseBooleanLiteral(e) {
    const t = this.startNode();
    return t.value = e, this.next(), this.finishNode(t, "BooleanLiteral");
  }
  parseNullLiteral() {
    const e = this.startNode();
    return this.next(), this.finishNode(e, "NullLiteral");
  }
  parseParenAndDistinguishExpression(e) {
    const t = this.state.startLoc;
    let s;
    this.next(), this.expressionScope.enter(QN());
    const i = this.state.maybeInArrowParameters, n = this.state.inFSharpPipelineDirectBody;
    this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
    const a = this.state.startLoc, o = [], u = new Fu();
    let l = !0, c, f;
    for (; !this.match(11); ) {
      if (l)
        l = !1;
      else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
        f = this.state.startLoc;
        break;
      }
      if (this.match(21)) {
        const m = this.state.startLoc;
        if (c = this.state.startLoc, o.push(this.parseParenItem(this.parseRestBinding(), m)), !this.checkCommaAfterRest(41))
          break;
      } else
        o.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
    }
    const p = this.state.lastTokEndLoc;
    this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = n;
    let h = this.startNodeAt(t);
    return e && this.shouldParseArrow(o) && (h = this.parseArrow(h)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(h, o, !1), h) : (this.expressionScope.exit(), o.length || this.unexpected(this.state.lastTokStartLoc), f && this.unexpected(f), c && this.unexpected(c), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(o, !0), o.length > 1 ? (s = this.startNodeAt(a), s.expressions = o, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s, p)) : s = o[0], this.wrapParenthesis(t, s));
  }
  wrapParenthesis(e, t) {
    if (!this.options.createParenthesizedExpressions)
      return this.addExtra(t, "parenthesized", !0), this.addExtra(t, "parenStart", e.index), this.takeSurroundingComments(t, e.index, this.state.lastTokEndLoc.index), t;
    const s = this.startNodeAt(e);
    return s.expression = t, this.finishNode(s, "ParenthesizedExpression");
  }
  shouldParseArrow(e) {
    return !this.canInsertSemicolon();
  }
  parseArrow(e) {
    if (this.eat(19))
      return e;
  }
  parseParenItem(e, t) {
    return e;
  }
  parseNewOrNewTarget() {
    const e = this.startNode();
    if (this.next(), this.match(16)) {
      const t = this.createIdentifier(this.startNodeAtNode(e), "new");
      this.next();
      const s = this.parseMetaProperty(e, t, "target");
      return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(O.UnexpectedNewTarget, s), s;
    }
    return this.parseNew(e);
  }
  parseNew(e) {
    if (this.parseNewCallee(e), this.eat(10)) {
      const t = this.parseExprList(11);
      this.toReferencedList(t), e.arguments = t;
    } else
      e.arguments = [];
    return this.finishNode(e, "NewExpression");
  }
  parseNewCallee(e) {
    const t = this.match(83), s = this.parseNoCallExpr();
    e.callee = s, t && (s.type === "Import" || s.type === "ImportExpression") && this.raise(O.ImportCallNotNewExpression, s);
  }
  parseTemplateElement(e) {
    const {
      start: t,
      startLoc: s,
      end: i,
      value: n
    } = this.state, a = t + 1, o = this.startNodeAt(Ht(s, 1));
    n === null && (e || this.raise(O.InvalidEscapeSequenceTemplate, Ht(this.state.firstInvalidTemplateEscapePos, 1)));
    const u = this.match(24), l = u ? -1 : -2, c = i + l;
    o.value = {
      raw: this.input.slice(a, c).replace(/\r\n?/g, `
`),
      cooked: n === null ? null : n.slice(1, l)
    }, o.tail = u, this.next();
    const f = this.finishNode(o, "TemplateElement");
    return this.resetEndLocation(f, Ht(this.state.lastTokEndLoc, l)), f;
  }
  parseTemplate(e) {
    const t = this.startNode();
    let s = this.parseTemplateElement(e);
    const i = [s], n = [];
    for (; !s.tail; )
      n.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i.push(s = this.parseTemplateElement(e));
    return t.expressions = n, t.quasis = i, this.finishNode(t, "TemplateLiteral");
  }
  parseTemplateSubstitution() {
    return this.parseExpression();
  }
  parseObjectLike(e, t, s, i) {
    s && this.expectPlugin("recordAndTuple");
    const n = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !1;
    const a = /* @__PURE__ */ Object.create(null);
    let o = !0;
    const u = this.startNode();
    for (u.properties = [], this.next(); !this.match(e); ) {
      if (o)
        o = !1;
      else if (this.expect(12), this.match(e)) {
        this.addTrailingCommaExtraToNode(u);
        break;
      }
      let c;
      t ? c = this.parseBindingProperty() : (c = this.parsePropertyDefinition(i), this.checkProto(c, s, a, i)), s && !this.isObjectProperty(c) && c.type !== "SpreadElement" && this.raise(O.InvalidRecordProperty, c), c.shorthand && this.addExtra(c, "shorthand", !0), u.properties.push(c);
    }
    this.next(), this.state.inFSharpPipelineDirectBody = n;
    let l = "ObjectExpression";
    return t ? l = "ObjectPattern" : s && (l = "RecordExpression"), this.finishNode(u, l);
  }
  addTrailingCommaExtraToNode(e) {
    this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
  }
  maybeAsyncOrAccessorProp(e) {
    return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
  }
  parsePropertyDefinition(e) {
    let t = [];
    if (this.match(26))
      for (this.hasPlugin("decorators") && this.raise(O.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
        t.push(this.parseDecorator());
    const s = this.startNode();
    let i = !1, n = !1, a;
    if (this.match(21))
      return t.length && this.unexpected(), this.parseSpread();
    t.length && (s.decorators = t, t = []), s.method = !1, e && (a = this.state.startLoc);
    let o = this.eat(55);
    this.parsePropertyNamePrefixOperator(s);
    const u = this.state.containsEsc;
    if (this.parsePropertyName(s, e), !o && !u && this.maybeAsyncOrAccessorProp(s)) {
      const {
        key: l
      } = s, c = l.name;
      c === "async" && !this.hasPrecedingLineBreak() && (i = !0, this.resetPreviousNodeTrailingComments(l), o = this.eat(55), this.parsePropertyName(s)), (c === "get" || c === "set") && (n = !0, this.resetPreviousNodeTrailingComments(l), s.kind = c, this.match(55) && (o = !0, this.raise(O.AccessorIsGenerator, this.state.curPosition(), {
        kind: c
      }), this.next()), this.parsePropertyName(s));
    }
    return this.parseObjPropValue(s, a, o, i, !1, n, e);
  }
  getGetterSetterExpectedParamCount(e) {
    return e.kind === "get" ? 0 : 1;
  }
  getObjectOrClassMethodParams(e) {
    return e.params;
  }
  checkGetterSetterParams(e) {
    var t;
    const s = this.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e);
    i.length !== s && this.raise(e.kind === "get" ? O.BadGetterArity : O.BadSetterArity, e), e.kind === "set" && ((t = i[i.length - 1]) == null ? void 0 : t.type) === "RestElement" && this.raise(O.BadSetterRestParameter, e);
  }
  parseObjectMethod(e, t, s, i, n) {
    if (n) {
      const a = this.parseMethod(e, t, !1, !1, !1, "ObjectMethod");
      return this.checkGetterSetterParams(a), a;
    }
    if (s || t || this.match(10))
      return i && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, t, s, !1, !1, "ObjectMethod");
  }
  parseObjectProperty(e, t, s, i) {
    if (e.shorthand = !1, this.eat(14))
      return e.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(e, "ObjectProperty");
    if (!e.computed && e.key.type === "Identifier") {
      if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), s)
        e.value = this.parseMaybeDefault(t, Ss(e.key));
      else if (this.match(29)) {
        const n = this.state.startLoc;
        i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = n) : this.raise(O.InvalidCoverInitializedName, n), e.value = this.parseMaybeDefault(t, Ss(e.key));
      } else
        e.value = Ss(e.key);
      return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
    }
  }
  parseObjPropValue(e, t, s, i, n, a, o) {
    const u = this.parseObjectMethod(e, s, i, n, a) || this.parseObjectProperty(e, t, n, o);
    return u || this.unexpected(), u;
  }
  parsePropertyName(e, t) {
    if (this.eat(0))
      e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
    else {
      const {
        type: s,
        value: i
      } = this.state;
      let n;
      if (Cr(s))
        n = this.parseIdentifier(!0);
      else
        switch (s) {
          case 134:
            n = this.parseNumericLiteral(i);
            break;
          case 133:
            n = this.parseStringLiteral(i);
            break;
          case 135:
            n = this.parseBigIntLiteral(i);
            break;
          case 136:
            n = this.parseDecimalLiteral(i);
            break;
          case 138: {
            const a = this.state.startLoc;
            t != null ? t.privateKeyLoc === null && (t.privateKeyLoc = a) : this.raise(O.UnexpectedPrivateField, a), n = this.parsePrivateName();
            break;
          }
          default:
            this.unexpected();
        }
      e.key = n, s !== 138 && (e.computed = !1);
    }
  }
  initFunction(e, t) {
    e.id = null, e.generator = !1, e.async = t;
  }
  parseMethod(e, t, s, i, n, a, o = !1) {
    this.initFunction(e, s), e.generator = t, this.scope.enter(18 | (o ? 64 : 0) | (n ? 32 : 0)), this.prodParam.enter($u(s, e.generator)), this.parseFunctionParams(e, i);
    const u = this.parseFunctionBodyAndFinish(e, a, !0);
    return this.prodParam.exit(), this.scope.exit(), u;
  }
  parseArrayLike(e, t, s, i) {
    s && this.expectPlugin("recordAndTuple");
    const n = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !1;
    const a = this.startNode();
    return this.next(), a.elements = this.parseExprList(e, !s, i, a), this.state.inFSharpPipelineDirectBody = n, this.finishNode(a, s ? "TupleExpression" : "ArrayExpression");
  }
  parseArrowExpression(e, t, s, i) {
    this.scope.enter(6);
    let n = $u(s, !1);
    !this.match(5) && this.prodParam.hasIn && (n |= 8), this.prodParam.enter(n), this.initFunction(e, s);
    const a = this.state.maybeInArrowParameters;
    return t && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, t, i)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a, this.finishNode(e, "ArrowFunctionExpression");
  }
  setArrowFunctionParameters(e, t, s) {
    this.toAssignableList(t, s, !1), e.params = t;
  }
  parseFunctionBodyAndFinish(e, t, s = !1) {
    return this.parseFunctionBody(e, !1, s), this.finishNode(e, t);
  }
  parseFunctionBody(e, t, s = !1) {
    const i = t && !this.match(5);
    if (this.expressionScope.enter(mS()), i)
      e.body = this.parseMaybeAssign(), this.checkParams(e, !1, t, !1);
    else {
      const n = this.state.strict, a = this.state.labels;
      this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (o) => {
        const u = !this.isSimpleParamList(e.params);
        o && u && this.raise(O.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
        const l = !n && this.state.strict;
        this.checkParams(e, !this.state.strict && !t && !s && !u, t, l), this.state.strict && e.id && this.checkIdentifier(e.id, 65, l);
      }), this.prodParam.exit(), this.state.labels = a;
    }
    this.expressionScope.exit();
  }
  isSimpleParameter(e) {
    return e.type === "Identifier";
  }
  isSimpleParamList(e) {
    for (let t = 0, s = e.length; t < s; t++)
      if (!this.isSimpleParameter(e[t])) return !1;
    return !0;
  }
  checkParams(e, t, s, i = !0) {
    const n = !t && /* @__PURE__ */ new Set(), a = {
      type: "FormalParameters"
    };
    for (const o of e.params)
      this.checkLVal(o, {
        in: a,
        binding: 5,
        checkClashes: n,
        strictModeChanged: i
      });
  }
  parseExprList(e, t, s, i) {
    const n = [];
    let a = !0;
    for (; !this.eat(e); ) {
      if (a)
        a = !1;
      else if (this.expect(12), this.match(e)) {
        i && this.addTrailingCommaExtraToNode(i), this.next();
        break;
      }
      n.push(this.parseExprListItem(t, s));
    }
    return n;
  }
  parseExprListItem(e, t, s) {
    let i;
    if (this.match(12))
      e || this.raise(O.UnexpectedToken, this.state.curPosition(), {
        unexpected: ","
      }), i = null;
    else if (this.match(21)) {
      const n = this.state.startLoc;
      i = this.parseParenItem(this.parseSpread(t), n);
    } else if (this.match(17)) {
      this.expectPlugin("partialApplication"), s || this.raise(O.UnexpectedArgumentPlaceholder, this.state.startLoc);
      const n = this.startNode();
      this.next(), i = this.finishNode(n, "ArgumentPlaceholder");
    } else
      i = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
    return i;
  }
  parseIdentifier(e) {
    const t = this.startNode(), s = this.parseIdentifierName(e);
    return this.createIdentifier(t, s);
  }
  createIdentifier(e, t) {
    return e.name = t, e.loc.identifierName = t, this.finishNode(e, "Identifier");
  }
  parseIdentifierName(e) {
    let t;
    const {
      startLoc: s,
      type: i
    } = this.state;
    Cr(i) ? t = this.state.value : this.unexpected();
    const n = yN(i);
    return e ? n && this.replaceToken(132) : this.checkReservedWord(t, s, n, !1), this.next(), t;
  }
  checkReservedWord(e, t, s, i) {
    if (e.length > 10 || !RN(e))
      return;
    if (s && DN(e)) {
      this.raise(O.UnexpectedKeyword, t, {
        keyword: e
      });
      return;
    }
    if ((this.state.strict ? i ? lS : oS : aS)(e, this.inModule)) {
      this.raise(O.UnexpectedReservedWord, t, {
        reservedWord: e
      });
      return;
    } else if (e === "yield") {
      if (this.prodParam.hasYield) {
        this.raise(O.YieldBindingIdentifier, t);
        return;
      }
    } else if (e === "await") {
      if (this.prodParam.hasAwait) {
        this.raise(O.AwaitBindingIdentifier, t);
        return;
      }
      if (this.scope.inStaticBlock) {
        this.raise(O.AwaitBindingIdentifierInStaticBlock, t);
        return;
      }
      this.expressionScope.recordAsyncArrowParametersError(t);
    } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
      this.raise(O.ArgumentsInClass, t);
      return;
    }
  }
  isAwaitAllowed() {
    return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
  }
  parseAwait(e) {
    const t = this.startNodeAt(e);
    return this.expressionScope.recordParameterInitializerError(O.AwaitExpressionFormalParameter, t), this.eat(55) && this.raise(O.ObsoleteAwaitStar, t), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (t.argument = this.parseMaybeUnary(null, !0)), this.finishNode(t, "AwaitExpression");
  }
  isAmbiguousAwait() {
    if (this.hasPrecedingLineBreak()) return !0;
    const {
      type: e
    } = this.state;
    return e === 53 || e === 10 || e === 0 || El(e) || e === 102 && !this.state.containsEsc || e === 137 || e === 56 || this.hasPlugin("v8intrinsic") && e === 54;
  }
  parseYield() {
    const e = this.startNode();
    this.expressionScope.recordParameterInitializerError(O.YieldInParameter, e), this.next();
    let t = !1, s = null;
    if (!this.hasPrecedingLineBreak())
      switch (t = this.eat(55), this.state.type) {
        case 13:
        case 139:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
          if (!t) break;
        default:
          s = this.parseMaybeAssign();
      }
    return e.delegate = t, e.argument = s, this.finishNode(e, "YieldExpression");
  }
  parseImportCall(e) {
    return this.next(), e.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(e, "ImportExpression");
  }
  checkPipelineAtInfixOperator(e, t) {
    this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }]) && e.type === "SequenceExpression" && this.raise(O.PipelineHeadSequenceExpression, t);
  }
  parseSmartPipelineBodyInStyle(e, t) {
    if (this.isSimpleReference(e)) {
      const s = this.startNodeAt(t);
      return s.callee = e, this.finishNode(s, "PipelineBareFunction");
    } else {
      const s = this.startNodeAt(t);
      return this.checkSmartPipeTopicBodyEarlyErrors(t), s.expression = e, this.finishNode(s, "PipelineTopicExpression");
    }
  }
  isSimpleReference(e) {
    switch (e.type) {
      case "MemberExpression":
        return !e.computed && this.isSimpleReference(e.object);
      case "Identifier":
        return !0;
      default:
        return !1;
    }
  }
  checkSmartPipeTopicBodyEarlyErrors(e) {
    if (this.match(19))
      throw this.raise(O.PipelineBodyNoArrow, this.state.startLoc);
    this.topicReferenceWasUsedInCurrentContext() || this.raise(O.PipelineTopicUnused, e);
  }
  withTopicBindingContext(e) {
    const t = this.state.topicContext;
    this.state.topicContext = {
      maxNumOfResolvableTopics: 1,
      maxTopicIndex: null
    };
    try {
      return e();
    } finally {
      this.state.topicContext = t;
    }
  }
  withSmartMixTopicForbiddingContext(e) {
    if (this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }])) {
      const t = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = t;
      }
    } else
      return e();
  }
  withSoloAwaitPermittingContext(e) {
    const t = this.state.soloAwait;
    this.state.soloAwait = !0;
    try {
      return e();
    } finally {
      this.state.soloAwait = t;
    }
  }
  allowInAnd(e) {
    const t = this.prodParam.currentFlags();
    if (8 & ~t) {
      this.prodParam.enter(t | 8);
      try {
        return e();
      } finally {
        this.prodParam.exit();
      }
    }
    return e();
  }
  disallowInAnd(e) {
    const t = this.prodParam.currentFlags();
    if (8 & t) {
      this.prodParam.enter(t & -9);
      try {
        return e();
      } finally {
        this.prodParam.exit();
      }
    }
    return e();
  }
  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0;
  }
  topicReferenceIsAllowedInCurrentContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
  }
  topicReferenceWasUsedInCurrentContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
  }
  parseFSharpPipelineBody(e) {
    const t = this.state.startLoc;
    this.state.potentialArrowAt = this.state.start;
    const s = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !0;
    const i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, e);
    return this.state.inFSharpPipelineDirectBody = s, i;
  }
  parseModuleExpression() {
    this.expectPlugin("moduleBlocks");
    const e = this.startNode();
    this.next(), this.match(5) || this.unexpected(null, 5);
    const t = this.startNodeAt(this.state.endLoc);
    this.next();
    const s = this.initializeScopes(!0);
    this.enterInitialScopes();
    try {
      e.body = this.parseProgram(t, 8, "module");
    } finally {
      s();
    }
    return this.finishNode(e, "ModuleExpression");
  }
  parsePropertyNamePrefixOperator(e) {
  }
}
const Rf = {
  kind: 1
}, IO = {
  kind: 2
}, kO = /[\uD800-\uDFFF]/u, $f = /in(?:stanceof)?/y;
function DO(r, e) {
  for (let t = 0; t < r.length; t++) {
    const s = r[t], {
      type: i
    } = s;
    if (typeof i == "number") {
      {
        if (i === 138) {
          const {
            loc: n,
            start: a,
            value: o,
            end: u
          } = s, l = a + 1, c = Ht(n.start, 1);
          r.splice(t, 1, new Vs({
            type: ls(27),
            value: "#",
            start: a,
            end: l,
            startLoc: n.start,
            endLoc: c
          }), new Vs({
            type: ls(132),
            value: o,
            start: l,
            end: u,
            startLoc: c,
            endLoc: n.end
          })), t++;
          continue;
        }
        if (El(i)) {
          const {
            loc: n,
            start: a,
            value: o,
            end: u
          } = s, l = a + 1, c = Ht(n.start, 1);
          let f;
          e.charCodeAt(a) === 96 ? f = new Vs({
            type: ls(22),
            value: "`",
            start: a,
            end: l,
            startLoc: n.start,
            endLoc: c
          }) : f = new Vs({
            type: ls(8),
            value: "}",
            start: a,
            end: l,
            startLoc: n.start,
            endLoc: c
          });
          let p, h, m, d;
          i === 24 ? (h = u - 1, m = Ht(n.end, -1), p = o === null ? null : o.slice(1, -1), d = new Vs({
            type: ls(22),
            value: "`",
            start: h,
            end: u,
            startLoc: m,
            endLoc: n.end
          })) : (h = u - 2, m = Ht(n.end, -2), p = o === null ? null : o.slice(1, -2), d = new Vs({
            type: ls(23),
            value: "${",
            start: h,
            end: u,
            startLoc: m,
            endLoc: n.end
          })), r.splice(t, 1, f, new Vs({
            type: ls(20),
            value: p,
            start: l,
            end: h,
            startLoc: c,
            endLoc: m
          }), d), t += 2;
          continue;
        }
      }
      s.type = ls(i);
    }
  }
  return r;
}
class LO extends OO {
  parseTopLevel(e, t) {
    return e.program = this.parseProgram(t), e.comments = this.comments, this.options.tokens && (e.tokens = DO(this.tokens, this.input)), this.finishNode(e, "File");
  }
  parseProgram(e, t = 139, s = this.options.sourceType) {
    if (e.sourceType = s, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, t), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
      for (const [n, a] of Array.from(this.scope.undefinedExports))
        this.raise(O.ModuleExportUndefined, a, {
          localName: n
        });
    let i;
    return t === 139 ? i = this.finishNode(e, "Program") : i = this.finishNodeAt(e, "Program", Ht(this.state.startLoc, -1)), i;
  }
  stmtToDirective(e) {
    const t = e;
    t.type = "Directive", t.value = t.expression, delete t.expression;
    const s = t.value, i = s.value, n = this.input.slice(s.start, s.end), a = s.value = n.slice(1, -1);
    return this.addExtra(s, "raw", n), this.addExtra(s, "rawValue", a), this.addExtra(s, "expressionValue", i), s.type = "DirectiveLiteral", t;
  }
  parseInterpreterDirective() {
    if (!this.match(28))
      return null;
    const e = this.startNode();
    return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
  }
  isLet() {
    return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
  }
  chStartsBindingIdentifier(e, t) {
    if (ms(e)) {
      if ($f.lastIndex = t, $f.test(this.input)) {
        const s = this.codePointAtPos($f.lastIndex);
        if (!Sn(s) && s !== 92)
          return !1;
      }
      return !0;
    } else return e === 92;
  }
  chStartsBindingPattern(e) {
    return e === 91 || e === 123;
  }
  hasFollowingBindingAtom() {
    const e = this.nextTokenStart(), t = this.codePointAtPos(e);
    return this.chStartsBindingPattern(t) || this.chStartsBindingIdentifier(t, e);
  }
  hasInLineFollowingBindingIdentifier() {
    const e = this.nextTokenInLineStart(), t = this.codePointAtPos(e);
    return this.chStartsBindingIdentifier(t, e);
  }
  startsUsingForOf() {
    const {
      type: e,
      containsEsc: t
    } = this.lookahead();
    if (e === 102 && !t)
      return !1;
    if (Le(e) && !this.hasFollowingLineBreak())
      return this.expectPlugin("explicitResourceManagement"), !0;
  }
  startsAwaitUsing() {
    let e = this.nextTokenInLineStart();
    if (this.isUnparsedContextual(e, "using")) {
      e = this.nextTokenInLineStartSince(e + 5);
      const t = this.codePointAtPos(e);
      if (this.chStartsBindingIdentifier(t, e))
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    return !1;
  }
  parseModuleItem() {
    return this.parseStatementLike(15);
  }
  parseStatementListItem() {
    return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
  }
  parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
    let t = 0;
    return this.options.annexB && !this.state.strict && (t |= 4, e && (t |= 8)), this.parseStatementLike(t);
  }
  parseStatement() {
    return this.parseStatementLike(0);
  }
  parseStatementLike(e) {
    let t = null;
    return this.match(26) && (t = this.parseDecorators(!0)), this.parseStatementContent(e, t);
  }
  parseStatementContent(e, t) {
    const s = this.state.type, i = this.startNode(), n = !!(e & 2), a = !!(e & 4), o = e & 1;
    switch (s) {
      case 60:
        return this.parseBreakContinueStatement(i, !0);
      case 63:
        return this.parseBreakContinueStatement(i, !1);
      case 64:
        return this.parseDebuggerStatement(i);
      case 90:
        return this.parseDoWhileStatement(i);
      case 91:
        return this.parseForStatement(i);
      case 68:
        if (this.lookaheadCharCode() === 46) break;
        return a || this.raise(this.state.strict ? O.StrictFunction : this.options.annexB ? O.SloppyFunctionAnnexB : O.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(i, !1, !n && a);
      case 80:
        return n || this.unexpected(), this.parseClass(this.maybeTakeDecorators(t, i), !0);
      case 69:
        return this.parseIfStatement(i);
      case 70:
        return this.parseReturnStatement(i);
      case 71:
        return this.parseSwitchStatement(i);
      case 72:
        return this.parseThrowStatement(i);
      case 73:
        return this.parseTryStatement(i);
      case 96:
        if (!this.state.containsEsc && this.startsAwaitUsing())
          return this.isAwaitAllowed() ? n || this.raise(O.UnexpectedLexicalDeclaration, i) : this.raise(O.AwaitUsingNotInAsyncContext, i), this.next(), this.parseVarStatement(i, "await using");
        break;
      case 107:
        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
          break;
        return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(O.UnexpectedUsingDeclaration, this.state.startLoc) : n || this.raise(O.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
      case 100: {
        if (this.state.containsEsc)
          break;
        const c = this.nextTokenStart(), f = this.codePointAtPos(c);
        if (f !== 91 && (!n && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(f, c) && f !== 123))
          break;
      }
      case 75:
        n || this.raise(O.UnexpectedLexicalDeclaration, this.state.startLoc);
      case 74: {
        const c = this.state.value;
        return this.parseVarStatement(i, c);
      }
      case 92:
        return this.parseWhileStatement(i);
      case 76:
        return this.parseWithStatement(i);
      case 5:
        return this.parseBlock();
      case 13:
        return this.parseEmptyStatement(i);
      case 83: {
        const c = this.lookaheadCharCode();
        if (c === 40 || c === 46)
          break;
      }
      case 82: {
        !this.options.allowImportExportEverywhere && !o && this.raise(O.UnexpectedImportExport, this.state.startLoc), this.next();
        let c;
        return s === 83 ? (c = this.parseImport(i), c.type === "ImportDeclaration" && (!c.importKind || c.importKind === "value") && (this.sawUnambiguousESM = !0)) : (c = this.parseExport(i, t), (c.type === "ExportNamedDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportAllDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(c), c;
      }
      default:
        if (this.isAsyncFunction())
          return n || this.raise(O.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i, !0, !n && a);
    }
    const u = this.state.value, l = this.parseExpression();
    return Le(s) && l.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, u, l, e) : this.parseExpressionStatement(i, l, t);
  }
  assertModuleNodeAllowed(e) {
    !this.options.allowImportExportEverywhere && !this.inModule && this.raise(O.ImportOutsideModule, e);
  }
  decoratorsEnabledBeforeExport() {
    return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
  }
  maybeTakeDecorators(e, t, s) {
    return e && (t.decorators && t.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(O.DecoratorsBeforeAfterExport, t.decorators[0]), t.decorators.unshift(...e)) : t.decorators = e, this.resetStartLocationFromNode(t, e[0]), s && this.resetStartLocationFromNode(s, t)), t;
  }
  canHaveLeadingDecorator() {
    return this.match(80);
  }
  parseDecorators(e) {
    const t = [];
    do
      t.push(this.parseDecorator());
    while (this.match(26));
    if (this.match(82))
      e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(O.DecoratorExportClass, this.state.startLoc);
    else if (!this.canHaveLeadingDecorator())
      throw this.raise(O.UnexpectedLeadingDecorator, this.state.startLoc);
    return t;
  }
  parseDecorator() {
    this.expectOnePlugin(["decorators", "decorators-legacy"]);
    const e = this.startNode();
    if (this.next(), this.hasPlugin("decorators")) {
      const t = this.state.startLoc;
      let s;
      if (this.match(10)) {
        const i = this.state.startLoc;
        this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(i, s);
        const n = this.state.startLoc;
        e.expression = this.parseMaybeDecoratorArguments(s), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !== s && this.raise(O.DecoratorArgumentsOutsideParentheses, n);
      } else {
        for (s = this.parseIdentifier(!1); this.eat(16); ) {
          const i = this.startNodeAt(t);
          i.object = s, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) : i.property = this.parseIdentifier(!0), i.computed = !1, s = this.finishNode(i, "MemberExpression");
        }
        e.expression = this.parseMaybeDecoratorArguments(s);
      }
    } else
      e.expression = this.parseExprSubscripts();
    return this.finishNode(e, "Decorator");
  }
  parseMaybeDecoratorArguments(e) {
    if (this.eat(10)) {
      const t = this.startNodeAtNode(e);
      return t.callee = e, t.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(t.arguments), this.finishNode(t, "CallExpression");
    }
    return e;
  }
  parseBreakContinueStatement(e, t) {
    return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e, t), this.finishNode(e, t ? "BreakStatement" : "ContinueStatement");
  }
  verifyBreakContinue(e, t) {
    let s;
    for (s = 0; s < this.state.labels.length; ++s) {
      const i = this.state.labels[s];
      if ((e.label == null || i.name === e.label.name) && (i.kind != null && (t || i.kind === 1) || e.label && t))
        break;
    }
    if (s === this.state.labels.length) {
      const i = t ? "BreakStatement" : "ContinueStatement";
      this.raise(O.IllegalBreakContinue, e, {
        type: i
      });
    }
  }
  parseDebuggerStatement(e) {
    return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
  }
  parseHeaderExpression() {
    this.expect(10);
    const e = this.parseExpression();
    return this.expect(11), e;
  }
  parseDoWhileStatement(e) {
    return this.next(), this.state.labels.push(Rf), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
  }
  parseForStatement(e) {
    this.next(), this.state.labels.push(Rf);
    let t = null;
    if (this.isAwaitAllowed() && this.eatContextual(96) && (t = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
      return t !== null && this.unexpected(t), this.parseFor(e, null);
    const s = this.isContextual(100);
    {
      const u = this.isContextual(96) && this.startsAwaitUsing(), l = u || this.isContextual(107) && this.startsUsingForOf(), c = s && this.hasFollowingBindingAtom() || l;
      if (this.match(74) || this.match(75) || c) {
        const f = this.startNode();
        let p;
        u ? (p = "await using", this.isAwaitAllowed() || this.raise(O.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : p = this.state.value, this.next(), this.parseVar(f, !0, p);
        const h = this.finishNode(f, "VariableDeclaration"), m = this.match(58);
        return m && l && this.raise(O.ForInUsing, h), (m || this.isContextual(102)) && h.declarations.length === 1 ? this.parseForIn(e, h, t) : (t !== null && this.unexpected(t), this.parseFor(e, h));
      }
    }
    const i = this.isContextual(95), n = new Fu(), a = this.parseExpression(!0, n), o = this.isContextual(102);
    if (o && (s && this.raise(O.ForOfLet, a), t === null && i && a.type === "Identifier" && this.raise(O.ForOfAsync, a)), o || this.match(58)) {
      this.checkDestructuringPrivate(n), this.toAssignable(a, !0);
      const u = o ? "ForOfStatement" : "ForInStatement";
      return this.checkLVal(a, {
        in: {
          type: u
        }
      }), this.parseForIn(e, a, t);
    } else
      this.checkExpressionErrors(n, !0);
    return t !== null && this.unexpected(t), this.parseFor(e, a);
  }
  parseFunctionStatement(e, t, s) {
    return this.next(), this.parseFunction(e, 1 | (s ? 2 : 0) | (t ? 8 : 0));
  }
  parseIfStatement(e) {
    return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
  }
  parseReturnStatement(e) {
    return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(O.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
  }
  parseSwitchStatement(e) {
    this.next(), e.discriminant = this.parseHeaderExpression();
    const t = e.cases = [];
    this.expect(5), this.state.labels.push(IO), this.scope.enter(0);
    let s;
    for (let i; !this.match(8); )
      if (this.match(61) || this.match(65)) {
        const n = this.match(61);
        s && this.finishNode(s, "SwitchCase"), t.push(s = this.startNode()), s.consequent = [], this.next(), n ? s.test = this.parseExpression() : (i && this.raise(O.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = !0, s.test = null), this.expect(14);
      } else
        s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
    return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchStatement");
  }
  parseThrowStatement(e) {
    return this.next(), this.hasPrecedingLineBreak() && this.raise(O.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
  }
  parseCatchClauseParam() {
    const e = this.parseBindingAtom();
    return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
      in: {
        type: "CatchClause"
      },
      binding: 9
    }), e;
  }
  parseTryStatement(e) {
    if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
      const t = this.startNode();
      this.next(), this.match(10) ? (this.expect(10), t.param = this.parseCatchClauseParam(), this.expect(11)) : (t.param = null, this.scope.enter(0)), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(t, "CatchClause");
    }
    return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(O.NoCatchOrFinally, e), this.finishNode(e, "TryStatement");
  }
  parseVarStatement(e, t, s = !1) {
    return this.next(), this.parseVar(e, !1, t, s), this.semicolon(), this.finishNode(e, "VariableDeclaration");
  }
  parseWhileStatement(e) {
    return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(Rf), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
  }
  parseWithStatement(e) {
    return this.state.strict && this.raise(O.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
  }
  parseEmptyStatement(e) {
    return this.next(), this.finishNode(e, "EmptyStatement");
  }
  parseLabeledStatement(e, t, s, i) {
    for (const a of this.state.labels)
      a.name === t && this.raise(O.LabelRedeclaration, s, {
        labelName: t
      });
    const n = EN(this.state.type) ? 1 : this.match(71) ? 2 : null;
    for (let a = this.state.labels.length - 1; a >= 0; a--) {
      const o = this.state.labels[a];
      if (o.statementStart === e.start)
        o.statementStart = this.state.start, o.kind = n;
      else
        break;
    }
    return this.state.labels.push({
      name: t,
      kind: n,
      statementStart: this.state.start
    }), e.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label = s, this.finishNode(e, "LabeledStatement");
  }
  parseExpressionStatement(e, t, s) {
    return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
  }
  parseBlock(e = !1, t = !0, s) {
    const i = this.startNode();
    return e && this.state.strictErrors.clear(), this.expect(5), t && this.scope.enter(0), this.parseBlockBody(i, e, !1, 8, s), t && this.scope.exit(), this.finishNode(i, "BlockStatement");
  }
  isValidDirective(e) {
    return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
  }
  parseBlockBody(e, t, s, i, n) {
    const a = e.body = [], o = e.directives = [];
    this.parseBlockOrModuleBlockBody(a, t ? o : void 0, s, i, n);
  }
  parseBlockOrModuleBlockBody(e, t, s, i, n) {
    const a = this.state.strict;
    let o = !1, u = !1;
    for (; !this.match(i); ) {
      const l = s ? this.parseModuleItem() : this.parseStatementListItem();
      if (t && !u) {
        if (this.isValidDirective(l)) {
          const c = this.stmtToDirective(l);
          t.push(c), !o && c.value.value === "use strict" && (o = !0, this.setStrict(!0));
          continue;
        }
        u = !0, this.state.strictErrors.clear();
      }
      e.push(l);
    }
    n == null || n.call(this, o), a || this.setStrict(!1), this.next();
  }
  parseFor(e, t) {
    return e.init = t, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
  }
  parseForIn(e, t, s) {
    const i = this.match(58);
    return this.next(), i ? s !== null && this.unexpected(s) : e.await = s !== null, t.type === "VariableDeclaration" && t.declarations[0].init != null && (!i || !this.options.annexB || this.state.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(O.ForInOfLoopInitializer, t, {
      type: i ? "ForInStatement" : "ForOfStatement"
    }), t.type === "AssignmentPattern" && this.raise(O.InvalidLhs, t, {
      ancestor: {
        type: "ForStatement"
      }
    }), e.left = t, e.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, i ? "ForInStatement" : "ForOfStatement");
  }
  parseVar(e, t, s, i = !1) {
    const n = e.declarations = [];
    for (e.kind = s; ; ) {
      const a = this.startNode();
      if (this.parseVarId(a, s), a.init = this.eat(29) ? t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a.init === null && !i && (a.id.type !== "Identifier" && !(t && (this.match(58) || this.isContextual(102))) ? this.raise(O.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
        kind: "destructuring"
      }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(O.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
        kind: s
      })), n.push(this.finishNode(a, "VariableDeclarator")), !this.eat(12)) break;
    }
    return e;
  }
  parseVarId(e, t) {
    const s = this.parseBindingAtom();
    this.checkLVal(s, {
      in: {
        type: "VariableDeclarator"
      },
      binding: t === "var" ? 5 : 8201
    }), e.id = s;
  }
  parseAsyncFunctionExpression(e) {
    return this.parseFunction(e, 8);
  }
  parseFunction(e, t = 0) {
    const s = t & 2, i = !!(t & 1), n = i && !(t & 4), a = !!(t & 8);
    this.initFunction(e, a), this.match(55) && (s && this.raise(O.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.generator = !0), i && (e.id = this.parseFunctionId(n));
    const o = this.state.maybeInArrowParameters;
    return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter($u(a, e.generator)), i || (e.id = this.parseFunctionId()), this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(e, i ? "FunctionDeclaration" : "FunctionExpression");
    }), this.prodParam.exit(), this.scope.exit(), i && !s && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = o, e;
  }
  parseFunctionId(e) {
    return e || Le(this.state.type) ? this.parseIdentifier() : null;
  }
  parseFunctionParams(e, t) {
    this.expect(10), this.expressionScope.enter(YN()), e.params = this.parseBindingList(11, 41, 2 | (t ? 4 : 0)), this.expressionScope.exit();
  }
  registerFunctionStatementId(e) {
    e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, e.id.loc.start);
  }
  parseClass(e, t, s) {
    this.next();
    const i = this.state.strict;
    return this.state.strict = !0, this.parseClassId(e, t, s), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, i), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
  }
  isClassProperty() {
    return this.match(29) || this.match(13) || this.match(8);
  }
  isClassMethod() {
    return this.match(10);
  }
  nameIsConstructor(e) {
    return e.type === "Identifier" && e.name === "constructor" || e.type === "StringLiteral" && e.value === "constructor";
  }
  isNonstaticConstructor(e) {
    return !e.computed && !e.static && this.nameIsConstructor(e.key);
  }
  parseClassBody(e, t) {
    this.classScope.enter();
    const s = {
      hadConstructor: !1,
      hadSuperClass: e
    };
    let i = [];
    const n = this.startNode();
    if (n.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
      for (; !this.match(8); ) {
        if (this.eat(13)) {
          if (i.length > 0)
            throw this.raise(O.DecoratorSemicolon, this.state.lastTokEndLoc);
          continue;
        }
        if (this.match(26)) {
          i.push(this.parseDecorator());
          continue;
        }
        const a = this.startNode();
        i.length && (a.decorators = i, this.resetStartLocationFromNode(a, i[0]), i = []), this.parseClassMember(n, a, s), a.kind === "constructor" && a.decorators && a.decorators.length > 0 && this.raise(O.DecoratorConstructor, a);
      }
    }), this.state.strict = t, this.next(), i.length)
      throw this.raise(O.TrailingDecorator, this.state.startLoc);
    return this.classScope.exit(), this.finishNode(n, "ClassBody");
  }
  parseClassMemberFromModifier(e, t) {
    const s = this.parseIdentifier(!0);
    if (this.isClassMethod()) {
      const i = t;
      return i.kind = "method", i.computed = !1, i.key = s, i.static = !1, this.pushClassMethod(e, i, !1, !1, !1, !1), !0;
    } else if (this.isClassProperty()) {
      const i = t;
      return i.computed = !1, i.key = s, i.static = !1, e.body.push(this.parseClassProperty(i)), !0;
    }
    return this.resetPreviousNodeTrailingComments(s), !1;
  }
  parseClassMember(e, t, s) {
    const i = this.isContextual(106);
    if (i) {
      if (this.parseClassMemberFromModifier(e, t))
        return;
      if (this.eat(5)) {
        this.parseClassStaticBlock(e, t);
        return;
      }
    }
    this.parseClassMemberWithIsStatic(e, t, s, i);
  }
  parseClassMemberWithIsStatic(e, t, s, i) {
    const n = t, a = t, o = t, u = t, l = t, c = n, f = n;
    if (t.static = i, this.parsePropertyNamePrefixOperator(t), this.eat(55)) {
      c.kind = "method";
      const S = this.match(138);
      if (this.parseClassElementName(c), S) {
        this.pushClassPrivateMethod(e, a, !0, !1);
        return;
      }
      this.isNonstaticConstructor(n) && this.raise(O.ConstructorIsGenerator, n.key), this.pushClassMethod(e, n, !0, !1, !1, !1);
      return;
    }
    const p = !this.state.containsEsc && Le(this.state.type), h = this.parseClassElementName(t), m = p ? h.name : null, d = this.isPrivateName(h), y = this.state.startLoc;
    if (this.parsePostMemberNameModifiers(f), this.isClassMethod()) {
      if (c.kind = "method", d) {
        this.pushClassPrivateMethod(e, a, !1, !1);
        return;
      }
      const S = this.isNonstaticConstructor(n);
      let E = !1;
      S && (n.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(O.DuplicateConstructor, h), S && this.hasPlugin("typescript") && t.override && this.raise(O.OverrideOnConstructor, h), s.hadConstructor = !0, E = s.hadSuperClass), this.pushClassMethod(e, n, !1, !1, S, E);
    } else if (this.isClassProperty())
      d ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, o);
    else if (m === "async" && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(h);
      const S = this.eat(55);
      f.optional && this.unexpected(y), c.kind = "method";
      const E = this.match(138);
      this.parseClassElementName(c), this.parsePostMemberNameModifiers(f), E ? this.pushClassPrivateMethod(e, a, S, !0) : (this.isNonstaticConstructor(n) && this.raise(O.ConstructorIsAsync, n.key), this.pushClassMethod(e, n, S, !0, !1, !1));
    } else if ((m === "get" || m === "set") && !(this.match(55) && this.isLineTerminator())) {
      this.resetPreviousNodeTrailingComments(h), c.kind = m;
      const S = this.match(138);
      this.parseClassElementName(n), S ? this.pushClassPrivateMethod(e, a, !1, !1) : (this.isNonstaticConstructor(n) && this.raise(O.ConstructorIsAccessor, n.key), this.pushClassMethod(e, n, !1, !1, !1, !1)), this.checkGetterSetterParams(n);
    } else if (m === "accessor" && !this.isLineTerminator()) {
      this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(h);
      const S = this.match(138);
      this.parseClassElementName(o), this.pushClassAccessorProperty(e, l, S);
    } else this.isLineTerminator() ? d ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, o) : this.unexpected();
  }
  parseClassElementName(e) {
    const {
      type: t,
      value: s
    } = this.state;
    if ((t === 132 || t === 133) && e.static && s === "prototype" && this.raise(O.StaticPrototype, this.state.startLoc), t === 138) {
      s === "constructor" && this.raise(O.ConstructorClassPrivateField, this.state.startLoc);
      const i = this.parsePrivateName();
      return e.key = i, i;
    }
    return this.parsePropertyName(e), e.key;
  }
  parseClassStaticBlock(e, t) {
    var s;
    this.scope.enter(208);
    const i = this.state.labels;
    this.state.labels = [], this.prodParam.enter(0);
    const n = t.body = [];
    this.parseBlockOrModuleBlockBody(n, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, e.body.push(this.finishNode(t, "StaticBlock")), (s = t.decorators) != null && s.length && this.raise(O.DecoratorStaticBlock, t);
  }
  pushClassProperty(e, t) {
    !t.computed && this.nameIsConstructor(t.key) && this.raise(O.ConstructorClassField, t.key), e.body.push(this.parseClassProperty(t));
  }
  pushClassPrivateProperty(e, t) {
    const s = this.parseClassPrivateProperty(t);
    e.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
  }
  pushClassAccessorProperty(e, t, s) {
    !s && !t.computed && this.nameIsConstructor(t.key) && this.raise(O.ConstructorClassField, t.key);
    const i = this.parseClassAccessorProperty(t);
    e.body.push(i), s && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
  }
  pushClassMethod(e, t, s, i, n, a) {
    e.body.push(this.parseMethod(t, s, i, n, a, "ClassMethod", !0));
  }
  pushClassPrivateMethod(e, t, s, i) {
    const n = this.parseMethod(t, s, i, !1, !1, "ClassPrivateMethod", !0);
    e.body.push(n);
    const a = n.kind === "get" ? n.static ? 6 : 2 : n.kind === "set" ? n.static ? 5 : 1 : 0;
    this.declareClassPrivateMethodInScope(n, a);
  }
  declareClassPrivateMethodInScope(e, t) {
    this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), t, e.key.loc.start);
  }
  parsePostMemberNameModifiers(e) {
  }
  parseClassPrivateProperty(e) {
    return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
  }
  parseClassProperty(e) {
    return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
  }
  parseClassAccessorProperty(e) {
    return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
  }
  parseInitializer(e) {
    this.scope.enter(80), this.expressionScope.enter(mS()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
  }
  parseClassId(e, t, s, i = 8331) {
    if (Le(this.state.type))
      e.id = this.parseIdentifier(), t && this.declareNameFromIdentifier(e.id, i);
    else if (s || !t)
      e.id = null;
    else
      throw this.raise(O.MissingClassName, this.state.startLoc);
  }
  parseClassSuper(e) {
    e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
  }
  parseExport(e, t) {
    const s = this.parseMaybeImportPhase(e, !0), i = this.maybeParseExportDefaultSpecifier(e, s), n = !i || this.eat(12), a = n && this.eatExportStar(e), o = a && this.maybeParseExportNamespaceSpecifier(e), u = n && (!o || this.eat(12)), l = i || a;
    if (a && !o) {
      if (i && this.unexpected(), t)
        throw this.raise(O.UnsupportedDecoratorExport, e);
      return this.parseExportFrom(e, !0), this.finishNode(e, "ExportAllDeclaration");
    }
    const c = this.maybeParseExportNamedSpecifiers(e);
    i && n && !a && !c && this.unexpected(null, 5), o && u && this.unexpected(null, 98);
    let f;
    if (l || c) {
      if (f = !1, t)
        throw this.raise(O.UnsupportedDecoratorExport, e);
      this.parseExportFrom(e, l);
    } else
      f = this.maybeParseExportDeclaration(e);
    if (l || c || f) {
      var p;
      const h = e;
      if (this.checkExport(h, !0, !1, !!h.source), ((p = h.declaration) == null ? void 0 : p.type) === "ClassDeclaration")
        this.maybeTakeDecorators(t, h.declaration, h);
      else if (t)
        throw this.raise(O.UnsupportedDecoratorExport, e);
      return this.finishNode(h, "ExportNamedDeclaration");
    }
    if (this.eat(65)) {
      const h = e, m = this.parseExportDefaultExpression();
      if (h.declaration = m, m.type === "ClassDeclaration")
        this.maybeTakeDecorators(t, m, h);
      else if (t)
        throw this.raise(O.UnsupportedDecoratorExport, e);
      return this.checkExport(h, !0, !0), this.finishNode(h, "ExportDefaultDeclaration");
    }
    this.unexpected(null, 5);
  }
  eatExportStar(e) {
    return this.eat(55);
  }
  maybeParseExportDefaultSpecifier(e, t) {
    if (t || this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom", t == null ? void 0 : t.loc.start);
      const s = t || this.parseIdentifier(!0), i = this.startNodeAtNode(s);
      return i.exported = s, e.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], !0;
    }
    return !1;
  }
  maybeParseExportNamespaceSpecifier(e) {
    if (this.isContextual(93)) {
      var t, s;
      (s = (t = e).specifiers) != null || (t.specifiers = []);
      const i = this.startNodeAt(this.state.lastTokStartLoc);
      return this.next(), i.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(i, "ExportNamespaceSpecifier")), !0;
    }
    return !1;
  }
  maybeParseExportNamedSpecifiers(e) {
    if (this.match(5)) {
      const t = e;
      t.specifiers || (t.specifiers = []);
      const s = t.exportKind === "type";
      return t.specifiers.push(...this.parseExportSpecifiers(s)), t.source = null, t.declaration = null, this.hasPlugin("importAssertions") && (t.assertions = []), !0;
    }
    return !1;
  }
  maybeParseExportDeclaration(e) {
    return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") && (e.assertions = []), e.declaration = this.parseExportDeclaration(e), !0) : !1;
  }
  isAsyncFunction() {
    if (!this.isContextual(95)) return !1;
    const e = this.nextTokenInLineStart();
    return this.isUnparsedContextual(e, "function");
  }
  parseExportDefaultExpression() {
    const e = this.startNode();
    if (this.match(68))
      return this.next(), this.parseFunction(e, 5);
    if (this.isAsyncFunction())
      return this.next(), this.next(), this.parseFunction(e, 13);
    if (this.match(80))
      return this.parseClass(e, !0, !0);
    if (this.match(26))
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(O.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
    if (this.match(75) || this.match(74) || this.isLet())
      throw this.raise(O.UnsupportedDefaultExport, this.state.startLoc);
    const t = this.parseMaybeAssignAllowIn();
    return this.semicolon(), t;
  }
  parseExportDeclaration(e) {
    return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
  }
  isExportDefaultSpecifier() {
    const {
      type: e
    } = this.state;
    if (Le(e)) {
      if (e === 95 && !this.state.containsEsc || e === 100)
        return !1;
      if ((e === 130 || e === 129) && !this.state.containsEsc) {
        const {
          type: i
        } = this.lookahead();
        if (Le(i) && i !== 98 || i === 5)
          return this.expectOnePlugin(["flow", "typescript"]), !1;
      }
    } else if (!this.match(65))
      return !1;
    const t = this.nextTokenStart(), s = this.isUnparsedContextual(t, "from");
    if (this.input.charCodeAt(t) === 44 || Le(this.state.type) && s)
      return !0;
    if (this.match(65) && s) {
      const i = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
      return i === 34 || i === 39;
    }
    return !1;
  }
  parseExportFrom(e, t) {
    this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(e)) : t && this.unexpected(), this.semicolon();
  }
  shouldParseExportDeclaration() {
    const {
      type: e
    } = this.state;
    return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(O.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.raise(O.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(O.UsingDeclarationExport, this.state.startLoc), !0) : e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
  }
  checkExport(e, t, s, i) {
    if (t) {
      var n;
      if (s) {
        if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
          var a;
          const o = e.declaration;
          o.type === "Identifier" && o.name === "from" && o.end - o.start === 4 && !((a = o.extra) != null && a.parenthesized) && this.raise(O.ExportDefaultFromAsIdentifier, o);
        }
      } else if ((n = e.specifiers) != null && n.length)
        for (const o of e.specifiers) {
          const {
            exported: u
          } = o, l = u.type === "Identifier" ? u.name : u.value;
          if (this.checkDuplicateExports(o, l), !i && o.local) {
            const {
              local: c
            } = o;
            c.type !== "Identifier" ? this.raise(O.ExportBindingIsString, o, {
              localName: c.value,
              exportName: l
            }) : (this.checkReservedWord(c.name, c.loc.start, !0, !1), this.scope.checkLocalExport(c));
          }
        }
      else if (e.declaration) {
        const o = e.declaration;
        if (o.type === "FunctionDeclaration" || o.type === "ClassDeclaration") {
          const {
            id: u
          } = o;
          if (!u) throw new Error("Assertion failure");
          this.checkDuplicateExports(e, u.name);
        } else if (o.type === "VariableDeclaration")
          for (const u of o.declarations)
            this.checkDeclaration(u.id);
      }
    }
  }
  checkDeclaration(e) {
    if (e.type === "Identifier")
      this.checkDuplicateExports(e, e.name);
    else if (e.type === "ObjectPattern")
      for (const t of e.properties)
        this.checkDeclaration(t);
    else if (e.type === "ArrayPattern")
      for (const t of e.elements)
        t && this.checkDeclaration(t);
    else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type === "AssignmentPattern" && this.checkDeclaration(e.left);
  }
  checkDuplicateExports(e, t) {
    this.exportedIdentifiers.has(t) && (t === "default" ? this.raise(O.DuplicateDefaultExport, e) : this.raise(O.DuplicateExport, e, {
      exportName: t
    })), this.exportedIdentifiers.add(t);
  }
  parseExportSpecifiers(e) {
    const t = [];
    let s = !0;
    for (this.expect(5); !this.eat(8); ) {
      if (s)
        s = !1;
      else if (this.expect(12), this.eat(8)) break;
      const i = this.isContextual(130), n = this.match(133), a = this.startNode();
      a.local = this.parseModuleExportName(), t.push(this.parseExportSpecifier(a, n, e, i));
    }
    return t;
  }
  parseExportSpecifier(e, t, s, i) {
    return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : t ? e.exported = sO(e.local) : e.exported || (e.exported = Ss(e.local)), this.finishNode(e, "ExportSpecifier");
  }
  parseModuleExportName() {
    if (this.match(133)) {
      const e = this.parseStringLiteral(this.state.value), t = e.value.match(kO);
      return t && this.raise(O.ModuleExportNameHasLoneSurrogate, e, {
        surrogateCharCode: t[0].charCodeAt(0)
      }), e;
    }
    return this.parseIdentifier(!0);
  }
  isJSONModuleImport(e) {
    return e.assertions != null ? e.assertions.some(({
      key: t,
      value: s
    }) => s.value === "json" && (t.type === "Identifier" ? t.name === "type" : t.value === "type")) : !1;
  }
  checkImportReflection(e) {
    const {
      specifiers: t
    } = e, s = t.length === 1 ? t[0].type : null;
    if (e.phase === "source")
      s !== "ImportDefaultSpecifier" && this.raise(O.SourcePhaseImportRequiresDefault, t[0].loc.start);
    else if (e.phase === "defer")
      s !== "ImportNamespaceSpecifier" && this.raise(O.DeferImportRequiresNamespace, t[0].loc.start);
    else if (e.module) {
      var i;
      s !== "ImportDefaultSpecifier" && this.raise(O.ImportReflectionNotBinding, t[0].loc.start), ((i = e.assertions) == null ? void 0 : i.length) > 0 && this.raise(O.ImportReflectionHasAssertion, t[0].loc.start);
    }
  }
  checkJSONModuleImport(e) {
    if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
      const {
        specifiers: t
      } = e;
      if (t != null) {
        const s = t.find((i) => {
          let n;
          if (i.type === "ExportSpecifier" ? n = i.local : i.type === "ImportSpecifier" && (n = i.imported), n !== void 0)
            return n.type === "Identifier" ? n.name !== "default" : n.value !== "default";
        });
        s !== void 0 && this.raise(O.ImportJSONBindingNotDefault, s.loc.start);
      }
    }
  }
  isPotentialImportPhase(e) {
    return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
  }
  applyImportPhase(e, t, s, i) {
    t || (s === "module" ? (this.expectPlugin("importReflection", i), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1), s === "source" ? (this.expectPlugin("sourcePhaseImports", i), e.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImportEvaluation", i), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
  }
  parseMaybeImportPhase(e, t) {
    if (!this.isPotentialImportPhase(t))
      return this.applyImportPhase(e, t, null), null;
    const s = this.parseIdentifier(!0), {
      type: i
    } = this.state;
    return (Cr(i) ? i !== 98 || this.lookaheadCharCode() === 102 : i !== 12) ? (this.resetPreviousIdentifierLeadingComments(s), this.applyImportPhase(e, t, s.name, s.loc.start), null) : (this.applyImportPhase(e, t, null), s);
  }
  isPrecedingIdImportPhase(e) {
    const {
      type: t
    } = this.state;
    return Le(t) ? t !== 98 || this.lookaheadCharCode() === 102 : t !== 12;
  }
  parseImport(e) {
    return this.match(133) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
  }
  parseImportSpecifiersAndAfter(e, t) {
    e.specifiers = [];
    const i = !this.maybeParseDefaultImportSpecifier(e, t) || this.eat(12), n = i && this.maybeParseStarImportSpecifier(e);
    return i && !n && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
  }
  parseImportSourceAndAttributes(e) {
    var t;
    return (t = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, "ImportDeclaration");
  }
  parseImportSource() {
    return this.match(133) || this.unexpected(), this.parseExprAtom();
  }
  parseImportSpecifierLocal(e, t, s) {
    t.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(t, s));
  }
  finishImportSpecifier(e, t, s = 8201) {
    return this.checkLVal(e.local, {
      in: {
        type: t
      },
      binding: s
    }), this.finishNode(e, t);
  }
  parseImportAttributes() {
    this.expect(5);
    const e = [], t = /* @__PURE__ */ new Set();
    do {
      if (this.match(8))
        break;
      const s = this.startNode(), i = this.state.value;
      if (t.has(i) && this.raise(O.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
        key: i
      }), t.add(i), this.match(133) ? s.key = this.parseStringLiteral(i) : s.key = this.parseIdentifier(!0), this.expect(14), !this.match(133))
        throw this.raise(O.ModuleAttributeInvalidValue, this.state.startLoc);
      s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
    } while (this.eat(12));
    return this.expect(8), e;
  }
  parseModuleAttributes() {
    const e = [], t = /* @__PURE__ */ new Set();
    do {
      const s = this.startNode();
      if (s.key = this.parseIdentifier(!0), s.key.name !== "type" && this.raise(O.ModuleAttributeDifferentFromType, s.key), t.has(s.key.name) && this.raise(O.ModuleAttributesWithDuplicateKeys, s.key, {
        key: s.key.name
      }), t.add(s.key.name), this.expect(14), !this.match(133))
        throw this.raise(O.ModuleAttributeInvalidValue, this.state.startLoc);
      s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
    } while (this.eat(12));
    return e;
  }
  maybeParseImportAttributes(e) {
    let t, s = !1;
    if (this.match(76)) {
      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
        return;
      this.next(), this.hasPlugin("moduleAttributes") ? t = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), t = this.parseImportAttributes()), s = !0;
    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
      this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(O.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(e, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), t = this.parseImportAttributes();
    else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
      t = [];
    else if (this.hasPlugin("moduleAttributes"))
      t = [];
    else return;
    !s && this.hasPlugin("importAssertions") ? e.assertions = t : e.attributes = t;
  }
  maybeParseDefaultImportSpecifier(e, t) {
    if (t) {
      const s = this.startNodeAtNode(t);
      return s.local = t, e.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), !0;
    } else if (Cr(this.state.type))
      return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
    return !1;
  }
  maybeParseStarImportSpecifier(e) {
    if (this.match(55)) {
      const t = this.startNode();
      return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, t, "ImportNamespaceSpecifier"), !0;
    }
    return !1;
  }
  parseNamedImportSpecifiers(e) {
    let t = !0;
    for (this.expect(5); !this.eat(8); ) {
      if (t)
        t = !1;
      else {
        if (this.eat(14))
          throw this.raise(O.DestructureNamedImport, this.state.startLoc);
        if (this.expect(12), this.eat(8)) break;
      }
      const s = this.startNode(), i = this.match(133), n = this.isContextual(130);
      s.imported = this.parseModuleExportName();
      const a = this.parseImportSpecifier(s, i, e.importKind === "type" || e.importKind === "typeof", n, void 0);
      e.specifiers.push(a);
    }
  }
  parseImportSpecifier(e, t, s, i, n) {
    if (this.eatContextual(93))
      e.local = this.parseIdentifier();
    else {
      const {
        imported: a
      } = e;
      if (t)
        throw this.raise(O.ImportBindingIsString, e, {
          importName: a.value
        });
      this.checkReservedWord(a.name, e.loc.start, !0, !0), e.local || (e.local = Ss(a));
    }
    return this.finishImportSpecifier(e, "ImportSpecifier", n);
  }
  isThisParam(e) {
    return e.type === "Identifier" && e.name === "this";
  }
}
let ES = class extends LO {
  constructor(e, t) {
    e = NO(e), super(e, t), this.options = e, this.initializeScopes(), this.plugins = MO(this.options.plugins), this.filename = e.sourceFilename;
  }
  getScopeHandler() {
    return pm;
  }
  parse() {
    this.enterInitialScopes();
    const e = this.startNode(), t = this.startNode();
    return this.nextToken(), e.errors = null, this.parseTopLevel(e, t), e.errors = this.state.errors, e.comments.length = this.state.commentsLen, e;
  }
};
function MO(r) {
  const e = /* @__PURE__ */ new Map();
  for (const t of r) {
    const [s, i] = Array.isArray(t) ? t : [t, {}];
    e.has(s) || e.set(s, i || {});
  }
  return e;
}
function RO(r, e) {
  var t;
  if (((t = e) == null ? void 0 : t.sourceType) === "unambiguous") {
    e = Object.assign({}, e);
    try {
      e.sourceType = "module";
      const s = Ia(e, r), i = s.parse();
      if (s.sawUnambiguousESM)
        return i;
      if (s.ambiguousScriptDifferentAst)
        try {
          return e.sourceType = "script", Ia(e, r).parse();
        } catch {
        }
      else
        i.program.sourceType = "script";
      return i;
    } catch (s) {
      try {
        return e.sourceType = "script", Ia(e, r).parse();
      } catch {
      }
      throw s;
    }
  } else
    return Ia(e, r).parse();
}
function $O(r, e) {
  const t = Ia(e, r);
  return t.options.strictMode && (t.state.strict = !0), t.getExpression();
}
function FO(r) {
  const e = {};
  for (const t of Object.keys(r))
    e[t] = ls(r[t]);
  return e;
}
const BO = FO(gN);
function Ia(r, e) {
  let t = ES;
  return r != null && r.plugins && (AO(r.plugins), t = VO(r.plugins)), new t(r, e);
}
const xy = {};
function VO(r) {
  const e = CO.filter((i) => lt(r, i)), t = e.join("/");
  let s = xy[t];
  if (!s) {
    s = ES;
    for (const i of e)
      s = vS[i](s);
    xy[t] = s;
  }
  return s;
}
var $n = Lc.parse = RO, _l = Lc.parseExpression = $O;
Lc.tokTypes = BO;
class UO {
  constructor() {
    this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (e) => this.replacement = e
    };
  }
  /**
   *
   * @param {any} parent
   * @param {string} prop
   * @param {number} index
   * @param {BaseNode} node
   */
  replace(e, t, s, i) {
    e && (s !== null ? e[t][s] = i : e[t] = i);
  }
  /**
   *
   * @param {any} parent
   * @param {string} prop
   * @param {number} index
   */
  remove(e, t, s) {
    e && (s !== null ? e[t].splice(s, 1) : delete e[t]);
  }
}
class jO extends UO {
  /**
   *
   * @param {SyncHandler} enter
   * @param {SyncHandler} leave
   */
  constructor(e, t) {
    super(), this.enter = e, this.leave = t;
  }
  /**
   *
   * @param {BaseNode} node
   * @param {BaseNode} parent
   * @param {string} [prop]
   * @param {number} [index]
   * @returns {BaseNode}
   */
  visit(e, t, s, i) {
    if (e) {
      if (this.enter) {
        const n = this.should_skip, a = this.should_remove, o = this.replacement;
        this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, e, t, s, i), this.replacement && (e = this.replacement, this.replace(t, s, i, e)), this.should_remove && this.remove(t, s, i);
        const u = this.should_skip, l = this.should_remove;
        if (this.should_skip = n, this.should_remove = a, this.replacement = o, u) return e;
        if (l) return null;
      }
      for (const n in e) {
        const a = e[n];
        if (typeof a == "object")
          if (Array.isArray(a))
            for (let o = 0; o < a.length; o += 1)
              a[o] !== null && typeof a[o].type == "string" && (this.visit(a[o], e, n, o) || o--);
          else a !== null && typeof a.type == "string" && this.visit(a, e, n, null);
      }
      if (this.leave) {
        const n = this.replacement, a = this.should_remove;
        this.replacement = null, this.should_remove = !1, this.leave.call(this.context, e, t, s, i), this.replacement && (e = this.replacement, this.replace(t, s, i, e)), this.should_remove && this.remove(t, s, i);
        const o = this.should_remove;
        if (this.replacement = n, this.should_remove = a, o) return null;
      }
    }
    return e;
  }
}
function Rc(r, { enter: e, leave: t }) {
  return new jO(e, t).visit(r, null);
}
function Uo(r, e, t = !1, s = [], i = /* @__PURE__ */ Object.create(null)) {
  const n = r.type === "Program" ? r.body[0].type === "ExpressionStatement" && r.body[0].expression : r;
  Rc(r, {
    enter(a, o) {
      if (o && s.push(o), o && o.type.startsWith("TS") && !ym.includes(o.type))
        return this.skip();
      if (a.type === "Identifier") {
        const u = !!i[a.name], l = mm(a, o, s);
        (t || l && !u) && e(a, o, s, l, u);
      } else if (a.type === "ObjectProperty" && // eslint-disable-next-line no-restricted-syntax
      (o == null ? void 0 : o.type) === "ObjectPattern")
        a.inPattern = !0;
      else if (Ys(a))
        a.scopeIds ? a.scopeIds.forEach((u) => Bp(u, i)) : gm(
          a,
          (u) => lu(a, u, i)
        );
      else if (a.type === "BlockStatement")
        a.scopeIds ? a.scopeIds.forEach((u) => Bp(u, i)) : _S(
          a,
          (u) => lu(a, u, i)
        );
      else if (a.type === "CatchClause" && a.param)
        for (const u of mr(a.param))
          lu(a, u, i);
      else xS(a) && wS(
        a,
        !1,
        (u) => lu(a, u, i)
      );
    },
    leave(a, o) {
      if (o && s.pop(), a !== n && a.scopeIds)
        for (const u of a.scopeIds)
          i[u]--, i[u] === 0 && delete i[u];
    }
  });
}
function mm(r, e, t) {
  if (!e)
    return !0;
  if (r.name === "arguments")
    return !1;
  if (qO(r, e))
    return !0;
  switch (e.type) {
    case "AssignmentExpression":
    case "AssignmentPattern":
      return !0;
    case "ObjectPattern":
    case "ArrayPattern":
      return jo(e, t);
  }
  return !1;
}
function jo(r, e) {
  if (r && (r.type === "ObjectProperty" || r.type === "ArrayPattern")) {
    let t = e.length;
    for (; t--; ) {
      const s = e[t];
      if (s.type === "AssignmentExpression")
        return !0;
      if (s.type !== "ObjectProperty" && !s.type.endsWith("Pattern"))
        break;
    }
  }
  return !1;
}
function SS(r) {
  let e = r.length;
  for (; e--; ) {
    const t = r[e];
    if (t.type === "NewExpression")
      return !0;
    if (t.type !== "MemberExpression")
      break;
  }
  return !1;
}
function gm(r, e) {
  for (const t of r.params)
    for (const s of mr(t))
      e(s);
}
function _S(r, e) {
  for (const t of r.body)
    if (t.type === "VariableDeclaration") {
      if (t.declare) continue;
      for (const s of t.declarations)
        for (const i of mr(s.id))
          e(i);
    } else if (t.type === "FunctionDeclaration" || t.type === "ClassDeclaration") {
      if (t.declare || !t.id) continue;
      e(t.id);
    } else xS(t) && wS(t, !0, e);
}
function xS(r) {
  return r.type === "ForOfStatement" || r.type === "ForInStatement" || r.type === "ForStatement";
}
function wS(r, e, t) {
  const s = r.type === "ForStatement" ? r.init : r.left;
  if (s && s.type === "VariableDeclaration" && (s.kind === "var" ? e : !e))
    for (const i of s.declarations)
      for (const n of mr(i.id))
        t(n);
}
function mr(r, e = []) {
  switch (r.type) {
    case "Identifier":
      e.push(r);
      break;
    case "MemberExpression":
      let t = r;
      for (; t.type === "MemberExpression"; )
        t = t.object;
      e.push(t);
      break;
    case "ObjectPattern":
      for (const s of r.properties)
        s.type === "RestElement" ? mr(s.argument, e) : mr(s.value, e);
      break;
    case "ArrayPattern":
      r.elements.forEach((s) => {
        s && mr(s, e);
      });
      break;
    case "RestElement":
      mr(r.argument, e);
      break;
    case "AssignmentPattern":
      mr(r.left, e);
      break;
  }
  return e;
}
function Bp(r, e) {
  r in e ? e[r]++ : e[r] = 1;
}
function lu(r, e, t) {
  const { name: s } = e;
  r.scopeIds && r.scopeIds.has(s) || (Bp(s, t), (r.scopeIds || (r.scopeIds = /* @__PURE__ */ new Set())).add(s));
}
const Ys = (r) => /Function(?:Expression|Declaration)$|Method$/.test(r.type), qo = (r) => r && (r.type === "ObjectProperty" || r.type === "ObjectMethod") && !r.computed, TS = (r, e) => qo(e) && e.key === r;
function qO(r, e, t) {
  switch (e.type) {
    case "MemberExpression":
    case "OptionalMemberExpression":
      return e.property === r ? !!e.computed : e.object === r;
    case "JSXMemberExpression":
      return e.object === r;
    case "VariableDeclarator":
      return e.init === r;
    case "ArrowFunctionExpression":
      return e.body === r;
    case "PrivateName":
      return !1;
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      return e.key === r ? !!e.computed : !1;
    case "ObjectProperty":
      return e.key === r ? !!e.computed : !t;
    case "ClassProperty":
      return e.key === r ? !!e.computed : !0;
    case "ClassPrivateProperty":
      return e.key !== r;
    case "ClassDeclaration":
    case "ClassExpression":
      return e.superClass === r;
    case "AssignmentExpression":
      return e.right === r;
    case "AssignmentPattern":
      return e.right === r;
    case "LabeledStatement":
      return !1;
    case "CatchClause":
      return !1;
    case "RestElement":
      return !1;
    case "BreakStatement":
    case "ContinueStatement":
      return !1;
    case "FunctionDeclaration":
    case "FunctionExpression":
      return !1;
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return !1;
    case "ExportSpecifier":
      return e.local === r;
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return !1;
    case "ImportAttribute":
      return !1;
    case "JSXAttribute":
      return !1;
    case "ObjectPattern":
    case "ArrayPattern":
      return !1;
    case "MetaProperty":
      return !1;
    case "ObjectTypeProperty":
      return e.key !== r;
    case "TSEnumMember":
      return e.id !== r;
    case "TSPropertySignature":
      return e.key === r ? !!e.computed : !0;
  }
  return !0;
}
const ym = [
  "TSAsExpression",
  // foo as number
  "TSTypeAssertion",
  // (<number>foo)
  "TSNonNullExpression",
  // foo!
  "TSInstantiationExpression",
  // foo<string>
  "TSSatisfiesExpression"
  // foo satisfies T
];
function br(r) {
  return ym.includes(r.type) ? br(r.expression) : r;
}
const Pt = (r) => r.type === 4 && r.isStatic;
function bm(r) {
  switch (r) {
    case "Teleport":
    case "teleport":
      return $i;
    case "Suspense":
    case "suspense":
      return Xn;
    case "KeepAlive":
    case "keep-alive":
      return oo;
    case "BaseTransition":
    case "base-transition":
      return zd;
  }
}
const HO = /^\d|[^\$\w\xA0-\uFFFF]/, Ts = (r) => !HO.test(r), WO = /[A-Za-z_$\xA0-\uFFFF]/, zO = /[\.\?\w$\xA0-\uFFFF]/, GO = /\s+[.[]\s*|\s*[.[]\s+/g, KO = (r) => {
  r = r.trim().replace(GO, (a) => a.trim());
  let e = 0, t = [], s = 0, i = 0, n = null;
  for (let a = 0; a < r.length; a++) {
    const o = r.charAt(a);
    switch (e) {
      case 0:
        if (o === "[")
          t.push(e), e = 1, s++;
        else if (o === "(")
          t.push(e), e = 2, i++;
        else if (!(a === 0 ? WO : zO).test(o))
          return !1;
        break;
      case 1:
        o === "'" || o === '"' || o === "`" ? (t.push(e), e = 3, n = o) : o === "[" ? s++ : o === "]" && (--s || (e = t.pop()));
        break;
      case 2:
        if (o === "'" || o === '"' || o === "`")
          t.push(e), e = 3, n = o;
        else if (o === "(")
          i++;
        else if (o === ")") {
          if (a === r.length - 1)
            return !1;
          --i || (e = t.pop());
        }
        break;
      case 3:
        o === n && (e = t.pop(), n = null);
        break;
    }
  }
  return !s && !i;
}, PS = (r, e) => {
  try {
    let t = _l(r, {
      plugins: e.expressionPlugins
    });
    return t = br(t), t.type === "MemberExpression" || t.type === "OptionalMemberExpression" || t.type === "Identifier" && t.name !== "undefined";
  } catch {
    return !1;
  }
}, vm = PS;
function Vp(r, e, t = e.length) {
  return Em(
    {
      offset: r.offset,
      line: r.line,
      column: r.column
    },
    e,
    t
  );
}
function Em(r, e, t = e.length) {
  let s = 0, i = -1;
  for (let n = 0; n < t; n++)
    e.charCodeAt(n) === 10 && (s++, i = n);
  return r.offset += t, r.line += s, r.column = i === -1 ? r.column + t : t - i, r;
}
function Up(r, e) {
  if (!r)
    throw new Error(e || "unexpected compiler condition");
}
function gt(r, e, t = !1) {
  for (let s = 0; s < r.props.length; s++) {
    const i = r.props[s];
    if (i.type === 7 && (t || i.exp) && (Ie(e) ? i.name === e : e.test(i.name)))
      return i;
  }
}
function Qt(r, e, t = !1, s = !1) {
  for (let i = 0; i < r.props.length; i++) {
    const n = r.props[i];
    if (n.type === 6) {
      if (t) continue;
      if (n.name === e && (n.value || s))
        return n;
    } else if (n.name === "bind" && (n.exp || s) && jr(n.arg, e))
      return n;
  }
}
function jr(r, e) {
  return !!(r && Pt(r) && r.content === e);
}
function $c(r) {
  return r.props.some(
    (e) => e.type === 7 && e.name === "bind" && (!e.arg || // v-bind="obj"
    e.arg.type !== 4 || // v-bind:[_ctx.foo]
    !e.arg.isStatic)
    // v-bind:[foo]
  );
}
function Ha(r) {
  return r.type === 5 || r.type === 2;
}
function Sm(r) {
  return r.type === 7 && r.name === "slot";
}
function Fn(r) {
  return r.type === 1 && r.tagType === 3;
}
function Bn(r) {
  return r.type === 1 && r.tagType === 2;
}
const XO = /* @__PURE__ */ new Set([Ln, Yn]);
function AS(r, e = []) {
  if (r && !Ie(r) && r.type === 14) {
    const t = r.callee;
    if (!Ie(t) && XO.has(t))
      return AS(
        r.arguments[0],
        e.concat(r)
      );
  }
  return [r, e];
}
function po(r, e, t) {
  let s, i = r.type === 13 ? r.props : r.arguments[2], n = [], a;
  if (i && !Ie(i) && i.type === 14) {
    const o = AS(i);
    i = o[0], n = o[1], a = n[n.length - 1];
  }
  if (i == null || Ie(i))
    s = Yt([e]);
  else if (i.type === 14) {
    const o = i.arguments[0];
    !Ie(o) && o.type === 15 ? wy(e, o) || o.properties.unshift(e) : i.callee === Ac ? s = ge(t.helper(Gi), [
      Yt([e]),
      i
    ]) : i.arguments.unshift(Yt([e])), !s && (s = i);
  } else i.type === 15 ? (wy(e, i) || i.properties.unshift(e), s = i) : (s = ge(t.helper(Gi), [
    Yt([e]),
    i
  ]), a && a.callee === Yn && (a = n[n.length - 2]));
  r.type === 13 ? a ? a.arguments[0] = s : r.props = s : a ? a.arguments[0] = s : r.arguments[2] = s;
}
function wy(r, e) {
  let t = !1;
  if (r.key.type === 4) {
    const s = r.key.content;
    t = e.properties.some(
      (i) => i.key.type === 4 && i.key.content === s
    );
  }
  return t;
}
function ho(r, e) {
  return `_${e}_${r.replace(/[^\w]/g, (t, s) => t === "-" ? "_" : r.charCodeAt(s).toString())}`;
}
function Xt(r, e) {
  if (!r || Object.keys(e).length === 0)
    return !1;
  switch (r.type) {
    case 1:
      for (let t = 0; t < r.props.length; t++) {
        const s = r.props[t];
        if (s.type === 7 && (Xt(s.arg, e) || Xt(s.exp, e)))
          return !0;
      }
      return r.children.some((t) => Xt(t, e));
    case 11:
      return Xt(r.source, e) ? !0 : r.children.some((t) => Xt(t, e));
    case 9:
      return r.branches.some((t) => Xt(t, e));
    case 10:
      return Xt(r.condition, e) ? !0 : r.children.some((t) => Xt(t, e));
    case 4:
      return !r.isStatic && Ts(r.content) && !!e[r.content];
    case 8:
      return r.children.some((t) => pi(t) && Xt(t, e));
    case 5:
    case 12:
      return Xt(r.content, e);
    case 2:
    case 3:
      return !1;
    default:
      return !1;
  }
}
function CS(r) {
  return r.type === 14 && r.callee === Ic ? r.arguments[1].returns : r;
}
const NS = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/, OS = {
  parseMode: "base",
  ns: 0,
  delimiters: ["{{", "}}"],
  getNamespace: () => 0,
  isVoidTag: ku,
  isPreTag: ku,
  isCustomElement: ku,
  onError: em,
  onWarn: eS,
  comments: !0,
  prefixIdentifiers: !1
};
let ze = OS, xl = null, _s = "", kt = null, Re = null, hr = "", cs = -1, Si = -1, wl = 0, zs = !1, jp = null;
const it = [], Xe = new ZC(it, {
  onerr: Ut,
  ontext(r, e) {
    cu(It(r, e), r, e);
  },
  ontextentity(r, e, t) {
    cu(r, e, t);
  },
  oninterpolation(r, e) {
    if (zs)
      return cu(It(r, e), r, e);
    let t = r + Xe.delimiterOpen.length, s = e - Xe.delimiterClose.length;
    for (; sr(_s.charCodeAt(t)); )
      t++;
    for (; sr(_s.charCodeAt(s - 1)); )
      s--;
    let i = It(t, s);
    i.includes("&") && (i = QC(i)), qp({
      type: 5,
      content: Vu(i, !1, ht(t, s)),
      loc: ht(r, e)
    });
  },
  onopentagname(r, e) {
    const t = It(r, e);
    kt = {
      type: 1,
      tag: t,
      ns: ze.getNamespace(t, it[0], ze.ns),
      tagType: 0,
      // will be refined on tag close
      props: [],
      children: [],
      loc: ht(r - 1, e),
      codegenNode: void 0
    };
  },
  onopentagend(r) {
    Py(r);
  },
  onclosetag(r, e) {
    const t = It(r, e);
    if (!ze.isVoidTag(t)) {
      let s = !1;
      for (let i = 0; i < it.length; i++)
        if (it[i].tag.toLowerCase() === t.toLowerCase()) {
          s = !0, i > 0 && Ut(24, it[0].loc.start.offset);
          for (let a = 0; a <= i; a++) {
            const o = it.shift();
            Bu(o, e, a < i);
          }
          break;
        }
      s || Ut(23, IS(r, 60));
    }
  },
  onselfclosingtag(r) {
    const e = kt.tag;
    kt.isSelfClosing = !0, Py(r), it[0] && it[0].tag === e && Bu(it.shift(), r);
  },
  onattribname(r, e) {
    Re = {
      type: 6,
      name: It(r, e),
      nameLoc: ht(r, e),
      value: void 0,
      loc: ht(r)
    };
  },
  ondirname(r, e) {
    const t = It(r, e), s = t === "." || t === ":" ? "bind" : t === "@" ? "on" : t === "#" ? "slot" : t.slice(2);
    if (!zs && s === "" && Ut(26, r), zs || s === "")
      Re = {
        type: 6,
        name: t,
        nameLoc: ht(r, e),
        value: void 0,
        loc: ht(r)
      };
    else if (Re = {
      type: 7,
      name: s,
      rawName: t,
      exp: void 0,
      arg: void 0,
      modifiers: t === "." ? ["prop"] : [],
      loc: ht(r)
    }, s === "pre") {
      zs = Xe.inVPre = !0, jp = kt;
      const i = kt.props;
      for (let n = 0; n < i.length; n++)
        i[n].type === 7 && (i[n] = aI(i[n]));
    }
  },
  ondirarg(r, e) {
    if (r === e) return;
    const t = It(r, e);
    if (zs)
      Re.name += t, Ti(Re.nameLoc, e);
    else {
      const s = t[0] !== "[";
      Re.arg = Vu(
        s ? t : t.slice(1, -1),
        s,
        ht(r, e),
        s ? 3 : 0
      );
    }
  },
  ondirmodifier(r, e) {
    const t = It(r, e);
    if (zs)
      Re.name += "." + t, Ti(Re.nameLoc, e);
    else if (Re.name === "slot") {
      const s = Re.arg;
      s && (s.content += "." + t, Ti(s.loc, e));
    } else
      Re.modifiers.push(t);
  },
  onattribdata(r, e) {
    hr += It(r, e), cs < 0 && (cs = r), Si = e;
  },
  onattribentity(r, e, t) {
    hr += r, cs < 0 && (cs = e), Si = t;
  },
  onattribnameend(r) {
    const e = Re.loc.start.offset, t = It(e, r);
    Re.type === 7 && (Re.rawName = t), kt.props.some(
      (s) => (s.type === 7 ? s.rawName : s.name) === t
    ) && Ut(2, e);
  },
  onattribend(r, e) {
    if (kt && Re) {
      if (Ti(Re.loc, e), r !== 0)
        if (Re.type === 6)
          Re.name === "class" && (hr = DS(hr).trim()), r === 1 && !hr && Ut(13, e), Re.value = {
            type: 2,
            content: hr,
            loc: r === 1 ? ht(cs, Si) : ht(cs - 1, Si + 1)
          }, Xe.inSFCRoot && kt.tag === "template" && Re.name === "lang" && hr && hr !== "html" && Xe.enterRCDATA(bl("</template"), 0);
        else {
          let t = 0;
          Re.name === "for" ? t = 3 : Re.name === "slot" ? t = 1 : Re.name === "on" && hr.includes(";") && (t = 2), Re.exp = Vu(
            hr,
            !1,
            ht(cs, Si),
            0,
            t
          ), Re.name === "for" && (Re.forParseResult = YO(Re.exp));
        }
      (Re.type !== 7 || Re.name !== "pre") && kt.props.push(Re);
    }
    hr = "", cs = Si = -1;
  },
  oncomment(r, e) {
    ze.comments && qp({
      type: 3,
      content: It(r, e),
      loc: ht(r - 4, e + 3)
    });
  },
  onend() {
    const r = _s.length;
    if (Xe.state !== 1)
      switch (Xe.state) {
        case 5:
        case 8:
          Ut(5, r);
          break;
        case 3:
        case 4:
          Ut(
            25,
            Xe.sectionStart
          );
          break;
        case 28:
          Xe.currentSequence === _t.CdataEnd ? Ut(6, r) : Ut(7, r);
          break;
        case 6:
        case 7:
        case 9:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
          Ut(9, r);
          break;
      }
    for (let e = 0; e < it.length; e++)
      Bu(it[e], r - 1), Ut(24, it[e].loc.start.offset);
  },
  oncdata(r, e) {
    it[0].ns !== 0 ? cu(It(r, e), r, e) : Ut(1, r - 9);
  },
  onprocessinginstruction(r) {
    (it[0] ? it[0].ns : ze.ns) === 0 && Ut(
      21,
      r - 1
    );
  }
}), Ty = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, JO = /^\(|\)$/g;
function YO(r) {
  const e = r.loc, t = r.content, s = t.match(NS);
  if (!s) return;
  const [, i, n] = s, a = (f, p, h = !1) => {
    const m = e.start.offset + p, d = m + f.length;
    return Vu(
      f,
      !1,
      ht(m, d),
      0,
      h ? 1 : 0
      /* Normal */
    );
  }, o = {
    source: a(n.trim(), t.indexOf(n, i.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: !1
  };
  let u = i.trim().replace(JO, "").trim();
  const l = i.indexOf(u), c = u.match(Ty);
  if (c) {
    u = u.replace(Ty, "").trim();
    const f = c[1].trim();
    let p;
    if (f && (p = t.indexOf(f, l + u.length), o.key = a(f, p, !0)), c[2]) {
      const h = c[2].trim();
      h && (o.index = a(
        h,
        t.indexOf(
          h,
          o.key ? p + f.length : l + u.length
        ),
        !0
      ));
    }
  }
  return u && (o.value = a(u, l, !0)), o;
}
function It(r, e) {
  return _s.slice(r, e);
}
function Py(r) {
  Xe.inSFCRoot && (kt.innerLoc = ht(r + 1, r + 1)), qp(kt);
  const { tag: e, ns: t } = kt;
  t === 0 && ze.isPreTag(e) && wl++, ze.isVoidTag(e) ? Bu(kt, r) : (it.unshift(kt), (t === 1 || t === 2) && (Xe.inXML = !0)), kt = null;
}
function cu(r, e, t) {
  const s = it[0] || xl, i = s.children[s.children.length - 1];
  i && i.type === 2 ? (i.content += r, Ti(i.loc, t)) : s.children.push({
    type: 2,
    content: r,
    loc: ht(e, t)
  });
}
function Bu(r, e, t = !1) {
  t ? Ti(r.loc, IS(e, 60)) : Ti(r.loc, QO(e, 62) + 1), Xe.inSFCRoot && (r.children.length ? r.innerLoc.end = Jr({}, r.children[r.children.length - 1].loc.end) : r.innerLoc.end = Jr({}, r.innerLoc.start), r.innerLoc.source = It(
    r.innerLoc.start.offset,
    r.innerLoc.end.offset
  ));
  const { tag: s, ns: i } = r;
  zs || (s === "slot" ? r.tagType = 2 : eI(r) ? r.tagType = 3 : tI(r) && (r.tagType = 1)), Xe.inRCDATA || (r.children = kS(r.children, r.tag)), i === 0 && ze.isPreTag(s) && wl--, jp === r && (zs = Xe.inVPre = !1, jp = null), Xe.inXML && (it[0] ? it[0].ns : ze.ns) === 0 && (Xe.inXML = !1);
}
function QO(r, e) {
  let t = r;
  for (; _s.charCodeAt(t) !== e && t < _s.length - 1; ) t++;
  return t;
}
function IS(r, e) {
  let t = r;
  for (; _s.charCodeAt(t) !== e && t >= 0; ) t--;
  return t;
}
const ZO = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
function eI({ tag: r, props: e }) {
  if (r === "template") {
    for (let t = 0; t < e.length; t++)
      if (e[t].type === 7 && ZO.has(e[t].name))
        return !0;
  }
  return !1;
}
function tI({ tag: r, props: e }) {
  if (ze.isCustomElement(r))
    return !1;
  if (r === "component" || rI(r.charCodeAt(0)) || bm(r) || ze.isBuiltInComponent && ze.isBuiltInComponent(r) || ze.isNativeTag && !ze.isNativeTag(r))
    return !0;
  for (let t = 0; t < e.length; t++) {
    const s = e[t];
    if (s.type === 6 && s.name === "is" && s.value && s.value.content.startsWith("vue:"))
      return !0;
  }
  return !1;
}
function rI(r) {
  return r > 64 && r < 91;
}
const sI = /\r\n/g;
function kS(r, e) {
  const t = ze.whitespace !== "preserve";
  let s = !1;
  for (let i = 0; i < r.length; i++) {
    const n = r[i];
    if (n.type === 2)
      if (wl)
        n.content = n.content.replace(sI, `
`);
      else if (iI(n.content)) {
        const a = r[i - 1] && r[i - 1].type, o = r[i + 1] && r[i + 1].type;
        !a || !o || t && (a === 3 && (o === 3 || o === 1) || a === 1 && (o === 3 || o === 1 && nI(n.content))) ? (s = !0, r[i] = null) : n.content = " ";
      } else t && (n.content = DS(n.content));
  }
  if (wl && e && ze.isPreTag(e)) {
    const i = r[0];
    i && i.type === 2 && (i.content = i.content.replace(/^\r?\n/, ""));
  }
  return s ? r.filter(Boolean) : r;
}
function iI(r) {
  for (let e = 0; e < r.length; e++)
    if (!sr(r.charCodeAt(e)))
      return !1;
  return !0;
}
function nI(r) {
  for (let e = 0; e < r.length; e++) {
    const t = r.charCodeAt(e);
    if (t === 10 || t === 13)
      return !0;
  }
  return !1;
}
function DS(r) {
  let e = "", t = !1;
  for (let s = 0; s < r.length; s++)
    sr(r.charCodeAt(s)) ? t || (e += " ", t = !0) : (e += r[s], t = !1);
  return e;
}
function qp(r) {
  (it[0] || xl).children.push(r);
}
function ht(r, e) {
  return {
    start: Xe.getPos(r),
    // @ts-expect-error allow late attachment
    end: e == null ? e : Xe.getPos(e),
    // @ts-expect-error allow late attachment
    source: e == null ? e : It(r, e)
  };
}
function Ti(r, e) {
  r.end = Xe.getPos(e), r.source = It(r.start.offset, e);
}
function aI(r) {
  const e = {
    type: 6,
    name: r.rawName,
    nameLoc: ht(
      r.loc.start.offset,
      r.loc.start.offset + r.rawName.length
    ),
    value: void 0,
    loc: r.loc
  };
  if (r.exp) {
    const t = r.exp.loc;
    t.end.offset < r.loc.end.offset && (t.start.offset--, t.start.column--, t.end.offset++, t.end.column++), e.value = {
      type: 2,
      content: r.exp.content,
      loc: t
    };
  }
  return e;
}
function Vu(r, e = !1, t, s = 0, i = 0) {
  const n = Q(r, e, t, s);
  if (!e && ze.prefixIdentifiers && i !== 3 && r.trim()) {
    if (Ts(r))
      return n.ast = null, n;
    try {
      const a = ze.expressionPlugins, o = {
        plugins: a ? [...a, "typescript"] : ["typescript"]
      };
      i === 2 ? n.ast = $n(` ${r} `, o).program : i === 1 ? n.ast = _l(`(${r})=>{}`, o) : n.ast = _l(`(${r})`, o);
    } catch (a) {
      n.ast = !1, Ut(45, t.start.offset, a.message);
    }
  }
  return n;
}
function Ut(r, e, t) {
  ze.onError(
    Me(r, ht(e, e), void 0, t)
  );
}
function oI() {
  Xe.reset(), kt = null, Re = null, hr = "", cs = -1, Si = -1, it.length = 0;
}
function Fc(r, e) {
  if (oI(), _s = r, ze = Jr({}, OS), e) {
    let i;
    for (i in e)
      e[i] != null && (ze[i] = e[i]);
  }
  ze.decodeEntities && console.warn(
    "[@vue/compiler-core] decodeEntities option is passed but will be ignored in non-browser builds."
  ), Xe.mode = ze.parseMode === "html" ? 1 : ze.parseMode === "sfc" ? 2 : 0, Xe.inXML = ze.ns === 1 || ze.ns === 2;
  const t = e && e.delimiters;
  t && (Xe.delimiterOpen = bl(t[0]), Xe.delimiterClose = bl(t[1]));
  const s = xl = rn([], r);
  return Xe.parse(_s), s.loc = ht(0, r.length), s.children = kS(s.children), xl = null, s;
}
function uI(r, e) {
  Uu(
    r,
    e,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    LS(r, r.children[0])
  );
}
function LS(r, e) {
  const { children: t } = r;
  return t.length === 1 && e.type === 1 && !Bn(e);
}
function Uu(r, e, t = !1) {
  const { children: s } = r, i = s.length;
  let n = 0;
  for (let a = 0; a < s.length; a++) {
    const o = s[a];
    if (o.type === 1 && o.tagType === 0) {
      const u = t ? 0 : ir(o, e);
      if (u > 0) {
        if (u >= 2) {
          o.codegenNode.patchFlag = -1, o.codegenNode = e.hoist(o.codegenNode), n++;
          continue;
        }
      } else {
        const l = o.codegenNode;
        if (l.type === 13) {
          const c = l.patchFlag;
          if ((c === void 0 || c === 512 || c === 1) && RS(o, e) >= 2) {
            const f = $S(o);
            f && (l.props = e.hoist(f));
          }
          l.dynamicProps && (l.dynamicProps = e.hoist(l.dynamicProps));
        }
      }
    }
    if (o.type === 1) {
      const u = o.tagType === 1;
      u && e.scopes.vSlot++, Uu(o, e), u && e.scopes.vSlot--;
    } else if (o.type === 11)
      Uu(o, e, o.children.length === 1);
    else if (o.type === 9)
      for (let u = 0; u < o.branches.length; u++)
        Uu(
          o.branches[u],
          e,
          o.branches[u].children.length === 1
        );
  }
  if (n && e.transformHoist && e.transformHoist(s, e, r), n && n === i && r.type === 1 && r.tagType === 0 && r.codegenNode && r.codegenNode.type === 13 && er(r.codegenNode.children)) {
    const a = e.hoist(
      sn(r.codegenNode.children)
    );
    e.hmr && (a.content = `[...${a.content}]`), r.codegenNode.children = a;
  }
}
function ir(r, e) {
  const { constantCache: t } = e;
  switch (r.type) {
    case 1:
      if (r.tagType !== 0)
        return 0;
      const s = t.get(r);
      if (s !== void 0)
        return s;
      const i = r.codegenNode;
      if (i.type !== 13 || i.isBlock && r.tag !== "svg" && r.tag !== "foreignObject" && r.tag !== "math")
        return 0;
      if (i.patchFlag === void 0) {
        let a = 3;
        const o = RS(r, e);
        if (o === 0)
          return t.set(r, 0), 0;
        o < a && (a = o);
        for (let u = 0; u < r.children.length; u++) {
          const l = ir(r.children[u], e);
          if (l === 0)
            return t.set(r, 0), 0;
          l < a && (a = l);
        }
        if (a > 1)
          for (let u = 0; u < r.props.length; u++) {
            const l = r.props[u];
            if (l.type === 7 && l.name === "bind" && l.exp) {
              const c = ir(l.exp, e);
              if (c === 0)
                return t.set(r, 0), 0;
              c < a && (a = c);
            }
          }
        if (i.isBlock) {
          for (let u = 0; u < r.props.length; u++)
            if (r.props[u].type === 7)
              return t.set(r, 0), 0;
          e.removeHelper(ui), e.removeHelper(
            Xi(e.inSSR, i.isComponent)
          ), i.isBlock = !1, e.helper(Ki(e.inSSR, i.isComponent));
        }
        return t.set(r, a), a;
      } else
        return t.set(r, 0), 0;
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return ir(r.content, e);
    case 4:
      return r.constType;
    case 8:
      let n = 3;
      for (let a = 0; a < r.children.length; a++) {
        const o = r.children[a];
        if (Ie(o) || fi(o))
          continue;
        const u = ir(o, e);
        if (u === 0)
          return 0;
        u < n && (n = u);
      }
      return n;
    default:
      return 0;
  }
}
const lI = /* @__PURE__ */ new Set([
  Tc,
  Pc,
  Ln,
  Yn
]);
function MS(r, e) {
  if (r.type === 14 && !Ie(r.callee) && lI.has(r.callee)) {
    const t = r.arguments[0];
    if (t.type === 4)
      return ir(t, e);
    if (t.type === 14)
      return MS(t, e);
  }
  return 0;
}
function RS(r, e) {
  let t = 3;
  const s = $S(r);
  if (s && s.type === 15) {
    const { properties: i } = s;
    for (let n = 0; n < i.length; n++) {
      const { key: a, value: o } = i[n], u = ir(a, e);
      if (u === 0)
        return u;
      u < t && (t = u);
      let l;
      if (o.type === 4 ? l = ir(o, e) : o.type === 14 ? l = MS(o, e) : l = 0, l === 0)
        return l;
      l < t && (t = l);
    }
  }
  return t;
}
function $S(r) {
  const e = r.codegenNode;
  if (e.type === 13)
    return e.props;
}
function Ho(r, {
  filename: e = "",
  prefixIdentifiers: t = !1,
  hoistStatic: s = !1,
  hmr: i = !1,
  cacheHandlers: n = !1,
  nodeTransforms: a = [],
  directiveTransforms: o = {},
  transformHoist: u = null,
  isBuiltInComponent: l = Nf,
  isCustomElement: c = Nf,
  expressionPlugins: f = [],
  scopeId: p = null,
  slotted: h = !0,
  ssr: m = !1,
  inSSR: d = !1,
  ssrCssVars: y = "",
  bindingMetadata: S = cC,
  inline: E = !1,
  isTS: g = !1,
  onError: b = em,
  onWarn: v = eS,
  compatConfig: A
}) {
  const C = e.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), x = {
    // options
    filename: e,
    selfName: C && oi(or(C[1])),
    prefixIdentifiers: t,
    hoistStatic: s,
    hmr: i,
    cacheHandlers: n,
    nodeTransforms: a,
    directiveTransforms: o,
    transformHoist: u,
    isBuiltInComponent: l,
    isCustomElement: c,
    expressionPlugins: f,
    scopeId: p,
    slotted: h,
    ssr: m,
    inSSR: d,
    ssrCssVars: y,
    bindingMetadata: S,
    inline: E,
    isTS: g,
    onError: b,
    onWarn: v,
    compatConfig: A,
    // state
    root: r,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: r,
    childIndex: 0,
    inVOnce: !1,
    // methods
    helper(P) {
      const I = x.helpers.get(P) || 0;
      return x.helpers.set(P, I + 1), P;
    },
    removeHelper(P) {
      const I = x.helpers.get(P);
      if (I) {
        const $ = I - 1;
        $ ? x.helpers.set(P, $) : x.helpers.delete(P);
      }
    },
    helperString(P) {
      return `_${Jt[x.helper(P)]}`;
    },
    replaceNode(P) {
      {
        if (!x.currentNode)
          throw new Error("Node being replaced is already removed.");
        if (!x.parent)
          throw new Error("Cannot replace root node.");
      }
      x.parent.children[x.childIndex] = x.currentNode = P;
    },
    removeNode(P) {
      if (!x.parent)
        throw new Error("Cannot remove root node.");
      const I = x.parent.children, $ = P ? I.indexOf(P) : x.currentNode ? x.childIndex : -1;
      if ($ < 0)
        throw new Error("node being removed is not a child of current parent");
      !P || P === x.currentNode ? (x.currentNode = null, x.onNodeRemoved()) : x.childIndex > $ && (x.childIndex--, x.onNodeRemoved()), x.parent.children.splice($, 1);
    },
    onNodeRemoved: Nf,
    addIdentifiers(P) {
      Ie(P) ? _(P) : P.identifiers ? P.identifiers.forEach(_) : P.type === 4 && _(P.content);
    },
    removeIdentifiers(P) {
      Ie(P) ? T(P) : P.identifiers ? P.identifiers.forEach(T) : P.type === 4 && T(P.content);
    },
    hoist(P) {
      Ie(P) && (P = Q(P)), x.hoists.push(P);
      const I = Q(
        `_hoisted_${x.hoists.length}`,
        !1,
        P.loc,
        2
      );
      return I.hoisted = P, I;
    },
    cache(P, I = !1) {
      return GE(x.cached++, P, I);
    }
  };
  function _(P) {
    const { identifiers: I } = x;
    I[P] === void 0 && (I[P] = 0), I[P]++;
  }
  function T(P) {
    x.identifiers[P]--;
  }
  return x;
}
function _m(r, e) {
  const t = Ho(r, e);
  Qn(r, t), e.hoistStatic && uI(r, t), e.ssr || cI(r, t), r.helpers = /* @__PURE__ */ new Set([...t.helpers.keys()]), r.components = [...t.components], r.directives = [...t.directives], r.imports = t.imports, r.hoists = t.hoists, r.temps = t.temps, r.cached = t.cached, r.transformed = !0;
}
function cI(r, e) {
  const { helper: t } = e, { children: s } = r;
  if (s.length === 1) {
    const i = s[0];
    if (LS(r, i) && i.codegenNode) {
      const n = i.codegenNode;
      n.type === 13 && kc(n, e), r.codegenNode = n;
    } else
      r.codegenNode = i;
  } else if (s.length > 1) {
    let i = 64, n = ti[64];
    s.filter((a) => a.type !== 3).length === 1 && (i |= 2048, n += `, ${ti[2048]}`), r.codegenNode = Rn(
      e,
      t(Dn),
      void 0,
      r.children,
      i,
      void 0,
      void 0,
      !0,
      void 0,
      !1
    );
  }
}
function fI(r, e) {
  let t = 0;
  const s = () => {
    t--;
  };
  for (; t < r.children.length; t++) {
    const i = r.children[t];
    Ie(i) || (e.grandParent = e.parent, e.parent = r, e.childIndex = t, e.onNodeRemoved = s, Qn(i, e));
  }
}
function Qn(r, e) {
  e.currentNode = r;
  const { nodeTransforms: t } = e, s = [];
  for (let n = 0; n < t.length; n++) {
    const a = t[n](r, e);
    if (a && (er(a) ? s.push(...a) : s.push(a)), e.currentNode)
      r = e.currentNode;
    else
      return;
  }
  switch (r.type) {
    case 3:
      e.ssr || e.helper(Jn);
      break;
    case 5:
      e.ssr || e.helper(Fo);
      break;
    case 9:
      for (let n = 0; n < r.branches.length; n++)
        Qn(r.branches[n], e);
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      fI(r, e);
      break;
  }
  e.currentNode = r;
  let i = s.length;
  for (; i--; )
    s[i]();
}
function Wo(r, e) {
  const t = Ie(r) ? (s) => s === r : (s) => r.test(s);
  return (s, i) => {
    if (s.type === 1) {
      const { props: n } = s;
      if (s.tagType === 3 && n.some(Sm))
        return;
      const a = [];
      for (let o = 0; o < n.length; o++) {
        const u = n[o];
        if (u.type === 7 && t(u.name)) {
          n.splice(o, 1), o--;
          const l = e(s, u, i);
          l && a.push(l);
        }
      }
      return a;
    }
  };
}
var Zn = {}, xm = {}, Bc = {}, wm = {}, Ay = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
wm.encode = function(r) {
  if (0 <= r && r < Ay.length)
    return Ay[r];
  throw new TypeError("Must be between 0 and 63: " + r);
};
wm.decode = function(r) {
  var e = 65, t = 90, s = 97, i = 122, n = 48, a = 57, o = 43, u = 47, l = 26, c = 52;
  return e <= r && r <= t ? r - e : s <= r && r <= i ? r - s + l : n <= r && r <= a ? r - n + c : r == o ? 62 : r == u ? 63 : -1;
};
var FS = wm, Tm = 5, BS = 1 << Tm, VS = BS - 1, US = BS;
function pI(r) {
  return r < 0 ? (-r << 1) + 1 : (r << 1) + 0;
}
function hI(r) {
  var e = (r & 1) === 1, t = r >> 1;
  return e ? -t : t;
}
Bc.encode = function(e) {
  var t = "", s, i = pI(e);
  do
    s = i & VS, i >>>= Tm, i > 0 && (s |= US), t += FS.encode(s);
  while (i > 0);
  return t;
};
Bc.decode = function(e, t, s) {
  var i = e.length, n = 0, a = 0, o, u;
  do {
    if (t >= i)
      throw new Error("Expected more digits in base 64 VLQ value.");
    if (u = FS.decode(e.charCodeAt(t++)), u === -1)
      throw new Error("Invalid base64 digit: " + e.charAt(t - 1));
    o = !!(u & US), u &= VS, n = n + (u << a), a += Tm;
  } while (o);
  s.value = hI(n), s.rest = t;
};
var ea = {};
(function(r) {
  function e(x, _, T) {
    if (_ in x)
      return x[_];
    if (arguments.length === 3)
      return T;
    throw new Error('"' + _ + '" is a required argument.');
  }
  r.getArg = e;
  var t = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, s = /^data:.+\,.+$/;
  function i(x) {
    var _ = x.match(t);
    return _ ? {
      scheme: _[1],
      auth: _[2],
      host: _[3],
      port: _[4],
      path: _[5]
    } : null;
  }
  r.urlParse = i;
  function n(x) {
    var _ = "";
    return x.scheme && (_ += x.scheme + ":"), _ += "//", x.auth && (_ += x.auth + "@"), x.host && (_ += x.host), x.port && (_ += ":" + x.port), x.path && (_ += x.path), _;
  }
  r.urlGenerate = n;
  var a = 32;
  function o(x) {
    var _ = [];
    return function(T) {
      for (var P = 0; P < _.length; P++)
        if (_[P].input === T) {
          var I = _[0];
          return _[0] = _[P], _[P] = I, _[0].result;
        }
      var $ = x(T);
      return _.unshift({
        input: T,
        result: $
      }), _.length > a && _.pop(), $;
    };
  }
  var u = o(function(_) {
    var T = _, P = i(_);
    if (P) {
      if (!P.path)
        return _;
      T = P.path;
    }
    for (var I = r.isAbsolute(T), $ = [], Y = 0, W = 0; ; )
      if (Y = W, W = T.indexOf("/", Y), W === -1) {
        $.push(T.slice(Y));
        break;
      } else
        for ($.push(T.slice(Y, W)); W < T.length && T[W] === "/"; )
          W++;
    for (var F, K = 0, W = $.length - 1; W >= 0; W--)
      F = $[W], F === "." ? $.splice(W, 1) : F === ".." ? K++ : K > 0 && (F === "" ? ($.splice(W + 1, K), K = 0) : ($.splice(W, 2), K--));
    return T = $.join("/"), T === "" && (T = I ? "/" : "."), P ? (P.path = T, n(P)) : T;
  });
  r.normalize = u;
  function l(x, _) {
    x === "" && (x = "."), _ === "" && (_ = ".");
    var T = i(_), P = i(x);
    if (P && (x = P.path || "/"), T && !T.scheme)
      return P && (T.scheme = P.scheme), n(T);
    if (T || _.match(s))
      return _;
    if (P && !P.host && !P.path)
      return P.host = _, n(P);
    var I = _.charAt(0) === "/" ? _ : u(x.replace(/\/+$/, "") + "/" + _);
    return P ? (P.path = I, n(P)) : I;
  }
  r.join = l, r.isAbsolute = function(x) {
    return x.charAt(0) === "/" || t.test(x);
  };
  function c(x, _) {
    x === "" && (x = "."), x = x.replace(/\/$/, "");
    for (var T = 0; _.indexOf(x + "/") !== 0; ) {
      var P = x.lastIndexOf("/");
      if (P < 0 || (x = x.slice(0, P), x.match(/^([^\/]+:\/)?\/*$/)))
        return _;
      ++T;
    }
    return Array(T + 1).join("../") + _.substr(x.length + 1);
  }
  r.relative = c;
  var f = function() {
    var x = /* @__PURE__ */ Object.create(null);
    return !("__proto__" in x);
  }();
  function p(x) {
    return x;
  }
  function h(x) {
    return d(x) ? "$" + x : x;
  }
  r.toSetString = f ? p : h;
  function m(x) {
    return d(x) ? x.slice(1) : x;
  }
  r.fromSetString = f ? p : m;
  function d(x) {
    if (!x)
      return !1;
    var _ = x.length;
    if (_ < 9 || x.charCodeAt(_ - 1) !== 95 || x.charCodeAt(_ - 2) !== 95 || x.charCodeAt(_ - 3) !== 111 || x.charCodeAt(_ - 4) !== 116 || x.charCodeAt(_ - 5) !== 111 || x.charCodeAt(_ - 6) !== 114 || x.charCodeAt(_ - 7) !== 112 || x.charCodeAt(_ - 8) !== 95 || x.charCodeAt(_ - 9) !== 95)
      return !1;
    for (var T = _ - 10; T >= 0; T--)
      if (x.charCodeAt(T) !== 36)
        return !1;
    return !0;
  }
  function y(x, _, T) {
    var P = b(x.source, _.source);
    return P !== 0 || (P = x.originalLine - _.originalLine, P !== 0) || (P = x.originalColumn - _.originalColumn, P !== 0 || T) || (P = x.generatedColumn - _.generatedColumn, P !== 0) || (P = x.generatedLine - _.generatedLine, P !== 0) ? P : b(x.name, _.name);
  }
  r.compareByOriginalPositions = y;
  function S(x, _, T) {
    var P;
    return P = x.originalLine - _.originalLine, P !== 0 || (P = x.originalColumn - _.originalColumn, P !== 0 || T) || (P = x.generatedColumn - _.generatedColumn, P !== 0) || (P = x.generatedLine - _.generatedLine, P !== 0) ? P : b(x.name, _.name);
  }
  r.compareByOriginalPositionsNoSource = S;
  function E(x, _, T) {
    var P = x.generatedLine - _.generatedLine;
    return P !== 0 || (P = x.generatedColumn - _.generatedColumn, P !== 0 || T) || (P = b(x.source, _.source), P !== 0) || (P = x.originalLine - _.originalLine, P !== 0) || (P = x.originalColumn - _.originalColumn, P !== 0) ? P : b(x.name, _.name);
  }
  r.compareByGeneratedPositionsDeflated = E;
  function g(x, _, T) {
    var P = x.generatedColumn - _.generatedColumn;
    return P !== 0 || T || (P = b(x.source, _.source), P !== 0) || (P = x.originalLine - _.originalLine, P !== 0) || (P = x.originalColumn - _.originalColumn, P !== 0) ? P : b(x.name, _.name);
  }
  r.compareByGeneratedPositionsDeflatedNoLine = g;
  function b(x, _) {
    return x === _ ? 0 : x === null ? 1 : _ === null ? -1 : x > _ ? 1 : -1;
  }
  function v(x, _) {
    var T = x.generatedLine - _.generatedLine;
    return T !== 0 || (T = x.generatedColumn - _.generatedColumn, T !== 0) || (T = b(x.source, _.source), T !== 0) || (T = x.originalLine - _.originalLine, T !== 0) || (T = x.originalColumn - _.originalColumn, T !== 0) ? T : b(x.name, _.name);
  }
  r.compareByGeneratedPositionsInflated = v;
  function A(x) {
    return JSON.parse(x.replace(/^\)]}'[^\n]*\n/, ""));
  }
  r.parseSourceMapInput = A;
  function C(x, _, T) {
    if (_ = _ || "", x && (x[x.length - 1] !== "/" && _[0] !== "/" && (x += "/"), _ = x + _), T) {
      var P = i(T);
      if (!P)
        throw new Error("sourceMapURL could not be parsed");
      if (P.path) {
        var I = P.path.lastIndexOf("/");
        I >= 0 && (P.path = P.path.substring(0, I + 1));
      }
      _ = l(n(P), _);
    }
    return u(_);
  }
  r.computeSourceURL = C;
})(ea);
var Pm = {}, Am = ea, Cm = Object.prototype.hasOwnProperty, Fi = typeof Map < "u";
function Ps() {
  this._array = [], this._set = Fi ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
}
Ps.fromArray = function(e, t) {
  for (var s = new Ps(), i = 0, n = e.length; i < n; i++)
    s.add(e[i], t);
  return s;
};
Ps.prototype.size = function() {
  return Fi ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
Ps.prototype.add = function(e, t) {
  var s = Fi ? e : Am.toSetString(e), i = Fi ? this.has(e) : Cm.call(this._set, s), n = this._array.length;
  (!i || t) && this._array.push(e), i || (Fi ? this._set.set(e, n) : this._set[s] = n);
};
Ps.prototype.has = function(e) {
  if (Fi)
    return this._set.has(e);
  var t = Am.toSetString(e);
  return Cm.call(this._set, t);
};
Ps.prototype.indexOf = function(e) {
  if (Fi) {
    var t = this._set.get(e);
    if (t >= 0)
      return t;
  } else {
    var s = Am.toSetString(e);
    if (Cm.call(this._set, s))
      return this._set[s];
  }
  throw new Error('"' + e + '" is not in the set.');
};
Ps.prototype.at = function(e) {
  if (e >= 0 && e < this._array.length)
    return this._array[e];
  throw new Error("No element indexed by " + e);
};
Ps.prototype.toArray = function() {
  return this._array.slice();
};
Pm.ArraySet = Ps;
var jS = {}, qS = ea;
function dI(r, e) {
  var t = r.generatedLine, s = e.generatedLine, i = r.generatedColumn, n = e.generatedColumn;
  return s > t || s == t && n >= i || qS.compareByGeneratedPositionsInflated(r, e) <= 0;
}
function Vc() {
  this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
}
Vc.prototype.unsortedForEach = function(e, t) {
  this._array.forEach(e, t);
};
Vc.prototype.add = function(e) {
  dI(this._last, e) ? (this._last = e, this._array.push(e)) : (this._sorted = !1, this._array.push(e));
};
Vc.prototype.toArray = function() {
  return this._sorted || (this._array.sort(qS.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
};
jS.MappingList = Vc;
var va = Bc, at = ea, Tl = Pm.ArraySet, mI = jS.MappingList;
function vr(r) {
  r || (r = {}), this._file = at.getArg(r, "file", null), this._sourceRoot = at.getArg(r, "sourceRoot", null), this._skipValidation = at.getArg(r, "skipValidation", !1), this._ignoreInvalidMapping = at.getArg(r, "ignoreInvalidMapping", !1), this._sources = new Tl(), this._names = new Tl(), this._mappings = new mI(), this._sourcesContents = null;
}
vr.prototype._version = 3;
vr.fromSourceMap = function(e, t) {
  var s = e.sourceRoot, i = new vr(Object.assign(t || {}, {
    file: e.file,
    sourceRoot: s
  }));
  return e.eachMapping(function(n) {
    var a = {
      generated: {
        line: n.generatedLine,
        column: n.generatedColumn
      }
    };
    n.source != null && (a.source = n.source, s != null && (a.source = at.relative(s, a.source)), a.original = {
      line: n.originalLine,
      column: n.originalColumn
    }, n.name != null && (a.name = n.name)), i.addMapping(a);
  }), e.sources.forEach(function(n) {
    var a = n;
    s !== null && (a = at.relative(s, n)), i._sources.has(a) || i._sources.add(a);
    var o = e.sourceContentFor(n);
    o != null && i.setSourceContent(n, o);
  }), i;
};
vr.prototype.addMapping = function(e) {
  var t = at.getArg(e, "generated"), s = at.getArg(e, "original", null), i = at.getArg(e, "source", null), n = at.getArg(e, "name", null);
  !this._skipValidation && this._validateMapping(t, s, i, n) === !1 || (i != null && (i = String(i), this._sources.has(i) || this._sources.add(i)), n != null && (n = String(n), this._names.has(n) || this._names.add(n)), this._mappings.add({
    generatedLine: t.line,
    generatedColumn: t.column,
    originalLine: s != null && s.line,
    originalColumn: s != null && s.column,
    source: i,
    name: n
  }));
};
vr.prototype.setSourceContent = function(e, t) {
  var s = e;
  this._sourceRoot != null && (s = at.relative(this._sourceRoot, s)), t != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[at.toSetString(s)] = t) : this._sourcesContents && (delete this._sourcesContents[at.toSetString(s)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
};
vr.prototype.applySourceMap = function(e, t, s) {
  var i = t;
  if (t == null) {
    if (e.file == null)
      throw new Error(
        `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
      );
    i = e.file;
  }
  var n = this._sourceRoot;
  n != null && (i = at.relative(n, i));
  var a = new Tl(), o = new Tl();
  this._mappings.unsortedForEach(function(u) {
    if (u.source === i && u.originalLine != null) {
      var l = e.originalPositionFor({
        line: u.originalLine,
        column: u.originalColumn
      });
      l.source != null && (u.source = l.source, s != null && (u.source = at.join(s, u.source)), n != null && (u.source = at.relative(n, u.source)), u.originalLine = l.line, u.originalColumn = l.column, l.name != null && (u.name = l.name));
    }
    var c = u.source;
    c != null && !a.has(c) && a.add(c);
    var f = u.name;
    f != null && !o.has(f) && o.add(f);
  }, this), this._sources = a, this._names = o, e.sources.forEach(function(u) {
    var l = e.sourceContentFor(u);
    l != null && (s != null && (u = at.join(s, u)), n != null && (u = at.relative(n, u)), this.setSourceContent(u, l));
  }, this);
};
vr.prototype._validateMapping = function(e, t, s, i) {
  if (t && typeof t.line != "number" && typeof t.column != "number") {
    var n = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
    if (this._ignoreInvalidMapping)
      return typeof console < "u" && console.warn && console.warn(n), !1;
    throw new Error(n);
  }
  if (!(e && "line" in e && "column" in e && e.line > 0 && e.column >= 0 && !t && !s && !i)) {
    if (e && "line" in e && "column" in e && t && "line" in t && "column" in t && e.line > 0 && e.column >= 0 && t.line > 0 && t.column >= 0 && s)
      return;
    var n = "Invalid mapping: " + JSON.stringify({
      generated: e,
      source: s,
      original: t,
      name: i
    });
    if (this._ignoreInvalidMapping)
      return typeof console < "u" && console.warn && console.warn(n), !1;
    throw new Error(n);
  }
};
vr.prototype._serializeMappings = function() {
  for (var e = 0, t = 1, s = 0, i = 0, n = 0, a = 0, o = "", u, l, c, f, p = this._mappings.toArray(), h = 0, m = p.length; h < m; h++) {
    if (l = p[h], u = "", l.generatedLine !== t)
      for (e = 0; l.generatedLine !== t; )
        u += ";", t++;
    else if (h > 0) {
      if (!at.compareByGeneratedPositionsInflated(l, p[h - 1]))
        continue;
      u += ",";
    }
    u += va.encode(l.generatedColumn - e), e = l.generatedColumn, l.source != null && (f = this._sources.indexOf(l.source), u += va.encode(f - a), a = f, u += va.encode(l.originalLine - 1 - i), i = l.originalLine - 1, u += va.encode(l.originalColumn - s), s = l.originalColumn, l.name != null && (c = this._names.indexOf(l.name), u += va.encode(c - n), n = c)), o += u;
  }
  return o;
};
vr.prototype._generateSourcesContent = function(e, t) {
  return e.map(function(s) {
    if (!this._sourcesContents)
      return null;
    t != null && (s = at.relative(t, s));
    var i = at.toSetString(s);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, i) ? this._sourcesContents[i] : null;
  }, this);
};
vr.prototype.toJSON = function() {
  var e = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  return this._file != null && (e.file = this._file), this._sourceRoot != null && (e.sourceRoot = this._sourceRoot), this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot)), e;
};
vr.prototype.toString = function() {
  return JSON.stringify(this.toJSON());
};
xm.SourceMapGenerator = vr;
var Uc = {}, HS = {};
(function(r) {
  r.GREATEST_LOWER_BOUND = 1, r.LEAST_UPPER_BOUND = 2;
  function e(t, s, i, n, a, o) {
    var u = Math.floor((s - t) / 2) + t, l = a(i, n[u], !0);
    return l === 0 ? u : l > 0 ? s - u > 1 ? e(u, s, i, n, a, o) : o == r.LEAST_UPPER_BOUND ? s < n.length ? s : -1 : u : u - t > 1 ? e(t, u, i, n, a, o) : o == r.LEAST_UPPER_BOUND ? u : t < 0 ? -1 : t;
  }
  r.search = function(s, i, n, a) {
    if (i.length === 0)
      return -1;
    var o = e(
      -1,
      i.length,
      s,
      i,
      n,
      a || r.GREATEST_LOWER_BOUND
    );
    if (o < 0)
      return -1;
    for (; o - 1 >= 0 && n(i[o], i[o - 1], !0) === 0; )
      --o;
    return o;
  };
})(HS);
var WS = {};
function gI(r) {
  function e(i, n, a) {
    var o = i[n];
    i[n] = i[a], i[a] = o;
  }
  function t(i, n) {
    return Math.round(i + Math.random() * (n - i));
  }
  function s(i, n, a, o) {
    if (a < o) {
      var u = t(a, o), l = a - 1;
      e(i, u, o);
      for (var c = i[o], f = a; f < o; f++)
        n(i[f], c, !1) <= 0 && (l += 1, e(i, l, f));
      e(i, l + 1, f);
      var p = l + 1;
      s(i, n, a, p - 1), s(i, n, p + 1, o);
    }
  }
  return s;
}
function yI(r) {
  let e = gI.toString();
  return new Function(`return ${e}`)()(r);
}
let Cy = /* @__PURE__ */ new WeakMap();
WS.quickSort = function(r, e, t = 0) {
  let s = Cy.get(e);
  s === void 0 && (s = yI(e), Cy.set(e, s)), s(r, e, t, r.length - 1);
};
var ue = ea, Nm = HS, Vn = Pm.ArraySet, bI = Bc, mo = WS.quickSort;
function Ye(r, e) {
  var t = r;
  return typeof r == "string" && (t = ue.parseSourceMapInput(r)), t.sections != null ? new Ir(t, e) : new Nt(t, e);
}
Ye.fromSourceMap = function(r, e) {
  return Nt.fromSourceMap(r, e);
};
Ye.prototype._version = 3;
Ye.prototype.__generatedMappings = null;
Object.defineProperty(Ye.prototype, "_generatedMappings", {
  configurable: !0,
  enumerable: !0,
  get: function() {
    return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
  }
});
Ye.prototype.__originalMappings = null;
Object.defineProperty(Ye.prototype, "_originalMappings", {
  configurable: !0,
  enumerable: !0,
  get: function() {
    return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
  }
});
Ye.prototype._charIsMappingSeparator = function(e, t) {
  var s = e.charAt(t);
  return s === ";" || s === ",";
};
Ye.prototype._parseMappings = function(e, t) {
  throw new Error("Subclasses must implement _parseMappings");
};
Ye.GENERATED_ORDER = 1;
Ye.ORIGINAL_ORDER = 2;
Ye.GREATEST_LOWER_BOUND = 1;
Ye.LEAST_UPPER_BOUND = 2;
Ye.prototype.eachMapping = function(e, t, s) {
  var i = t || null, n = s || Ye.GENERATED_ORDER, a;
  switch (n) {
    case Ye.GENERATED_ORDER:
      a = this._generatedMappings;
      break;
    case Ye.ORIGINAL_ORDER:
      a = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }
  for (var o = this.sourceRoot, u = e.bind(i), l = this._names, c = this._sources, f = this._sourceMapURL, p = 0, h = a.length; p < h; p++) {
    var m = a[p], d = m.source === null ? null : c.at(m.source);
    d = ue.computeSourceURL(o, d, f), u({
      source: d,
      generatedLine: m.generatedLine,
      generatedColumn: m.generatedColumn,
      originalLine: m.originalLine,
      originalColumn: m.originalColumn,
      name: m.name === null ? null : l.at(m.name)
    });
  }
};
Ye.prototype.allGeneratedPositionsFor = function(e) {
  var t = ue.getArg(e, "line"), s = {
    source: ue.getArg(e, "source"),
    originalLine: t,
    originalColumn: ue.getArg(e, "column", 0)
  };
  if (s.source = this._findSourceIndex(s.source), s.source < 0)
    return [];
  var i = [], n = this._findMapping(
    s,
    this._originalMappings,
    "originalLine",
    "originalColumn",
    ue.compareByOriginalPositions,
    Nm.LEAST_UPPER_BOUND
  );
  if (n >= 0) {
    var a = this._originalMappings[n];
    if (e.column === void 0)
      for (var o = a.originalLine; a && a.originalLine === o; )
        i.push({
          line: ue.getArg(a, "generatedLine", null),
          column: ue.getArg(a, "generatedColumn", null),
          lastColumn: ue.getArg(a, "lastGeneratedColumn", null)
        }), a = this._originalMappings[++n];
    else
      for (var u = a.originalColumn; a && a.originalLine === t && a.originalColumn == u; )
        i.push({
          line: ue.getArg(a, "generatedLine", null),
          column: ue.getArg(a, "generatedColumn", null),
          lastColumn: ue.getArg(a, "lastGeneratedColumn", null)
        }), a = this._originalMappings[++n];
  }
  return i;
};
Uc.SourceMapConsumer = Ye;
function Nt(r, e) {
  var t = r;
  typeof r == "string" && (t = ue.parseSourceMapInput(r));
  var s = ue.getArg(t, "version"), i = ue.getArg(t, "sources"), n = ue.getArg(t, "names", []), a = ue.getArg(t, "sourceRoot", null), o = ue.getArg(t, "sourcesContent", null), u = ue.getArg(t, "mappings"), l = ue.getArg(t, "file", null);
  if (s != this._version)
    throw new Error("Unsupported version: " + s);
  a && (a = ue.normalize(a)), i = i.map(String).map(ue.normalize).map(function(c) {
    return a && ue.isAbsolute(a) && ue.isAbsolute(c) ? ue.relative(a, c) : c;
  }), this._names = Vn.fromArray(n.map(String), !0), this._sources = Vn.fromArray(i, !0), this._absoluteSources = this._sources.toArray().map(function(c) {
    return ue.computeSourceURL(a, c, e);
  }), this.sourceRoot = a, this.sourcesContent = o, this._mappings = u, this._sourceMapURL = e, this.file = l;
}
Nt.prototype = Object.create(Ye.prototype);
Nt.prototype.consumer = Ye;
Nt.prototype._findSourceIndex = function(r) {
  var e = r;
  if (this.sourceRoot != null && (e = ue.relative(this.sourceRoot, e)), this._sources.has(e))
    return this._sources.indexOf(e);
  var t;
  for (t = 0; t < this._absoluteSources.length; ++t)
    if (this._absoluteSources[t] == r)
      return t;
  return -1;
};
Nt.fromSourceMap = function(e, t) {
  var s = Object.create(Nt.prototype), i = s._names = Vn.fromArray(e._names.toArray(), !0), n = s._sources = Vn.fromArray(e._sources.toArray(), !0);
  s.sourceRoot = e._sourceRoot, s.sourcesContent = e._generateSourcesContent(
    s._sources.toArray(),
    s.sourceRoot
  ), s.file = e._file, s._sourceMapURL = t, s._absoluteSources = s._sources.toArray().map(function(h) {
    return ue.computeSourceURL(s.sourceRoot, h, t);
  });
  for (var a = e._mappings.toArray().slice(), o = s.__generatedMappings = [], u = s.__originalMappings = [], l = 0, c = a.length; l < c; l++) {
    var f = a[l], p = new zS();
    p.generatedLine = f.generatedLine, p.generatedColumn = f.generatedColumn, f.source && (p.source = n.indexOf(f.source), p.originalLine = f.originalLine, p.originalColumn = f.originalColumn, f.name && (p.name = i.indexOf(f.name)), u.push(p)), o.push(p);
  }
  return mo(s.__originalMappings, ue.compareByOriginalPositions), s;
};
Nt.prototype._version = 3;
Object.defineProperty(Nt.prototype, "sources", {
  get: function() {
    return this._absoluteSources.slice();
  }
});
function zS() {
  this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
}
const Ff = ue.compareByGeneratedPositionsDeflatedNoLine;
function Ny(r, e) {
  let t = r.length, s = r.length - e;
  if (!(s <= 1))
    if (s == 2) {
      let i = r[e], n = r[e + 1];
      Ff(i, n) > 0 && (r[e] = n, r[e + 1] = i);
    } else if (s < 20)
      for (let i = e; i < t; i++)
        for (let n = i; n > e; n--) {
          let a = r[n - 1], o = r[n];
          if (Ff(a, o) <= 0)
            break;
          r[n - 1] = o, r[n] = a;
        }
    else
      mo(r, Ff, e);
}
Nt.prototype._parseMappings = function(e, t) {
  var s = 1, i = 0, n = 0, a = 0, o = 0, u = 0, l = e.length, c = 0, f = {}, p = [], h = [], m, d, y, S;
  let E = 0;
  for (; c < l; )
    if (e.charAt(c) === ";")
      s++, c++, i = 0, Ny(h, E), E = h.length;
    else if (e.charAt(c) === ",")
      c++;
    else {
      for (m = new zS(), m.generatedLine = s, y = c; y < l && !this._charIsMappingSeparator(e, y); y++)
        ;
      for (e.slice(c, y), d = []; c < y; )
        bI.decode(e, c, f), S = f.value, c = f.rest, d.push(S);
      if (d.length === 2)
        throw new Error("Found a source, but no line and column");
      if (d.length === 3)
        throw new Error("Found a source and line, but no column");
      if (m.generatedColumn = i + d[0], i = m.generatedColumn, d.length > 1 && (m.source = o + d[1], o += d[1], m.originalLine = n + d[2], n = m.originalLine, m.originalLine += 1, m.originalColumn = a + d[3], a = m.originalColumn, d.length > 4 && (m.name = u + d[4], u += d[4])), h.push(m), typeof m.originalLine == "number") {
        let b = m.source;
        for (; p.length <= b; )
          p.push(null);
        p[b] === null && (p[b] = []), p[b].push(m);
      }
    }
  Ny(h, E), this.__generatedMappings = h;
  for (var g = 0; g < p.length; g++)
    p[g] != null && mo(p[g], ue.compareByOriginalPositionsNoSource);
  this.__originalMappings = [].concat(...p);
};
Nt.prototype._findMapping = function(e, t, s, i, n, a) {
  if (e[s] <= 0)
    throw new TypeError("Line must be greater than or equal to 1, got " + e[s]);
  if (e[i] < 0)
    throw new TypeError("Column must be greater than or equal to 0, got " + e[i]);
  return Nm.search(e, t, n, a);
};
Nt.prototype.computeColumnSpans = function() {
  for (var e = 0; e < this._generatedMappings.length; ++e) {
    var t = this._generatedMappings[e];
    if (e + 1 < this._generatedMappings.length) {
      var s = this._generatedMappings[e + 1];
      if (t.generatedLine === s.generatedLine) {
        t.lastGeneratedColumn = s.generatedColumn - 1;
        continue;
      }
    }
    t.lastGeneratedColumn = 1 / 0;
  }
};
Nt.prototype.originalPositionFor = function(e) {
  var t = {
    generatedLine: ue.getArg(e, "line"),
    generatedColumn: ue.getArg(e, "column")
  }, s = this._findMapping(
    t,
    this._generatedMappings,
    "generatedLine",
    "generatedColumn",
    ue.compareByGeneratedPositionsDeflated,
    ue.getArg(e, "bias", Ye.GREATEST_LOWER_BOUND)
  );
  if (s >= 0) {
    var i = this._generatedMappings[s];
    if (i.generatedLine === t.generatedLine) {
      var n = ue.getArg(i, "source", null);
      n !== null && (n = this._sources.at(n), n = ue.computeSourceURL(this.sourceRoot, n, this._sourceMapURL));
      var a = ue.getArg(i, "name", null);
      return a !== null && (a = this._names.at(a)), {
        source: n,
        line: ue.getArg(i, "originalLine", null),
        column: ue.getArg(i, "originalColumn", null),
        name: a
      };
    }
  }
  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
Nt.prototype.hasContentsOfAllSources = function() {
  return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e) {
    return e == null;
  }) : !1;
};
Nt.prototype.sourceContentFor = function(e, t) {
  if (!this.sourcesContent)
    return null;
  var s = this._findSourceIndex(e);
  if (s >= 0)
    return this.sourcesContent[s];
  var i = e;
  this.sourceRoot != null && (i = ue.relative(this.sourceRoot, i));
  var n;
  if (this.sourceRoot != null && (n = ue.urlParse(this.sourceRoot))) {
    var a = i.replace(/^file:\/\//, "");
    if (n.scheme == "file" && this._sources.has(a))
      return this.sourcesContent[this._sources.indexOf(a)];
    if ((!n.path || n.path == "/") && this._sources.has("/" + i))
      return this.sourcesContent[this._sources.indexOf("/" + i)];
  }
  if (t)
    return null;
  throw new Error('"' + i + '" is not in the SourceMap.');
};
Nt.prototype.generatedPositionFor = function(e) {
  var t = ue.getArg(e, "source");
  if (t = this._findSourceIndex(t), t < 0)
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  var s = {
    source: t,
    originalLine: ue.getArg(e, "line"),
    originalColumn: ue.getArg(e, "column")
  }, i = this._findMapping(
    s,
    this._originalMappings,
    "originalLine",
    "originalColumn",
    ue.compareByOriginalPositions,
    ue.getArg(e, "bias", Ye.GREATEST_LOWER_BOUND)
  );
  if (i >= 0) {
    var n = this._originalMappings[i];
    if (n.source === s.source)
      return {
        line: ue.getArg(n, "generatedLine", null),
        column: ue.getArg(n, "generatedColumn", null),
        lastColumn: ue.getArg(n, "lastGeneratedColumn", null)
      };
  }
  return {
    line: null,
    column: null,
    lastColumn: null
  };
};
Uc.BasicSourceMapConsumer = Nt;
function Ir(r, e) {
  var t = r;
  typeof r == "string" && (t = ue.parseSourceMapInput(r));
  var s = ue.getArg(t, "version"), i = ue.getArg(t, "sections");
  if (s != this._version)
    throw new Error("Unsupported version: " + s);
  this._sources = new Vn(), this._names = new Vn();
  var n = {
    line: -1,
    column: 0
  };
  this._sections = i.map(function(a) {
    if (a.url)
      throw new Error("Support for url field in sections not implemented.");
    var o = ue.getArg(a, "offset"), u = ue.getArg(o, "line"), l = ue.getArg(o, "column");
    if (u < n.line || u === n.line && l < n.column)
      throw new Error("Section offsets must be ordered and non-overlapping.");
    return n = o, {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: u + 1,
        generatedColumn: l + 1
      },
      consumer: new Ye(ue.getArg(a, "map"), e)
    };
  });
}
Ir.prototype = Object.create(Ye.prototype);
Ir.prototype.constructor = Ye;
Ir.prototype._version = 3;
Object.defineProperty(Ir.prototype, "sources", {
  get: function() {
    for (var r = [], e = 0; e < this._sections.length; e++)
      for (var t = 0; t < this._sections[e].consumer.sources.length; t++)
        r.push(this._sections[e].consumer.sources[t]);
    return r;
  }
});
Ir.prototype.originalPositionFor = function(e) {
  var t = {
    generatedLine: ue.getArg(e, "line"),
    generatedColumn: ue.getArg(e, "column")
  }, s = Nm.search(
    t,
    this._sections,
    function(n, a) {
      var o = n.generatedLine - a.generatedOffset.generatedLine;
      return o || n.generatedColumn - a.generatedOffset.generatedColumn;
    }
  ), i = this._sections[s];
  return i ? i.consumer.originalPositionFor({
    line: t.generatedLine - (i.generatedOffset.generatedLine - 1),
    column: t.generatedColumn - (i.generatedOffset.generatedLine === t.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),
    bias: e.bias
  }) : {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
Ir.prototype.hasContentsOfAllSources = function() {
  return this._sections.every(function(e) {
    return e.consumer.hasContentsOfAllSources();
  });
};
Ir.prototype.sourceContentFor = function(e, t) {
  for (var s = 0; s < this._sections.length; s++) {
    var i = this._sections[s], n = i.consumer.sourceContentFor(e, !0);
    if (n || n === "")
      return n;
  }
  if (t)
    return null;
  throw new Error('"' + e + '" is not in the SourceMap.');
};
Ir.prototype.generatedPositionFor = function(e) {
  for (var t = 0; t < this._sections.length; t++) {
    var s = this._sections[t];
    if (s.consumer._findSourceIndex(ue.getArg(e, "source")) !== -1) {
      var i = s.consumer.generatedPositionFor(e);
      if (i) {
        var n = {
          line: i.line + (s.generatedOffset.generatedLine - 1),
          column: i.column + (s.generatedOffset.generatedLine === i.line ? s.generatedOffset.generatedColumn - 1 : 0)
        };
        return n;
      }
    }
  }
  return {
    line: null,
    column: null
  };
};
Ir.prototype._parseMappings = function(e, t) {
  this.__generatedMappings = [], this.__originalMappings = [];
  for (var s = 0; s < this._sections.length; s++)
    for (var i = this._sections[s], n = i.consumer._generatedMappings, a = 0; a < n.length; a++) {
      var o = n[a], u = i.consumer._sources.at(o.source);
      u = ue.computeSourceURL(i.consumer.sourceRoot, u, this._sourceMapURL), this._sources.add(u), u = this._sources.indexOf(u);
      var l = null;
      o.name && (l = i.consumer._names.at(o.name), this._names.add(l), l = this._names.indexOf(l));
      var c = {
        source: u,
        generatedLine: o.generatedLine + (i.generatedOffset.generatedLine - 1),
        generatedColumn: o.generatedColumn + (i.generatedOffset.generatedLine === o.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),
        originalLine: o.originalLine,
        originalColumn: o.originalColumn,
        name: l
      };
      this.__generatedMappings.push(c), typeof c.originalLine == "number" && this.__originalMappings.push(c);
    }
  mo(this.__generatedMappings, ue.compareByGeneratedPositionsDeflated), mo(this.__originalMappings, ue.compareByOriginalPositions);
};
Uc.IndexedSourceMapConsumer = Ir;
var GS = {}, vI = xm.SourceMapGenerator, Pl = ea, EI = /(\r?\n)/, SI = 10, ta = "$$$isSourceNode$$$";
function ur(r, e, t, s, i) {
  this.children = [], this.sourceContents = {}, this.line = r ?? null, this.column = e ?? null, this.source = t ?? null, this.name = i ?? null, this[ta] = !0, s != null && this.add(s);
}
ur.fromStringWithSourceMap = function(e, t, s) {
  var i = new ur(), n = e.split(EI), a = 0, o = function() {
    var p = m(), h = m() || "";
    return p + h;
    function m() {
      return a < n.length ? n[a++] : void 0;
    }
  }, u = 1, l = 0, c = null;
  return t.eachMapping(function(p) {
    if (c !== null)
      if (u < p.generatedLine)
        f(c, o()), u++, l = 0;
      else {
        var h = n[a] || "", m = h.substr(0, p.generatedColumn - l);
        n[a] = h.substr(p.generatedColumn - l), l = p.generatedColumn, f(c, m), c = p;
        return;
      }
    for (; u < p.generatedLine; )
      i.add(o()), u++;
    if (l < p.generatedColumn) {
      var h = n[a] || "";
      i.add(h.substr(0, p.generatedColumn)), n[a] = h.substr(p.generatedColumn), l = p.generatedColumn;
    }
    c = p;
  }, this), a < n.length && (c && f(c, o()), i.add(n.splice(a).join(""))), t.sources.forEach(function(p) {
    var h = t.sourceContentFor(p);
    h != null && (s != null && (p = Pl.join(s, p)), i.setSourceContent(p, h));
  }), i;
  function f(p, h) {
    if (p === null || p.source === void 0)
      i.add(h);
    else {
      var m = s ? Pl.join(s, p.source) : p.source;
      i.add(new ur(
        p.originalLine,
        p.originalColumn,
        m,
        h,
        p.name
      ));
    }
  }
};
ur.prototype.add = function(e) {
  if (Array.isArray(e))
    e.forEach(function(t) {
      this.add(t);
    }, this);
  else if (e[ta] || typeof e == "string")
    e && this.children.push(e);
  else
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e
    );
  return this;
};
ur.prototype.prepend = function(e) {
  if (Array.isArray(e))
    for (var t = e.length - 1; t >= 0; t--)
      this.prepend(e[t]);
  else if (e[ta] || typeof e == "string")
    this.children.unshift(e);
  else
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e
    );
  return this;
};
ur.prototype.walk = function(e) {
  for (var t, s = 0, i = this.children.length; s < i; s++)
    t = this.children[s], t[ta] ? t.walk(e) : t !== "" && e(t, {
      source: this.source,
      line: this.line,
      column: this.column,
      name: this.name
    });
};
ur.prototype.join = function(e) {
  var t, s, i = this.children.length;
  if (i > 0) {
    for (t = [], s = 0; s < i - 1; s++)
      t.push(this.children[s]), t.push(e);
    t.push(this.children[s]), this.children = t;
  }
  return this;
};
ur.prototype.replaceRight = function(e, t) {
  var s = this.children[this.children.length - 1];
  return s[ta] ? s.replaceRight(e, t) : typeof s == "string" ? this.children[this.children.length - 1] = s.replace(e, t) : this.children.push("".replace(e, t)), this;
};
ur.prototype.setSourceContent = function(e, t) {
  this.sourceContents[Pl.toSetString(e)] = t;
};
ur.prototype.walkSourceContents = function(e) {
  for (var t = 0, s = this.children.length; t < s; t++)
    this.children[t][ta] && this.children[t].walkSourceContents(e);
  for (var i = Object.keys(this.sourceContents), t = 0, s = i.length; t < s; t++)
    e(Pl.fromSetString(i[t]), this.sourceContents[i[t]]);
};
ur.prototype.toString = function() {
  var e = "";
  return this.walk(function(t) {
    e += t;
  }), e;
};
ur.prototype.toStringWithSourceMap = function(e) {
  var t = {
    code: "",
    line: 1,
    column: 0
  }, s = new vI(e), i = !1, n = null, a = null, o = null, u = null;
  return this.walk(function(l, c) {
    t.code += l, c.source !== null && c.line !== null && c.column !== null ? ((n !== c.source || a !== c.line || o !== c.column || u !== c.name) && s.addMapping({
      source: c.source,
      original: {
        line: c.line,
        column: c.column
      },
      generated: {
        line: t.line,
        column: t.column
      },
      name: c.name
    }), n = c.source, a = c.line, o = c.column, u = c.name, i = !0) : i && (s.addMapping({
      generated: {
        line: t.line,
        column: t.column
      }
    }), n = null, i = !1);
    for (var f = 0, p = l.length; f < p; f++)
      l.charCodeAt(f) === SI ? (t.line++, t.column = 0, f + 1 === p ? (n = null, i = !1) : i && s.addMapping({
        source: c.source,
        original: {
          line: c.line,
          column: c.column
        },
        generated: {
          line: t.line,
          column: t.column
        },
        name: c.name
      })) : t.column++;
  }), this.walkSourceContents(function(l, c) {
    s.setSourceContent(l, c);
  }), { code: t.code, map: s };
};
GS.SourceNode = ur;
var Om = Zn.SourceMapGenerator = xm.SourceMapGenerator, Oy = Zn.SourceMapConsumer = Uc.SourceMapConsumer;
Zn.SourceNode = GS.SourceNode;
const zo = "/*#__PURE__*/", ju = (r) => `${Jt[r]}: _${Jt[r]}`;
function Iy(r, {
  mode: e = "function",
  prefixIdentifiers: t = e === "module",
  sourceMap: s = !1,
  filename: i = "template.vue.html",
  scopeId: n = null,
  optimizeImports: a = !1,
  runtimeGlobalName: o = "Vue",
  runtimeModuleName: u = "vue",
  ssrRuntimeModuleName: l = "vue/server-renderer",
  ssr: c = !1,
  isTS: f = !1,
  inSSR: p = !1
}) {
  const h = {
    mode: e,
    prefixIdentifiers: t,
    sourceMap: s,
    filename: i,
    scopeId: n,
    optimizeImports: a,
    runtimeGlobalName: o,
    runtimeModuleName: u,
    ssrRuntimeModuleName: l,
    ssr: c,
    isTS: f,
    inSSR: p,
    source: r.source,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: !1,
    map: void 0,
    helper(y) {
      return `_${Jt[y]}`;
    },
    push(y, S = -2, E) {
      if (h.code += y, h.map) {
        if (E) {
          let g;
          if (E.type === 4 && !E.isStatic) {
            const b = E.content.replace(/^_ctx\./, "");
            b !== E.content && Ts(b) && (g = b);
          }
          d(E.loc.start, g);
        }
        S === -3 ? Em(h, y) : (h.offset += y.length, S === -2 ? h.column += y.length : (S === -1 && (S = y.length - 1), h.line++, h.column = y.length - S)), E && E.loc !== rt && d(E.loc.end);
      }
    },
    indent() {
      m(++h.indentLevel);
    },
    deindent(y = !1) {
      y ? --h.indentLevel : m(--h.indentLevel);
    },
    newline() {
      m(h.indentLevel);
    }
  };
  function m(y) {
    h.push(
      `
` + "  ".repeat(y),
      0
      /* Start */
    );
  }
  function d(y, S = null) {
    const { _names: E, _mappings: g } = h.map;
    S !== null && !E.has(S) && E.add(S), g.add({
      originalLine: y.line,
      originalColumn: y.column - 1,
      // source-map column is 0 based
      generatedLine: h.line,
      generatedColumn: h.column - 1,
      source: i,
      name: S
    });
  }
  return s && (h.map = new Om(), h.map.setSourceContent(i, h.source), h.map._sources.add(i)), h;
}
function Im(r, e = {}) {
  const t = Iy(r, e);
  e.onContextCreated && e.onContextCreated(t);
  const {
    mode: s,
    push: i,
    prefixIdentifiers: n,
    indent: a,
    deindent: o,
    newline: u,
    scopeId: l,
    ssr: c
  } = t, f = Array.from(r.helpers), p = f.length > 0, h = !n && s !== "module", m = l != null && s === "module", d = !!e.inline, y = d ? Iy(r, e) : t;
  s === "module" ? xI(r, y, m, d) : _I(r, y);
  const S = c ? "ssrRender" : "render", E = c ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  e.bindingMetadata && !e.inline && E.push("$props", "$setup", "$data", "$options");
  const g = e.isTS ? E.map((b) => `${b}: any`).join(",") : E.join(", ");
  if (i(d ? `(${g}) => {` : `function ${S}(${g}) {`), a(), h && (i("with (_ctx) {"), a(), p && (i(
    `const { ${f.map(ju).join(", ")} } = _Vue
`,
    -1
    /* End */
  ), u())), r.components.length && (ky(r.components, "component", t), (r.directives.length || r.temps > 0) && u()), r.directives.length && (ky(r.directives, "directive", t), r.temps > 0 && u()), r.temps > 0) {
    i("let ");
    for (let b = 0; b < r.temps; b++)
      i(`${b > 0 ? ", " : ""}_temp${b}`);
  }
  return (r.components.length || r.directives.length || r.temps) && (i(
    `
`,
    0
    /* Start */
  ), u()), c || i("return "), r.codegenNode ? tt(r.codegenNode, t) : i("null"), h && (o(), i("}")), o(), i("}"), {
    ast: r,
    code: t.code,
    preamble: d ? y.code : "",
    map: t.map ? t.map.toJSON() : void 0
  };
}
function _I(r, e) {
  const {
    ssr: t,
    prefixIdentifiers: s,
    push: i,
    newline: n,
    runtimeModuleName: a,
    runtimeGlobalName: o,
    ssrRuntimeModuleName: u
  } = e, l = t ? `require(${JSON.stringify(a)})` : o, c = Array.from(r.helpers);
  if (c.length > 0) {
    if (s)
      i(
        `const { ${c.map(ju).join(", ")} } = ${l}
`,
        -1
        /* End */
      );
    else if (i(
      `const _Vue = ${l}
`,
      -1
      /* End */
    ), r.hoists.length) {
      const f = [
        Ro,
        vc,
        Jn,
        Ec,
        Sc
      ].filter((p) => c.includes(p)).map(ju).join(", ");
      i(
        `const { ${f} } = _Vue
`,
        -1
        /* End */
      );
    }
  }
  r.ssrHelpers && r.ssrHelpers.length && i(
    `const { ${r.ssrHelpers.map(ju).join(", ")} } = require("${u}")
`,
    -1
    /* End */
  ), KS(r.hoists, e), n(), i("return ");
}
function xI(r, e, t, s) {
  const {
    push: i,
    newline: n,
    optimizeImports: a,
    runtimeModuleName: o,
    ssrRuntimeModuleName: u
  } = e;
  if (t && r.hoists.length && (r.helpers.add(Cc), r.helpers.add(Nc)), r.helpers.size) {
    const l = Array.from(r.helpers);
    a ? (i(
      `import { ${l.map((c) => Jt[c]).join(", ")} } from ${JSON.stringify(o)}
`,
      -1
      /* End */
    ), i(
      `
// Binding optimization for webpack code-split
const ${l.map((c) => `_${Jt[c]} = ${Jt[c]}`).join(", ")}
`,
      -1
      /* End */
    )) : i(
      `import { ${l.map((c) => `${Jt[c]} as _${Jt[c]}`).join(", ")} } from ${JSON.stringify(o)}
`,
      -1
      /* End */
    );
  }
  r.ssrHelpers && r.ssrHelpers.length && i(
    `import { ${r.ssrHelpers.map((l) => `${Jt[l]} as _${Jt[l]}`).join(", ")} } from "${u}"
`,
    -1
    /* End */
  ), r.imports.length && (wI(r.imports, e), n()), KS(r.hoists, e), n(), s || i("export ");
}
function ky(r, e, { helper: t, push: s, newline: i, isTS: n }) {
  const a = t(
    e === "component" ? uo : _c
  );
  for (let o = 0; o < r.length; o++) {
    let u = r[o];
    const l = u.endsWith("__self");
    l && (u = u.slice(0, -6)), s(
      `const ${ho(u, e)} = ${a}(${JSON.stringify(u)}${l ? ", true" : ""})${n ? "!" : ""}`
    ), o < r.length - 1 && i();
  }
}
function KS(r, e) {
  if (!r.length)
    return;
  e.pure = !0;
  const { push: t, newline: s, helper: i, scopeId: n, mode: a } = e, o = n != null && a !== "function";
  if (s(), o) {
    const u = e.isTS ? "(n: any)" : "n";
    t(
      `const _withScopeId = ${u} => (${i(
        Cc
      )}("${n}"),n=n(),${i(Nc)}(),n)`
    ), s();
  }
  for (let u = 0; u < r.length; u++) {
    const l = r[u];
    if (l) {
      const c = o && l.type === 13;
      t(
        `const _hoisted_${u + 1} = ${c ? `${zo} _withScopeId(() => ` : ""}`
      ), tt(l, e), c && t(")"), s();
    }
  }
  e.pure = !1;
}
function wI(r, e) {
  r.length && r.forEach((t) => {
    e.push("import "), tt(t.exp, e), e.push(` from '${t.path}'`), e.newline();
  });
}
function TI(r) {
  return Ie(r) || r.type === 4 || r.type === 2 || r.type === 5 || r.type === 8;
}
function jc(r, e) {
  const t = r.length > 3 || r.some((s) => er(s) || !TI(s));
  e.push("["), t && e.indent(), ra(r, e, t), t && e.deindent(), e.push("]");
}
function ra(r, e, t = !1, s = !0) {
  const { push: i, newline: n } = e;
  for (let a = 0; a < r.length; a++) {
    const o = r[a];
    Ie(o) ? i(
      o,
      -3
      /* Unknown */
    ) : er(o) ? jc(o, e) : tt(o, e), a < r.length - 1 && (t ? (s && i(","), n()) : s && i(", "));
  }
}
function tt(r, e) {
  if (Ie(r)) {
    e.push(
      r,
      -3
      /* Unknown */
    );
    return;
  }
  if (fi(r)) {
    e.push(e.helper(r));
    return;
  }
  switch (r.type) {
    case 1:
    case 9:
    case 11:
      Up(
        r.codegenNode != null,
        "Codegen node is missing for element/if/for node. Apply appropriate transforms first."
      ), tt(r.codegenNode, e);
      break;
    case 2:
      PI(r, e);
      break;
    case 4:
      XS(r, e);
      break;
    case 5:
      AI(r, e);
      break;
    case 12:
      tt(r.codegenNode, e);
      break;
    case 8:
      JS(r, e);
      break;
    case 3:
      NI(r, e);
      break;
    case 13:
      OI(r, e);
      break;
    case 14:
      kI(r, e);
      break;
    case 15:
      DI(r, e);
      break;
    case 17:
      LI(r, e);
      break;
    case 18:
      MI(r, e);
      break;
    case 19:
      RI(r, e);
      break;
    case 20:
      $I(r, e);
      break;
    case 21:
      ra(r.body, e, !0, !1);
      break;
    case 22:
      FI(r, e);
      break;
    case 23:
      YS(r, e);
      break;
    case 24:
      BI(r, e);
      break;
    case 25:
      VI(r, e);
      break;
    case 26:
      UI(r, e);
      break;
    case 10:
      break;
    default:
      return Up(!1, `unhandled codegen node type: ${r.type}`), r;
  }
}
function PI(r, e) {
  e.push(JSON.stringify(r.content), -3, r);
}
function XS(r, e) {
  const { content: t, isStatic: s } = r;
  e.push(
    s ? JSON.stringify(t) : t,
    -3,
    r
  );
}
function AI(r, e) {
  const { push: t, helper: s, pure: i } = e;
  i && t(zo), t(`${s(Fo)}(`), tt(r.content, e), t(")");
}
function JS(r, e) {
  for (let t = 0; t < r.children.length; t++) {
    const s = r.children[t];
    Ie(s) ? e.push(
      s,
      -3
      /* Unknown */
    ) : tt(s, e);
  }
}
function CI(r, e) {
  const { push: t } = e;
  if (r.type === 8)
    t("["), JS(r, e), t("]");
  else if (r.isStatic) {
    const s = Ts(r.content) ? r.content : JSON.stringify(r.content);
    t(s, -2, r);
  } else
    t(`[${r.content}]`, -3, r);
}
function NI(r, e) {
  const { push: t, helper: s, pure: i } = e;
  i && t(zo), t(
    `${s(Jn)}(${JSON.stringify(r.content)})`,
    -3,
    r
  );
}
function OI(r, e) {
  const { push: t, helper: s, pure: i } = e, {
    tag: n,
    props: a,
    children: o,
    patchFlag: u,
    dynamicProps: l,
    directives: c,
    isBlock: f,
    disableTracking: p,
    isComponent: h
  } = r;
  let m;
  if (u)
    if (u < 0)
      m = u + ` /* ${ti[u]} */`;
    else {
      const y = Object.keys(ti).map(Number).filter((S) => S > 0 && u & S).map((S) => ti[S]).join(", ");
      m = u + ` /* ${y} */`;
    }
  c && t(s(xc) + "("), f && t(`(${s(ui)}(${p ? "true" : ""}), `), i && t(zo);
  const d = f ? Xi(e.inSSR, h) : Ki(e.inSSR, h);
  t(s(d) + "(", -2, r), ra(
    II([n, a, o, m, l]),
    e
  ), t(")"), f && t(")"), c && (t(", "), tt(c, e), t(")"));
}
function II(r) {
  let e = r.length;
  for (; e-- && r[e] == null; )
    ;
  return r.slice(0, e + 1).map((t) => t || "null");
}
function kI(r, e) {
  const { push: t, helper: s, pure: i } = e, n = Ie(r.callee) ? r.callee : s(r.callee);
  i && t(zo), t(n + "(", -2, r), ra(r.arguments, e), t(")");
}
function DI(r, e) {
  const { push: t, indent: s, deindent: i, newline: n } = e, { properties: a } = r;
  if (!a.length) {
    t("{}", -2, r);
    return;
  }
  const o = a.length > 1 || a.some((u) => u.value.type !== 4);
  t(o ? "{" : "{ "), o && s();
  for (let u = 0; u < a.length; u++) {
    const { key: l, value: c } = a[u];
    CI(l, e), t(": "), tt(c, e), u < a.length - 1 && (t(","), n());
  }
  o && i(), t(o ? "}" : " }");
}
function LI(r, e) {
  jc(r.elements, e);
}
function MI(r, e) {
  const { push: t, indent: s, deindent: i } = e, { params: n, returns: a, body: o, newline: u, isSlot: l } = r;
  l && t(`_${Jt[Oc]}(`), t("(", -2, r), er(n) ? ra(n, e) : n && tt(n, e), t(") => "), (u || o) && (t("{"), s()), a ? (u && t("return "), er(a) ? jc(a, e) : tt(a, e)) : o && tt(o, e), (u || o) && (i(), t("}")), l && t(")");
}
function RI(r, e) {
  const { test: t, consequent: s, alternate: i, newline: n } = r, { push: a, indent: o, deindent: u, newline: l } = e;
  if (t.type === 4) {
    const f = !Ts(t.content);
    f && a("("), XS(t, e), f && a(")");
  } else
    a("("), tt(t, e), a(")");
  n && o(), e.indentLevel++, n || a(" "), a("? "), tt(s, e), e.indentLevel--, n && l(), n || a(" "), a(": ");
  const c = i.type === 19;
  c || e.indentLevel++, tt(i, e), c || e.indentLevel--, n && u(
    !0
    /* without newline */
  );
}
function $I(r, e) {
  const { push: t, helper: s, indent: i, deindent: n, newline: a } = e;
  t(`_cache[${r.index}] || (`), r.isVOnce && (i(), t(`${s(lo)}(-1),`), a(), t("(")), t(`_cache[${r.index}] = `), tt(r.value, e), r.isVOnce && (t(`).cacheIndex = ${r.index},`), a(), t(`${s(lo)}(1),`), a(), t(`_cache[${r.index}]`), n()), t(")");
}
function FI(r, e) {
  const { push: t, indent: s, deindent: i } = e;
  t("`");
  const n = r.elements.length, a = n > 3;
  for (let o = 0; o < n; o++) {
    const u = r.elements[o];
    Ie(u) ? t(
      u.replace(/(`|\$|\\)/g, "\\$1"),
      -3
      /* Unknown */
    ) : (t("${"), a && s(), tt(u, e), a && i(), t("}"));
  }
  t("`");
}
function YS(r, e) {
  const { push: t, indent: s, deindent: i } = e, { test: n, consequent: a, alternate: o } = r;
  t("if ("), tt(n, e), t(") {"), s(), tt(a, e), i(), t("}"), o && (t(" else "), o.type === 23 ? YS(o, e) : (t("{"), s(), tt(o, e), i(), t("}")));
}
function BI(r, e) {
  tt(r.left, e), e.push(" = "), tt(r.right, e);
}
function VI(r, e) {
  e.push("("), ra(r.expressions, e), e.push(")");
}
function UI({ returns: r }, e) {
  e.push("return "), er(r) ? jc(r, e) : tt(r, e);
}
const jI = /* @__PURE__ */ Rt("true,false,null,this"), km = (r, e) => {
  if (r.type === 5)
    r.content = vt(
      r.content,
      e
    );
  else if (r.type === 1)
    for (let t = 0; t < r.props.length; t++) {
      const s = r.props[t];
      if (s.type === 7 && s.name !== "for") {
        const i = s.exp, n = s.arg;
        i && i.type === 4 && !(s.name === "on" && n) && (s.exp = vt(
          i,
          e,
          // slot args must be processed as function params
          s.name === "slot"
        )), n && n.type === 4 && !n.isStatic && (s.arg = vt(n, e));
      }
    }
};
function vt(r, e, t = !1, s = !1, i = Object.create(e.identifiers)) {
  if (!e.prefixIdentifiers || !r.content.trim())
    return r;
  const { inline: n, bindingMetadata: a } = e, o = (d, y, S) => {
    const E = qd(a, d) && a[d];
    if (n) {
      const g = y && y.type === "AssignmentExpression" && y.left === S, b = y && y.type === "UpdateExpression" && y.argument === S, v = y && jo(y, f), A = y && SS(f), C = (x) => {
        const _ = `${e.helperString(Mn)}(${x})`;
        return A ? `(${_})` : _;
      };
      if (Dy(E) || E === "setup-reactive-const" || i[d])
        return d;
      if (E === "setup-ref")
        return `${d}.value`;
      if (E === "setup-maybe-ref")
        return g || b || v ? `${d}.value` : C(d);
      if (E === "setup-let")
        if (g) {
          const { right: x, operator: _ } = y, T = u.slice(x.start - 1, x.end - 1), P = qc(
            vt(
              Q(T, !1),
              e,
              !1,
              !1,
              p
            )
          );
          return `${e.helperString(co)}(${d})${e.isTS ? ` //@ts-ignore
` : ""} ? ${d}.value ${_} ${P} : ${d}`;
        } else if (b) {
          S.start = y.start, S.end = y.end;
          const { prefix: x, operator: _ } = y, T = x ? _ : "", P = x ? "" : _;
          return `${e.helperString(co)}(${d})${e.isTS ? ` //@ts-ignore
` : ""} ? ${T}${d}.value${P} : ${T}${d}${P}`;
        } else return v ? d : C(d);
      else {
        if (E === "props")
          return hl(d);
        if (E === "props-aliased")
          return hl(a.__propsAliases[d]);
      }
    } else {
      if (E && E.startsWith("setup") || E === "literal-const")
        return `$setup.${d}`;
      if (E === "props-aliased")
        return `$props['${a.__propsAliases[d]}']`;
      if (E)
        return `$${E}.${d}`;
    }
    return `_ctx.${d}`;
  }, u = r.content;
  let l = r.ast;
  if (l === !1)
    return r;
  if (l === null || !l && Ts(u)) {
    const d = e.identifiers[u], y = $E(u), S = jI(u);
    return !t && !d && !S && (!y || a[u]) ? (Dy(a[u]) && (r.constType = 1), r.content = o(u)) : d || (S ? r.constType = 3 : r.constType = 2), r;
  }
  if (!l) {
    const d = s ? ` ${u} ` : `(${u})${t ? "=>{}" : ""}`;
    try {
      l = _l(d, {
        sourceType: "module",
        plugins: e.expressionPlugins
      });
    } catch (y) {
      return e.onError(
        Me(
          45,
          r.loc,
          void 0,
          y.message
        )
      ), r;
    }
  }
  const c = [], f = [], p = Object.create(e.identifiers);
  Uo(
    l,
    (d, y, S, E, g) => {
      if (TS(d, y))
        return;
      const b = E && qI(d);
      b && !g ? (qo(y) && y.shorthand && (d.prefix = `${d.name}: `), d.name = o(d.name, y, d), c.push(d)) : (!(b && g) && (!y || y.type !== "CallExpression" && y.type !== "NewExpression" && y.type !== "MemberExpression") && (d.isConstant = !0), c.push(d));
    },
    !0,
    // invoke on ALL identifiers
    f,
    p
  );
  const h = [];
  c.sort((d, y) => d.start - y.start), c.forEach((d, y) => {
    const S = d.start - 1, E = d.end - 1, g = c[y - 1], b = u.slice(g ? g.end - 1 : 0, S);
    (b.length || d.prefix) && h.push(b + (d.prefix || ""));
    const v = u.slice(S, E);
    h.push(
      Q(
        d.name,
        !1,
        {
          start: Vp(r.loc.start, v, S),
          end: Vp(r.loc.start, v, E),
          source: v
        },
        d.isConstant ? 3 : 0
      )
    ), y === c.length - 1 && E < u.length && h.push(u.slice(E));
  });
  let m;
  return h.length ? (m = yt(h, r.loc), m.ast = l) : (m = r, m.constType = 3), m.identifiers = Object.keys(p), m;
}
function qI(r) {
  return !($E(r.name) || r.name === "require");
}
function qc(r) {
  return Ie(r) ? r : r.type === 4 ? r.content : r.children.map(qc).join("");
}
function Dy(r) {
  return r === "setup-const" || r === "literal-const";
}
const HI = Wo(
  /^(if|else|else-if)$/,
  (r, e, t) => Dm(r, e, t, (s, i, n) => {
    const a = t.parent.children;
    let o = a.indexOf(s), u = 0;
    for (; o-- >= 0; ) {
      const l = a[o];
      l && l.type === 9 && (u += l.branches.length);
    }
    return () => {
      if (n)
        s.codegenNode = My(
          i,
          u,
          t
        );
      else {
        const l = zI(s.codegenNode);
        l.alternate = My(
          i,
          u + s.branches.length - 1,
          t
        );
      }
    };
  })
);
function Dm(r, e, t, s) {
  if (e.name !== "else" && (!e.exp || !e.exp.content.trim())) {
    const i = e.exp ? e.exp.loc : r.loc;
    t.onError(
      Me(28, e.loc)
    ), e.exp = Q("true", !1, i);
  }
  if (t.prefixIdentifiers && e.exp && (e.exp = vt(e.exp, t)), e.name === "if") {
    const i = Ly(r, e), n = {
      type: 9,
      loc: r.loc,
      branches: [i]
    };
    if (t.replaceNode(n), s)
      return s(n, i, !0);
  } else {
    const i = t.parent.children, n = [];
    let a = i.indexOf(r);
    for (; a-- >= -1; ) {
      const o = i[a];
      if (o && o.type === 3) {
        t.removeNode(o), n.unshift(o);
        continue;
      }
      if (o && o.type === 2 && !o.content.trim().length) {
        t.removeNode(o);
        continue;
      }
      if (o && o.type === 9) {
        e.name === "else-if" && o.branches[o.branches.length - 1].condition === void 0 && t.onError(
          Me(30, r.loc)
        ), t.removeNode();
        const u = Ly(r, e);
        n.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(t.parent && t.parent.type === 1 && (t.parent.tag === "transition" || t.parent.tag === "Transition")) && (u.children = [...n, ...u.children]);
        {
          const c = u.userKey;
          c && o.branches.forEach(({ userKey: f }) => {
            WI(f, c) && t.onError(
              Me(
                29,
                u.userKey.loc
              )
            );
          });
        }
        o.branches.push(u);
        const l = s && s(o, u, !1);
        Qn(u, t), l && l(), t.currentNode = null;
      } else
        t.onError(
          Me(30, r.loc)
        );
      break;
    }
  }
}
function Ly(r, e) {
  const t = r.tagType === 3;
  return {
    type: 10,
    loc: r.loc,
    condition: e.name === "else" ? void 0 : e.exp,
    children: t && !gt(r, "for") ? r.children : [r],
    userKey: Qt(r, "key"),
    isTemplateIf: t
  };
}
function My(r, e, t) {
  return r.condition ? Nr(
    r.condition,
    Ry(r, e, t),
    // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    ge(t.helper(Jn), [
      '"v-if"',
      "true"
    ])
  ) : Ry(r, e, t);
}
function Ry(r, e, t) {
  const { helper: s } = t, i = Fe(
    "key",
    Q(
      `${e}`,
      !1,
      rt,
      2
    )
  ), { children: n } = r, a = n[0];
  if (n.length !== 1 || a.type !== 1)
    if (n.length === 1 && a.type === 11) {
      const u = a.codegenNode;
      return po(u, i, t), u;
    } else {
      let u = 64, l = ti[64];
      return !r.isTemplateIf && n.filter((c) => c.type !== 3).length === 1 && (u |= 2048, l += `, ${ti[2048]}`), Rn(
        t,
        s(Dn),
        Yt([i]),
        n,
        u,
        void 0,
        void 0,
        !0,
        !1,
        !1,
        r.loc
      );
    }
  else {
    const u = a.codegenNode, l = CS(u);
    return l.type === 13 && kc(l, t), po(l, i, t), u;
  }
}
function WI(r, e) {
  if (!r || r.type !== e.type)
    return !1;
  if (r.type === 6) {
    if (r.value.content !== e.value.content)
      return !1;
  } else {
    const t = r.exp, s = e.exp;
    if (t.type !== s.type || t.type !== 4 || t.isStatic !== s.isStatic || t.content !== s.content)
      return !1;
  }
  return !0;
}
function zI(r) {
  for (; ; )
    if (r.type === 19)
      if (r.alternate.type === 19)
        r = r.alternate;
      else
        return r;
    else r.type === 20 && (r = r.value);
}
const Lm = (r, e, t) => {
  const { modifiers: s, loc: i } = r, n = r.arg;
  let { exp: a } = r;
  if (a && a.type === 4 && !a.content.trim())
    return t.onError(
      Me(34, i)
    ), {
      props: [
        Fe(n, Q("", !0, i))
      ]
    };
  if (!a) {
    if (n.type !== 4 || !n.isStatic)
      return t.onError(
        Me(
          52,
          n.loc
        )
      ), {
        props: [
          Fe(n, Q("", !0, i))
        ]
      };
    QS(r, t), a = r.exp;
  }
  return n.type !== 4 ? (n.children.unshift("("), n.children.push(') || ""')) : n.isStatic || (n.content = `${n.content} || ""`), s.includes("camel") && (n.type === 4 ? n.isStatic ? n.content = or(n.content) : n.content = `${t.helperString(dl)}(${n.content})` : (n.children.unshift(`${t.helperString(dl)}(`), n.children.push(")"))), t.inSSR || (s.includes("prop") && $y(n, "."), s.includes("attr") && $y(n, "^")), {
    props: [Fe(n, a)]
  };
}, QS = (r, e) => {
  const t = r.arg, s = or(t.content);
  r.exp = Q(s, !1, t.loc), r.exp = vt(r.exp, e);
}, $y = (r, e) => {
  r.type === 4 ? r.isStatic ? r.content = e + r.content : r.content = `\`${e}\${${r.content}}\`` : (r.children.unshift(`'${e}' + (`), r.children.push(")"));
}, GI = Wo(
  "for",
  (r, e, t) => {
    const { helper: s, removeHelper: i } = t;
    return Mm(r, e, t, (n) => {
      const a = ge(s(wc), [
        n.source
      ]), o = Fn(r), u = gt(r, "memo"), l = Qt(r, "key", !1, !0);
      l && l.type === 7 && !l.exp && QS(l, t);
      const c = l && (l.type === 6 ? l.value ? Q(l.value.content, !0) : void 0 : l.exp), f = l && c ? Fe("key", c) : null;
      o && (u && (u.exp = vt(
        u.exp,
        t
      )), f && l.type !== 6 && (f.value = vt(
        f.value,
        t
      )));
      const p = n.source.type === 4 && n.source.constType > 0, h = p ? 64 : l ? 128 : 256;
      return n.codegenNode = Rn(
        t,
        s(Dn),
        void 0,
        a,
        h,
        void 0,
        void 0,
        !0,
        !p,
        !1,
        r.loc
      ), () => {
        let m;
        const { children: d } = n;
        o && r.children.some((E) => {
          if (E.type === 1) {
            const g = Qt(E, "key");
            if (g)
              return t.onError(
                Me(
                  33,
                  g.loc
                )
              ), !0;
          }
        });
        const y = d.length !== 1 || d[0].type !== 1, S = Bn(r) ? r : o && r.children.length === 1 && Bn(r.children[0]) ? r.children[0] : null;
        if (S ? (m = S.codegenNode, o && f && po(m, f, t)) : y ? m = Rn(
          t,
          s(Dn),
          f ? Yt([f]) : void 0,
          r.children,
          64,
          void 0,
          void 0,
          !0,
          void 0,
          !1
        ) : (m = d[0].codegenNode, o && f && po(m, f, t), m.isBlock !== !p && (m.isBlock ? (i(ui), i(
          Xi(t.inSSR, m.isComponent)
        )) : i(
          Ki(t.inSSR, m.isComponent)
        )), m.isBlock = !p, m.isBlock ? (s(ui), s(Xi(t.inSSR, m.isComponent))) : s(Ki(t.inSSR, m.isComponent))), u) {
          const E = fr(
            go(n.parseResult, [
              Q("_cached")
            ])
          );
          E.body = Bo([
            yt(["const _memo = (", u.exp, ")"]),
            yt([
              "if (_cached",
              ...c ? [" && _cached.key === ", c] : [],
              ` && ${t.helperString(
                Yd
              )}(_cached, _memo)) return _cached`
            ]),
            yt(["const _item = ", m]),
            Q("_item.memo = _memo"),
            Q("return _item")
          ]), a.arguments.push(
            E,
            Q("_cache"),
            Q(String(t.cached++))
          );
        } else
          a.arguments.push(
            fr(
              go(n.parseResult),
              m,
              !0
            )
          );
      };
    });
  }
);
function Mm(r, e, t, s) {
  if (!e.exp) {
    t.onError(
      Me(31, e.loc)
    );
    return;
  }
  const i = e.forParseResult;
  if (!i) {
    t.onError(
      Me(32, e.loc)
    );
    return;
  }
  Rm(i, t);
  const { addIdentifiers: n, removeIdentifiers: a, scopes: o } = t, { source: u, value: l, key: c, index: f } = i, p = {
    type: 11,
    loc: e.loc,
    source: u,
    valueAlias: l,
    keyAlias: c,
    objectIndexAlias: f,
    parseResult: i,
    children: Fn(r) ? r.children : [r]
  };
  t.replaceNode(p), o.vFor++, t.prefixIdentifiers && (l && n(l), c && n(c), f && n(f));
  const h = s && s(p);
  return () => {
    o.vFor--, t.prefixIdentifiers && (l && a(l), c && a(c), f && a(f)), h && h();
  };
}
function Rm(r, e) {
  r.finalized || (e.prefixIdentifiers && (r.source = vt(
    r.source,
    e
  ), r.key && (r.key = vt(
    r.key,
    e,
    !0
  )), r.index && (r.index = vt(
    r.index,
    e,
    !0
  )), r.value && (r.value = vt(
    r.value,
    e,
    !0
  ))), r.finalized = !0);
}
function go({ value: r, key: e, index: t }, s = []) {
  return KI([r, e, t, ...s]);
}
function KI(r) {
  let e = r.length;
  for (; e-- && !r[e]; )
    ;
  return r.slice(0, e + 1).map((t, s) => t || Q("_".repeat(s + 1), !1));
}
const Fy = Q("undefined", !1), $m = (r, e) => {
  if (r.type === 1 && (r.tagType === 1 || r.tagType === 3)) {
    const t = gt(r, "slot");
    if (t) {
      const s = t.exp;
      return e.prefixIdentifiers && s && e.addIdentifiers(s), e.scopes.vSlot++, () => {
        e.prefixIdentifiers && s && e.removeIdentifiers(s), e.scopes.vSlot--;
      };
    }
  }
}, Fm = (r, e) => {
  let t;
  if (Fn(r) && r.props.some(Sm) && (t = gt(r, "for"))) {
    const s = t.forParseResult;
    if (s) {
      Rm(s, e);
      const { value: i, key: n, index: a } = s, { addIdentifiers: o, removeIdentifiers: u } = e;
      return i && o(i), n && o(n), a && o(a), () => {
        i && u(i), n && u(n), a && u(a);
      };
    }
  }
}, XI = (r, e, t, s) => fr(
  r,
  t,
  !1,
  !0,
  t.length ? t[0].loc : s
);
function yo(r, e, t = XI) {
  e.helper(Oc);
  const { children: s, loc: i } = r, n = [], a = [];
  let o = e.scopes.vSlot > 0 || e.scopes.vFor > 0;
  !e.ssr && e.prefixIdentifiers && (o = Xt(r, e.identifiers));
  const u = gt(r, "slot", !0);
  if (u) {
    const { arg: y, exp: S } = u;
    y && !Pt(y) && (o = !0), n.push(
      Fe(
        y || Q("default", !0),
        t(S, void 0, s, i)
      )
    );
  }
  let l = !1, c = !1;
  const f = [], p = /* @__PURE__ */ new Set();
  let h = 0;
  for (let y = 0; y < s.length; y++) {
    const S = s[y];
    let E;
    if (!Fn(S) || !(E = gt(S, "slot", !0))) {
      S.type !== 3 && f.push(S);
      continue;
    }
    if (u) {
      e.onError(
        Me(37, E.loc)
      );
      break;
    }
    l = !0;
    const { children: g, loc: b } = S, {
      arg: v = Q("default", !0),
      exp: A,
      loc: C
    } = E;
    let x;
    Pt(v) ? x = v ? v.content : "default" : o = !0;
    const _ = gt(S, "for"), T = t(A, _, g, b);
    let P, I;
    if (P = gt(S, "if"))
      o = !0, a.push(
        Nr(
          P.exp,
          fu(v, T, h++),
          Fy
        )
      );
    else if (I = gt(
      S,
      /^else(-if)?$/,
      !0
      /* allowEmpty */
    )) {
      let $ = y, Y;
      for (; $-- && (Y = s[$], Y.type === 3); )
        ;
      if (Y && Fn(Y) && gt(Y, /^(else-)?if$/)) {
        let W = a[a.length - 1];
        for (; W.alternate.type === 19; )
          W = W.alternate;
        W.alternate = I.exp ? Nr(
          I.exp,
          fu(
            v,
            T,
            h++
          ),
          Fy
        ) : fu(v, T, h++);
      } else
        e.onError(
          Me(30, I.loc)
        );
    } else if (_) {
      o = !0;
      const $ = _.forParseResult;
      $ ? (Rm($, e), a.push(
        ge(e.helper(wc), [
          $.source,
          fr(
            go($),
            fu(v, T),
            !0
          )
        ])
      )) : e.onError(
        Me(
          32,
          _.loc
        )
      );
    } else {
      if (x) {
        if (p.has(x)) {
          e.onError(
            Me(
              38,
              C
            )
          );
          continue;
        }
        p.add(x), x === "default" && (c = !0);
      }
      n.push(Fe(v, T));
    }
  }
  if (!u) {
    const y = (S, E) => {
      const g = t(S, void 0, E, i);
      return Fe("default", g);
    };
    l ? f.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    f.some((S) => ZS(S)) && (c ? e.onError(
      Me(
        39,
        f[0].loc
      )
    ) : n.push(
      y(void 0, f)
    )) : n.push(y(void 0, s));
  }
  const m = o ? 2 : qu(r.children) ? 3 : 1;
  let d = Yt(
    n.concat(
      Fe(
        "_",
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        Q(
          m + ` /* ${vC[m]} */`,
          !1
        )
      )
    ),
    i
  );
  return a.length && (d = ge(e.helper(Jd), [
    d,
    sn(a)
  ])), {
    slots: d,
    hasDynamicSlots: o
  };
}
function fu(r, e, t) {
  const s = [
    Fe("name", r),
    Fe("fn", e)
  ];
  return t != null && s.push(
    Fe("key", Q(String(t), !0))
  ), Yt(s);
}
function qu(r) {
  for (let e = 0; e < r.length; e++) {
    const t = r[e];
    switch (t.type) {
      case 1:
        if (t.tagType === 2 || qu(t.children))
          return !0;
        break;
      case 9:
        if (qu(t.branches)) return !0;
        break;
      case 10:
      case 11:
        if (qu(t.children)) return !0;
        break;
    }
  }
  return !1;
}
function ZS(r) {
  return r.type !== 2 && r.type !== 12 ? !0 : r.type === 2 ? !!r.content.trim() : ZS(r.content);
}
const e2 = /* @__PURE__ */ new WeakMap(), t2 = (r, e) => function() {
  if (r = e.currentNode, !(r.type === 1 && (r.tagType === 0 || r.tagType === 1)))
    return;
  const { tag: s, props: i } = r, n = r.tagType === 1;
  let a = n ? Hc(r, e) : `"${s}"`;
  const o = pi(a) && a.callee === $o;
  let u, l, c = 0, f, p, h, m = (
    // dynamic component may resolve to plain elements
    o || a === $i || a === Xn || !n && // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    (s === "svg" || s === "foreignObject" || s === "math")
  );
  if (i.length > 0) {
    const d = sa(
      r,
      e,
      void 0,
      n,
      o
    );
    u = d.props, c = d.patchFlag, p = d.dynamicPropNames;
    const y = d.directives;
    h = y && y.length ? sn(
      y.map((S) => Bm(S, e))
    ) : void 0, d.shouldUseBlock && (m = !0);
  }
  if (r.children.length > 0)
    if (a === oo && (m = !0, c |= 1024, r.children.length > 1 && e.onError(
      Me(46, {
        start: r.children[0].loc.start,
        end: r.children[r.children.length - 1].loc.end,
        source: ""
      })
    )), n && // Teleport is not a real component and has dedicated runtime handling
    a !== $i && // explained above.
    a !== oo) {
      const { slots: y, hasDynamicSlots: S } = yo(r, e);
      l = y, S && (c |= 1024);
    } else if (r.children.length === 1 && a !== $i) {
      const y = r.children[0], S = y.type, E = S === 5 || S === 8;
      E && ir(y, e) === 0 && (c |= 1), E || S === 2 ? l = y : l = r.children;
    } else
      l = r.children;
  p && p.length && (f = YI(p)), r.codegenNode = Rn(
    e,
    a,
    u,
    l,
    c === 0 ? void 0 : c,
    f,
    h,
    !!m,
    !1,
    n,
    r.loc
  );
};
function Hc(r, e, t = !1) {
  let { tag: s } = r;
  const i = Wp(s), n = Qt(
    r,
    "is",
    !1,
    !0
    /* allow empty */
  );
  if (n)
    if (i) {
      let o;
      if (n.type === 6 ? o = n.value && Q(n.value.content, !0) : (o = n.exp, o || (o = Q("is", !1, n.arg.loc), o = n.exp = vt(o, e))), o)
        return ge(e.helper($o), [
          o
        ]);
    } else n.type === 6 && n.value.content.startsWith("vue:") && (s = n.value.content.slice(4));
  const a = bm(s) || e.isBuiltInComponent(s);
  if (a)
    return t || e.helper(a), a;
  {
    const o = Hp(s, e);
    if (o)
      return o;
    const u = s.indexOf(".");
    if (u > 0) {
      const l = Hp(s.slice(0, u), e);
      if (l)
        return l + s.slice(u);
    }
  }
  return e.selfName && oi(or(s)) === e.selfName ? (e.helper(uo), e.components.add(s + "__self"), ho(s, "component")) : (e.helper(uo), e.components.add(s), ho(s, "component"));
}
function Hp(r, e) {
  const t = e.bindingMetadata;
  if (!t || t.__isScriptSetup === !1)
    return;
  const s = or(r), i = oi(s), n = (l) => {
    if (t[r] === l)
      return r;
    if (t[s] === l)
      return s;
    if (t[i] === l)
      return i;
  }, a = n("setup-const") || n("setup-reactive-const") || n("literal-const");
  if (a)
    return e.inline ? (
      // in inline mode, const setup bindings (e.g. imports) can be used as-is
      a
    ) : `$setup[${JSON.stringify(a)}]`;
  const o = n("setup-let") || n("setup-ref") || n("setup-maybe-ref");
  if (o)
    return e.inline ? (
      // setup scope bindings that may be refs need to be unrefed
      `${e.helperString(Mn)}(${o})`
    ) : `$setup[${JSON.stringify(o)}]`;
  const u = n("props");
  if (u)
    return `${e.helperString(Mn)}(${e.inline ? "__props" : "$props"}[${JSON.stringify(u)}])`;
}
function sa(r, e, t = r.props, s, i, n = !1) {
  const { tag: a, loc: o, children: u } = r;
  let l = [];
  const c = [], f = [], p = u.length > 0;
  let h = !1, m = 0, d = !1, y = !1, S = !1, E = !1, g = !1, b = !1;
  const v = [], A = (T) => {
    l.length && (c.push(
      Yt(By(l), o)
    ), l = []), T && c.push(T);
  }, C = () => {
    e.scopes.vFor > 0 && l.push(
      Fe(
        Q("ref_for", !0),
        Q("true")
      )
    );
  }, x = ({ key: T, value: P }) => {
    if (Pt(T)) {
      const I = T.content, $ = DE(I);
      if ($ && (!s || i) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      I.toLowerCase() !== "onclick" && // omit v-model handlers
      I !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !iy(I) && (E = !0), $ && iy(I) && (b = !0), $ && P.type === 14 && (P = P.arguments[0]), P.type === 20 || (P.type === 4 || P.type === 8) && ir(P, e) > 0)
        return;
      I === "ref" ? d = !0 : I === "class" ? y = !0 : I === "style" ? S = !0 : I !== "key" && !v.includes(I) && v.push(I), s && (I === "class" || I === "style") && !v.includes(I) && v.push(I);
    } else
      g = !0;
  };
  for (let T = 0; T < t.length; T++) {
    const P = t[T];
    if (P.type === 6) {
      const { loc: I, name: $, nameLoc: Y, value: W } = P;
      let F = !0;
      if ($ === "ref" && (d = !0, C(), W && e.inline)) {
        const K = e.bindingMetadata[W.content];
        (K === "setup-let" || K === "setup-ref" || K === "setup-maybe-ref") && (F = !1, l.push(
          Fe(
            Q("ref_key", !0),
            Q(W.content, !0, W.loc)
          )
        ));
      }
      if ($ === "is" && (Wp(a) || W && W.content.startsWith("vue:")))
        continue;
      l.push(
        Fe(
          Q($, !0, Y),
          Q(
            W ? W.content : "",
            F,
            W ? W.loc : I
          )
        )
      );
    } else {
      const { name: I, arg: $, exp: Y, loc: W, modifiers: F } = P, K = I === "bind", Z = I === "on";
      if (I === "slot") {
        s || e.onError(
          Me(40, W)
        );
        continue;
      }
      if (I === "once" || I === "memo" || I === "is" || K && jr($, "is") && Wp(a) || Z && n)
        continue;
      if (
        // #938: elements with dynamic keys should be forced into blocks
        (K && jr($, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        Z && p && jr($, "vue:before-update")) && (h = !0), K && jr($, "ref") && C(), !$ && (K || Z)
      ) {
        g = !0, Y ? K ? (C(), A(), c.push(Y)) : A({
          type: 14,
          loc: W,
          callee: e.helper(Ac),
          arguments: s ? [Y] : [Y, "true"]
        }) : e.onError(
          Me(
            K ? 34 : 35,
            W
          )
        );
        continue;
      }
      K && F.includes("prop") && (m |= 32);
      const Ce = e.directiveTransforms[I];
      if (Ce) {
        const { props: Ve, needRuntime: ee } = Ce(P, r, e);
        !n && Ve.forEach(x), Z && $ && !Pt($) ? A(Yt(Ve, o)) : l.push(...Ve), ee && (f.push(P), fi(ee) && e2.set(P, ee));
      } else Wd(I) || (f.push(P), p && (h = !0));
    }
  }
  let _;
  if (c.length ? (A(), c.length > 1 ? _ = ge(
    e.helper(Gi),
    c,
    o
  ) : _ = c[0]) : l.length && (_ = Yt(
    By(l),
    o
  )), g ? m |= 16 : (y && !s && (m |= 2), S && !s && (m |= 4), v.length && (m |= 8), E && (m |= 32)), !h && (m === 0 || m === 32) && (d || b || f.length > 0) && (m |= 512), !e.inSSR && _)
    switch (_.type) {
      case 15:
        let T = -1, P = -1, I = !1;
        for (let W = 0; W < _.properties.length; W++) {
          const F = _.properties[W].key;
          Pt(F) ? F.content === "class" ? T = W : F.content === "style" && (P = W) : F.isHandlerKey || (I = !0);
        }
        const $ = _.properties[T], Y = _.properties[P];
        I ? _ = ge(
          e.helper(Ln),
          [_]
        ) : ($ && !Pt($.value) && ($.value = ge(
          e.helper(Tc),
          [$.value]
        )), Y && // the static style is compiled into an object,
        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
        (S || Y.value.type === 4 && Y.value.content.trim()[0] === "[" || // v-bind:style and style both exist,
        // v-bind:style with static literal object
        Y.value.type === 17) && (Y.value = ge(
          e.helper(Pc),
          [Y.value]
        )));
        break;
      case 14:
        break;
      default:
        _ = ge(
          e.helper(Ln),
          [
            ge(e.helper(Yn), [
              _
            ])
          ]
        );
        break;
    }
  return {
    props: _,
    directives: f,
    patchFlag: m,
    dynamicPropNames: v,
    shouldUseBlock: h
  };
}
function By(r) {
  const e = /* @__PURE__ */ new Map(), t = [];
  for (let s = 0; s < r.length; s++) {
    const i = r[s];
    if (i.key.type === 8 || !i.key.isStatic) {
      t.push(i);
      continue;
    }
    const n = i.key.content, a = e.get(n);
    a ? (n === "style" || n === "class" || DE(n)) && JI(a, i) : (e.set(n, i), t.push(i));
  }
  return t;
}
function JI(r, e) {
  r.value.type === 17 ? r.value.elements.push(e.value) : r.value = sn(
    [r.value, e.value],
    r.loc
  );
}
function Bm(r, e) {
  const t = [], s = e2.get(r);
  if (s)
    t.push(e.helperString(s));
  else {
    const n = Hp("v-" + r.name, e);
    n ? t.push(n) : (e.helper(_c), e.directives.add(r.name), t.push(ho(r.name, "directive")));
  }
  const { loc: i } = r;
  if (r.exp && t.push(r.exp), r.arg && (r.exp || t.push("void 0"), t.push(r.arg)), Object.keys(r.modifiers).length) {
    r.arg || (r.exp || t.push("void 0"), t.push("void 0"));
    const n = Q("true", !1, i);
    t.push(
      Yt(
        r.modifiers.map(
          (a) => Fe(a, n)
        ),
        i
      )
    );
  }
  return sn(t, r.loc);
}
function YI(r) {
  let e = "[";
  for (let t = 0, s = r.length; t < s; t++)
    e += JSON.stringify(r[t]), t < s - 1 && (e += ", ");
  return e + "]";
}
function Wp(r) {
  return r === "component" || r === "Component";
}
const QI = (r, e) => {
  if (Bn(r)) {
    const { children: t, loc: s } = r, { slotName: i, slotProps: n } = Vm(r, e), a = [
      e.prefixIdentifiers ? "_ctx.$slots" : "$slots",
      i,
      "{}",
      "undefined",
      "true"
    ];
    let o = 2;
    n && (a[2] = n, o = 3), t.length && (a[3] = fr([], t, !1, !1, s), o = 4), e.scopeId && !e.slotted && (o = 5), a.splice(o), r.codegenNode = ge(
      e.helper(Xd),
      a,
      s
    );
  }
};
function Vm(r, e) {
  let t = '"default"', s;
  const i = [];
  for (let n = 0; n < r.props.length; n++) {
    const a = r.props[n];
    if (a.type === 6)
      a.value && (a.name === "name" ? t = JSON.stringify(a.value.content) : (a.name = or(a.name), i.push(a)));
    else if (a.name === "bind" && jr(a.arg, "name")) {
      if (a.exp)
        t = a.exp;
      else if (a.arg && a.arg.type === 4) {
        const o = or(a.arg.content);
        t = a.exp = Q(o, !1, a.arg.loc), t = a.exp = vt(a.exp, e);
      }
    } else
      a.name === "bind" && a.arg && Pt(a.arg) && (a.arg.content = or(a.arg.content)), i.push(a);
  }
  if (i.length > 0) {
    const { props: n, directives: a } = sa(
      r,
      e,
      i,
      !1,
      !1
    );
    s = n, a.length && e.onError(
      Me(
        36,
        a[0].loc
      )
    );
  }
  return {
    slotName: t,
    slotProps: s
  };
}
const ZI = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/, Wc = (r, e, t, s) => {
  const { loc: i, modifiers: n, arg: a } = r;
  !r.exp && !n.length && t.onError(Me(35, i));
  let o;
  if (a.type === 4)
    if (a.isStatic) {
      let f = a.content;
      f.startsWith("vnode") && t.onError(Me(51, a.loc)), f.startsWith("vue:") && (f = `vnode-${f.slice(4)}`);
      const p = e.tagType !== 0 || f.startsWith("vnode") || !/[A-Z]/.test(f) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        yC(or(f))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${f}`
      );
      o = Q(p, !0, a.loc);
    } else
      o = yt([
        `${t.helperString(ml)}(`,
        a,
        ")"
      ]);
  else
    o = a, o.children.unshift(`${t.helperString(ml)}(`), o.children.push(")");
  let u = r.exp;
  u && !u.content.trim() && (u = void 0);
  let l = t.cacheHandlers && !u && !t.inVOnce;
  if (u) {
    const f = vm(u.content, t), p = !(f || ZI.test(u.content)), h = u.content.includes(";");
    t.prefixIdentifiers && (p && t.addIdentifiers("$event"), u = r.exp = vt(
      u,
      t,
      !1,
      h
    ), p && t.removeIdentifiers("$event"), l = t.cacheHandlers && // unnecessary to cache inside v-once
    !t.inVOnce && // runtime constants don't need to be cached
    // (this is analyzed by compileScript in SFC <script setup>)
    !(u.type === 4 && u.constType > 0) && // #1541 bail if this is a member exp handler passed to a component -
    // we need to use the original function to preserve arity,
    // e.g. <transition> relies on checking cb.length to determine
    // transition end handling. Inline function is ok since its arity
    // is preserved even when cached.
    !(f && e.tagType === 1) && // bail if the function references closure variables (v-for, v-slot)
    // it must be passed fresh to avoid stale values.
    !Xt(u, t.identifiers), l && f && (u.type === 4 ? u.content = `${u.content} && ${u.content}(...args)` : u.children = [...u.children, " && ", ...u.children, "(...args)"])), (p || l && f) && (u = yt([
      `${p ? t.isTS ? "($event: any)" : "$event" : `${t.isTS ? `
//@ts-ignore
` : ""}(...args)`} => ${h ? "{" : "("}`,
      u,
      h ? "}" : ")"
    ]));
  }
  let c = {
    props: [
      Fe(
        o,
        u || Q("() => {}", !1, i)
      )
    ]
  };
  return s && (c = s(c)), l && (c.props[0].value = t.cache(c.props[0].value)), c.props.forEach((f) => f.key.isHandlerKey = !0), c;
}, e6 = (r, e) => {
  if (r.type === 0 || r.type === 1 || r.type === 11 || r.type === 10)
    return () => {
      const t = r.children;
      let s, i = !1;
      for (let n = 0; n < t.length; n++) {
        const a = t[n];
        if (Ha(a)) {
          i = !0;
          for (let o = n + 1; o < t.length; o++) {
            const u = t[o];
            if (Ha(u))
              s || (s = t[n] = yt(
                [a],
                a.loc
              )), s.children.push(" + ", u), t.splice(o, 1), o--;
            else {
              s = void 0;
              break;
            }
          }
        }
      }
      if (!(!i || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      t.length === 1 && (r.type === 0 || r.type === 1 && r.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !r.props.find(
        (n) => n.type === 7 && !e.directiveTransforms[n.name]
      ))))
        for (let n = 0; n < t.length; n++) {
          const a = t[n];
          if (Ha(a) || a.type === 8) {
            const o = [];
            (a.type !== 2 || a.content !== " ") && o.push(a), !e.ssr && ir(a, e) === 0 && o.push(
              `1 /* ${ti[1]} */`
            ), t[n] = {
              type: 12,
              content: a,
              loc: a.loc,
              codegenNode: ge(
                e.helper(Ec),
                o
              )
            };
          }
        }
    };
}, Vy = /* @__PURE__ */ new WeakSet(), t6 = (r, e) => {
  if (r.type === 1 && gt(r, "once", !0))
    return Vy.has(r) || e.inVOnce || e.inSSR ? void 0 : (Vy.add(r), e.inVOnce = !0, e.helper(lo), () => {
      e.inVOnce = !1;
      const t = e.currentNode;
      t.codegenNode && (t.codegenNode = e.cache(
        t.codegenNode,
        !0
        /* isVNode */
      ));
    });
}, zc = (r, e, t) => {
  const { exp: s, arg: i } = r;
  if (!s)
    return t.onError(
      Me(41, r.loc)
    ), Ea();
  const n = s.loc.source, a = s.type === 4 ? s.content : n, o = t.bindingMetadata[n];
  if (o === "props" || o === "props-aliased")
    return t.onError(Me(44, s.loc)), Ea();
  const u = t.inline && (o === "setup-let" || o === "setup-ref" || o === "setup-maybe-ref");
  if (!a.trim() || !vm(a, t) && !u)
    return t.onError(
      Me(42, s.loc)
    ), Ea();
  if (t.prefixIdentifiers && Ts(a) && t.identifiers[a])
    return t.onError(
      Me(43, s.loc)
    ), Ea();
  const l = i || Q("modelValue", !0), c = i ? Pt(i) ? `onUpdate:${or(i.content)}` : yt(['"onUpdate:" + ', i]) : "onUpdate:modelValue";
  let f;
  const p = t.isTS ? "($event: any)" : "$event";
  if (u)
    if (o === "setup-ref")
      f = yt([
        `${p} => ((`,
        Q(n, !1, s.loc),
        ").value = $event)"
      ]);
    else {
      const m = o === "setup-let" ? `${n} = $event` : "null";
      f = yt([
        `${p} => (${t.helperString(co)}(${n}) ? (`,
        Q(n, !1, s.loc),
        `).value = $event : ${m})`
      ]);
    }
  else
    f = yt([
      `${p} => ((`,
      s,
      ") = $event)"
    ]);
  const h = [
    // modelValue: foo
    Fe(l, r.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    Fe(c, f)
  ];
  if (t.prefixIdentifiers && !t.inVOnce && t.cacheHandlers && !Xt(s, t.identifiers) && (h[1].value = t.cache(h[1].value)), r.modifiers.length && e.tagType === 1) {
    const m = r.modifiers.map((y) => (Ts(y) ? y : JSON.stringify(y)) + ": true").join(", "), d = i ? Pt(i) ? `${i.content}Modifiers` : yt([i, ' + "Modifiers"']) : "modelModifiers";
    h.push(
      Fe(
        d,
        Q(
          `{ ${m} }`,
          !1,
          r.loc,
          2
        )
      )
    );
  }
  return Ea(h);
};
function Ea(r = []) {
  return { props: r };
}
const Uy = /* @__PURE__ */ new WeakSet(), r6 = (r, e) => {
  if (r.type === 1) {
    const t = gt(r, "memo");
    return !t || Uy.has(r) ? void 0 : (Uy.add(r), () => {
      const s = r.codegenNode || e.currentNode.codegenNode;
      s && s.type === 13 && (r.tagType !== 1 && kc(s, e), r.codegenNode = ge(e.helper(Ic), [
        t.exp,
        fr(void 0, s),
        "_cache",
        String(e.cached++)
      ]));
    });
  }
};
function Um(r) {
  return [
    [
      t6,
      HI,
      r6,
      GI,
      ...r ? [
        // order is important
        Fm,
        km
      ] : [],
      QI,
      t2,
      $m,
      e6
    ],
    {
      on: Wc,
      bind: Lm,
      model: zc
    }
  ];
}
function r2(r, e = {}) {
  const t = e.onError || em, s = e.mode === "module", i = e.prefixIdentifiers === !0 || s;
  !i && e.cacheHandlers && t(Me(49)), e.scopeId && !s && t(Me(50));
  const n = Jr({}, e, {
    prefixIdentifiers: i
  }), a = Ie(r) ? Fc(r, n) : r, [o, u] = Um(i);
  if (e.isTS) {
    const { expressionPlugins: l } = e;
    (!l || !l.includes("typescript")) && (e.expressionPlugins = [...l || [], "typescript"]);
  }
  return _m(
    a,
    Jr({}, n, {
      nodeTransforms: [
        ...o,
        ...e.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: Jr(
        {},
        u,
        e.directiveTransforms || {}
        // user transforms
      )
    })
  ), Im(a, n);
}
const s6 = {
  DATA: "data",
  PROPS: "props",
  PROPS_ALIASED: "props-aliased",
  SETUP_LET: "setup-let",
  SETUP_CONST: "setup-const",
  SETUP_REACTIVE_CONST: "setup-reactive-const",
  SETUP_MAYBE_REF: "setup-maybe-ref",
  SETUP_REF: "setup-ref",
  OPTIONS: "options",
  LITERAL_CONST: "literal-const"
}, Wa = () => ({ props: [] }), jm = Symbol("vModelRadio"), qm = Symbol("vModelCheckbox"), Hm = Symbol("vModelText"), Wm = Symbol("vModelSelect"), Al = Symbol("vModelDynamic"), zm = Symbol("vOnModifiersGuard"), Gm = Symbol("vOnKeysGuard"), Km = Symbol("vShow"), nn = Symbol("Transition"), ia = Symbol("TransitionGroup");
Qd({
  [jm]: "vModelRadio",
  [qm]: "vModelCheckbox",
  [Hm]: "vModelText",
  [Wm]: "vModelSelect",
  [Al]: "vModelDynamic",
  [zm]: "withModifiers",
  [Gm]: "withKeys",
  [Km]: "vShow",
  [nn]: "Transition",
  [ia]: "TransitionGroup"
});
const Un = {
  parseMode: "html",
  isVoidTag: UE,
  isNativeTag: (r) => NC(r) || OC(r) || IC(r),
  isPreTag: (r) => r === "pre",
  decodeEntities: void 0,
  isBuiltInComponent: (r) => {
    if (r === "Transition" || r === "transition")
      return nn;
    if (r === "TransitionGroup" || r === "transition-group")
      return ia;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(r, e, t) {
    let s = e ? e.ns : t;
    if (e && s === 2)
      if (e.tag === "annotation-xml") {
        if (r === "svg")
          return 1;
        e.props.some(
          (i) => i.type === 6 && i.name === "encoding" && i.value != null && (i.value.content === "text/html" || i.value.content === "application/xhtml+xml")
        ) && (s = 0);
      } else /^m(?:[ions]|text)$/.test(e.tag) && r !== "mglyph" && r !== "malignmark" && (s = 0);
    else e && s === 1 && (e.tag === "foreignObject" || e.tag === "desc" || e.tag === "title") && (s = 0);
    if (s === 0) {
      if (r === "svg")
        return 1;
      if (r === "math")
        return 2;
    }
    return s;
  }
}, Xm = (r) => {
  r.type === 1 && r.props.forEach((e, t) => {
    e.type === 6 && e.name === "style" && e.value && (r.props[t] = {
      type: 7,
      name: "bind",
      arg: Q("style", !0, e.loc),
      exp: i6(e.value.content, e.loc),
      modifiers: [],
      loc: e.loc
    });
  });
}, i6 = (r, e) => {
  const t = BE(r);
  return Q(
    JSON.stringify(t),
    !1,
    e,
    3
  );
};
function Mt(r, e) {
  return Me(
    r,
    e,
    Jm
  );
}
const n6 = {
  X_V_HTML_NO_EXPRESSION: 53,
  53: "X_V_HTML_NO_EXPRESSION",
  X_V_HTML_WITH_CHILDREN: 54,
  54: "X_V_HTML_WITH_CHILDREN",
  X_V_TEXT_NO_EXPRESSION: 55,
  55: "X_V_TEXT_NO_EXPRESSION",
  X_V_TEXT_WITH_CHILDREN: 56,
  56: "X_V_TEXT_WITH_CHILDREN",
  X_V_MODEL_ON_INVALID_ELEMENT: 57,
  57: "X_V_MODEL_ON_INVALID_ELEMENT",
  X_V_MODEL_ARG_ON_ELEMENT: 58,
  58: "X_V_MODEL_ARG_ON_ELEMENT",
  X_V_MODEL_ON_FILE_INPUT_ELEMENT: 59,
  59: "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
  X_V_MODEL_UNNECESSARY_VALUE: 60,
  60: "X_V_MODEL_UNNECESSARY_VALUE",
  X_V_SHOW_NO_EXPRESSION: 61,
  61: "X_V_SHOW_NO_EXPRESSION",
  X_TRANSITION_INVALID_CHILDREN: 62,
  62: "X_TRANSITION_INVALID_CHILDREN",
  X_IGNORED_SIDE_EFFECT_TAG: 63,
  63: "X_IGNORED_SIDE_EFFECT_TAG",
  __EXTEND_POINT__: 64,
  64: "__EXTEND_POINT__"
}, Jm = {
  53: "v-html is missing expression.",
  54: "v-html will override element children.",
  55: "v-text is missing expression.",
  56: "v-text will override element children.",
  57: "v-model can only be used on <input>, <textarea> and <select> elements.",
  58: "v-model argument is not supported on plain elements.",
  59: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",
  60: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",
  61: "v-show is missing expression.",
  62: "<Transition> expects exactly one child element or component.",
  63: "Tags with side effect (<script> and <style>) are ignored in client component templates."
}, a6 = (r, e, t) => {
  const { exp: s, loc: i } = r;
  return s || t.onError(
    Mt(53, i)
  ), e.children.length && (t.onError(
    Mt(54, i)
  ), e.children.length = 0), {
    props: [
      Fe(
        Q("innerHTML", !0, i),
        s || Q("", !0)
      )
    ]
  };
}, o6 = (r, e, t) => {
  const { exp: s, loc: i } = r;
  return s || t.onError(
    Mt(55, i)
  ), e.children.length && (t.onError(
    Mt(56, i)
  ), e.children.length = 0), {
    props: [
      Fe(
        Q("textContent", !0),
        s ? ir(s, t) > 0 ? s : ge(
          t.helperString(Fo),
          [s],
          i
        ) : Q("", !0)
      )
    ]
  };
}, u6 = (r, e, t) => {
  const s = zc(r, e, t);
  if (!s.props.length || e.tagType === 1)
    return s;
  r.arg && t.onError(
    Mt(
      58,
      r.arg.loc
    )
  );
  function i() {
    const o = gt(e, "bind");
    o && jr(o.arg, "value") && t.onError(
      Mt(
        60,
        o.loc
      )
    );
  }
  const { tag: n } = e, a = t.isCustomElement(n);
  if (n === "input" || n === "textarea" || n === "select" || a) {
    let o = Hm, u = !1;
    if (n === "input" || a) {
      const l = Qt(e, "type");
      if (l) {
        if (l.type === 7)
          o = Al;
        else if (l.value)
          switch (l.value.content) {
            case "radio":
              o = jm;
              break;
            case "checkbox":
              o = qm;
              break;
            case "file":
              u = !0, t.onError(
                Mt(
                  59,
                  r.loc
                )
              );
              break;
            default:
              i();
              break;
          }
      } else $c(e) ? o = Al : i();
    } else n === "select" ? o = Wm : i();
    u || (s.needRuntime = t.helper(o));
  } else
    t.onError(
      Mt(
        57,
        r.loc
      )
    );
  return s.props = s.props.filter(
    (o) => !(o.key.type === 4 && o.key.content === "modelValue")
  ), s;
}, l6 = /* @__PURE__ */ Rt("passive,once,capture"), c6 = /* @__PURE__ */ Rt(
  // event propagation management
  "stop,prevent,self,ctrl,shift,alt,meta,exact,middle"
), f6 = /* @__PURE__ */ Rt("left,right"), s2 = /* @__PURE__ */ Rt(
  "onkeyup,onkeydown,onkeypress",
  !0
), p6 = (r, e, t, s) => {
  const i = [], n = [], a = [];
  for (let o = 0; o < e.length; o++) {
    const u = e[o];
    l6(u) ? a.push(u) : f6(u) ? Pt(r) ? s2(r.content) ? i.push(u) : n.push(u) : (i.push(u), n.push(u)) : c6(u) ? n.push(u) : i.push(u);
  }
  return {
    keyModifiers: i,
    nonKeyModifiers: n,
    eventOptionModifiers: a
  };
}, jy = (r, e) => Pt(r) && r.content.toLowerCase() === "onclick" ? Q(e, !0) : r.type !== 4 ? yt([
  "(",
  r,
  `) === "onClick" ? "${e}" : (`,
  r,
  ")"
]) : r, h6 = (r, e, t) => Wc(r, e, t, (s) => {
  const { modifiers: i } = r;
  if (!i.length) return s;
  let { key: n, value: a } = s.props[0];
  const { keyModifiers: o, nonKeyModifiers: u, eventOptionModifiers: l } = p6(n, i, t, r.loc);
  if (u.includes("right") && (n = jy(n, "onContextmenu")), u.includes("middle") && (n = jy(n, "onMouseup")), u.length && (a = ge(t.helper(zm), [
    a,
    JSON.stringify(u)
  ])), o.length && // if event name is dynamic, always wrap with keys guard
  (!Pt(n) || s2(n.content)) && (a = ge(t.helper(Gm), [
    a,
    JSON.stringify(o)
  ])), l.length) {
    const c = l.map(oi).join("");
    n = Pt(n) ? Q(`${n.content}${c}`, !0) : yt(["(", n, `) + "${c}"`]);
  }
  return {
    props: [Fe(n, a)]
  };
}), d6 = (r, e, t) => {
  const { exp: s, loc: i } = r;
  return s || t.onError(
    Mt(61, i)
  ), {
    props: [],
    needRuntime: t.helper(Km)
  };
}, m6 = (r, e) => {
  if (r.type === 1 && r.tagType === 1 && e.isBuiltInComponent(r.tag) === nn)
    return () => {
      if (!r.children.length)
        return;
      i2(r) && e.onError(
        Mt(
          62,
          {
            start: r.children[0].loc.start,
            end: r.children[r.children.length - 1].loc.end,
            source: ""
          }
        )
      );
      const s = r.children[0];
      if (s.type === 1)
        for (const i of s.props)
          i.type === 7 && i.name === "show" && r.props.push({
            type: 6,
            name: "persisted",
            nameLoc: r.loc,
            value: void 0,
            loc: r.loc
          });
    };
};
function i2(r) {
  const e = r.children = r.children.filter(
    (s) => s.type !== 3 && !(s.type === 2 && !s.content.trim())
  ), t = e[0];
  return e.length !== 1 || t.type === 11 || t.type === 9 && t.branches.some(i2);
}
const g6 = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g, y6 = (r, e, t) => {
  if (e.scopes.vSlot > 0)
    return;
  let s = 0, i = 0;
  const n = [], a = (u) => {
    if (s >= 20 || i >= 5) {
      const l = ge(e.helper(Sc), [
        JSON.stringify(
          n.map((c) => Ym(c, e)).join("")
        ).replace(g6, '" + $1 + "'),
        // the 2nd argument indicates the number of DOM nodes this static vnode
        // will insert / hydrate
        String(n.length)
      ]);
      if (Hy(n[0], l, e), n.length > 1) {
        for (let f = 1; f < n.length; f++)
          Hy(n[f], null, e);
        const c = n.length - 1;
        return r.splice(u - n.length + 1, c), c;
      }
    }
    return 0;
  };
  let o = 0;
  for (; o < r.length; o++) {
    const u = r[o];
    if (b6(u)) {
      const c = u, f = S6(c);
      if (f) {
        s += f[0], i += f[1], n.push(c);
        continue;
      }
    }
    o -= a(o), s = 0, i = 0, n.length = 0;
  }
  a(o);
}, b6 = (r) => (r.type === 1 && r.tagType === 0 || r.type == 12) && r.codegenNode && r.codegenNode.type === 4 && r.codegenNode.hoisted, v6 = /^(data|aria)-/, qy = (r, e) => (e === 0 ? RC(r) : e === 1 ? $C(r) : !1) || v6.test(r), Hy = (r, e, t) => {
  const s = r.codegenNode.hoisted;
  t.hoists[t.hoists.indexOf(s)] = e;
}, E6 = /* @__PURE__ */ Rt(
  "caption,thead,tr,th,tbody,td,tfoot,colgroup,col"
);
function S6(r) {
  if (r.type === 1 && E6(r.tag))
    return !1;
  if (r.type === 12)
    return [1, 0];
  let e = 1, t = r.props.length > 0 ? 1 : 0, s = !1;
  const i = () => (s = !0, !1);
  function n(a) {
    const o = a.tag === "option" && a.ns === 0;
    for (let u = 0; u < a.props.length; u++) {
      const l = a.props[u];
      if (l.type === 6 && !qy(l.name, a.ns) || l.type === 7 && l.name === "bind" && (l.arg && (l.arg.type === 8 || l.arg.isStatic && !qy(l.arg.content, a.ns)) || l.exp && (l.exp.type === 8 || l.exp.constType < 3) || o && jr(l.arg, "value") && l.exp && l.exp.ast && l.exp.ast.type !== "StringLiteral"))
        return i();
    }
    for (let u = 0; u < a.children.length; u++) {
      e++;
      const l = a.children[u];
      if (l.type === 1 && (l.props.length > 0 && t++, n(l), s))
        return !1;
    }
    return !0;
  }
  return n(r) ? [e, t] : !1;
}
function Ym(r, e) {
  if (Ie(r))
    return r;
  if (fi(r))
    return "";
  switch (r.type) {
    case 1:
      return _6(r, e);
    case 2:
      return Ur(r.content);
    case 3:
      return `<!--${Ur(r.content)}-->`;
    case 5:
      return Ur(bc(Bi(r.content)));
    case 8:
      return Ur(Bi(r));
    case 12:
      return Ym(r.content, e);
    default:
      return "";
  }
}
function _6(r, e) {
  let t = `<${r.tag}`, s = "";
  for (let i = 0; i < r.props.length; i++) {
    const n = r.props[i];
    if (n.type === 6)
      t += ` ${n.name}`, n.value && (t += `="${Ur(n.value.content)}"`);
    else if (n.type === 7)
      if (n.name === "bind") {
        const a = n.exp;
        if (a.content[0] === "_") {
          t += ` ${n.arg.content}="__VUE_EXP_START__${a.content}__VUE_EXP_END__"`;
          continue;
        }
        if (jE(n.arg.content) && a.content === "false")
          continue;
        let o = Bi(a);
        if (o != null) {
          const u = n.arg && n.arg.content;
          u === "class" ? o = VE(o) : u === "style" && (o = wC(FE(o))), t += ` ${n.arg.content}="${Ur(
            o
          )}"`;
        }
      } else n.name === "html" ? s = Bi(n.exp) : n.name === "text" && (s = Ur(
        bc(Bi(n.exp))
      ));
  }
  if (e.scopeId && (t += ` ${e.scopeId}`), t += ">", s)
    t += s;
  else
    for (let i = 0; i < r.children.length; i++)
      t += Ym(r.children[i], e);
  return UE(r.tag) || (t += `</${r.tag}>`), t;
}
function Bi(r) {
  if (r.type === 4)
    return new Function(`return (${r.content})`)();
  {
    let e = "";
    return r.children.forEach((t) => {
      Ie(t) || fi(t) || (t.type === 2 ? e += t.content : t.type === 5 ? e += bc(Bi(t.content)) : e += Bi(t));
    }), e;
  }
}
const x6 = (r, e) => {
  r.type === 1 && r.tagType === 0 && (r.tag === "script" || r.tag === "style") && (e.onError(
    Mt(
      63,
      r.loc
    )
  ), e.removeNode());
}, Qm = [
  Xm,
  m6
], Zm = {
  cloak: Wa,
  html: a6,
  text: o6,
  model: u6,
  // override compiler-core
  on: h6,
  // override compiler-core
  show: d6
};
function w6(r, e = {}) {
  return r2(
    r,
    Jr({}, Un, e, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        x6,
        ...Qm,
        ...e.nodeTransforms || []
      ],
      directiveTransforms: Jr(
        {},
        Zm,
        e.directiveTransforms || {}
      ),
      transformHoist: y6
    })
  );
}
function T6(r, e = {}) {
  return Fc(r, Jr({}, Un, e));
}
var zp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BASE_TRANSITION: zd,
  BindingTypes: s6,
  CAMELIZE: dl,
  CAPITALIZE: zE,
  CREATE_BLOCK: Gd,
  CREATE_COMMENT: Jn,
  CREATE_ELEMENT_BLOCK: Kd,
  CREATE_ELEMENT_VNODE: vc,
  CREATE_SLOTS: Jd,
  CREATE_STATIC: Sc,
  CREATE_TEXT: Ec,
  CREATE_VNODE: Ro,
  CompilerDeprecationTypes: eN,
  ConstantTypes: jC,
  DOMDirectiveTransforms: Zm,
  DOMErrorCodes: n6,
  DOMErrorMessages: Jm,
  DOMNodeTransforms: Qm,
  ElementTypes: UC,
  ErrorCodes: iN,
  FRAGMENT: Dn,
  GUARD_REACTIVE_PROPS: Yn,
  IS_MEMO_SAME: Yd,
  IS_REF: co,
  KEEP_ALIVE: oo,
  MERGE_PROPS: Gi,
  NORMALIZE_CLASS: Tc,
  NORMALIZE_PROPS: Ln,
  NORMALIZE_STYLE: Pc,
  Namespaces: BC,
  NodeTypes: VC,
  OPEN_BLOCK: ui,
  POP_SCOPE_ID: Nc,
  PUSH_SCOPE_ID: Cc,
  RENDER_LIST: wc,
  RENDER_SLOT: Xd,
  RESOLVE_COMPONENT: uo,
  RESOLVE_DIRECTIVE: _c,
  RESOLVE_DYNAMIC_COMPONENT: $o,
  RESOLVE_FILTER: WE,
  SET_BLOCK_TRACKING: lo,
  SUSPENSE: Xn,
  TELEPORT: $i,
  TO_DISPLAY_STRING: Fo,
  TO_HANDLERS: Ac,
  TO_HANDLER_KEY: ml,
  TRANSITION: nn,
  TRANSITION_GROUP: ia,
  TS_NODE_TYPES: ym,
  UNREF: Mn,
  V_MODEL_CHECKBOX: qm,
  V_MODEL_DYNAMIC: Al,
  V_MODEL_RADIO: jm,
  V_MODEL_SELECT: Wm,
  V_MODEL_TEXT: Hm,
  V_ON_WITH_KEYS: Gm,
  V_ON_WITH_MODIFIERS: zm,
  V_SHOW: Km,
  WITH_CTX: Oc,
  WITH_DIRECTIVES: xc,
  WITH_MEMO: Ic,
  advancePositionWithClone: Vp,
  advancePositionWithMutation: Em,
  assert: Up,
  baseCompile: r2,
  baseParse: Fc,
  buildDirectiveArgs: Bm,
  buildProps: sa,
  buildSlots: yo,
  checkCompatEnabled: sN,
  compile: w6,
  convertToBlock: kc,
  createArrayExpression: sn,
  createAssignmentExpression: Du,
  createBlockStatement: Bo,
  createCacheExpression: GE,
  createCallExpression: ge,
  createCompilerError: Me,
  createCompoundExpression: yt,
  createConditionalExpression: Nr,
  createDOMCompilerError: Mt,
  createForLoopParams: go,
  createFunctionExpression: fr,
  createIfStatement: yl,
  createInterpolation: gl,
  createObjectExpression: Yt,
  createObjectProperty: Fe,
  createReturnStatement: XE,
  createRoot: rn,
  createSequenceExpression: KE,
  createSimpleExpression: Q,
  createStructuralDirectiveTransform: Wo,
  createTemplateLiteral: Zd,
  createTransformContext: Ho,
  createVNodeCall: Rn,
  errorMessages: tm,
  extractIdentifiers: mr,
  findDir: gt,
  findProp: Qt,
  forAliasRE: NS,
  generate: Im,
  generateCodeFrame: kn,
  getBaseTransformPreset: Um,
  getConstantType: ir,
  getMemoedVNodeCall: CS,
  getVNodeBlockHelper: Xi,
  getVNodeHelper: Ki,
  hasDynamicKeyVBind: $c,
  hasScopeRef: Xt,
  helperNameMap: Jt,
  injectProp: po,
  isCoreComponent: bm,
  isFunctionType: Ys,
  isInDestructureAssignment: jo,
  isInNewExpression: SS,
  isMemberExpression: vm,
  isMemberExpressionBrowser: KO,
  isMemberExpressionNode: PS,
  isReferencedIdentifier: mm,
  isSimpleIdentifier: Ts,
  isSlotOutlet: Bn,
  isStaticArgOf: jr,
  isStaticExp: Pt,
  isStaticProperty: qo,
  isStaticPropertyKey: TS,
  isTemplateNode: Fn,
  isText: Ha,
  isVSlot: Sm,
  locStub: rt,
  noopDirectiveTransform: Wa,
  parse: T6,
  parserOptions: Un,
  processExpression: vt,
  processFor: Mm,
  processIf: Dm,
  processSlotOutlet: Vm,
  registerRuntimeHelpers: Qd,
  resolveComponentType: Hc,
  stringifyExpression: qc,
  toValidAssetId: ho,
  trackSlotScopes: $m,
  trackVForSlotScopes: Fm,
  transform: _m,
  transformBind: Lm,
  transformElement: t2,
  transformExpression: km,
  transformModel: zc,
  transformOn: Wc,
  transformStyle: Xm,
  traverseNode: Qn,
  unwrapTSNode: br,
  walkBlockDeclarations: _S,
  walkFunctionParams: gm,
  walkIdentifiers: Uo,
  warnDeprecation: ZE
});
function n2(r, e) {
  for (var t = 0, s = r.length - 1; s >= 0; s--) {
    var i = r[s];
    i === "." ? r.splice(s, 1) : i === ".." ? (r.splice(s, 1), t++) : t && (r.splice(s, 1), t--);
  }
  if (e)
    for (; t--; t)
      r.unshift("..");
  return r;
}
var P6 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, e0 = function(r) {
  return P6.exec(r).slice(1);
};
function Cl() {
  for (var r = "", e = !1, t = arguments.length - 1; t >= -1 && !e; t--) {
    var s = t >= 0 ? arguments[t] : "/";
    if (typeof s != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!s)
      continue;
    r = s + "/" + r, e = s.charAt(0) === "/";
  }
  return r = n2(i0(r.split("/"), function(i) {
    return !!i;
  }), !e).join("/"), (e ? "/" : "") + r || ".";
}
function t0(r) {
  var e = r0(r), t = A6(r, -1) === "/";
  return r = n2(i0(r.split("/"), function(s) {
    return !!s;
  }), !e).join("/"), !r && !e && (r = "."), r && t && (r += "/"), (e ? "/" : "") + r;
}
function r0(r) {
  return r.charAt(0) === "/";
}
function a2() {
  var r = Array.prototype.slice.call(arguments, 0);
  return t0(i0(r, function(e, t) {
    if (typeof e != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return e;
  }).join("/"));
}
function o2(r, e) {
  r = Cl(r).substr(1), e = Cl(e).substr(1);
  function t(l) {
    for (var c = 0; c < l.length && l[c] === ""; c++)
      ;
    for (var f = l.length - 1; f >= 0 && l[f] === ""; f--)
      ;
    return c > f ? [] : l.slice(c, f - c + 1);
  }
  for (var s = t(r.split("/")), i = t(e.split("/")), n = Math.min(s.length, i.length), a = n, o = 0; o < n; o++)
    if (s[o] !== i[o]) {
      a = o;
      break;
    }
  for (var u = [], o = a; o < s.length; o++)
    u.push("..");
  return u = u.concat(i.slice(a)), u.join("/");
}
var u2 = "/", l2 = ":";
function Nl(r) {
  var e = e0(r), t = e[0], s = e[1];
  return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
}
function c2(r, e) {
  var t = e0(r)[2];
  return e && t.substr(-1 * e.length) === e && (t = t.substr(0, t.length - e.length)), t;
}
function s0(r) {
  return e0(r)[3];
}
var As = {
  extname: s0,
  basename: c2,
  dirname: Nl,
  sep: u2,
  delimiter: l2,
  relative: o2,
  join: a2,
  isAbsolute: r0,
  normalize: t0,
  resolve: Cl
};
function i0(r, e) {
  if (r.filter) return r.filter(e);
  for (var t = [], s = 0; s < r.length; s++)
    e(r[s], s, r) && t.push(r[s]);
  return t;
}
var A6 = "ab".substr(-1) === "b" ? function(r, e, t) {
  return r.substr(e, t);
} : function(r, e, t) {
  return e < 0 && (e = r.length + e), r.substr(e, t);
}, C6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  basename: c2,
  default: As,
  delimiter: l2,
  dirname: Nl,
  extname: s0,
  isAbsolute: r0,
  join: a2,
  normalize: t0,
  relative: o2,
  resolve: Cl,
  sep: u2
});
const $r = "Unknown";
function n0(r, e) {
  switch (r.type) {
    case "StringLiteral":
    case "NumericLiteral":
      return String(r.value);
    case "Identifier":
      if (!e) return r.name;
  }
}
function Wy(r) {
  return r.filter((e) => !!e).join(", ");
}
function f2(r) {
  return r.type.endsWith("Literal");
}
function Wt(r, e) {
  return !!(r && e && r.type === "CallExpression" && r.callee.type === "Identifier" && (typeof e == "string" ? r.callee.name === e : e(r.callee.name)));
}
function dn(r) {
  return r.length > 1 ? `[${r.join(", ")}]` : r[0];
}
function Gp(r) {
  return r.type === "ImportSpecifier" ? r.imported.type === "Identifier" ? r.imported.name : r.imported.value : r.type === "ImportNamespaceSpecifier" ? "*" : "default";
}
function Ji(r) {
  return r.type === "Identifier" ? r.name : r.type === "StringLiteral" ? r.value : null;
}
const N6 = (As.posix || As).normalize, O6 = /\\/g;
function a0(r) {
  return N6(r.replace(O6, "/"));
}
const za = (As.posix || As).join, I6 = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~\-]/;
function p2(r) {
  return I6.test(r) ? JSON.stringify(r) : r;
}
const k6 = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function D6(r, e) {
  return r.replace(
    k6,
    (t) => e ? `\\\\${t}` : `\\${t}`
  );
}
function L6(r, e) {
  for (; r.length < e; )
    r = "0" + r;
  return r;
}
function ns(r, e) {
  var t, s, i;
  if (e.length === 0)
    return r;
  for (t = 0, i = e.length; t < i; t++)
    s = e.charCodeAt(t), r = (r << 5) - r + s, r |= 0;
  return r < 0 ? r * -2 : r;
}
function M6(r, e, t) {
  return Object.keys(e).sort().reduce(s, r);
  function s(i, n) {
    return h2(i, e[n], n, t);
  }
}
function h2(r, e, t, s) {
  var i = ns(ns(ns(r, t), R6(e)), typeof e);
  if (e === null)
    return ns(i, "null");
  if (e === void 0)
    return ns(i, "undefined");
  if (typeof e == "object" || typeof e == "function") {
    if (s.indexOf(e) !== -1)
      return ns(i, "[Circular]" + t);
    s.push(e);
    var n = M6(i, e, s);
    if (!("valueOf" in e) || typeof e.valueOf != "function")
      return n;
    try {
      return ns(n, String(e.valueOf()));
    } catch (a) {
      return ns(n, "[valueOf exception]" + (a.stack || a.message));
    }
  }
  return ns(i, e.toString());
}
function R6(r) {
  return Object.prototype.toString.call(r);
}
function $6(r) {
  return L6(h2(0, r, "", []).toString(16), 8);
}
var F6 = $6, B6 = /* @__PURE__ */ Dc(F6);
const Ol = "useCssVars";
function d2(r, e, t, s = !1) {
  return `{
  ${r.map(
    (i) => `"${s ? "--" : ""}${m2(e, i, t, s)}": (${i})`
  ).join(`,
  `)}
}`;
}
function m2(r, e, t, s = !1) {
  return t ? B6(r + e) : `${r}-${D6(e, s)}`;
}
function g2(r) {
  return r = r.trim(), r[0] === "'" && r[r.length - 1] === "'" || r[0] === '"' && r[r.length - 1] === '"' ? r.slice(1, -1) : r;
}
const Hu = /v-bind\s*\(/g;
function V6(r) {
  const e = [];
  return r.styles.forEach((t) => {
    let s;
    const i = t.content.replace(/\/\*([\s\S]*?)\*\/|\/\/.*/g, "");
    for (; s = Hu.exec(i); ) {
      const n = s.index + s[0].length, a = y2(i, n);
      if (a !== null) {
        const o = g2(i.slice(n, a));
        e.includes(o) || e.push(o);
      }
    }
  }), e;
}
function y2(r, e) {
  let t = 0, s = 0;
  for (let i = e; i < r.length; i++) {
    const n = r.charAt(i);
    switch (t) {
      case 0:
        if (n === "'")
          t = 1;
        else if (n === '"')
          t = 2;
        else if (n === "(")
          s++;
        else if (n === ")")
          if (s > 0)
            s--;
          else
            return i;
        break;
      case 1:
        n === "'" && (t = 0);
        break;
      case 2:
        n === '"' && (t = 0);
        break;
    }
  }
  return null;
}
const b2 = (r) => {
  const { id: e, isProd: t } = r;
  return {
    postcssPlugin: "vue-sfc-vars",
    Declaration(s) {
      const i = s.value;
      if (Hu.test(i)) {
        Hu.lastIndex = 0;
        let n = "", a = 0, o;
        for (; o = Hu.exec(i); ) {
          const u = o.index + o[0].length, l = y2(i, u);
          if (l !== null) {
            const c = g2(i.slice(u, l));
            n += i.slice(a, o.index) + `var(--${m2(e, c, t)})`, a = l + 1;
          }
        }
        s.value = n + i.slice(a);
      }
    }
  };
};
b2.postcss = !0;
function v2(r, e, t, s) {
  const i = d2(r, t, s), n = Q(i, !1), a = Ho(rn([]), {
    prefixIdentifiers: !0,
    inline: !0,
    bindingMetadata: e.__isScriptSetup === !1 ? void 0 : e
  }), o = vt(n, a), u = o.type === 4 ? o.content : o.children.map((l) => typeof l == "string" ? l : l.content).join("");
  return `_${Ol}(_ctx => (${u}))`;
}
function U6(r, e, t, s, i) {
  return `
import { ${Ol} as _${Ol} } from 'vue'
const __injectCSSVars__ = () => {
${v2(
    r,
    e,
    t,
    s
  )}}
const __setup__ = ${i}.setup
${i}.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
}
var li = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {};
function E2() {
  throw new Error("setTimeout has not been defined");
}
function S2() {
  throw new Error("clearTimeout has not been defined");
}
var Us = E2, js = S2;
typeof li.setTimeout == "function" && (Us = setTimeout);
typeof li.clearTimeout == "function" && (js = clearTimeout);
function _2(r) {
  if (Us === setTimeout)
    return setTimeout(r, 0);
  if ((Us === E2 || !Us) && setTimeout)
    return Us = setTimeout, setTimeout(r, 0);
  try {
    return Us(r, 0);
  } catch {
    try {
      return Us.call(null, r, 0);
    } catch {
      return Us.call(this, r, 0);
    }
  }
}
function j6(r) {
  if (js === clearTimeout)
    return clearTimeout(r);
  if ((js === S2 || !js) && clearTimeout)
    return js = clearTimeout, clearTimeout(r);
  try {
    return js(r);
  } catch {
    try {
      return js.call(null, r);
    } catch {
      return js.call(this, r);
    }
  }
}
var ys = [], _n = !1, Pi, Wu = -1;
function q6() {
  !_n || !Pi || (_n = !1, Pi.length ? ys = Pi.concat(ys) : Wu = -1, ys.length && x2());
}
function x2() {
  if (!_n) {
    var r = _2(q6);
    _n = !0;
    for (var e = ys.length; e; ) {
      for (Pi = ys, ys = []; ++Wu < e; )
        Pi && Pi[Wu].run();
      Wu = -1, e = ys.length;
    }
    Pi = null, _n = !1, j6(r);
  }
}
function H6(r) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var t = 1; t < arguments.length; t++)
      e[t - 1] = arguments[t];
  ys.push(new w2(r, e)), ys.length === 1 && !_n && _2(x2);
}
function w2(r, e) {
  this.fun = r, this.array = e;
}
w2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var W6 = "browser", z6 = "browser", G6 = !0, K6 = {}, X6 = [], J6 = "", Y6 = {}, Q6 = {}, Z6 = {};
function an() {
}
var e4 = an, t4 = an, r4 = an, s4 = an, i4 = an, n4 = an, a4 = an;
function o4(r) {
  throw new Error("process.binding is not supported");
}
function u4() {
  return "/";
}
function l4(r) {
  throw new Error("process.chdir is not supported");
}
function c4() {
  return 0;
}
var cn = li.performance || {}, f4 = cn.now || cn.mozNow || cn.msNow || cn.oNow || cn.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function p4(r) {
  var e = f4.call(cn) * 1e-3, t = Math.floor(e), s = Math.floor(e % 1 * 1e9);
  return r && (t = t - r[0], s = s - r[1], s < 0 && (t--, s += 1e9)), [t, s];
}
var h4 = /* @__PURE__ */ new Date();
function d4() {
  var r = /* @__PURE__ */ new Date(), e = r - h4;
  return e / 1e3;
}
var Zt = {
  nextTick: H6,
  title: W6,
  browser: G6,
  env: K6,
  argv: X6,
  version: J6,
  versions: Y6,
  on: e4,
  addListener: t4,
  once: r4,
  off: s4,
  removeListener: i4,
  removeAllListeners: n4,
  emit: a4,
  binding: o4,
  cwd: u4,
  chdir: l4,
  umask: c4,
  hrtime: p4,
  platform: z6,
  release: Q6,
  config: Z6,
  uptime: d4
};
function Gc(r = 500) {
  return /* @__PURE__ */ new Map();
}
function T2(r, e) {
  return m4(e).has(r);
}
const zy = Gc();
function m4(r) {
  const { content: e, ast: t } = r.template, s = zy.get(e);
  if (s)
    return s;
  const i = /* @__PURE__ */ new Set();
  t.children.forEach(n);
  function n(a) {
    var o;
    switch (a.type) {
      case 1:
        let u = a.tag;
        u.includes(".") && (u = u.split(".")[0].trim()), !Un.isNativeTag(u) && !Un.isBuiltInComponent(u) && (i.add(or(u)), i.add(oi(or(u))));
        for (let l = 0; l < a.props.length; l++) {
          const c = a.props[l];
          c.type === 7 && (Wd(c.name) || i.add(`v${oi(or(c.name))}`), c.arg && !c.arg.isStatic && pu(i, c.arg), c.name === "for" ? pu(i, c.forParseResult.source) : c.exp ? pu(i, c.exp) : c.name === "bind" && !c.exp && i.add(c.arg.content)), c.type === 6 && c.name === "ref" && ((o = c.value) != null && o.content) && i.add(c.value.content);
        }
        a.children.forEach(n);
        break;
      case 5:
        pu(i, a.content);
        break;
    }
  }
  return zy.set(e, i), i;
}
function pu(r, e) {
  e.ast ? Uo(e.ast, (t) => r.add(t.name)) : e.ast === null && r.add(e.content);
}
var g4 = Object.defineProperty, y4 = Object.defineProperties, b4 = Object.getOwnPropertyDescriptors, Gy = Object.getOwnPropertySymbols, v4 = Object.prototype.hasOwnProperty, E4 = Object.prototype.propertyIsEnumerable, Ky = (r, e, t) => e in r ? g4(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, P2 = (r, e) => {
  for (var t in e || (e = {}))
    v4.call(e, t) && Ky(r, t, e[t]);
  if (Gy)
    for (var t of Gy(e))
      E4.call(e, t) && Ky(r, t, e[t]);
  return r;
}, A2 = (r, e) => y4(r, b4(e));
const C2 = "anonymous.vue", Kp = Gc();
function S4(r, e) {
  var t;
  return r + JSON.stringify(
    A2(P2({}, e), {
      compiler: { parse: (t = e.compiler) == null ? void 0 : t.parse }
    }),
    (s, i) => typeof i == "function" ? i.toString() : i
  );
}
function N2(r, e = {}) {
  const t = S4(r, e), s = Kp.get(t);
  if (s)
    return s;
  const {
    sourceMap: i = !0,
    filename: n = C2,
    sourceRoot: a = "",
    pad: o = !1,
    ignoreEmpty: u = !0,
    compiler: l = zp,
    templateParseOptions: c = {},
    parseExpressions: f = !0
  } = e, p = {
    filename: n,
    source: r,
    template: null,
    script: null,
    scriptSetup: null,
    styles: [],
    customBlocks: [],
    cssVars: [],
    slotted: !1,
    shouldForceReload: (E) => C4(E, p)
  }, h = [];
  l.parse(r, A2(P2({
    parseMode: "sfc",
    prefixIdentifiers: f
  }, c), {
    onError: (E) => {
      h.push(E);
    }
  })).children.forEach((E) => {
    if (E.type === 1 && !(u && E.tag !== "template" && A4(E) && !P4(E)))
      switch (E.tag) {
        case "template":
          if (p.template)
            h.push(Xy(E));
          else {
            const A = p.template = hu(
              E,
              r,
              !1
            );
            if (A.attrs.src || (A.ast = rn(E.children, r)), A.attrs.functional) {
              const C = new SyntaxError(
                "<template functional> is no longer supported in Vue 3, since functional components no longer have significant performance difference from stateful ones. Just use a normal <template> instead."
              );
              C.loc = E.props.find(
                (x) => x.type === 6 && x.name === "functional"
              ).loc, h.push(C);
            }
          }
          break;
        case "script":
          const g = hu(E, r, o), b = !!g.attrs.setup;
          if (b && !p.scriptSetup) {
            p.scriptSetup = g;
            break;
          }
          if (!b && !p.script) {
            p.script = g;
            break;
          }
          h.push(Xy(E, b));
          break;
        case "style":
          const v = hu(E, r, o);
          v.attrs.vars && h.push(
            new SyntaxError(
              "<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231"
            )
          ), p.styles.push(v);
          break;
        default:
          p.customBlocks.push(hu(E, r, o));
          break;
      }
  }), !p.template && !p.script && !p.scriptSetup && h.push(
    new SyntaxError(
      "At least one <template> or <script> is required in a single file component."
    )
  ), p.scriptSetup && (p.scriptSetup.src && (h.push(
    new SyntaxError(
      '<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.'
    )
  ), p.scriptSetup = null), p.script && p.script.src && (h.push(
    new SyntaxError(
      '<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.'
    )
  ), p.script = null));
  let d = 0;
  if (p.template && (p.template.lang === "pug" || p.template.lang === "jade") && ([p.template.content, d] = N4(
    p.template.content
  )), i) {
    const E = (g, b = 0) => {
      g && !g.src && (g.map = w4(
        n,
        r,
        g.content,
        a,
        !o || g.type === "template" ? g.loc.start.line - 1 : 0,
        b
      ));
    };
    E(p.template, d), E(p.script), p.styles.forEach((g) => E(g)), p.customBlocks.forEach((g) => E(g));
  }
  p.cssVars = V6(p);
  const y = /(?:::v-|:)slotted\(/;
  p.slotted = p.styles.some(
    (E) => E.scoped && y.test(E.content)
  );
  const S = {
    descriptor: p,
    errors: h
  };
  return Kp.set(t, S), S;
}
function Xy(r, e = !1) {
  const t = new SyntaxError(
    `Single file component can contain only one <${r.tag}${e ? " setup" : ""}> element`
  );
  return t.loc = r.loc, t;
}
function hu(r, e, t) {
  const s = r.tag, i = r.innerLoc, n = {}, a = {
    type: s,
    content: e.slice(i.start.offset, i.end.offset),
    loc: i,
    attrs: n
  };
  return t && (a.content = T4(e, a, t) + a.content), r.props.forEach((o) => {
    if (o.type === 6) {
      const u = o.name;
      n[u] = o.value && o.value.content || !0, u === "lang" ? a.lang = o.value && o.value.content : u === "src" ? a.src = o.value && o.value.content : s === "style" ? u === "scoped" ? a.scoped = !0 : u === "module" && (a.module = n[u]) : s === "script" && u === "setup" && (a.setup = n.setup);
    }
  }), a;
}
const O2 = /\r?\n/g, _4 = /^(?:\/\/)?\s*$/, x4 = /./g;
function w4(r, e, t, s, i, n) {
  const a = new Om({
    file: r.replace(/\\/g, "/"),
    sourceRoot: s.replace(/\\/g, "/")
  });
  return a.setSourceContent(r, e), a._sources.add(r), t.split(O2).forEach((o, u) => {
    if (!_4.test(o)) {
      const l = u + 1 + i, c = u + 1;
      for (let f = 0; f < o.length; f++)
        /\s/.test(o[f]) || a._mappings.add({
          originalLine: l,
          originalColumn: f + n,
          generatedLine: c,
          generatedColumn: f,
          source: r,
          name: null
        });
    }
  }), a.toJSON();
}
function T4(r, e, t) {
  if (r = r.slice(0, e.loc.start.offset), t === "space")
    return r.replace(x4, " ");
  {
    const s = r.split(O2).length, i = e.type === "script" && !e.lang ? `//
` : `
`;
    return Array(s).join(i);
  }
}
function P4(r) {
  return r.props.some((e) => e.type !== 6 ? !1 : e.name === "src");
}
function A4(r) {
  for (let e = 0; e < r.children.length; e++) {
    const t = r.children[e];
    if (t.type !== 2 || t.content.trim() !== "")
      return !1;
  }
  return !0;
}
function C4(r, e) {
  if (!e.scriptSetup || e.scriptSetup.lang !== "ts" && e.scriptSetup.lang !== "tsx")
    return !1;
  for (const t in r)
    if (!r[t].isUsedInTemplate && T2(t, e))
      return !0;
  return !1;
}
function N4(r) {
  const e = r.split(`
`), t = e.reduce(function(s, i) {
    var n, a;
    if (i.trim() === "")
      return s;
    const o = ((a = (n = i.match(/^\s*/)) == null ? void 0 : n[0]) == null ? void 0 : a.length) || 0;
    return Math.min(o, s);
  }, 1 / 0);
  return t === 0 ? [r, t] : [
    e.map(function(s) {
      return s.slice(t);
    }).join(`
`),
    t
  ];
}
/*! https://mths.be/punycode v1.4.1 by @mathias */
var Bf = 2147483647, Ga = 36, I2 = 1, Xp = 26, O4 = 38, I4 = 700, k4 = 72, D4 = 128, L4 = "-", M4 = /[^\x20-\x7E]/, R4 = /[\x2E\u3002\uFF0E\uFF61]/g, $4 = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, Vf = Ga - I2, mn = Math.floor, Uf = String.fromCharCode;
function Jy(r) {
  throw new RangeError($4[r]);
}
function F4(r, e) {
  for (var t = r.length, s = []; t--; )
    s[t] = e(r[t]);
  return s;
}
function B4(r, e) {
  var t = r.split("@"), s = "";
  t.length > 1 && (s = t[0] + "@", r = t[1]), r = r.replace(R4, ".");
  var i = r.split("."), n = F4(i, e).join(".");
  return s + n;
}
function V4(r) {
  for (var e = [], t = 0, s = r.length, i, n; t < s; )
    i = r.charCodeAt(t++), i >= 55296 && i <= 56319 && t < s ? (n = r.charCodeAt(t++), (n & 64512) == 56320 ? e.push(((i & 1023) << 10) + (n & 1023) + 65536) : (e.push(i), t--)) : e.push(i);
  return e;
}
function Yy(r, e) {
  return r + 22 + 75 * (r < 26) - ((e != 0) << 5);
}
function U4(r, e, t) {
  var s = 0;
  for (r = t ? mn(r / I4) : r >> 1, r += mn(r / e); r > Vf * Xp >> 1; s += Ga)
    r = mn(r / Vf);
  return mn(s + (Vf + 1) * r / (r + O4));
}
function j4(r) {
  var e, t, s, i, n, a, o, u, l, c, f, p = [], h, m, d, y;
  for (r = V4(r), h = r.length, e = D4, t = 0, n = k4, a = 0; a < h; ++a)
    f = r[a], f < 128 && p.push(Uf(f));
  for (s = i = p.length, i && p.push(L4); s < h; ) {
    for (o = Bf, a = 0; a < h; ++a)
      f = r[a], f >= e && f < o && (o = f);
    for (m = s + 1, o - e > mn((Bf - t) / m) && Jy("overflow"), t += (o - e) * m, e = o, a = 0; a < h; ++a)
      if (f = r[a], f < e && ++t > Bf && Jy("overflow"), f == e) {
        for (u = t, l = Ga; c = l <= n ? I2 : l >= n + Xp ? Xp : l - n, !(u < c); l += Ga)
          y = u - c, d = Ga - c, p.push(
            Uf(Yy(c + y % d, 0))
          ), u = mn(y / d);
        p.push(Uf(Yy(u, 0))), n = U4(t, m, s == i), t = 0, ++s;
      }
    ++t, ++e;
  }
  return p.join("");
}
function q4(r) {
  return B4(r, function(e) {
    return M4.test(e) ? "xn--" + j4(e) : e;
  });
}
var Vr = [], dr = [], H4 = typeof Uint8Array < "u" ? Uint8Array : Array, o0 = !1;
function k2() {
  o0 = !0;
  for (var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = 0, t = r.length; e < t; ++e)
    Vr[e] = r[e], dr[r.charCodeAt(e)] = e;
  dr[45] = 62, dr[95] = 63;
}
function W4(r) {
  o0 || k2();
  var e, t, s, i, n, a, o = r.length;
  if (o % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  n = r[o - 2] === "=" ? 2 : r[o - 1] === "=" ? 1 : 0, a = new H4(o * 3 / 4 - n), s = n > 0 ? o - 4 : o;
  var u = 0;
  for (e = 0, t = 0; e < s; e += 4, t += 3)
    i = dr[r.charCodeAt(e)] << 18 | dr[r.charCodeAt(e + 1)] << 12 | dr[r.charCodeAt(e + 2)] << 6 | dr[r.charCodeAt(e + 3)], a[u++] = i >> 16 & 255, a[u++] = i >> 8 & 255, a[u++] = i & 255;
  return n === 2 ? (i = dr[r.charCodeAt(e)] << 2 | dr[r.charCodeAt(e + 1)] >> 4, a[u++] = i & 255) : n === 1 && (i = dr[r.charCodeAt(e)] << 10 | dr[r.charCodeAt(e + 1)] << 4 | dr[r.charCodeAt(e + 2)] >> 2, a[u++] = i >> 8 & 255, a[u++] = i & 255), a;
}
function z4(r) {
  return Vr[r >> 18 & 63] + Vr[r >> 12 & 63] + Vr[r >> 6 & 63] + Vr[r & 63];
}
function G4(r, e, t) {
  for (var s, i = [], n = e; n < t; n += 3)
    s = (r[n] << 16) + (r[n + 1] << 8) + r[n + 2], i.push(z4(s));
  return i.join("");
}
function Qy(r) {
  o0 || k2();
  for (var e, t = r.length, s = t % 3, i = "", n = [], a = 16383, o = 0, u = t - s; o < u; o += a)
    n.push(G4(r, o, o + a > u ? u : o + a));
  return s === 1 ? (e = r[t - 1], i += Vr[e >> 2], i += Vr[e << 4 & 63], i += "==") : s === 2 && (e = (r[t - 2] << 8) + r[t - 1], i += Vr[e >> 10], i += Vr[e >> 4 & 63], i += Vr[e << 2 & 63], i += "="), n.push(i), n.join("");
}
function Kc(r, e, t, s, i) {
  var n, a, o = i * 8 - s - 1, u = (1 << o) - 1, l = u >> 1, c = -7, f = t ? i - 1 : 0, p = t ? -1 : 1, h = r[e + f];
  for (f += p, n = h & (1 << -c) - 1, h >>= -c, c += o; c > 0; n = n * 256 + r[e + f], f += p, c -= 8)
    ;
  for (a = n & (1 << -c) - 1, n >>= -c, c += s; c > 0; a = a * 256 + r[e + f], f += p, c -= 8)
    ;
  if (n === 0)
    n = 1 - l;
  else {
    if (n === u)
      return a ? NaN : (h ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, s), n = n - l;
  }
  return (h ? -1 : 1) * a * Math.pow(2, n - s);
}
function D2(r, e, t, s, i, n) {
  var a, o, u, l = n * 8 - i - 1, c = (1 << l) - 1, f = c >> 1, p = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = s ? 0 : n - 1, m = s ? 1 : -1, d = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), a + f >= 1 ? e += p / u : e += p * Math.pow(2, 1 - f), e * u >= 2 && (a++, u /= 2), a + f >= c ? (o = 0, a = c) : a + f >= 1 ? (o = (e * u - 1) * Math.pow(2, i), a = a + f) : (o = e * Math.pow(2, f - 1) * Math.pow(2, i), a = 0)); i >= 8; r[t + h] = o & 255, h += m, o /= 256, i -= 8)
    ;
  for (a = a << i | o, l += i; l > 0; r[t + h] = a & 255, h += m, a /= 256, l -= 8)
    ;
  r[t + h - m] |= d * 128;
}
var K4 = {}.toString, L2 = Array.isArray || function(r) {
  return K4.call(r) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var X4 = 50;
H.TYPED_ARRAY_SUPPORT = li.TYPED_ARRAY_SUPPORT !== void 0 ? li.TYPED_ARRAY_SUPPORT : !0;
Il();
function Il() {
  return H.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function bs(r, e) {
  if (Il() < e)
    throw new RangeError("Invalid typed array length");
  return H.TYPED_ARRAY_SUPPORT ? (r = new Uint8Array(e), r.__proto__ = H.prototype) : (r === null && (r = new H(e)), r.length = e), r;
}
function H(r, e, t) {
  if (!H.TYPED_ARRAY_SUPPORT && !(this instanceof H))
    return new H(r, e, t);
  if (typeof r == "number") {
    if (typeof e == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return u0(this, r);
  }
  return M2(this, r, e, t);
}
H.poolSize = 8192;
H._augment = function(r) {
  return r.__proto__ = H.prototype, r;
};
function M2(r, e, t, s) {
  if (typeof e == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer ? Q4(r, e, t, s) : typeof e == "string" ? Y4(r, e, t) : Z4(r, e);
}
H.from = function(r, e, t) {
  return M2(null, r, e, t);
};
H.TYPED_ARRAY_SUPPORT && (H.prototype.__proto__ = Uint8Array.prototype, H.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && H[Symbol.species]);
function R2(r) {
  if (typeof r != "number")
    throw new TypeError('"size" argument must be a number');
  if (r < 0)
    throw new RangeError('"size" argument must not be negative');
}
function J4(r, e, t, s) {
  return R2(e), e <= 0 ? bs(r, e) : t !== void 0 ? typeof s == "string" ? bs(r, e).fill(t, s) : bs(r, e).fill(t) : bs(r, e);
}
H.alloc = function(r, e, t) {
  return J4(null, r, e, t);
};
function u0(r, e) {
  if (R2(e), r = bs(r, e < 0 ? 0 : l0(e) | 0), !H.TYPED_ARRAY_SUPPORT)
    for (var t = 0; t < e; ++t)
      r[t] = 0;
  return r;
}
H.allocUnsafe = function(r) {
  return u0(null, r);
};
H.allocUnsafeSlow = function(r) {
  return u0(null, r);
};
function Y4(r, e, t) {
  if ((typeof t != "string" || t === "") && (t = "utf8"), !H.isEncoding(t))
    throw new TypeError('"encoding" must be a valid string encoding');
  var s = $2(e, t) | 0;
  r = bs(r, s);
  var i = r.write(e, t);
  return i !== s && (r = r.slice(0, i)), r;
}
function Jp(r, e) {
  var t = e.length < 0 ? 0 : l0(e.length) | 0;
  r = bs(r, t);
  for (var s = 0; s < t; s += 1)
    r[s] = e[s] & 255;
  return r;
}
function Q4(r, e, t, s) {
  if (e.byteLength, t < 0 || e.byteLength < t)
    throw new RangeError("'offset' is out of bounds");
  if (e.byteLength < t + (s || 0))
    throw new RangeError("'length' is out of bounds");
  return t === void 0 && s === void 0 ? e = new Uint8Array(e) : s === void 0 ? e = new Uint8Array(e, t) : e = new Uint8Array(e, t, s), H.TYPED_ARRAY_SUPPORT ? (r = e, r.__proto__ = H.prototype) : r = Jp(r, e), r;
}
function Z4(r, e) {
  if (ss(e)) {
    var t = l0(e.length) | 0;
    return r = bs(r, t), r.length === 0 || e.copy(r, 0, 0, t), r;
  }
  if (e) {
    if (typeof ArrayBuffer < "u" && e.buffer instanceof ArrayBuffer || "length" in e)
      return typeof e.length != "number" || b8(e.length) ? bs(r, 0) : Jp(r, e);
    if (e.type === "Buffer" && L2(e.data))
      return Jp(r, e.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function l0(r) {
  if (r >= Il())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Il().toString(16) + " bytes");
  return r | 0;
}
H.isBuffer = v8;
function ss(r) {
  return !!(r != null && r._isBuffer);
}
H.compare = function(e, t) {
  if (!ss(e) || !ss(t))
    throw new TypeError("Arguments must be Buffers");
  if (e === t) return 0;
  for (var s = e.length, i = t.length, n = 0, a = Math.min(s, i); n < a; ++n)
    if (e[n] !== t[n]) {
      s = e[n], i = t[n];
      break;
    }
  return s < i ? -1 : i < s ? 1 : 0;
};
H.isEncoding = function(e) {
  switch (String(e).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
};
H.concat = function(e, t) {
  if (!L2(e))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (e.length === 0)
    return H.alloc(0);
  var s;
  if (t === void 0)
    for (t = 0, s = 0; s < e.length; ++s)
      t += e[s].length;
  var i = H.allocUnsafe(t), n = 0;
  for (s = 0; s < e.length; ++s) {
    var a = e[s];
    if (!ss(a))
      throw new TypeError('"list" argument must be an Array of Buffers');
    a.copy(i, n), n += a.length;
  }
  return i;
};
function $2(r, e) {
  if (ss(r))
    return r.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(r) || r instanceof ArrayBuffer))
    return r.byteLength;
  typeof r != "string" && (r = "" + r);
  var t = r.length;
  if (t === 0) return 0;
  for (var s = !1; ; )
    switch (e) {
      case "ascii":
      case "latin1":
      case "binary":
        return t;
      case "utf8":
      case "utf-8":
      case void 0:
        return kl(r).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return t * 2;
      case "hex":
        return t >>> 1;
      case "base64":
        return H2(r).length;
      default:
        if (s) return kl(r).length;
        e = ("" + e).toLowerCase(), s = !0;
    }
}
H.byteLength = $2;
function e8(r, e, t) {
  var s = !1;
  if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e))
    return "";
  for (r || (r = "utf8"); ; )
    switch (r) {
      case "hex":
        return c8(this, e, t);
      case "utf8":
      case "utf-8":
        return V2(this, e, t);
      case "ascii":
        return u8(this, e, t);
      case "latin1":
      case "binary":
        return l8(this, e, t);
      case "base64":
        return a8(this, e, t);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return f8(this, e, t);
      default:
        if (s) throw new TypeError("Unknown encoding: " + r);
        r = (r + "").toLowerCase(), s = !0;
    }
}
H.prototype._isBuffer = !0;
function Ai(r, e, t) {
  var s = r[e];
  r[e] = r[t], r[t] = s;
}
H.prototype.swap16 = function() {
  var e = this.length;
  if (e % 2 !== 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t = 0; t < e; t += 2)
    Ai(this, t, t + 1);
  return this;
};
H.prototype.swap32 = function() {
  var e = this.length;
  if (e % 4 !== 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t = 0; t < e; t += 4)
    Ai(this, t, t + 3), Ai(this, t + 1, t + 2);
  return this;
};
H.prototype.swap64 = function() {
  var e = this.length;
  if (e % 8 !== 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t = 0; t < e; t += 8)
    Ai(this, t, t + 7), Ai(this, t + 1, t + 6), Ai(this, t + 2, t + 5), Ai(this, t + 3, t + 4);
  return this;
};
H.prototype.toString = function() {
  var e = this.length | 0;
  return e === 0 ? "" : arguments.length === 0 ? V2(this, 0, e) : e8.apply(this, arguments);
};
H.prototype.equals = function(e) {
  if (!ss(e)) throw new TypeError("Argument must be a Buffer");
  return this === e ? !0 : H.compare(this, e) === 0;
};
H.prototype.inspect = function() {
  var e = "", t = X4;
  return this.length > 0 && (e = this.toString("hex", 0, t).match(/.{2}/g).join(" "), this.length > t && (e += " ... ")), "<Buffer " + e + ">";
};
H.prototype.compare = function(e, t, s, i, n) {
  if (!ss(e))
    throw new TypeError("Argument must be a Buffer");
  if (t === void 0 && (t = 0), s === void 0 && (s = e ? e.length : 0), i === void 0 && (i = 0), n === void 0 && (n = this.length), t < 0 || s > e.length || i < 0 || n > this.length)
    throw new RangeError("out of range index");
  if (i >= n && t >= s)
    return 0;
  if (i >= n)
    return -1;
  if (t >= s)
    return 1;
  if (t >>>= 0, s >>>= 0, i >>>= 0, n >>>= 0, this === e) return 0;
  for (var a = n - i, o = s - t, u = Math.min(a, o), l = this.slice(i, n), c = e.slice(t, s), f = 0; f < u; ++f)
    if (l[f] !== c[f]) {
      a = l[f], o = c[f];
      break;
    }
  return a < o ? -1 : o < a ? 1 : 0;
};
function F2(r, e, t, s, i) {
  if (r.length === 0) return -1;
  if (typeof t == "string" ? (s = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, isNaN(t) && (t = i ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
    if (i) return -1;
    t = r.length - 1;
  } else if (t < 0)
    if (i) t = 0;
    else return -1;
  if (typeof e == "string" && (e = H.from(e, s)), ss(e))
    return e.length === 0 ? -1 : Zy(r, e, t, s, i);
  if (typeof e == "number")
    return e = e & 255, H.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : Zy(r, [e], t, s, i);
  throw new TypeError("val must be string, number or Buffer");
}
function Zy(r, e, t, s, i) {
  var n = 1, a = r.length, o = e.length;
  if (s !== void 0 && (s = String(s).toLowerCase(), s === "ucs2" || s === "ucs-2" || s === "utf16le" || s === "utf-16le")) {
    if (r.length < 2 || e.length < 2)
      return -1;
    n = 2, a /= 2, o /= 2, t /= 2;
  }
  function u(h, m) {
    return n === 1 ? h[m] : h.readUInt16BE(m * n);
  }
  var l;
  if (i) {
    var c = -1;
    for (l = t; l < a; l++)
      if (u(r, l) === u(e, c === -1 ? 0 : l - c)) {
        if (c === -1 && (c = l), l - c + 1 === o) return c * n;
      } else
        c !== -1 && (l -= l - c), c = -1;
  } else
    for (t + o > a && (t = a - o), l = t; l >= 0; l--) {
      for (var f = !0, p = 0; p < o; p++)
        if (u(r, l + p) !== u(e, p)) {
          f = !1;
          break;
        }
      if (f) return l;
    }
  return -1;
}
H.prototype.includes = function(e, t, s) {
  return this.indexOf(e, t, s) !== -1;
};
H.prototype.indexOf = function(e, t, s) {
  return F2(this, e, t, s, !0);
};
H.prototype.lastIndexOf = function(e, t, s) {
  return F2(this, e, t, s, !1);
};
function t8(r, e, t, s) {
  t = Number(t) || 0;
  var i = r.length - t;
  s ? (s = Number(s), s > i && (s = i)) : s = i;
  var n = e.length;
  if (n % 2 !== 0) throw new TypeError("Invalid hex string");
  s > n / 2 && (s = n / 2);
  for (var a = 0; a < s; ++a) {
    var o = parseInt(e.substr(a * 2, 2), 16);
    if (isNaN(o)) return a;
    r[t + a] = o;
  }
  return a;
}
function r8(r, e, t, s) {
  return Yc(kl(e, r.length - t), r, t, s);
}
function B2(r, e, t, s) {
  return Yc(g8(e), r, t, s);
}
function s8(r, e, t, s) {
  return B2(r, e, t, s);
}
function i8(r, e, t, s) {
  return Yc(H2(e), r, t, s);
}
function n8(r, e, t, s) {
  return Yc(y8(e, r.length - t), r, t, s);
}
H.prototype.write = function(e, t, s, i) {
  if (t === void 0)
    i = "utf8", s = this.length, t = 0;
  else if (s === void 0 && typeof t == "string")
    i = t, s = this.length, t = 0;
  else if (isFinite(t))
    t = t | 0, isFinite(s) ? (s = s | 0, i === void 0 && (i = "utf8")) : (i = s, s = void 0);
  else
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  var n = this.length - t;
  if ((s === void 0 || s > n) && (s = n), e.length > 0 && (s < 0 || t < 0) || t > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  i || (i = "utf8");
  for (var a = !1; ; )
    switch (i) {
      case "hex":
        return t8(this, e, t, s);
      case "utf8":
      case "utf-8":
        return r8(this, e, t, s);
      case "ascii":
        return B2(this, e, t, s);
      case "latin1":
      case "binary":
        return s8(this, e, t, s);
      case "base64":
        return i8(this, e, t, s);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return n8(this, e, t, s);
      default:
        if (a) throw new TypeError("Unknown encoding: " + i);
        i = ("" + i).toLowerCase(), a = !0;
    }
};
H.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function a8(r, e, t) {
  return e === 0 && t === r.length ? Qy(r) : Qy(r.slice(e, t));
}
function V2(r, e, t) {
  t = Math.min(r.length, t);
  for (var s = [], i = e; i < t; ) {
    var n = r[i], a = null, o = n > 239 ? 4 : n > 223 ? 3 : n > 191 ? 2 : 1;
    if (i + o <= t) {
      var u, l, c, f;
      switch (o) {
        case 1:
          n < 128 && (a = n);
          break;
        case 2:
          u = r[i + 1], (u & 192) === 128 && (f = (n & 31) << 6 | u & 63, f > 127 && (a = f));
          break;
        case 3:
          u = r[i + 1], l = r[i + 2], (u & 192) === 128 && (l & 192) === 128 && (f = (n & 15) << 12 | (u & 63) << 6 | l & 63, f > 2047 && (f < 55296 || f > 57343) && (a = f));
          break;
        case 4:
          u = r[i + 1], l = r[i + 2], c = r[i + 3], (u & 192) === 128 && (l & 192) === 128 && (c & 192) === 128 && (f = (n & 15) << 18 | (u & 63) << 12 | (l & 63) << 6 | c & 63, f > 65535 && f < 1114112 && (a = f));
      }
    }
    a === null ? (a = 65533, o = 1) : a > 65535 && (a -= 65536, s.push(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), s.push(a), i += o;
  }
  return o8(s);
}
var e1 = 4096;
function o8(r) {
  var e = r.length;
  if (e <= e1)
    return String.fromCharCode.apply(String, r);
  for (var t = "", s = 0; s < e; )
    t += String.fromCharCode.apply(
      String,
      r.slice(s, s += e1)
    );
  return t;
}
function u8(r, e, t) {
  var s = "";
  t = Math.min(r.length, t);
  for (var i = e; i < t; ++i)
    s += String.fromCharCode(r[i] & 127);
  return s;
}
function l8(r, e, t) {
  var s = "";
  t = Math.min(r.length, t);
  for (var i = e; i < t; ++i)
    s += String.fromCharCode(r[i]);
  return s;
}
function c8(r, e, t) {
  var s = r.length;
  (!e || e < 0) && (e = 0), (!t || t < 0 || t > s) && (t = s);
  for (var i = "", n = e; n < t; ++n)
    i += m8(r[n]);
  return i;
}
function f8(r, e, t) {
  for (var s = r.slice(e, t), i = "", n = 0; n < s.length; n += 2)
    i += String.fromCharCode(s[n] + s[n + 1] * 256);
  return i;
}
H.prototype.slice = function(e, t) {
  var s = this.length;
  e = ~~e, t = t === void 0 ? s : ~~t, e < 0 ? (e += s, e < 0 && (e = 0)) : e > s && (e = s), t < 0 ? (t += s, t < 0 && (t = 0)) : t > s && (t = s), t < e && (t = e);
  var i;
  if (H.TYPED_ARRAY_SUPPORT)
    i = this.subarray(e, t), i.__proto__ = H.prototype;
  else {
    var n = t - e;
    i = new H(n, void 0);
    for (var a = 0; a < n; ++a)
      i[a] = this[a + e];
  }
  return i;
};
function St(r, e, t) {
  if (r % 1 !== 0 || r < 0) throw new RangeError("offset is not uint");
  if (r + e > t) throw new RangeError("Trying to access beyond buffer length");
}
H.prototype.readUIntLE = function(e, t, s) {
  e = e | 0, t = t | 0, s || St(e, t, this.length);
  for (var i = this[e], n = 1, a = 0; ++a < t && (n *= 256); )
    i += this[e + a] * n;
  return i;
};
H.prototype.readUIntBE = function(e, t, s) {
  e = e | 0, t = t | 0, s || St(e, t, this.length);
  for (var i = this[e + --t], n = 1; t > 0 && (n *= 256); )
    i += this[e + --t] * n;
  return i;
};
H.prototype.readUInt8 = function(e, t) {
  return t || St(e, 1, this.length), this[e];
};
H.prototype.readUInt16LE = function(e, t) {
  return t || St(e, 2, this.length), this[e] | this[e + 1] << 8;
};
H.prototype.readUInt16BE = function(e, t) {
  return t || St(e, 2, this.length), this[e] << 8 | this[e + 1];
};
H.prototype.readUInt32LE = function(e, t) {
  return t || St(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
};
H.prototype.readUInt32BE = function(e, t) {
  return t || St(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
};
H.prototype.readIntLE = function(e, t, s) {
  e = e | 0, t = t | 0, s || St(e, t, this.length);
  for (var i = this[e], n = 1, a = 0; ++a < t && (n *= 256); )
    i += this[e + a] * n;
  return n *= 128, i >= n && (i -= Math.pow(2, 8 * t)), i;
};
H.prototype.readIntBE = function(e, t, s) {
  e = e | 0, t = t | 0, s || St(e, t, this.length);
  for (var i = t, n = 1, a = this[e + --i]; i > 0 && (n *= 256); )
    a += this[e + --i] * n;
  return n *= 128, a >= n && (a -= Math.pow(2, 8 * t)), a;
};
H.prototype.readInt8 = function(e, t) {
  return t || St(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
};
H.prototype.readInt16LE = function(e, t) {
  t || St(e, 2, this.length);
  var s = this[e] | this[e + 1] << 8;
  return s & 32768 ? s | 4294901760 : s;
};
H.prototype.readInt16BE = function(e, t) {
  t || St(e, 2, this.length);
  var s = this[e + 1] | this[e] << 8;
  return s & 32768 ? s | 4294901760 : s;
};
H.prototype.readInt32LE = function(e, t) {
  return t || St(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
};
H.prototype.readInt32BE = function(e, t) {
  return t || St(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
};
H.prototype.readFloatLE = function(e, t) {
  return t || St(e, 4, this.length), Kc(this, e, !0, 23, 4);
};
H.prototype.readFloatBE = function(e, t) {
  return t || St(e, 4, this.length), Kc(this, e, !1, 23, 4);
};
H.prototype.readDoubleLE = function(e, t) {
  return t || St(e, 8, this.length), Kc(this, e, !0, 52, 8);
};
H.prototype.readDoubleBE = function(e, t) {
  return t || St(e, 8, this.length), Kc(this, e, !1, 52, 8);
};
function tr(r, e, t, s, i, n) {
  if (!ss(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (e > i || e < n) throw new RangeError('"value" argument is out of bounds');
  if (t + s > r.length) throw new RangeError("Index out of range");
}
H.prototype.writeUIntLE = function(e, t, s, i) {
  if (e = +e, t = t | 0, s = s | 0, !i) {
    var n = Math.pow(2, 8 * s) - 1;
    tr(this, e, t, s, n, 0);
  }
  var a = 1, o = 0;
  for (this[t] = e & 255; ++o < s && (a *= 256); )
    this[t + o] = e / a & 255;
  return t + s;
};
H.prototype.writeUIntBE = function(e, t, s, i) {
  if (e = +e, t = t | 0, s = s | 0, !i) {
    var n = Math.pow(2, 8 * s) - 1;
    tr(this, e, t, s, n, 0);
  }
  var a = s - 1, o = 1;
  for (this[t + a] = e & 255; --a >= 0 && (o *= 256); )
    this[t + a] = e / o & 255;
  return t + s;
};
H.prototype.writeUInt8 = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 1, 255, 0), H.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = e & 255, t + 1;
};
function Xc(r, e, t, s) {
  e < 0 && (e = 65535 + e + 1);
  for (var i = 0, n = Math.min(r.length - t, 2); i < n; ++i)
    r[t + i] = (e & 255 << 8 * (s ? i : 1 - i)) >>> (s ? i : 1 - i) * 8;
}
H.prototype.writeUInt16LE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 2, 65535, 0), H.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8) : Xc(this, e, t, !0), t + 2;
};
H.prototype.writeUInt16BE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 2, 65535, 0), H.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = e & 255) : Xc(this, e, t, !1), t + 2;
};
function Jc(r, e, t, s) {
  e < 0 && (e = 4294967295 + e + 1);
  for (var i = 0, n = Math.min(r.length - t, 4); i < n; ++i)
    r[t + i] = e >>> (s ? i : 3 - i) * 8 & 255;
}
H.prototype.writeUInt32LE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 4, 4294967295, 0), H.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255) : Jc(this, e, t, !0), t + 4;
};
H.prototype.writeUInt32BE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 4, 4294967295, 0), H.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255) : Jc(this, e, t, !1), t + 4;
};
H.prototype.writeIntLE = function(e, t, s, i) {
  if (e = +e, t = t | 0, !i) {
    var n = Math.pow(2, 8 * s - 1);
    tr(this, e, t, s, n - 1, -n);
  }
  var a = 0, o = 1, u = 0;
  for (this[t] = e & 255; ++a < s && (o *= 256); )
    e < 0 && u === 0 && this[t + a - 1] !== 0 && (u = 1), this[t + a] = (e / o >> 0) - u & 255;
  return t + s;
};
H.prototype.writeIntBE = function(e, t, s, i) {
  if (e = +e, t = t | 0, !i) {
    var n = Math.pow(2, 8 * s - 1);
    tr(this, e, t, s, n - 1, -n);
  }
  var a = s - 1, o = 1, u = 0;
  for (this[t + a] = e & 255; --a >= 0 && (o *= 256); )
    e < 0 && u === 0 && this[t + a + 1] !== 0 && (u = 1), this[t + a] = (e / o >> 0) - u & 255;
  return t + s;
};
H.prototype.writeInt8 = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 1, 127, -128), H.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1;
};
H.prototype.writeInt16LE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 2, 32767, -32768), H.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8) : Xc(this, e, t, !0), t + 2;
};
H.prototype.writeInt16BE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 2, 32767, -32768), H.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = e & 255) : Xc(this, e, t, !1), t + 2;
};
H.prototype.writeInt32LE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 4, 2147483647, -2147483648), H.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : Jc(this, e, t, !0), t + 4;
};
H.prototype.writeInt32BE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), H.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255) : Jc(this, e, t, !1), t + 4;
};
function U2(r, e, t, s, i, n) {
  if (t + s > r.length) throw new RangeError("Index out of range");
  if (t < 0) throw new RangeError("Index out of range");
}
function j2(r, e, t, s, i) {
  return i || U2(r, e, t, 4), D2(r, e, t, s, 23, 4), t + 4;
}
H.prototype.writeFloatLE = function(e, t, s) {
  return j2(this, e, t, !0, s);
};
H.prototype.writeFloatBE = function(e, t, s) {
  return j2(this, e, t, !1, s);
};
function q2(r, e, t, s, i) {
  return i || U2(r, e, t, 8), D2(r, e, t, s, 52, 8), t + 8;
}
H.prototype.writeDoubleLE = function(e, t, s) {
  return q2(this, e, t, !0, s);
};
H.prototype.writeDoubleBE = function(e, t, s) {
  return q2(this, e, t, !1, s);
};
H.prototype.copy = function(e, t, s, i) {
  if (s || (s = 0), !i && i !== 0 && (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < s && (i = s), i === s || e.length === 0 || this.length === 0) return 0;
  if (t < 0)
    throw new RangeError("targetStart out of bounds");
  if (s < 0 || s >= this.length) throw new RangeError("sourceStart out of bounds");
  if (i < 0) throw new RangeError("sourceEnd out of bounds");
  i > this.length && (i = this.length), e.length - t < i - s && (i = e.length - t + s);
  var n = i - s, a;
  if (this === e && s < t && t < i)
    for (a = n - 1; a >= 0; --a)
      e[a + t] = this[a + s];
  else if (n < 1e3 || !H.TYPED_ARRAY_SUPPORT)
    for (a = 0; a < n; ++a)
      e[a + t] = this[a + s];
  else
    Uint8Array.prototype.set.call(
      e,
      this.subarray(s, s + n),
      t
    );
  return n;
};
H.prototype.fill = function(e, t, s, i) {
  if (typeof e == "string") {
    if (typeof t == "string" ? (i = t, t = 0, s = this.length) : typeof s == "string" && (i = s, s = this.length), e.length === 1) {
      var n = e.charCodeAt(0);
      n < 256 && (e = n);
    }
    if (i !== void 0 && typeof i != "string")
      throw new TypeError("encoding must be a string");
    if (typeof i == "string" && !H.isEncoding(i))
      throw new TypeError("Unknown encoding: " + i);
  } else typeof e == "number" && (e = e & 255);
  if (t < 0 || this.length < t || this.length < s)
    throw new RangeError("Out of range index");
  if (s <= t)
    return this;
  t = t >>> 0, s = s === void 0 ? this.length : s >>> 0, e || (e = 0);
  var a;
  if (typeof e == "number")
    for (a = t; a < s; ++a)
      this[a] = e;
  else {
    var o = ss(e) ? e : kl(new H(e, i).toString()), u = o.length;
    for (a = 0; a < s - t; ++a)
      this[a + t] = o[a % u];
  }
  return this;
};
var p8 = /[^+\/0-9A-Za-z-_]/g;
function h8(r) {
  if (r = d8(r).replace(p8, ""), r.length < 2) return "";
  for (; r.length % 4 !== 0; )
    r = r + "=";
  return r;
}
function d8(r) {
  return r.trim ? r.trim() : r.replace(/^\s+|\s+$/g, "");
}
function m8(r) {
  return r < 16 ? "0" + r.toString(16) : r.toString(16);
}
function kl(r, e) {
  e = e || 1 / 0;
  for (var t, s = r.length, i = null, n = [], a = 0; a < s; ++a) {
    if (t = r.charCodeAt(a), t > 55295 && t < 57344) {
      if (!i) {
        if (t > 56319) {
          (e -= 3) > -1 && n.push(239, 191, 189);
          continue;
        } else if (a + 1 === s) {
          (e -= 3) > -1 && n.push(239, 191, 189);
          continue;
        }
        i = t;
        continue;
      }
      if (t < 56320) {
        (e -= 3) > -1 && n.push(239, 191, 189), i = t;
        continue;
      }
      t = (i - 55296 << 10 | t - 56320) + 65536;
    } else i && (e -= 3) > -1 && n.push(239, 191, 189);
    if (i = null, t < 128) {
      if ((e -= 1) < 0) break;
      n.push(t);
    } else if (t < 2048) {
      if ((e -= 2) < 0) break;
      n.push(
        t >> 6 | 192,
        t & 63 | 128
      );
    } else if (t < 65536) {
      if ((e -= 3) < 0) break;
      n.push(
        t >> 12 | 224,
        t >> 6 & 63 | 128,
        t & 63 | 128
      );
    } else if (t < 1114112) {
      if ((e -= 4) < 0) break;
      n.push(
        t >> 18 | 240,
        t >> 12 & 63 | 128,
        t >> 6 & 63 | 128,
        t & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return n;
}
function g8(r) {
  for (var e = [], t = 0; t < r.length; ++t)
    e.push(r.charCodeAt(t) & 255);
  return e;
}
function y8(r, e) {
  for (var t, s, i, n = [], a = 0; a < r.length && !((e -= 2) < 0); ++a)
    t = r.charCodeAt(a), s = t >> 8, i = t % 256, n.push(i), n.push(s);
  return n;
}
function H2(r) {
  return W4(h8(r));
}
function Yc(r, e, t, s) {
  for (var i = 0; i < s && !(i + t >= e.length || i >= r.length); ++i)
    e[i + t] = r[i];
  return i;
}
function b8(r) {
  return r !== r;
}
function v8(r) {
  return r != null && (!!r._isBuffer || W2(r) || E8(r));
}
function W2(r) {
  return !!r.constructor && typeof r.constructor.isBuffer == "function" && r.constructor.isBuffer(r);
}
function E8(r) {
  return typeof r.readFloatLE == "function" && typeof r.slice == "function" && W2(r.slice(0, 0));
}
var Dl;
typeof Object.create == "function" ? Dl = function(e, t) {
  e.super_ = t, e.prototype = Object.create(t.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  });
} : Dl = function(e, t) {
  e.super_ = t;
  var s = function() {
  };
  s.prototype = t.prototype, e.prototype = new s(), e.prototype.constructor = e;
};
var z2 = Object.getOwnPropertyDescriptors || function(e) {
  for (var t = Object.keys(e), s = {}, i = 0; i < t.length; i++)
    s[t[i]] = Object.getOwnPropertyDescriptor(e, t[i]);
  return s;
}, S8 = /%[sdj%]/g;
function Qc(r) {
  if (!hi(r)) {
    for (var e = [], t = 0; t < arguments.length; t++)
      e.push(Yr(arguments[t]));
    return e.join(" ");
  }
  for (var t = 1, s = arguments, i = s.length, n = String(r).replace(S8, function(o) {
    if (o === "%%") return "%";
    if (t >= i) return o;
    switch (o) {
      case "%s":
        return String(s[t++]);
      case "%d":
        return Number(s[t++]);
      case "%j":
        try {
          return JSON.stringify(s[t++]);
        } catch {
          return "[Circular]";
        }
      default:
        return o;
    }
  }), a = s[t]; t < i; a = s[++t])
    vs(a) || !Ds(a) ? n += " " + a : n += " " + Yr(a);
  return n;
}
function c0(r, e) {
  if (qr(li.process))
    return function() {
      return c0(r, e).apply(this, arguments);
    };
  if (Zt.noDeprecation === !0)
    return r;
  var t = !1;
  function s() {
    if (!t) {
      if (Zt.throwDeprecation)
        throw new Error(e);
      Zt.traceDeprecation ? console.trace(e) : console.error(e), t = !0;
    }
    return r.apply(this, arguments);
  }
  return s;
}
var du = {}, jf;
function G2(r) {
  if (qr(jf) && (jf = Zt.env.NODE_DEBUG || ""), r = r.toUpperCase(), !du[r])
    if (new RegExp("\\b" + r + "\\b", "i").test(jf)) {
      var e = 0;
      du[r] = function() {
        var t = Qc.apply(null, arguments);
        console.error("%s %d: %s", r, e, t);
      };
    } else
      du[r] = function() {
      };
  return du[r];
}
function Yr(r, e) {
  var t = {
    seen: [],
    stylize: x8
  };
  return arguments.length >= 3 && (t.depth = arguments[2]), arguments.length >= 4 && (t.colors = arguments[3]), Zc(e) ? t.showHidden = e : e && m0(t, e), qr(t.showHidden) && (t.showHidden = !1), qr(t.depth) && (t.depth = 2), qr(t.colors) && (t.colors = !1), qr(t.customInspect) && (t.customInspect = !0), t.colors && (t.stylize = _8), Ll(t, r, t.depth);
}
Yr.colors = {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
};
Yr.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  // "name": intentionally not styling
  regexp: "red"
};
function _8(r, e) {
  var t = Yr.styles[e];
  return t ? "\x1B[" + Yr.colors[t][0] + "m" + r + "\x1B[" + Yr.colors[t][1] + "m" : r;
}
function x8(r, e) {
  return r;
}
function w8(r) {
  var e = {};
  return r.forEach(function(t, s) {
    e[t] = !0;
  }), e;
}
function Ll(r, e, t) {
  if (r.customInspect && e && Ja(e.inspect) && // Filter out the util module, it's inspect function is special
  e.inspect !== Yr && // Also filter out any prototype objects using the circular check.
  !(e.constructor && e.constructor.prototype === e)) {
    var s = e.inspect(t, r);
    return hi(s) || (s = Ll(r, s, t)), s;
  }
  var i = T8(r, e);
  if (i)
    return i;
  var n = Object.keys(e), a = w8(n);
  if (r.showHidden && (n = Object.getOwnPropertyNames(e)), Xa(e) && (n.indexOf("message") >= 0 || n.indexOf("description") >= 0))
    return qf(e);
  if (n.length === 0) {
    if (Ja(e)) {
      var o = e.name ? ": " + e.name : "";
      return r.stylize("[Function" + o + "]", "special");
    }
    if (Ka(e))
      return r.stylize(RegExp.prototype.toString.call(e), "regexp");
    if (Ml(e))
      return r.stylize(Date.prototype.toString.call(e), "date");
    if (Xa(e))
      return qf(e);
  }
  var u = "", l = !1, c = ["{", "}"];
  if (f0(e) && (l = !0, c = ["[", "]"]), Ja(e)) {
    var f = e.name ? ": " + e.name : "";
    u = " [Function" + f + "]";
  }
  if (Ka(e) && (u = " " + RegExp.prototype.toString.call(e)), Ml(e) && (u = " " + Date.prototype.toUTCString.call(e)), Xa(e) && (u = " " + qf(e)), n.length === 0 && (!l || e.length == 0))
    return c[0] + u + c[1];
  if (t < 0)
    return Ka(e) ? r.stylize(RegExp.prototype.toString.call(e), "regexp") : r.stylize("[Object]", "special");
  r.seen.push(e);
  var p;
  return l ? p = P8(r, e, t, a, n) : p = n.map(function(h) {
    return Yp(r, e, t, a, h, l);
  }), r.seen.pop(), A8(p, u, c);
}
function T8(r, e) {
  if (qr(e))
    return r.stylize("undefined", "undefined");
  if (hi(e)) {
    var t = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return r.stylize(t, "string");
  }
  if (h0(e))
    return r.stylize("" + e, "number");
  if (Zc(e))
    return r.stylize("" + e, "boolean");
  if (vs(e))
    return r.stylize("null", "null");
}
function qf(r) {
  return "[" + Error.prototype.toString.call(r) + "]";
}
function P8(r, e, t, s, i) {
  for (var n = [], a = 0, o = e.length; a < o; ++a)
    Q2(e, String(a)) ? n.push(Yp(
      r,
      e,
      t,
      s,
      String(a),
      !0
    )) : n.push("");
  return i.forEach(function(u) {
    u.match(/^\d+$/) || n.push(Yp(
      r,
      e,
      t,
      s,
      u,
      !0
    ));
  }), n;
}
function Yp(r, e, t, s, i, n) {
  var a, o, u;
  if (u = Object.getOwnPropertyDescriptor(e, i) || { value: e[i] }, u.get ? u.set ? o = r.stylize("[Getter/Setter]", "special") : o = r.stylize("[Getter]", "special") : u.set && (o = r.stylize("[Setter]", "special")), Q2(s, i) || (a = "[" + i + "]"), o || (r.seen.indexOf(u.value) < 0 ? (vs(t) ? o = Ll(r, u.value, null) : o = Ll(r, u.value, t - 1), o.indexOf(`
`) > -1 && (n ? o = o.split(`
`).map(function(l) {
    return "  " + l;
  }).join(`
`).substr(2) : o = `
` + o.split(`
`).map(function(l) {
    return "   " + l;
  }).join(`
`))) : o = r.stylize("[Circular]", "special")), qr(a)) {
    if (n && i.match(/^\d+$/))
      return o;
    a = JSON.stringify("" + i), a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a = a.substr(1, a.length - 2), a = r.stylize(a, "name")) : (a = a.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a = r.stylize(a, "string"));
  }
  return a + ": " + o;
}
function A8(r, e, t) {
  var s = r.reduce(function(i, n) {
    return n.indexOf(`
`) >= 0, i + n.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  return s > 60 ? t[0] + (e === "" ? "" : e + `
 `) + " " + r.join(`,
  `) + " " + t[1] : t[0] + e + " " + r.join(", ") + " " + t[1];
}
function f0(r) {
  return Array.isArray(r);
}
function Zc(r) {
  return typeof r == "boolean";
}
function vs(r) {
  return r === null;
}
function p0(r) {
  return r == null;
}
function h0(r) {
  return typeof r == "number";
}
function hi(r) {
  return typeof r == "string";
}
function K2(r) {
  return typeof r == "symbol";
}
function qr(r) {
  return r === void 0;
}
function Ka(r) {
  return Ds(r) && d0(r) === "[object RegExp]";
}
function Ds(r) {
  return typeof r == "object" && r !== null;
}
function Ml(r) {
  return Ds(r) && d0(r) === "[object Date]";
}
function Xa(r) {
  return Ds(r) && (d0(r) === "[object Error]" || r instanceof Error);
}
function Ja(r) {
  return typeof r == "function";
}
function X2(r) {
  return r === null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || typeof r == "symbol" || // ES6 symbol
  typeof r > "u";
}
function J2(r) {
  return H.isBuffer(r);
}
function d0(r) {
  return Object.prototype.toString.call(r);
}
function Hf(r) {
  return r < 10 ? "0" + r.toString(10) : r.toString(10);
}
var C8 = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function N8() {
  var r = /* @__PURE__ */ new Date(), e = [
    Hf(r.getHours()),
    Hf(r.getMinutes()),
    Hf(r.getSeconds())
  ].join(":");
  return [r.getDate(), C8[r.getMonth()], e].join(" ");
}
function Y2() {
  console.log("%s - %s", N8(), Qc.apply(null, arguments));
}
function m0(r, e) {
  if (!e || !Ds(e)) return r;
  for (var t = Object.keys(e), s = t.length; s--; )
    r[t[s]] = e[t[s]];
  return r;
}
function Q2(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
var _i = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
function g0(r) {
  if (typeof r != "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (_i && r[_i]) {
    var e = r[_i];
    if (typeof e != "function")
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(e, _i, {
      value: e,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), e;
  }
  function e() {
    for (var t, s, i = new Promise(function(o, u) {
      t = o, s = u;
    }), n = [], a = 0; a < arguments.length; a++)
      n.push(arguments[a]);
    n.push(function(o, u) {
      o ? s(o) : t(u);
    });
    try {
      r.apply(this, n);
    } catch (o) {
      s(o);
    }
    return i;
  }
  return Object.setPrototypeOf(e, Object.getPrototypeOf(r)), _i && Object.defineProperty(e, _i, {
    value: e,
    enumerable: !1,
    writable: !1,
    configurable: !0
  }), Object.defineProperties(
    e,
    z2(r)
  );
}
g0.custom = _i;
function O8(r, e) {
  if (!r) {
    var t = new Error("Promise was rejected with a falsy value");
    t.reason = r, r = t;
  }
  return e(r);
}
function Z2(r) {
  if (typeof r != "function")
    throw new TypeError('The "original" argument must be of type Function');
  function e() {
    for (var t = [], s = 0; s < arguments.length; s++)
      t.push(arguments[s]);
    var i = t.pop();
    if (typeof i != "function")
      throw new TypeError("The last argument must be of type Function");
    var n = this, a = function() {
      return i.apply(n, arguments);
    };
    r.apply(this, t).then(
      function(o) {
        Zt.nextTick(a.bind(null, null, o));
      },
      function(o) {
        Zt.nextTick(O8.bind(null, o, a));
      }
    );
  }
  return Object.setPrototypeOf(e, Object.getPrototypeOf(r)), Object.defineProperties(e, z2(r)), e;
}
var I8 = {
  inherits: Dl,
  _extend: m0,
  log: Y2,
  isBuffer: J2,
  isPrimitive: X2,
  isFunction: Ja,
  isError: Xa,
  isDate: Ml,
  isObject: Ds,
  isRegExp: Ka,
  isUndefined: qr,
  isSymbol: K2,
  isString: hi,
  isNumber: h0,
  isNullOrUndefined: p0,
  isNull: vs,
  isBoolean: Zc,
  isArray: f0,
  inspect: Yr,
  deprecate: c0,
  format: Qc,
  debuglog: G2,
  promisify: g0,
  callbackify: Z2
}, k8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _extend: m0,
  callbackify: Z2,
  debuglog: G2,
  default: I8,
  deprecate: c0,
  format: Qc,
  inherits: Dl,
  inspect: Yr,
  isArray: f0,
  isBoolean: Zc,
  isBuffer: J2,
  isDate: Ml,
  isError: Xa,
  isFunction: Ja,
  isNull: vs,
  isNullOrUndefined: p0,
  isNumber: h0,
  isObject: Ds,
  isPrimitive: X2,
  isRegExp: Ka,
  isString: hi,
  isSymbol: K2,
  isUndefined: qr,
  log: Y2,
  promisify: g0
});
function D8(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
var e_ = Array.isArray || function(r) {
  return Object.prototype.toString.call(r) === "[object Array]";
};
function Wf(r) {
  switch (typeof r) {
    case "string":
      return r;
    case "boolean":
      return r ? "true" : "false";
    case "number":
      return isFinite(r) ? r : "";
    default:
      return "";
  }
}
function L8(r, e, t, s) {
  return e = e || "&", t = t || "=", r === null && (r = void 0), typeof r == "object" ? t1(M8(r), function(i) {
    var n = encodeURIComponent(Wf(i)) + t;
    return e_(r[i]) ? t1(r[i], function(a) {
      return n + encodeURIComponent(Wf(a));
    }).join(e) : n + encodeURIComponent(Wf(r[i]));
  }).join(e) : "";
}
function t1(r, e) {
  if (r.map) return r.map(e);
  for (var t = [], s = 0; s < r.length; s++)
    t.push(e(r[s], s));
  return t;
}
var M8 = Object.keys || function(r) {
  var e = [];
  for (var t in r)
    Object.prototype.hasOwnProperty.call(r, t) && e.push(t);
  return e;
};
function r1(r, e, t, s) {
  e = e || "&", t = t || "=";
  var i = {};
  if (typeof r != "string" || r.length === 0)
    return i;
  var n = /\+/g;
  r = r.split(e);
  var a = 1e3, o = r.length;
  o > a && (o = a);
  for (var u = 0; u < o; ++u) {
    var l = r[u].replace(n, "%20"), c = l.indexOf(t), f, p, h, m;
    c >= 0 ? (f = l.substr(0, c), p = l.substr(c + 1)) : (f = l, p = ""), h = decodeURIComponent(f), m = decodeURIComponent(p), D8(i, h) ? e_(i[h]) ? i[h].push(m) : i[h] = [i[h], m] : i[h] = m;
  }
  return i;
}
const t_ = li.URL, r_ = li.URLSearchParams;
var R8 = {
  parse: na,
  resolve: a_,
  resolveObject: o_,
  fileURLToPath: i_,
  format: n_,
  Url: lr,
  // WHATWG API
  URL: t_,
  URLSearchParams: r_
};
function lr() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var $8 = /^([a-z0-9.+-]+:)/i, F8 = /:[0-9]*$/, B8 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, V8 = ["<", ">", '"', "`", " ", "\r", `
`, "	"], U8 = ["{", "}", "|", "\\", "^", "`"].concat(V8), Qp = ["'"].concat(U8), s1 = ["%", "/", "?", ";", "#"].concat(Qp), i1 = ["/", "?", "#"], j8 = 255, n1 = /^[+a-z0-9A-Z_-]{0,63}$/, q8 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, H8 = {
  javascript: !0,
  "javascript:": !0
}, Zp = {
  javascript: !0,
  "javascript:": !0
}, xn = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function na(r, e, t) {
  if (r && Ds(r) && r instanceof lr) return r;
  var s = new lr();
  return s.parse(r, e, t), s;
}
lr.prototype.parse = function(r, e, t) {
  return s_(this, r, e, t);
};
function s_(r, e, t, s) {
  if (!hi(e))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
  var i = e.indexOf("?"), n = i !== -1 && i < e.indexOf("#") ? "?" : "#", a = e.split(n), o = /\\/g;
  a[0] = a[0].replace(o, "/"), e = a.join(n);
  var u = e;
  if (u = u.trim(), !s && e.split("#").length === 1) {
    var l = B8.exec(u);
    if (l)
      return r.path = u, r.href = u, r.pathname = l[1], l[2] ? (r.search = l[2], t ? r.query = r1(r.search.substr(1)) : r.query = r.search.substr(1)) : t && (r.search = "", r.query = {}), r;
  }
  var c = $8.exec(u);
  if (c) {
    c = c[0];
    var f = c.toLowerCase();
    r.protocol = f, u = u.substr(c.length);
  }
  if (s || c || u.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var p = u.substr(0, 2) === "//";
    p && !(c && Zp[c]) && (u = u.substr(2), r.slashes = !0);
  }
  var h, m, d, y;
  if (!Zp[c] && (p || c && !xn[c])) {
    var S = -1;
    for (h = 0; h < i1.length; h++)
      m = u.indexOf(i1[h]), m !== -1 && (S === -1 || m < S) && (S = m);
    var E, g;
    for (S === -1 ? g = u.lastIndexOf("@") : g = u.lastIndexOf("@", S), g !== -1 && (E = u.slice(0, g), u = u.slice(g + 1), r.auth = decodeURIComponent(E)), S = -1, h = 0; h < s1.length; h++)
      m = u.indexOf(s1[h]), m !== -1 && (S === -1 || m < S) && (S = m);
    S === -1 && (S = u.length), r.host = u.slice(0, S), u = u.slice(S), u_(r), r.hostname = r.hostname || "";
    var b = r.hostname[0] === "[" && r.hostname[r.hostname.length - 1] === "]";
    if (!b) {
      var v = r.hostname.split(/\./);
      for (h = 0, d = v.length; h < d; h++) {
        var A = v[h];
        if (A && !A.match(n1)) {
          for (var C = "", x = 0, _ = A.length; x < _; x++)
            A.charCodeAt(x) > 127 ? C += "x" : C += A[x];
          if (!C.match(n1)) {
            var T = v.slice(0, h), P = v.slice(h + 1), I = A.match(q8);
            I && (T.push(I[1]), P.unshift(I[2])), P.length && (u = "/" + P.join(".") + u), r.hostname = T.join(".");
            break;
          }
        }
      }
    }
    r.hostname.length > j8 ? r.hostname = "" : r.hostname = r.hostname.toLowerCase(), b || (r.hostname = q4(r.hostname)), y = r.port ? ":" + r.port : "";
    var $ = r.hostname || "";
    r.host = $ + y, r.href += r.host, b && (r.hostname = r.hostname.substr(1, r.hostname.length - 2), u[0] !== "/" && (u = "/" + u));
  }
  if (!H8[f])
    for (h = 0, d = Qp.length; h < d; h++) {
      var Y = Qp[h];
      if (u.indexOf(Y) !== -1) {
        var W = encodeURIComponent(Y);
        W === Y && (W = escape(Y)), u = u.split(Y).join(W);
      }
    }
  var F = u.indexOf("#");
  F !== -1 && (r.hash = u.substr(F), u = u.slice(0, F));
  var K = u.indexOf("?");
  if (K !== -1 ? (r.search = u.substr(K), r.query = u.substr(K + 1), t && (r.query = r1(r.query)), u = u.slice(0, K)) : t && (r.search = "", r.query = {}), u && (r.pathname = u), xn[f] && r.hostname && !r.pathname && (r.pathname = "/"), r.pathname || r.search) {
    y = r.pathname || "";
    var Z = r.search || "";
    r.path = y + Z;
  }
  return r.href = y0(r), r;
}
function i_(r) {
  if (typeof r == "string")
    r = new lr().parse(r);
  else if (!(r instanceof lr))
    throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof r + String(r));
  if (r.protocol !== "file:")
    throw new TypeError("The URL must be of scheme file");
  return W8(r);
}
function W8(r) {
  const e = r.pathname;
  for (let t = 0; t < e.length; t++)
    if (e[t] === "%") {
      const s = e.codePointAt(t + 2) | 32;
      if (e[t + 1] === "2" && s === 102)
        throw new TypeError(
          "must not include encoded / characters"
        );
    }
  return decodeURIComponent(e);
}
function n_(r) {
  return hi(r) && (r = s_({}, r)), y0(r);
}
function y0(r) {
  var e = r.auth || "";
  e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
  var t = r.protocol || "", s = r.pathname || "", i = r.hash || "", n = !1, a = "";
  r.host ? n = e + r.host : r.hostname && (n = e + (r.hostname.indexOf(":") === -1 ? r.hostname : "[" + this.hostname + "]"), r.port && (n += ":" + r.port)), r.query && Ds(r.query) && Object.keys(r.query).length && (a = L8(r.query));
  var o = r.search || a && "?" + a || "";
  return t && t.substr(-1) !== ":" && (t += ":"), r.slashes || (!t || xn[t]) && n !== !1 ? (n = "//" + (n || ""), s && s.charAt(0) !== "/" && (s = "/" + s)) : n || (n = ""), i && i.charAt(0) !== "#" && (i = "#" + i), o && o.charAt(0) !== "?" && (o = "?" + o), s = s.replace(/[?#]/g, function(u) {
    return encodeURIComponent(u);
  }), o = o.replace("#", "%23"), t + n + s + o + i;
}
lr.prototype.format = function() {
  return y0(this);
};
function a_(r, e) {
  return na(r, !1, !0).resolve(e);
}
lr.prototype.resolve = function(r) {
  return this.resolveObject(na(r, !1, !0)).format();
};
function o_(r, e) {
  return r ? na(r, !1, !0).resolveObject(e) : e;
}
lr.prototype.resolveObject = function(r) {
  if (hi(r)) {
    var e = new lr();
    e.parse(r, !1, !0), r = e;
  }
  for (var t = new lr(), s = Object.keys(this), i = 0; i < s.length; i++) {
    var n = s[i];
    t[n] = this[n];
  }
  if (t.hash = r.hash, r.href === "")
    return t.href = t.format(), t;
  if (r.slashes && !r.protocol) {
    for (var a = Object.keys(r), o = 0; o < a.length; o++) {
      var u = a[o];
      u !== "protocol" && (t[u] = r[u]);
    }
    return xn[t.protocol] && t.hostname && !t.pathname && (t.path = t.pathname = "/"), t.href = t.format(), t;
  }
  var l;
  if (r.protocol && r.protocol !== t.protocol) {
    if (!xn[r.protocol]) {
      for (var c = Object.keys(r), f = 0; f < c.length; f++) {
        var p = c[f];
        t[p] = r[p];
      }
      return t.href = t.format(), t;
    }
    if (t.protocol = r.protocol, !r.host && !Zp[r.protocol]) {
      for (l = (r.pathname || "").split("/"); l.length && !(r.host = l.shift()); ) ;
      r.host || (r.host = ""), r.hostname || (r.hostname = ""), l[0] !== "" && l.unshift(""), l.length < 2 && l.unshift(""), t.pathname = l.join("/");
    } else
      t.pathname = r.pathname;
    if (t.search = r.search, t.query = r.query, t.host = r.host || "", t.auth = r.auth, t.hostname = r.hostname || r.host, t.port = r.port, t.pathname || t.search) {
      var h = t.pathname || "", m = t.search || "";
      t.path = h + m;
    }
    return t.slashes = t.slashes || r.slashes, t.href = t.format(), t;
  }
  var d = t.pathname && t.pathname.charAt(0) === "/", y = r.host || r.pathname && r.pathname.charAt(0) === "/", S = y || d || t.host && r.pathname, E = S, g = t.pathname && t.pathname.split("/") || [], b = t.protocol && !xn[t.protocol];
  l = r.pathname && r.pathname.split("/") || [], b && (t.hostname = "", t.port = null, t.host && (g[0] === "" ? g[0] = t.host : g.unshift(t.host)), t.host = "", r.protocol && (r.hostname = null, r.port = null, r.host && (l[0] === "" ? l[0] = r.host : l.unshift(r.host)), r.host = null), S = S && (l[0] === "" || g[0] === ""));
  var v;
  if (y)
    t.host = r.host || r.host === "" ? r.host : t.host, t.hostname = r.hostname || r.hostname === "" ? r.hostname : t.hostname, t.search = r.search, t.query = r.query, g = l;
  else if (l.length)
    g || (g = []), g.pop(), g = g.concat(l), t.search = r.search, t.query = r.query;
  else if (!p0(r.search))
    return b && (t.hostname = t.host = g.shift(), v = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1, v && (t.auth = v.shift(), t.host = t.hostname = v.shift())), t.search = r.search, t.query = r.query, (!vs(t.pathname) || !vs(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.href = t.format(), t;
  if (!g.length)
    return t.pathname = null, t.search ? t.path = "/" + t.search : t.path = null, t.href = t.format(), t;
  for (var A = g.slice(-1)[0], C = (t.host || r.host || g.length > 1) && (A === "." || A === "..") || A === "", x = 0, _ = g.length; _ >= 0; _--)
    A = g[_], A === "." ? g.splice(_, 1) : A === ".." ? (g.splice(_, 1), x++) : x && (g.splice(_, 1), x--);
  if (!S && !E)
    for (; x--; x)
      g.unshift("..");
  S && g[0] !== "" && (!g[0] || g[0].charAt(0) !== "/") && g.unshift(""), C && g.join("/").substr(-1) !== "/" && g.push("");
  var T = g[0] === "" || g[0] && g[0].charAt(0) === "/";
  return b && (t.hostname = t.host = T ? "" : g.length ? g.shift() : "", v = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1, v && (t.auth = v.shift(), t.host = t.hostname = v.shift())), S = S || t.host && g.length, S && !T && g.unshift(""), g.length ? t.pathname = g.join("/") : (t.pathname = null, t.path = null), (!vs(t.pathname) || !vs(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.auth = r.auth || t.auth, t.slashes = t.slashes || r.slashes, t.href = t.format(), t;
};
lr.prototype.parseHost = function() {
  return u_(this);
};
function u_(r) {
  var e = r.host, t = F8.exec(e);
  t && (t = t[0], t !== ":" && (r.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (r.hostname = e);
}
var z8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  URL: t_,
  URLSearchParams: r_,
  Url: lr,
  default: R8,
  fileURLToPath: i_,
  format: n_,
  parse: na,
  resolve: a_,
  resolveObject: o_
});
function l_(r) {
  const e = r.charAt(0);
  return e === "." || e === "~" || e === "@";
}
const G8 = /^(https?:)?\/\//;
function c_(r) {
  return G8.test(r);
}
const K8 = /^\s*data:/i;
function eh(r) {
  return K8.test(r);
}
function th(r) {
  if (r.charAt(0) === "~") {
    const t = r.charAt(1);
    r = r.slice(t === "/" ? 2 : 1);
  }
  return X8(r);
}
function X8(r) {
  return na(Ie(r) ? r : "", !1, !0);
}
var J8 = Object.defineProperty, Y8 = Object.defineProperties, Q8 = Object.getOwnPropertyDescriptors, a1 = Object.getOwnPropertySymbols, Z8 = Object.prototype.hasOwnProperty, ek = Object.prototype.propertyIsEnumerable, o1 = (r, e, t) => e in r ? J8(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, zf = (r, e) => {
  for (var t in e || (e = {}))
    Z8.call(e, t) && o1(r, t, e[t]);
  if (a1)
    for (var t of a1(e))
      ek.call(e, t) && o1(r, t, e[t]);
  return r;
}, tk = (r, e) => Y8(r, Q8(e));
const bo = {
  base: null,
  includeAbsolute: !1,
  tags: {
    video: ["src", "poster"],
    source: ["src"],
    img: ["src"],
    image: ["xlink:href", "href"],
    use: ["xlink:href", "href"]
  }
}, rk = (r) => Object.keys(r).some((e) => er(r[e])) ? tk(zf({}, bo), {
  tags: r
}) : zf(zf({}, bo), r), sk = (r) => (e, t) => f_(e, t, r), f_ = (r, e, t = bo) => {
  if (r.type === 1) {
    if (!r.props.length)
      return;
    const s = t.tags || bo.tags, i = s[r.tag], n = s["*"];
    if (!i && !n)
      return;
    const a = (i || []).concat(n || []);
    r.props.forEach((o, u) => {
      if (o.type !== 6 || !a.includes(o.name) || !o.value || c_(o.value.content) || eh(o.value.content) || o.value.content[0] === "#" || !t.includeAbsolute && !l_(o.value.content))
        return;
      const l = th(o.value.content);
      if (t.base && o.value.content[0] === ".") {
        const f = th(t.base), p = f.protocol || "", h = f.host ? p + "//" + f.host : "", m = f.path || "/";
        o.value.content = h + (As.posix || As).join(m, l.path + (l.hash || ""));
        return;
      }
      const c = ik(l.path, l.hash, o.loc, e);
      r.props[u] = {
        type: 7,
        name: "bind",
        arg: Q(o.name, !0, o.loc),
        exp: c,
        modifiers: [],
        loc: o.loc
      };
    });
  }
};
function ik(r, e, t, s) {
  if (r) {
    let i, n;
    const a = s.imports.findIndex((c) => c.path === r);
    if (a > -1 ? (i = `_imports_${a}`, n = s.imports[a].exp) : (i = `_imports_${s.imports.length}`, n = Q(
      i,
      !1,
      t,
      3
    ), s.imports.push({
      exp: n,
      path: decodeURIComponent(r)
    })), !e)
      return n;
    const o = `${i} + '${e}'`, u = Q(
      o,
      !1,
      t,
      3
    );
    if (!s.hoistStatic)
      return u;
    const l = s.hoists.findIndex((c) => c && c.type === 4 && !c.isStatic && c.content === o);
    return l > -1 ? Q(
      `_hoisted_${l + 1}`,
      !1,
      t,
      3
    ) : s.hoist(u);
  } else
    return Q("''", !1, t, 3);
}
const nk = ["img", "source"], ak = /( |\\t|\\n|\\f|\\r)+/g, ok = (r) => (e, t) => p_(e, t, r), p_ = (r, e, t = bo) => {
  r.type === 1 && nk.includes(r.tag) && r.props.length && r.props.forEach((s, i) => {
    if (s.name === "srcset" && s.type === 6) {
      if (!s.value) return;
      const n = s.value.content;
      if (!n) return;
      const a = n.split(",").map((c) => {
        const [f, p] = c.replace(ak, " ").trim().split(" ", 2);
        return { url: f, descriptor: p };
      });
      for (let c = 0; c < a.length; c++) {
        const { url: f } = a[c];
        eh(f) && (a[c + 1].url = f + "," + a[c + 1].url, a.splice(c, 1));
      }
      const o = (c) => !c_(c) && !eh(c) && (t.includeAbsolute || l_(c));
      if (!a.some(({ url: c }) => o(c)))
        return;
      if (t.base) {
        const c = t.base, f = [];
        let p = !1;
        if (a.forEach((h) => {
          let { url: m, descriptor: d } = h;
          d = d ? ` ${d}` : "", m[0] === "." ? (h.url = (As.posix || As).join(c, m), f.push(h.url + d)) : o(m) ? p = !0 : f.push(m + d);
        }), !p) {
          s.value.content = f.join(", ");
          return;
        }
      }
      const u = yt([], s.loc);
      a.forEach(({ url: c, descriptor: f }, p) => {
        if (o(c)) {
          const { path: m } = th(c);
          let d;
          if (m) {
            const y = e.imports.findIndex(
              (S) => S.path === m
            );
            y > -1 ? d = Q(
              `_imports_${y}`,
              !1,
              s.loc,
              3
            ) : (d = Q(
              `_imports_${e.imports.length}`,
              !1,
              s.loc,
              3
            ), e.imports.push({ exp: d, path: m })), u.children.push(d);
          }
        } else {
          const m = Q(
            `"${c}"`,
            !1,
            s.loc,
            3
          );
          u.children.push(m);
        }
        const h = a.length - 1 > p;
        f && h ? u.children.push(` + ' ${f}, ' + `) : f ? u.children.push(` + ' ${f}'`) : h && u.children.push(" + ', ' + ");
      });
      let l = u;
      e.hoistStatic && (l = e.hoist(u), l.constType = 3), r.props[i] = {
        type: 7,
        name: "bind",
        arg: Q("srcset", !0, s.loc),
        exp: l,
        modifiers: [],
        loc: s.loc
      };
    }
  });
}, Rl = Symbol("ssrInterpolate"), h_ = Symbol("ssrRenderVNode"), d_ = Symbol("ssrRenderComponent"), m_ = Symbol("ssrRenderSlot"), g_ = Symbol("ssrRenderSlotInner"), y_ = Symbol("ssrRenderClass"), b_ = Symbol("ssrRenderStyle"), b0 = Symbol("ssrRenderAttrs"), v_ = Symbol("ssrRenderAttr"), E_ = Symbol("ssrRenderDynamicAttr"), S_ = Symbol("ssrRenderList"), v0 = Symbol("ssrIncludeBooleanAttr"), zu = Symbol("ssrLooseEqual"), rh = Symbol("ssrLooseContain"), __ = Symbol("ssrRenderDynamicModel"), x_ = Symbol("ssrGetDynamicModelProps"), w_ = Symbol("ssrRenderTeleport"), T_ = Symbol("ssrRenderSuspense"), P_ = Symbol("ssrGetDirectiveProps"), sh = {
  [Rl]: "ssrInterpolate",
  [h_]: "ssrRenderVNode",
  [d_]: "ssrRenderComponent",
  [m_]: "ssrRenderSlot",
  [g_]: "ssrRenderSlotInner",
  [y_]: "ssrRenderClass",
  [b_]: "ssrRenderStyle",
  [b0]: "ssrRenderAttrs",
  [v_]: "ssrRenderAttr",
  [E_]: "ssrRenderDynamicAttr",
  [S_]: "ssrRenderList",
  [v0]: "ssrIncludeBooleanAttr",
  [zu]: "ssrLooseEqual",
  [rh]: "ssrLooseContain",
  [__]: "ssrRenderDynamicModel",
  [x_]: "ssrGetDynamicModelProps",
  [w_]: "ssrRenderTeleport",
  [T_]: "ssrRenderSuspense",
  [P_]: "ssrGetDirectiveProps"
};
Qd(sh);
const uk = Wo(
  /^(if|else|else-if)$/,
  Dm
);
function lk(r, e, t = !1, s = !1) {
  const [i] = r.branches, n = yl(
    i.condition,
    u1(i, e, t)
  );
  e.pushStatement(n);
  let a = n;
  for (let o = 1; o < r.branches.length; o++) {
    const u = r.branches[o], l = u1(
      u,
      e,
      t
    );
    u.condition ? a = a.alternate = yl(
      u.condition,
      l
    ) : a.alternate = l;
  }
  !a.alternate && !s && (a.alternate = Bo([
    ge("_push", ["`<!---->`"])
  ]));
}
function u1(r, e, t = !1) {
  const { children: s } = r, i = !t && (s.length !== 1 || s[0].type !== 1) && // optimize away nested fragments when the only child is a ForNode
  !(s.length === 1 && s[0].type === 11);
  return aa(r, e, i);
}
const ck = Wo(
  "for",
  Mm
);
function fk(r, e, t = !1) {
  const s = !t && (r.children.length !== 1 || r.children[0].type !== 1), i = fr(
    go(r.parseResult)
  );
  i.body = aa(
    r,
    e,
    s
  ), t || e.pushStringPart("<!--[-->"), e.pushStatement(
    ge(e.helper(S_), [
      r.source,
      i
    ])
  ), t || e.pushStringPart("<!--]-->");
}
const pk = (r, e) => {
  if (Bn(r)) {
    const { slotName: t, slotProps: s } = Vm(r, e), i = [
      "_ctx.$slots",
      t,
      s || "{}",
      // fallback content placeholder. will be replaced in the process phase
      "null",
      "_push",
      "_parent"
    ];
    e.scopeId && e.slotted !== !1 && i.push(`"${e.scopeId}-s"`);
    let n = m_, a = e.parent;
    if (a) {
      const o = a.children;
      a.type === 10 && (a = e.grandParent);
      let u;
      a.type === 1 && a.tagType === 1 && ((u = Hc(a, e, !0)) === nn || u === ia) && o.filter((l) => l.type === 1).length === 1 && (n = g_, e.scopeId && e.slotted !== !1 || i.push("null"), i.push("true"));
    }
    r.ssrCodegenNode = ge(e.helper(n), i);
  }
};
function hk(r, e) {
  const t = r.ssrCodegenNode;
  if (r.children.length) {
    const s = fr([]);
    s.body = aa(r, e), t.arguments[3] = s;
  }
  if (e.withSlotScopeId) {
    const s = t.arguments[6];
    t.arguments[6] = s ? `${s} + _scopeId` : "_scopeId";
  }
  e.pushStatement(r.ssrCodegenNode);
}
function vo(r, e) {
  return Me(r, e, dk);
}
const dk = {
  65: "Unsafe attribute name for SSR.",
  66: "Missing the 'to' prop on teleport element.",
  67: "Invalid AST node during SSR transform."
};
function mk(r, e) {
  const t = Qt(r, "to");
  if (!t) {
    e.onError(
      vo(66, r.loc)
    );
    return;
  }
  let s;
  if (t.type === 6 ? s = t.value && Q(t.value.content, !0) : s = t.exp, !s) {
    e.onError(
      vo(
        66,
        t.loc
      )
    );
    return;
  }
  const i = Qt(
    r,
    "disabled",
    !1,
    !0
    /* allow empty */
  ), n = i ? i.type === 6 ? "true" : i.exp || "false" : "false", a = fr(
    ["_push"],
    void 0,
    // Body is added later
    !0,
    // newline
    !1,
    // isSlot
    r.loc
  );
  a.body = aa(r, e), e.pushStatement(
    ge(e.helper(w_), [
      "_push",
      a,
      s,
      n,
      "_parent"
    ])
  );
}
const A_ = /* @__PURE__ */ new WeakMap();
function gk(r, e) {
  return () => {
    if (r.children.length) {
      const t = {
        slotsExp: null,
        // to be immediately set
        wipSlots: []
      };
      A_.set(r, t), t.slotsExp = yo(
        r,
        e,
        (s, i, n, a) => {
          const o = fr(
            [],
            void 0,
            // no return, assign body later
            !0,
            // newline
            !1,
            // suspense slots are not treated as normal slots
            a
          );
          return t.wipSlots.push({
            fn: o,
            children: n
          }), o;
        }
      ).slots;
    }
  };
}
function yk(r, e) {
  const t = A_.get(r);
  if (!t)
    return;
  const { slotsExp: s, wipSlots: i } = t;
  for (let n = 0; n < i.length; n++) {
    const a = i[n];
    a.fn.body = aa(a, e);
  }
  e.pushStatement(
    ge(e.helper(T_), [
      "_push",
      s
    ])
  );
}
const ka = /* @__PURE__ */ new WeakMap(), bk = (r, e) => {
  if (!(r.type !== 1 || r.tagType !== 0))
    return function() {
      const s = [`<${r.tag}`], i = r.tag === "textarea" || r.tag.indexOf("-") > 0, n = $c(r), a = r.props.some(
        (f) => f.type === 7 && !Wd(f.name)
      ), o = n || a;
      if (o) {
        const { props: f, directives: p } = sa(
          r,
          e,
          r.props,
          !1,
          !1,
          !0
        );
        if (f || p.length) {
          const h = E0(f, p, e), m = ge(
            e.helper(b0),
            [h]
          );
          if (r.tag === "textarea") {
            const d = r.children[0];
            if (!d || d.type !== 5) {
              const y = `_temp${e.temps++}`;
              m.arguments = [
                Du(
                  Q(y, !1),
                  h
                )
              ], ka.set(
                r,
                ge(e.helper(Rl), [
                  Nr(
                    Q(`"value" in ${y}`, !1),
                    Q(`${y}.value`, !1),
                    Q(
                      d ? d.content : "",
                      !0
                    ),
                    !1
                  )
                ])
              );
            }
          } else if (r.tag === "input") {
            const d = _k(r);
            if (d) {
              const y = `_temp${e.temps++}`, S = Q(y, !1);
              m.arguments = [
                KE([
                  Du(S, h),
                  ge(e.helper(Gi), [
                    S,
                    ge(
                      e.helper(x_),
                      [
                        S,
                        // existing props
                        d.exp
                        // model
                      ]
                    )
                  ])
                ])
              ];
            }
          } else if (p.length && !r.children.length) {
            const d = `_temp${e.temps++}`;
            m.arguments = [
              Du(
                Q(d, !1),
                h
              )
            ], ka.set(
              r,
              Nr(
                Q(`"textContent" in ${d}`, !1),
                ge(e.helper(Rl), [
                  Q(`${d}.textContent`, !1)
                ]),
                Q(`${d}.innerHTML ?? ''`, !1),
                !1
              )
            );
          }
          i && m.arguments.push(`"${r.tag}"`), s.push(m);
        }
      }
      let u, l, c;
      for (let f = 0; f < r.props.length; f++) {
        const p = r.props[f];
        if (!(r.tag === "input" && vk(p)))
          if (p.type === 7) {
            if (p.name === "html" && p.exp)
              ka.set(
                r,
                yt(["(", p.exp, ") ?? ''"])
              );
            else if (p.name === "text" && p.exp)
              r.children = [gl(p.exp, p.loc)];
            else if (p.name === "slot")
              e.onError(
                Me(40, p.loc)
              );
            else if (Ek(r, p) && p.exp)
              o || (r.children = [gl(p.exp, p.loc)]);
            else if (!o && p.name !== "on") {
              const h = e.directiveTransforms[p.name];
              if (h) {
                const { props: m, ssrTagParts: d } = h(
                  p,
                  r,
                  e
                );
                d && s.push(...d);
                for (let y = 0; y < m.length; y++) {
                  const { key: S, value: E } = m[y];
                  if (Pt(S)) {
                    let g = S.content;
                    if (g === "key" || g === "ref")
                      continue;
                    g === "class" ? s.push(
                      ' class="',
                      u = ge(
                        e.helper(y_),
                        [E]
                      ),
                      '"'
                    ) : g === "style" ? c ? l1(c, E) : s.push(
                      ' style="',
                      c = ge(
                        e.helper(b_),
                        [E]
                      ),
                      '"'
                    ) : (g = r.tag.indexOf("-") > 0 ? g : MC[g] || g.toLowerCase(), jE(g) ? s.push(
                      Nr(
                        ge(
                          e.helper(v0),
                          [E]
                        ),
                        Q(" " + g, !0),
                        Q("", !0),
                        !1
                      )
                    ) : LC(g) ? s.push(
                      ge(e.helper(v_), [
                        S,
                        E
                      ])
                    ) : e.onError(
                      vo(
                        65,
                        S.loc
                      )
                    ));
                  } else {
                    const g = [S, E];
                    i && g.push(`"${r.tag}"`), s.push(
                      ge(
                        e.helper(E_),
                        g
                      )
                    );
                  }
                }
              }
            }
          } else {
            const h = p.name;
            if (r.tag === "textarea" && h === "value" && p.value)
              ka.set(r, Ur(p.value.content));
            else if (!o) {
              if (h === "key" || h === "ref")
                continue;
              h === "class" && p.value && (l = JSON.stringify(p.value.content)), s.push(
                ` ${p.name}` + (p.value ? `="${Ur(p.value.content)}"` : "")
              );
            }
          }
      }
      u && l && (l1(u, l), Sk(s, "class")), e.scopeId && s.push(` ${e.scopeId}`), r.ssrCodegenNode = Zd(s);
    };
};
function E0(r, e, t) {
  let s = [];
  if (r && (r.type === 14 ? s = r.arguments : s.push(r)), e.length)
    for (const i of e)
      s.push(
        ge(t.helper(P_), [
          "_ctx",
          ...Bm(i, t).elements
        ])
      );
  return s.length > 1 ? ge(t.helper(Gi), s) : s[0];
}
function vk(r) {
  return r.type === 7 ? r.name === "bind" && r.arg && Pt(r.arg) && (r.arg.content === "true-value" || r.arg.content === "false-value") : r.name === "true-value" || r.name === "false-value";
}
function Ek(r, e) {
  return !!(r.tag === "textarea" && e.name === "bind" && jr(e.arg, "value"));
}
function l1(r, e) {
  const t = r.arguments[0];
  t.type === 17 ? t.elements.push(e) : r.arguments[0] = sn([t, e]);
}
function Sk(r, e) {
  const t = new RegExp(`^ ${e}=".+"$`), s = r.findIndex((i) => typeof i == "string" && t.test(i));
  s > -1 && r.splice(s, 1);
}
function _k(r) {
  return r.props.find(
    (e) => e.type === 7 && e.name === "model" && e.exp
  );
}
function xk(r, e) {
  const t = e.options.isVoidTag || ku, s = r.ssrCodegenNode.elements;
  for (let n = 0; n < s.length; n++)
    e.pushStringPart(s[n]);
  e.withSlotScopeId && e.pushStringPart(Q("_scopeId", !1)), e.pushStringPart(">");
  const i = ka.get(r);
  i ? e.pushStringPart(i) : r.children.length && xs(r, e), t(r.tag) || e.pushStringPart(`</${r.tag}>`);
}
const C_ = /* @__PURE__ */ new WeakMap();
function wk(r, e) {
  return () => {
    const t = Qt(r, "tag");
    if (t) {
      const s = r.props.filter((o) => o !== t), { props: i, directives: n } = sa(
        r,
        e,
        s,
        !0,
        !1,
        !0
      );
      let a = null;
      (i || n.length) && (a = ge(e.helper(b0), [
        E0(i, n, e)
      ])), C_.set(r, {
        tag: t,
        propsExp: a,
        scopeId: e.scopeId || null
      });
    }
  };
}
function Tk(r, e) {
  const t = C_.get(r);
  if (t) {
    const { tag: s, propsExp: i, scopeId: n } = t;
    s.type === 7 ? (e.pushStringPart("<"), e.pushStringPart(s.exp), i && e.pushStringPart(i), n && e.pushStringPart(` ${n}`), e.pushStringPart(">"), xs(
      r,
      e,
      !1,
      /**
       * TransitionGroup has the special runtime behavior of flattening and
       * concatenating all children into a single fragment (in order for them to
       * be patched using the same key map) so we need to account for that here
       * by disabling nested fragment wrappers from being generated.
       */
      !0,
      /**
       * TransitionGroup filters out comment children at runtime and thus
       * doesn't expect comments to be present during hydration. We need to
       * account for that by disabling the empty comment that is otherwise
       * rendered for a falsy v-if that has no v-else specified. (#6715)
       */
      !0
    ), e.pushStringPart("</"), e.pushStringPart(s.exp), e.pushStringPart(">")) : (e.pushStringPart(`<${s.value.content}`), i && e.pushStringPart(i), n && e.pushStringPart(` ${n}`), e.pushStringPart(">"), xs(r, e, !1, !0, !0), e.pushStringPart(`</${s.value.content}>`));
  } else
    xs(r, e, !0, !0, !0);
}
const N_ = /* @__PURE__ */ new WeakMap();
function Pk(r, e) {
  return () => {
    const t = Qt(r, "appear", !1, !0);
    N_.set(r, !!t);
  };
}
function Ak(r, e) {
  r.children = r.children.filter((s) => s.type !== 3), N_.get(r) ? (e.pushStringPart("<template>"), xs(r, e, !1, !0), e.pushStringPart("</template>")) : xs(r, e, !1, !0);
}
var Ck = Object.defineProperty, Nk = Object.defineProperties, Ok = Object.getOwnPropertyDescriptors, c1 = Object.getOwnPropertySymbols, Ik = Object.prototype.hasOwnProperty, kk = Object.prototype.propertyIsEnumerable, f1 = (r, e, t) => e in r ? Ck(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Vi = (r, e) => {
  for (var t in e || (e = {}))
    Ik.call(e, t) && f1(r, t, e[t]);
  if (c1)
    for (var t of c1(e))
      kk.call(e, t) && f1(r, t, e[t]);
  return r;
}, Dk = (r, e) => Nk(r, Ok(e));
const O_ = /* @__PURE__ */ new WeakMap(), I_ = Symbol(), k_ = /* @__PURE__ */ new WeakMap(), Lk = (r, e) => {
  if (r.type !== 1 || r.tagType !== 1)
    return;
  const t = Hc(
    r,
    e,
    !0
    /* ssr */
  ), s = pi(t) && t.callee === $o;
  if (k_.set(r, t), fi(t))
    return t === Xn ? gk(r, e) : t === ia ? wk(r, e) : t === nn ? Pk(r) : void 0;
  const i = [], n = ih(r);
  return function() {
    n.children.length && yo(n, e, (f, p, h) => (i.push(
      Vk(f, p, h, e)
    ), fr(void 0)));
    let o = "null";
    if (r.props.length) {
      const { props: f, directives: p } = sa(
        r,
        e,
        void 0,
        !0,
        s
      );
      (f || p.length) && (o = E0(f, p, e));
    }
    const u = [];
    O_.set(r, u);
    const l = (f, p, h, m) => {
      const d = f && qc(f) || "_", y = fr(
        [d, "_push", "_parent", "_scopeId"],
        void 0,
        // no return, assign body later
        !0,
        // newline
        !0,
        // isSlot
        m
      );
      return u.push({
        type: I_,
        fn: y,
        children: h,
        // also collect the corresponding vnode branch built earlier
        vnodeBranch: i[u.length]
      }), y;
    }, c = r.children.length ? yo(r, e, l).slots : "null";
    typeof t != "string" ? r.ssrCodegenNode = ge(
      e.helper(h_),
      [
        "_push",
        ge(e.helper(Ro), [
          t,
          o,
          c
        ]),
        "_parent"
      ]
    ) : r.ssrCodegenNode = ge(
      e.helper(d_),
      [t, o, c, "_parent"]
    );
  };
};
function Mk(r, e, t) {
  const s = k_.get(r);
  if (r.ssrCodegenNode) {
    const i = O_.get(r) || [];
    for (let n = 0; n < i.length; n++) {
      const { fn: a, vnodeBranch: o } = i[n];
      a.body = yl(
        Q("_push", !1),
        aa(
          i[n],
          e,
          !1,
          !0
        ),
        o
      );
    }
    e.withSlotScopeId && r.ssrCodegenNode.arguments.push("_scopeId"), typeof s == "string" ? e.pushStatement(
      ge("_push", [r.ssrCodegenNode])
    ) : e.pushStatement(r.ssrCodegenNode);
  } else {
    if (s === $i)
      return mk(r, e);
    if (s === Xn)
      return yk(r, e);
    if (s === ia)
      return Tk(r, e);
    if (t.type === I_ && e.pushStringPart(""), s === nn)
      return Ak(r, e);
    xs(r, e);
  }
}
const D_ = /* @__PURE__ */ new WeakMap(), [Rk, $k] = Um(!0), Fk = [...Rk, ...Qm], Bk = Vi(Vi({}, $k), Zm);
function Vk(r, e, t, s) {
  const i = D_.get(s.root), n = Dk(Vi({}, i), {
    // overwrite with vnode-based transforms
    nodeTransforms: [
      ...Fk,
      ...i.nodeTransforms || []
    ],
    directiveTransforms: Vi(Vi({}, Bk), i.directiveTransforms || {})
  }), a = [];
  return r && a.push({
    type: 7,
    name: "slot",
    exp: r,
    arg: void 0,
    modifiers: [],
    loc: rt
  }), e && a.push(Jr({}, e)), Uk({
    type: 1,
    ns: 0,
    tag: "template",
    tagType: 3,
    props: a,
    children: t,
    loc: rt,
    codegenNode: void 0
  }, n, s), XE(t);
}
function Uk(r, e, t) {
  const s = rn([r]), i = Ho(s, e);
  i.ssr = !1, i.scopes = Vi({}, t.scopes), i.identifiers = Vi({}, t.identifiers), i.imports = t.imports, Qn(s, i), ["helpers", "components", "directives"].forEach((n) => {
    i[n].forEach((a, o) => {
      if (n === "helpers") {
        const u = t.helpers.get(o);
        u === void 0 ? t.helpers.set(o, a) : t.helpers.set(o, a + u);
      } else
        t[n].add(a);
    });
  });
}
function ih(r) {
  if (er(r))
    return r.map(ih);
  if (RE(r)) {
    const e = {};
    for (const t in r)
      e[t] = ih(r[t]);
    return e;
  } else
    return r;
}
function jk(r, e) {
  const t = L_(r, e);
  if (e.ssrCssVars) {
    const i = Ho(rn([]), e), n = vt(
      Q(e.ssrCssVars, !1),
      i
    );
    t.body.push(
      yt(["const _cssVars = { style: ", n, "}"])
    ), Array.from(i.helpers.keys()).forEach((a) => {
      r.helpers.add(a);
    });
  }
  const s = r.children.length > 1 && r.children.some((i) => !Ha(i));
  xs(r, t, s), r.codegenNode = Bo(t.body), r.ssrHelpers = Array.from(
    /* @__PURE__ */ new Set([
      ...Array.from(r.helpers).filter((i) => i in sh),
      ...t.helpers
    ])
  ), r.helpers = new Set(Array.from(r.helpers).filter((i) => !(i in sh)));
}
function L_(r, e, t = /* @__PURE__ */ new Set(), s = !1) {
  const i = [];
  let n = null;
  return {
    root: r,
    options: e,
    body: i,
    helpers: t,
    withSlotScopeId: s,
    onError: e.onError || ((a) => {
      throw a;
    }),
    helper(a) {
      return t.add(a), a;
    },
    pushStringPart(a) {
      if (!n) {
        const l = ge("_push");
        i.push(l), n = Zd([]), l.arguments.push(n);
      }
      const o = n.elements, u = o[o.length - 1];
      Ie(a) && Ie(u) ? o[o.length - 1] += a : o.push(a);
    },
    pushStatement(a) {
      n = null, i.push(a);
    }
  };
}
function qk(r, e = r.withSlotScopeId) {
  return L_(
    r.root,
    r.options,
    r.helpers,
    e
  );
}
function xs(r, e, t = !1, s = !1, i = !1) {
  t && e.pushStringPart("<!--[-->");
  const { children: n } = r;
  for (let a = 0; a < n.length; a++) {
    const o = n[a];
    switch (o.type) {
      case 1:
        switch (o.tagType) {
          case 0:
            xk(o, e);
            break;
          case 1:
            Mk(o, e, r);
            break;
          case 2:
            hk(o, e);
            break;
          case 3:
            break;
          default:
            return e.onError(
              vo(
                67,
                o.loc
              )
            ), o;
        }
        break;
      case 2:
        e.pushStringPart(Ur(o.content));
        break;
      case 3:
        e.pushStringPart(`<!--${o.content}-->`);
        break;
      case 5:
        e.pushStringPart(
          ge(e.helper(Rl), [
            o.content
          ])
        );
        break;
      case 9:
        lk(
          o,
          e,
          s,
          i
        );
        break;
      case 11:
        fk(o, e, s);
        break;
      case 10:
        break;
      case 12:
      case 8:
        break;
      default:
        return e.onError(
          vo(
            67,
            o.loc
          )
        ), o;
    }
  }
  t && e.pushStringPart("<!--]-->");
}
function aa(r, e, t = !1, s = e.withSlotScopeId) {
  const i = qk(e, s);
  return xs(r, i, t), Bo(i.body);
}
const Hk = (r, e, t) => {
  const s = r.exp;
  function i() {
    const a = Qt(e, "value");
    a && t.onError(
      Mt(
        60,
        a.loc
      )
    );
  }
  function n(a) {
    if (a.tag === "option") {
      if (a.props.findIndex((o) => o.name === "selected") === -1) {
        const o = p1(a);
        a.ssrCodegenNode.elements.push(
          Nr(
            ge(t.helper(v0), [
              Nr(
                ge("Array.isArray", [s]),
                ge(t.helper(rh), [
                  s,
                  o
                ]),
                ge(t.helper(zu), [
                  s,
                  o
                ])
              )
            ]),
            Q(" selected", !0),
            Q("", !0),
            !1
          )
        );
      }
    } else a.tag === "optgroup" && a.children.forEach(
      (o) => n(o)
    );
  }
  if (e.tagType === 0) {
    const a = { props: [] }, o = [
      // default value binding for text type inputs
      Fe("value", s)
    ];
    if (e.tag === "input") {
      const u = Qt(e, "type");
      if (u) {
        const l = p1(e);
        if (u.type === 7)
          a.ssrTagParts = [
            ge(t.helper(__), [
              u.exp,
              s,
              l
            ])
          ];
        else if (u.value)
          switch (u.value.content) {
            case "radio":
              a.props = [
                Fe(
                  "checked",
                  ge(t.helper(zu), [
                    s,
                    l
                  ])
                )
              ];
              break;
            case "checkbox":
              const c = Qt(e, "true-value");
              if (c) {
                const f = c.type === 6 ? JSON.stringify(c.value.content) : c.exp;
                a.props = [
                  Fe(
                    "checked",
                    ge(t.helper(zu), [
                      s,
                      f
                    ])
                  )
                ];
              } else
                a.props = [
                  Fe(
                    "checked",
                    Nr(
                      ge("Array.isArray", [s]),
                      ge(t.helper(rh), [
                        s,
                        l
                      ]),
                      s
                    )
                  )
                ];
              break;
            case "file":
              t.onError(
                Mt(
                  59,
                  r.loc
                )
              );
              break;
            default:
              i(), a.props = o;
              break;
          }
      } else $c(e) || (i(), a.props = o);
    } else e.tag === "textarea" ? (i(), e.children = [gl(s, s.loc)]) : e.tag === "select" ? e.children.forEach((u) => {
      u.type === 1 && n(u);
    }) : t.onError(
      Mt(
        57,
        r.loc
      )
    );
    return a;
  } else
    return zc(r, e, t);
};
function p1(r) {
  const e = Qt(r, "value");
  return e ? e.type === 7 ? e.exp : Q(e.value.content, !0) : Q("null", !1);
}
const Wk = (r, e, t) => (r.exp || t.onError(
  Mt(61)
), {
  props: [
    Fe(
      "style",
      Nr(
        r.exp,
        Q("null", !1),
        Yt([
          Fe(
            "display",
            Q("none", !0)
          )
        ]),
        !1
      )
    )
  ]
}), nh = (r) => r.children.filter((e) => e.type !== 3), Gf = (r) => nh(r).length === 1, zk = (r, e) => {
  if (r.type === 0 && (e.identifiers._attrs = 1), r.type === 1 && r.tagType === 1 && (r.tag === "transition" || r.tag === "Transition" || r.tag === "KeepAlive" || r.tag === "keep-alive")) {
    const s = nh(e.root);
    if (s.length === 1 && s[0] === r) {
      Gf(r) && Kf(r.children[0]);
      return;
    }
  }
  const t = e.parent;
  if (!(!t || t.type !== 0))
    if (r.type === 10 && Gf(r)) {
      let s = !1;
      for (const i of nh(t))
        if (i.type === 9 || i.type === 1 && gt(i, "if")) {
          if (s) return;
          s = !0;
        } else if (
          // node before v-if
          !s || // non else nodes
          !(i.type === 1 && gt(i, /else/, !0))
        )
          return;
      Kf(r.children[0]);
    } else Gf(t) && Kf(r);
};
function Kf(r) {
  r.type === 1 && (r.tagType === 0 || r.tagType === 1) && !gt(r, "for") && r.props.push({
    type: 7,
    name: "bind",
    arg: void 0,
    exp: Q("_attrs", !1),
    modifiers: [],
    loc: rt
  });
}
const Gk = (r, e) => {
  if (!e.ssrCssVars)
    return;
  r.type === 0 && (e.identifiers._cssVars = 1);
  const t = e.parent;
  if (!(!t || t.type !== 0))
    if (r.type === 10)
      for (const s of r.children)
        $l(s);
    else
      $l(r);
};
function $l(r) {
  if (r.type === 1 && (r.tagType === 0 || r.tagType === 1) && !gt(r, "for"))
    if (r.tag === "suspense" || r.tag === "Suspense")
      for (const e of r.children)
        e.type === 1 && e.tagType === 3 ? e.children.forEach($l) : $l(e);
    else
      r.props.push({
        type: 7,
        name: "bind",
        arg: void 0,
        exp: Q("_cssVars", !1),
        modifiers: [],
        loc: rt
      });
}
var Kk = Object.defineProperty, Xk = Object.defineProperties, Jk = Object.getOwnPropertyDescriptors, h1 = Object.getOwnPropertySymbols, Yk = Object.prototype.hasOwnProperty, Qk = Object.prototype.propertyIsEnumerable, d1 = (r, e, t) => e in r ? Kk(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, mu = (r, e) => {
  for (var t in e || (e = {}))
    Yk.call(e, t) && d1(r, t, e[t]);
  if (h1)
    for (var t of h1(e))
      Qk.call(e, t) && d1(r, t, e[t]);
  return r;
}, m1 = (r, e) => Xk(r, Jk(e));
function Zk(r, e = {}) {
  e = m1(mu(mu({}, e), Un), {
    ssr: !0,
    inSSR: !0,
    scopeId: e.mode === "function" ? null : e.scopeId,
    // always prefix since compiler-ssr doesn't have size concern
    prefixIdentifiers: !0,
    // disable optimizations that are unnecessary for ssr
    cacheHandlers: !1,
    hoistStatic: !1
  });
  const t = typeof r == "string" ? Fc(r, e) : r;
  return D_.set(t, e), _m(t, m1(mu({}, e), {
    hoistStatic: !1,
    nodeTransforms: [
      uk,
      ck,
      Fm,
      km,
      pk,
      zk,
      Gk,
      bk,
      Lk,
      $m,
      Xm,
      ...e.nodeTransforms || []
      // user transforms
    ],
    directiveTransforms: mu({
      // reusing core v-bind
      bind: Lm,
      on: Wc,
      // model and show have dedicated SSR handling
      model: Hk,
      show: Wk,
      // the following are ignored during SSR
      // on: noopDirectiveTransform,
      cloak: Wa,
      once: Wa,
      memo: Wa
    }, e.directiveTransforms || {})
  })), jk(t, e), Im(t, e);
}
var eD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  compile: Zk
});
function tD(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var rD = {}, sD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: rD
}), iD = /* @__PURE__ */ Vo(sD), S0 = /* @__PURE__ */ Vo(C6), nD = /* @__PURE__ */ Vo(k8);
const g1 = {};
function wn(r) {
  !(typeof process < "u" && process.env.NODE_ENV === "production") && !g1[r] && (g1[r] = !0, ah(r));
}
function ah(r) {
  console.warn(
    `\x1B[1m\x1B[33m[@vue/compiler-sfc]\x1B[0m\x1B[33m ${r}\x1B[0m
`
  );
}
var aD = Object.defineProperty, oD = Object.defineProperties, uD = Object.getOwnPropertyDescriptors, y1 = Object.getOwnPropertySymbols, lD = Object.prototype.hasOwnProperty, cD = Object.prototype.propertyIsEnumerable, b1 = (r, e, t) => e in r ? aD(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Fl = (r, e) => {
  for (var t in e || (e = {}))
    lD.call(e, t) && b1(r, t, e[t]);
  if (y1)
    for (var t of y1(e))
      cD.call(e, t) && b1(r, t, e[t]);
  return r;
}, oh = (r, e) => oD(r, uD(e));
function fD({ source: r, filename: e, preprocessOptions: t }, s) {
  let i = "", n = null;
  if (s.render(
    r,
    Fl({ filename: e }, t),
    (a, o) => {
      a && (n = a), i = o;
    }
  ), n) throw n;
  return i;
}
function M_(r) {
  const { preprocessLang: e, preprocessCustomRequire: t } = r;
  if (e && !t)
    throw new Error(
      "[@vue/compiler-sfc] Template preprocessing in the browser build must provide the `preprocessCustomRequire` option to return the in-browser version of the preprocessor in the shape of { render(): string }."
    );
  const s = e ? t ? t(e) : void 0 : !1;
  if (s)
    try {
      return v1(oh(Fl({}, r), {
        source: fD(r, s),
        ast: void 0
        // invalidate AST if template goes through preprocessor
      }));
    } catch (i) {
      return {
        code: "export default function render() {}",
        source: r.source,
        tips: [],
        errors: [i]
      };
    }
  else return e ? {
    code: "export default function render() {}",
    source: r.source,
    tips: [
      `Component ${r.filename} uses lang ${e} for template. Please install the language preprocessor.`
    ],
    errors: [
      `Component ${r.filename} uses lang ${e} for template, however it is not installed.`
    ]
  } : v1(r);
}
function v1({
  filename: r,
  id: e,
  scoped: t,
  slotted: s,
  inMap: i,
  source: n,
  ast: a,
  ssr: o = !1,
  ssrCssVars: u,
  isProd: l = !1,
  compiler: c,
  compilerOptions: f = {},
  transformAssetUrls: p
}) {
  const h = [], m = [];
  let d = [];
  if (pi(p)) {
    const x = rk(p);
    d = [
      sk(x),
      ok(x)
    ];
  } else p !== !1 && (d = [f_, p_]);
  o && !u && wn(
    "compileTemplate is called with `ssr: true` but no corresponding `cssVars` option."
  ), e || (wn("compileTemplate now requires the `id` option."), e = "");
  const y = e.replace(/^data-v-/, ""), S = `data-v-${y}`, E = o ? eD : zp;
  if (c = c || E, c !== E && (a = void 0), a != null && a.transformed) {
    const _ = (o ? zp : c).parse(a.source, oh(Fl({
      prefixIdentifiers: !0
    }, f), {
      parseMode: "sfc",
      onError: (T) => h.push(T)
    })).children.find(
      (T) => T.type === 1 && T.tag === "template"
    );
    a = rn(_.children, a.source);
  }
  let { code: g, ast: b, preamble: v, map: A } = c.compile(a || n, oh(Fl({
    mode: "module",
    prefixIdentifiers: !0,
    hoistStatic: !0,
    cacheHandlers: !0,
    ssrCssVars: o && u && u.length ? d2(u, y, l, !0) : "",
    scopeId: t ? S : void 0,
    slotted: s,
    sourceMap: !0
  }, f), {
    hmr: !l,
    nodeTransforms: d.concat(f.nodeTransforms || []),
    filename: r,
    onError: (x) => h.push(x),
    onWarn: (x) => m.push(x)
  }));
  i && !a && (A && (A = pD(i, A)), h.length && hD(h, n, i));
  const C = m.map((x) => {
    let _ = x.message;
    return x.loc && (_ += `
${kn(
      (a == null ? void 0 : a.source) || n,
      x.loc.start.offset,
      x.loc.end.offset
    )}`), _;
  });
  return { code: g, ast: b, preamble: v, source: n, errors: h, tips: C, map: A };
}
function pD(r, e) {
  if (!r) return e;
  if (!e) return r;
  const t = new Oy(r), s = new Oy(e), i = new Om();
  s.eachMapping((a) => {
    if (a.originalLine == null)
      return;
    const o = t.originalPositionFor({
      line: a.originalLine,
      column: a.originalColumn
    });
    o.source != null && i.addMapping({
      generated: {
        line: a.generatedLine,
        column: a.generatedColumn
      },
      original: {
        line: o.line,
        // map line
        // use current column, since the oldMap produced by @vue/compiler-sfc
        // does not
        column: a.originalColumn
      },
      source: o.source,
      name: o.name
    });
  });
  const n = i;
  return t.sources.forEach((a) => {
    n._sources.add(a);
    const o = t.sourceContentFor(a);
    o != null && i.setSourceContent(a, o);
  }), n._sourceRoot = r.sourceRoot, n._file = r.file, n.toJSON();
}
function hD(r, e, t) {
  const s = t.sourcesContent[0], i = s.indexOf(e), n = s.slice(0, i).split(/\r?\n/).length - 1;
  r.forEach((a) => {
    a.loc && (a.loc.start.line += n, a.loc.start.offset += i, a.loc.end !== a.loc.start && (a.loc.end.line += n, a.loc.end.offset += i));
  });
}
var _0 = { exports: {} };
function R_() {
  return !1;
}
function $_() {
  throw new Error("tty.ReadStream is not implemented");
}
function F_() {
  throw new Error("tty.ReadStream is not implemented");
}
var dD = {
  isatty: R_,
  ReadStream: $_,
  WriteStream: F_
}, mD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ReadStream: $_,
  WriteStream: F_,
  default: dD,
  isatty: R_
}), gD = /* @__PURE__ */ Vo(mD);
let E1 = Zt.argv || [], gu = {}, yD = !("NO_COLOR" in gu || E1.includes("--no-color")) && ("FORCE_COLOR" in gu || E1.includes("--color") || !1 || tD != null && gD.isatty(1) && gu.TERM !== "dumb" || "CI" in gu), bD = (r, e, t = r) => (s) => {
  let i = "" + s, n = i.indexOf(e, r.length);
  return ~n ? r + vD(i, e, t, n) + e : r + i + e;
}, vD = (r, e, t, s) => {
  let i = "", n = 0;
  do
    i += r.substring(n, s) + t, n = s + e.length, s = r.indexOf(e, n);
  while (~s);
  return i + r.substring(n);
}, B_ = (r = yD) => {
  let e = r ? bD : () => String;
  return {
    isColorSupported: r,
    reset: e("\x1B[0m", "\x1B[0m"),
    bold: e("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
    dim: e("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
    italic: e("\x1B[3m", "\x1B[23m"),
    underline: e("\x1B[4m", "\x1B[24m"),
    inverse: e("\x1B[7m", "\x1B[27m"),
    hidden: e("\x1B[8m", "\x1B[28m"),
    strikethrough: e("\x1B[9m", "\x1B[29m"),
    black: e("\x1B[30m", "\x1B[39m"),
    red: e("\x1B[31m", "\x1B[39m"),
    green: e("\x1B[32m", "\x1B[39m"),
    yellow: e("\x1B[33m", "\x1B[39m"),
    blue: e("\x1B[34m", "\x1B[39m"),
    magenta: e("\x1B[35m", "\x1B[39m"),
    cyan: e("\x1B[36m", "\x1B[39m"),
    white: e("\x1B[37m", "\x1B[39m"),
    gray: e("\x1B[90m", "\x1B[39m"),
    bgBlack: e("\x1B[40m", "\x1B[49m"),
    bgRed: e("\x1B[41m", "\x1B[49m"),
    bgGreen: e("\x1B[42m", "\x1B[49m"),
    bgYellow: e("\x1B[43m", "\x1B[49m"),
    bgBlue: e("\x1B[44m", "\x1B[49m"),
    bgMagenta: e("\x1B[45m", "\x1B[49m"),
    bgCyan: e("\x1B[46m", "\x1B[49m"),
    bgWhite: e("\x1B[47m", "\x1B[49m")
  };
};
_0.exports = B_();
_0.exports.createColors = B_;
var V_ = _0.exports;
const Xf = 39, S1 = 34, yu = 92, _1 = 47, bu = 10, Sa = 32, vu = 12, Eu = 9, Su = 13, ED = 91, SD = 93, _D = 40, xD = 41, wD = 123, TD = 125, PD = 59, AD = 42, CD = 58, ND = 64, _u = /[\t\n\f\r "#'()/;[\\\]{}]/g, xu = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, OD = /.[\r\n"'(/\\]/, x1 = /[\da-f]/i;
var U_ = function(e, t = {}) {
  let s = e.css.valueOf(), i = t.ignoreErrors, n, a, o, u, l, c, f, p, h, m, d = s.length, y = 0, S = [], E = [];
  function g() {
    return y;
  }
  function b(x) {
    throw e.error("Unclosed " + x, y);
  }
  function v() {
    return E.length === 0 && y >= d;
  }
  function A(x) {
    if (E.length) return E.pop();
    if (y >= d) return;
    let _ = x ? x.ignoreUnclosed : !1;
    switch (n = s.charCodeAt(y), n) {
      case bu:
      case Sa:
      case Eu:
      case Su:
      case vu: {
        a = y;
        do
          a += 1, n = s.charCodeAt(a);
        while (n === Sa || n === bu || n === Eu || n === Su || n === vu);
        m = ["space", s.slice(y, a)], y = a - 1;
        break;
      }
      case ED:
      case SD:
      case wD:
      case TD:
      case CD:
      case PD:
      case xD: {
        let T = String.fromCharCode(n);
        m = [T, T, y];
        break;
      }
      case _D: {
        if (p = S.length ? S.pop()[1] : "", h = s.charCodeAt(y + 1), p === "url" && h !== Xf && h !== S1 && h !== Sa && h !== bu && h !== Eu && h !== vu && h !== Su) {
          a = y;
          do {
            if (c = !1, a = s.indexOf(")", a + 1), a === -1)
              if (i || _) {
                a = y;
                break;
              } else
                b("bracket");
            for (f = a; s.charCodeAt(f - 1) === yu; )
              f -= 1, c = !c;
          } while (c);
          m = ["brackets", s.slice(y, a + 1), y, a], y = a;
        } else
          a = s.indexOf(")", y + 1), u = s.slice(y, a + 1), a === -1 || OD.test(u) ? m = ["(", "(", y] : (m = ["brackets", u, y, a], y = a);
        break;
      }
      case Xf:
      case S1: {
        o = n === Xf ? "'" : '"', a = y;
        do {
          if (c = !1, a = s.indexOf(o, a + 1), a === -1)
            if (i || _) {
              a = y + 1;
              break;
            } else
              b("string");
          for (f = a; s.charCodeAt(f - 1) === yu; )
            f -= 1, c = !c;
        } while (c);
        m = ["string", s.slice(y, a + 1), y, a], y = a;
        break;
      }
      case ND: {
        _u.lastIndex = y + 1, _u.test(s), _u.lastIndex === 0 ? a = s.length - 1 : a = _u.lastIndex - 2, m = ["at-word", s.slice(y, a + 1), y, a], y = a;
        break;
      }
      case yu: {
        for (a = y, l = !0; s.charCodeAt(a + 1) === yu; )
          a += 1, l = !l;
        if (n = s.charCodeAt(a + 1), l && n !== _1 && n !== Sa && n !== bu && n !== Eu && n !== Su && n !== vu && (a += 1, x1.test(s.charAt(a)))) {
          for (; x1.test(s.charAt(a + 1)); )
            a += 1;
          s.charCodeAt(a + 1) === Sa && (a += 1);
        }
        m = ["word", s.slice(y, a + 1), y, a], y = a;
        break;
      }
      default: {
        n === _1 && s.charCodeAt(y + 1) === AD ? (a = s.indexOf("*/", y + 2) + 1, a === 0 && (i || _ ? a = s.length : b("comment")), m = ["comment", s.slice(y, a + 1), y, a], y = a) : (xu.lastIndex = y + 1, xu.test(s), xu.lastIndex === 0 ? a = s.length - 1 : a = xu.lastIndex - 2, m = ["word", s.slice(y, a + 1), y, a], S.push(m), y = a);
        break;
      }
    }
    return y++, m;
  }
  function C(x) {
    E.push(x);
  }
  return {
    back: C,
    endOfFile: v,
    nextToken: A,
    position: g
  };
};
let Bt = V_, ID = U_, j_;
function kD(r) {
  j_ = r;
}
const DD = {
  ";": Bt.yellow,
  ":": Bt.yellow,
  "(": Bt.cyan,
  ")": Bt.cyan,
  "[": Bt.yellow,
  "]": Bt.yellow,
  "{": Bt.yellow,
  "}": Bt.yellow,
  "at-word": Bt.cyan,
  brackets: Bt.cyan,
  call: Bt.cyan,
  class: Bt.yellow,
  comment: Bt.gray,
  hash: Bt.magenta,
  string: Bt.green
};
function LD([r, e], t) {
  if (r === "word") {
    if (e[0] === ".")
      return "class";
    if (e[0] === "#")
      return "hash";
  }
  if (!t.endOfFile()) {
    let s = t.nextToken();
    if (t.back(s), s[0] === "brackets" || s[0] === "(") return "call";
  }
  return r;
}
function q_(r) {
  let e = ID(new j_(r), { ignoreErrors: !0 }), t = "";
  for (; !e.endOfFile(); ) {
    let s = e.nextToken(), i = DD[LD(s, e)];
    i ? t += s[1].split(/\r?\n/).map((n) => i(n)).join(`
`) : t += s[1];
  }
  return t;
}
q_.registerInput = kD;
var H_ = q_;
let w1 = V_, T1 = H_, uh = class W_ extends Error {
  constructor(e, t, s, i, n, a) {
    super(e), this.name = "CssSyntaxError", this.reason = e, n && (this.file = n), i && (this.source = i), a && (this.plugin = a), typeof t < "u" && typeof s < "u" && (typeof t == "number" ? (this.line = t, this.column = s) : (this.line = t.line, this.column = t.column, this.endLine = s.line, this.endColumn = s.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, W_);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source) return "";
    let t = this.source;
    e == null && (e = w1.isColorSupported), T1 && e && (t = T1(t));
    let s = t.split(/\r?\n/), i = Math.max(this.line - 3, 0), n = Math.min(this.line + 2, s.length), a = String(n).length, o, u;
    if (e) {
      let { bold: l, gray: c, red: f } = w1.createColors(!0);
      o = (p) => l(f(p)), u = (p) => c(p);
    } else
      o = u = (l) => l;
    return s.slice(i, n).map((l, c) => {
      let f = i + 1 + c, p = " " + (" " + f).slice(-a) + " | ";
      if (f === this.line) {
        let h = u(p.replace(/\d/g, " ")) + l.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return o(">") + u(p) + l + `
 ` + h + o("^");
      }
      return " " + u(p) + l;
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
};
var x0 = uh;
uh.default = uh;
var Go = {};
Go.isClean = Symbol("isClean");
Go.my = Symbol("my");
const P1 = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function MD(r) {
  return r[0].toUpperCase() + r.slice(1);
}
let lh = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, t) {
    let s = "@" + e.name, i = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName < "u" ? s += e.raws.afterName : i && (s += " "), e.nodes)
      this.block(e, s + i);
    else {
      let n = (e.raws.between || "") + (t ? ";" : "");
      this.builder(s + i + n, e);
    }
  }
  beforeAfter(e, t) {
    let s;
    e.type === "decl" ? s = this.raw(e, null, "beforeDecl") : e.type === "comment" ? s = this.raw(e, null, "beforeComment") : t === "before" ? s = this.raw(e, null, "beforeRule") : s = this.raw(e, null, "beforeClose");
    let i = e.parent, n = 0;
    for (; i && i.type !== "root"; )
      n += 1, i = i.parent;
    if (s.includes(`
`)) {
      let a = this.raw(e, null, "indent");
      if (a.length)
        for (let o = 0; o < n; o++) s += a;
    }
    return s;
  }
  block(e, t) {
    let s = this.raw(e, "between", "beforeOpen");
    this.builder(t + s + "{", e, "start");
    let i;
    e.nodes && e.nodes.length ? (this.body(e), i = this.raw(e, "after")) : i = this.raw(e, "after", "emptyBody"), i && this.builder(i), this.builder("}", e, "end");
  }
  body(e) {
    let t = e.nodes.length - 1;
    for (; t > 0 && e.nodes[t].type === "comment"; )
      t -= 1;
    let s = this.raw(e, "semicolon");
    for (let i = 0; i < e.nodes.length; i++) {
      let n = e.nodes[i], a = this.raw(n, "before");
      a && this.builder(a), this.stringify(n, t !== i || s);
    }
  }
  comment(e) {
    let t = this.raw(e, "left", "commentLeft"), s = this.raw(e, "right", "commentRight");
    this.builder("/*" + t + e.text + s + "*/", e);
  }
  decl(e, t) {
    let s = this.raw(e, "between", "colon"), i = e.prop + s + this.rawValue(e, "value");
    e.important && (i += e.raws.important || " !important"), t && (i += ";"), this.builder(i, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, t, s) {
    let i;
    if (s || (s = t), t && (i = e.raws[t], typeof i < "u"))
      return i;
    let n = e.parent;
    if (s === "before" && (!n || n.type === "root" && n.first === e || n && n.type === "document"))
      return "";
    if (!n) return P1[s];
    let a = e.root();
    if (a.rawCache || (a.rawCache = {}), typeof a.rawCache[s] < "u")
      return a.rawCache[s];
    if (s === "before" || s === "after")
      return this.beforeAfter(e, s);
    {
      let o = "raw" + MD(s);
      this[o] ? i = this[o](a, e) : a.walk((u) => {
        if (i = u.raws[t], typeof i < "u") return !1;
      });
    }
    return typeof i > "u" && (i = P1[s]), a.rawCache[s] = i, i;
  }
  rawBeforeClose(e) {
    let t;
    return e.walk((s) => {
      if (s.nodes && s.nodes.length > 0 && typeof s.raws.after < "u")
        return t = s.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeComment(e, t) {
    let s;
    return e.walkComments((i) => {
      if (typeof i.raws.before < "u")
        return s = i.raws.before, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), !1;
    }), typeof s > "u" ? s = this.raw(t, null, "beforeDecl") : s && (s = s.replace(/\S/g, "")), s;
  }
  rawBeforeDecl(e, t) {
    let s;
    return e.walkDecls((i) => {
      if (typeof i.raws.before < "u")
        return s = i.raws.before, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), !1;
    }), typeof s > "u" ? s = this.raw(t, null, "beforeRule") : s && (s = s.replace(/\S/g, "")), s;
  }
  rawBeforeOpen(e) {
    let t;
    return e.walk((s) => {
      if (s.type !== "decl" && (t = s.raws.between, typeof t < "u"))
        return !1;
    }), t;
  }
  rawBeforeRule(e) {
    let t;
    return e.walk((s) => {
      if (s.nodes && (s.parent !== e || e.first !== s) && typeof s.raws.before < "u")
        return t = s.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawColon(e) {
    let t;
    return e.walkDecls((s) => {
      if (typeof s.raws.between < "u")
        return t = s.raws.between.replace(/[^\s:]/g, ""), !1;
    }), t;
  }
  rawEmptyBody(e) {
    let t;
    return e.walk((s) => {
      if (s.nodes && s.nodes.length === 0 && (t = s.raws.after, typeof t < "u"))
        return !1;
    }), t;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let t;
    return e.walk((s) => {
      let i = s.parent;
      if (i && i !== e && i.parent && i.parent === e && typeof s.raws.before < "u") {
        let n = s.raws.before.split(`
`);
        return t = n[n.length - 1], t = t.replace(/\S/g, ""), !1;
      }
    }), t;
  }
  rawSemicolon(e) {
    let t;
    return e.walk((s) => {
      if (s.nodes && s.nodes.length && s.last.type === "decl" && (t = s.raws.semicolon, typeof t < "u"))
        return !1;
    }), t;
  }
  rawValue(e, t) {
    let s = e[t], i = e.raws[t];
    return i && i.value === s ? i.raw : s;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, t) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, t);
  }
};
var z_ = lh;
lh.default = lh;
let RD = z_;
function ch(r, e) {
  new RD(e).stringify(r);
}
var ef = ch;
ch.default = ch;
let { isClean: wu, my: $D } = Go, FD = x0, BD = z_, VD = ef;
function fh(r, e) {
  let t = new r.constructor();
  for (let s in r) {
    if (!Object.prototype.hasOwnProperty.call(r, s) || s === "proxyCache") continue;
    let i = r[s], n = typeof i;
    s === "parent" && n === "object" ? e && (t[s] = e) : s === "source" ? t[s] = i : Array.isArray(i) ? t[s] = i.map((a) => fh(a, t)) : (n === "object" && i !== null && (i = fh(i)), t[s] = i);
  }
  return t;
}
let ph = class {
  constructor(e = {}) {
    this.raws = {}, this[wu] = !1, this[$D] = !0;
    for (let t in e)
      if (t === "nodes") {
        this.nodes = [];
        for (let s of e[t])
          typeof s.clone == "function" ? this.append(s.clone()) : this.append(s);
      } else
        this[t] = e[t];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let t = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${t.input.from}:${t.start.line}:${t.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let t in e)
      this[t] = e[t];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let t = fh(this);
    for (let s in e)
      t[s] = e[s];
    return t;
  }
  cloneAfter(e = {}) {
    let t = this.clone(e);
    return this.parent.insertAfter(this, t), t;
  }
  cloneBefore(e = {}) {
    let t = this.clone(e);
    return this.parent.insertBefore(this, t), t;
  }
  error(e, t = {}) {
    if (this.source) {
      let { end: s, start: i } = this.rangeBy(t);
      return this.source.input.error(
        e,
        { column: i.column, line: i.line },
        { column: s.column, line: s.line },
        t
      );
    }
    return new FD(e);
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t];
      },
      set(e, t, s) {
        return e[t] === s || (e[t] = s, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || /* c8 ignore next */
        t === "text") && e.markDirty()), !0;
      }
    };
  }
  markDirty() {
    if (this[wu]) {
      this[wu] = !1;
      let e = this;
      for (; e = e.parent; )
        e[wu] = !1;
    }
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e, t) {
    let s = this.source.start;
    if (e.index)
      s = this.positionInside(e.index, t);
    else if (e.word) {
      t = this.toString();
      let i = t.indexOf(e.word);
      i !== -1 && (s = this.positionInside(i, t));
    }
    return s;
  }
  positionInside(e, t) {
    let s = t || this.toString(), i = this.source.start.column, n = this.source.start.line;
    for (let a = 0; a < e; a++)
      s[a] === `
` ? (i = 1, n += 1) : i += 1;
    return { column: i, line: n };
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e) {
    let t = {
      column: this.source.start.column,
      line: this.source.start.line
    }, s = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: t.column + 1,
      line: t.line
    };
    if (e.word) {
      let i = this.toString(), n = i.indexOf(e.word);
      n !== -1 && (t = this.positionInside(n, i), s = this.positionInside(n + e.word.length, i));
    } else
      e.start ? t = {
        column: e.start.column,
        line: e.start.line
      } : e.index && (t = this.positionInside(e.index)), e.end ? s = {
        column: e.end.column,
        line: e.end.line
      } : typeof e.endIndex == "number" ? s = this.positionInside(e.endIndex) : e.index && (s = this.positionInside(e.index + 1));
    return (s.line < t.line || s.line === t.line && s.column <= t.column) && (s = { column: t.column + 1, line: t.line }), { end: s, start: t };
  }
  raw(e, t) {
    return new BD().raw(this, e, t);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let t = this, s = !1;
      for (let i of e)
        i === this ? s = !0 : s ? (this.parent.insertAfter(t, i), t = i) : this.parent.insertBefore(t, i);
      s || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, t) {
    let s = {}, i = t == null;
    t = t || /* @__PURE__ */ new Map();
    let n = 0;
    for (let a in this) {
      if (!Object.prototype.hasOwnProperty.call(this, a) || a === "parent" || a === "proxyCache") continue;
      let o = this[a];
      if (Array.isArray(o))
        s[a] = o.map((u) => typeof u == "object" && u.toJSON ? u.toJSON(null, t) : u);
      else if (typeof o == "object" && o.toJSON)
        s[a] = o.toJSON(null, t);
      else if (a === "source") {
        let u = t.get(o.input);
        u == null && (u = n, t.set(o.input, n), n++), s[a] = {
          end: o.end,
          inputId: u,
          start: o.start
        };
      } else
        s[a] = o;
    }
    return i && (s.inputs = [...t.keys()].map((a) => a.toJSON())), s;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = VD) {
    e.stringify && (e = e.stringify);
    let t = "";
    return e(this, (s) => {
      t += s;
    }), t;
  }
  warn(e, t, s) {
    let i = { node: this };
    for (let n in s) i[n] = s[n];
    return e.warn(t, i);
  }
  get proxyOf() {
    return this;
  }
};
var tf = ph;
ph.default = ph;
let UD = tf, hh = class extends UD {
  constructor(e) {
    e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var rf = hh;
hh.default = hh;
var G_ = /* @__PURE__ */ Vo(z8);
let jD = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", qD = (r, e = 21) => (t = e) => {
  let s = "", i = t;
  for (; i--; )
    s += r[Math.random() * r.length | 0];
  return s;
}, HD = (r = 21) => {
  let e = "", t = r;
  for (; t--; )
    e += jD[Math.random() * 64 | 0];
  return e;
};
var WD = { nanoid: HD, customAlphabet: qD };
let { SourceMapConsumer: A1, SourceMapGenerator: C1 } = Zn, { existsSync: zD, readFileSync: GD } = iD, { dirname: Jf, join: KD } = S0;
function XD(r) {
  return H ? H.from(r, "base64").toString() : window.atob(r);
}
let dh = class {
  constructor(e, t) {
    if (t.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let s = t.map ? t.map.prev : void 0, i = this.loadMap(t.from, s);
    !this.mapFile && t.from && (this.mapFile = t.from), this.mapFile && (this.root = Jf(this.mapFile)), i && (this.text = i);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new A1(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let t = /^data:application\/json;charset=utf-?8;base64,/, s = /^data:application\/json;base64,/, i = /^data:application\/json;charset=utf-?8,/, n = /^data:application\/json,/;
    if (i.test(e) || n.test(e))
      return decodeURIComponent(e.substr(RegExp.lastMatch.length));
    if (t.test(e) || s.test(e))
      return XD(e.substr(RegExp.lastMatch.length));
    let a = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + a);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let t = e.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!t) return;
    let s = e.lastIndexOf(t.pop()), i = e.indexOf("*/", s);
    s > -1 && i > -1 && (this.annotation = this.getAnnotationURL(e.substring(s, i)));
  }
  loadFile(e) {
    if (this.root = Jf(e), zD(e))
      return this.mapFile = e, GD(e, "utf-8").toString().trim();
  }
  loadMap(e, t) {
    if (t === !1) return !1;
    if (t) {
      if (typeof t == "string")
        return t;
      if (typeof t == "function") {
        let s = t(e);
        if (s) {
          let i = this.loadFile(s);
          if (!i)
            throw new Error(
              "Unable to load previous source map: " + s.toString()
            );
          return i;
        }
      } else {
        if (t instanceof A1)
          return C1.fromSourceMap(t).toString();
        if (t instanceof C1)
          return t.toString();
        if (this.isMap(t))
          return JSON.stringify(t);
        throw new Error(
          "Unsupported previous source map format: " + t.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let s = this.annotation;
        return e && (s = KD(Jf(e), s)), this.loadFile(s);
      }
    }
  }
  startWith(e, t) {
    return e ? e.substr(0, t.length) === t : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var K_ = dh;
dh.default = dh;
let { SourceMapConsumer: JD, SourceMapGenerator: YD } = Zn, { fileURLToPath: N1, pathToFileURL: Tu } = G_, { isAbsolute: mh, resolve: gh } = S0, { nanoid: QD } = WD, Yf = H_, O1 = x0, ZD = K_, Qf = Symbol("fromOffsetCache"), eL = !!(JD && YD), I1 = !!(gh && mh), Bl = class {
  constructor(e, t = {}) {
    if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, t.from && (!I1 || /^\w+:\/\//.test(t.from) || mh(t.from) ? this.file = t.from : this.file = gh(t.from)), I1 && eL) {
      let s = new ZD(this.css, t);
      if (s.text) {
        this.map = s;
        let i = s.consumer().file;
        !this.file && i && (this.file = this.mapResolve(i));
      }
    }
    this.file || (this.id = "<input css " + QD(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, t, s, i = {}) {
    let n, a, o;
    if (t && typeof t == "object") {
      let l = t, c = s;
      if (typeof l.offset == "number") {
        let f = this.fromOffset(l.offset);
        t = f.line, s = f.col;
      } else
        t = l.line, s = l.column;
      if (typeof c.offset == "number") {
        let f = this.fromOffset(c.offset);
        a = f.line, o = f.col;
      } else
        a = c.line, o = c.column;
    } else if (!s) {
      let l = this.fromOffset(t);
      t = l.line, s = l.col;
    }
    let u = this.origin(t, s, a, o);
    return u ? n = new O1(
      e,
      u.endLine === void 0 ? u.line : { column: u.column, line: u.line },
      u.endLine === void 0 ? u.column : { column: u.endColumn, line: u.endLine },
      u.source,
      u.file,
      i.plugin
    ) : n = new O1(
      e,
      a === void 0 ? t : { column: s, line: t },
      a === void 0 ? s : { column: o, line: a },
      this.css,
      this.file,
      i.plugin
    ), n.input = { column: s, endColumn: o, endLine: a, line: t, source: this.css }, this.file && (Tu && (n.input.url = Tu(this.file).toString()), n.input.file = this.file), n;
  }
  fromOffset(e) {
    let t, s;
    if (this[Qf])
      s = this[Qf];
    else {
      let n = this.css.split(`
`);
      s = new Array(n.length);
      let a = 0;
      for (let o = 0, u = n.length; o < u; o++)
        s[o] = a, a += n[o].length + 1;
      this[Qf] = s;
    }
    t = s[s.length - 1];
    let i = 0;
    if (e >= t)
      i = s.length - 1;
    else {
      let n = s.length - 2, a;
      for (; i < n; )
        if (a = i + (n - i >> 1), e < s[a])
          n = a - 1;
        else if (e >= s[a + 1])
          i = a + 1;
        else {
          i = a;
          break;
        }
    }
    return {
      col: e - s[i] + 1,
      line: i + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : gh(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, t, s, i) {
    if (!this.map) return !1;
    let n = this.map.consumer(), a = n.originalPositionFor({ column: t, line: e });
    if (!a.source) return !1;
    let o;
    typeof s == "number" && (o = n.originalPositionFor({ column: i, line: s }));
    let u;
    mh(a.source) ? u = Tu(a.source) : u = new URL(
      a.source,
      this.map.consumer().sourceRoot || Tu(this.map.mapFile)
    );
    let l = {
      column: a.column,
      endColumn: o && o.column,
      endLine: o && o.line,
      line: a.line,
      url: u.toString()
    };
    if (u.protocol === "file:")
      if (N1)
        l.file = N1(u);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let c = n.sourceContentFor(a.source);
    return c && (l.source = c), l;
  }
  toJSON() {
    let e = {};
    for (let t of ["hasBOM", "css", "file", "id"])
      this[t] != null && (e[t] = this[t]);
    return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
  get from() {
    return this.file || this.id;
  }
};
var sf = Bl;
Bl.default = Bl;
Yf && Yf.registerInput && Yf.registerInput(Bl);
let { SourceMapConsumer: X_, SourceMapGenerator: Gu } = Zn, { dirname: Ku, relative: J_, resolve: Y_, sep: Q_ } = S0, { pathToFileURL: k1 } = G_, tL = sf, rL = !!(X_ && Gu), sL = !!(Ku && Y_ && J_ && Q_), iL = class {
  constructor(e, t, s, i) {
    this.stringify = e, this.mapOpts = s.map || {}, this.root = t, this.opts = s, this.css = i, this.originalCSS = i, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let t = `
`;
    this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let t = this.toUrl(this.path(e.file)), s = e.root || Ku(e.file), i;
      this.mapOpts.sourcesContent === !1 ? (i = new X_(e.text), i.sourcesContent && (i.sourcesContent = null)) : i = e.consumer(), this.map.applySourceMap(i, t, this.toUrl(this.path(s)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let t = this.root.nodes.length - 1; t >= 0; t--)
          e = this.root.nodes[t], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(t);
      } else this.css && (this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), sL && rL && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (t) => {
        e += t;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = Gu.fromSourceMap(e, {
        ignoreInvalidMapping: !0
      });
    } else
      this.map = new Gu({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new Gu({
      file: this.outputFile(),
      ignoreInvalidMapping: !0
    });
    let e = 1, t = 1, s = "<no source>", i = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, n, a;
    this.stringify(this.root, (o, u, l) => {
      if (this.css += o, u && l !== "end" && (i.generated.line = e, i.generated.column = t - 1, u.source && u.source.start ? (i.source = this.sourcePath(u), i.original.line = u.source.start.line, i.original.column = u.source.start.column - 1, this.map.addMapping(i)) : (i.source = s, i.original.line = 1, i.original.column = 0, this.map.addMapping(i))), n = o.match(/\n/g), n ? (e += n.length, a = o.lastIndexOf(`
`), t = o.length - a) : t += o.length, u && l !== "start") {
        let c = u.parent || { raws: {} };
        (!(u.type === "decl" || u.type === "atrule" && !u.nodes) || u !== c.last || c.raws.semicolon) && (u.source && u.source.end ? (i.source = this.sourcePath(u), i.original.line = u.source.end.line, i.original.column = u.source.end.column - 1, i.generated.line = e, i.generated.column = t - 2, this.map.addMapping(i)) : (i.source = s, i.original.line = 1, i.original.column = 0, i.generated.line = e, i.generated.column = t - 1, this.map.addMapping(i)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e)) return e;
    let t = this.memoizedPaths.get(e);
    if (t) return t;
    let s = this.opts.to ? Ku(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (s = Ku(Y_(s, this.mapOpts.annotation)));
    let i = J_(s, e);
    return this.memoizedPaths.set(e, i), i;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let t = e.source.input.map;
            this.previousMaps.includes(t) || this.previousMaps.push(t);
          }
        });
      else {
        let e = new tL(this.originalCSS, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((t) => {
        if (t.source) {
          let s = t.source.input.from;
          if (s && !e[s]) {
            e[s] = !0;
            let i = this.usesFileUrls ? this.toFileUrl(s) : this.toUrl(this.path(s));
            this.map.setSourceContent(i, t.source.input.css);
          }
        }
      });
    else if (this.css) {
      let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(t, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return H ? H.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let t = this.memoizedFileURLs.get(e);
    if (t) return t;
    if (k1) {
      let s = k1(e).toString();
      return this.memoizedFileURLs.set(e, s), s;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let t = this.memoizedURLs.get(e);
    if (t) return t;
    Q_ === "\\" && (e = e.replace(/\\/g, "/"));
    let s = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, s), s;
  }
};
var Z_ = iL;
let nL = tf, yh = class extends nL {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var nf = yh;
yh.default = yh;
let { isClean: ex, my: tx } = Go, rx = rf, sx = nf, aL = tf, ix, w0, T0, nx;
function ax(r) {
  return r.map((e) => (e.nodes && (e.nodes = ax(e.nodes)), delete e.source, e));
}
function ox(r) {
  if (r[ex] = !1, r.proxyOf.nodes)
    for (let e of r.proxyOf.nodes)
      ox(e);
}
let Cs = class ux extends aL {
  append(...e) {
    for (let t of e) {
      let s = this.normalize(t, this.last);
      for (let i of s) this.proxyOf.nodes.push(i);
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let t of this.nodes) t.cleanRaws(e);
  }
  each(e) {
    if (!this.proxyOf.nodes) return;
    let t = this.getIterator(), s, i;
    for (; this.indexes[t] < this.proxyOf.nodes.length && (s = this.indexes[t], i = e(this.proxyOf.nodes[s], s), i !== !1); )
      this.indexes[t] += 1;
    return delete this.indexes[t], i;
  }
  every(e) {
    return this.nodes.every(e);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : e[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? (...s) => e[t](
          ...s.map((i) => typeof i == "function" ? (n, a) => i(n.toProxy(), a) : i)
        ) : t === "every" || t === "some" ? (s) => e[t](
          (i, ...n) => s(i.toProxy(), ...n)
        ) : t === "root" ? () => e.root().toProxy() : t === "nodes" ? e.nodes.map((s) => s.toProxy()) : t === "first" || t === "last" ? e[t].toProxy() : e[t] : e[t];
      },
      set(e, t, s) {
        return e[t] === s || (e[t] = s, (t === "name" || t === "params" || t === "selector") && e.markDirty()), !0;
      }
    };
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  insertAfter(e, t) {
    let s = this.index(e), i = this.normalize(t, this.proxyOf.nodes[s]).reverse();
    s = this.index(e);
    for (let a of i) this.proxyOf.nodes.splice(s + 1, 0, a);
    let n;
    for (let a in this.indexes)
      n = this.indexes[a], s < n && (this.indexes[a] = n + i.length);
    return this.markDirty(), this;
  }
  insertBefore(e, t) {
    let s = this.index(e), i = s === 0 ? "prepend" : !1, n = this.normalize(
      t,
      this.proxyOf.nodes[s],
      i
    ).reverse();
    s = this.index(e);
    for (let o of n) this.proxyOf.nodes.splice(s, 0, o);
    let a;
    for (let o in this.indexes)
      a = this.indexes[o], s <= a && (this.indexes[o] = a + n.length);
    return this.markDirty(), this;
  }
  normalize(e, t) {
    if (typeof e == "string")
      e = ax(ix(e).nodes);
    else if (typeof e > "u")
      e = [];
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let i of e)
        i.parent && i.parent.removeChild(i, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let i of e)
        i.parent && i.parent.removeChild(i, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value > "u")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new rx(e)];
    } else if (e.selector)
      e = [new w0(e)];
    else if (e.name)
      e = [new T0(e)];
    else if (e.text)
      e = [new sx(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((i) => (i[tx] || ux.rebuild(i), i = i.proxyOf, i.parent && i.parent.removeChild(i), i[ex] && ox(i), typeof i.raws.before > "u" && t && typeof t.raws.before < "u" && (i.raws.before = t.raws.before.replace(/\S/g, "")), i.parent = this.proxyOf, i));
  }
  prepend(...e) {
    e = e.reverse();
    for (let t of e) {
      let s = this.normalize(t, this.first, "prepend").reverse();
      for (let i of s) this.proxyOf.nodes.unshift(i);
      for (let i in this.indexes)
        this.indexes[i] = this.indexes[i] + s.length;
    }
    return this.markDirty(), this;
  }
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes) e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let t;
    for (let s in this.indexes)
      t = this.indexes[s], t >= e && (this.indexes[s] = t - 1);
    return this.markDirty(), this;
  }
  replaceValues(e, t, s) {
    return s || (s = t, t = {}), this.walkDecls((i) => {
      t.props && !t.props.includes(i.prop) || t.fast && !i.value.includes(t.fast) || (i.value = i.value.replace(e, s));
    }), this.markDirty(), this;
  }
  some(e) {
    return this.nodes.some(e);
  }
  walk(e) {
    return this.each((t, s) => {
      let i;
      try {
        i = e(t, s);
      } catch (n) {
        throw t.addToError(n);
      }
      return i !== !1 && t.walk && (i = t.walk(e)), i;
    });
  }
  walkAtRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((s, i) => {
      if (s.type === "atrule" && e.test(s.name))
        return t(s, i);
    }) : this.walk((s, i) => {
      if (s.type === "atrule" && s.name === e)
        return t(s, i);
    }) : (t = e, this.walk((s, i) => {
      if (s.type === "atrule")
        return t(s, i);
    }));
  }
  walkComments(e) {
    return this.walk((t, s) => {
      if (t.type === "comment")
        return e(t, s);
    });
  }
  walkDecls(e, t) {
    return t ? e instanceof RegExp ? this.walk((s, i) => {
      if (s.type === "decl" && e.test(s.prop))
        return t(s, i);
    }) : this.walk((s, i) => {
      if (s.type === "decl" && s.prop === e)
        return t(s, i);
    }) : (t = e, this.walk((s, i) => {
      if (s.type === "decl")
        return t(s, i);
    }));
  }
  walkRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((s, i) => {
      if (s.type === "rule" && e.test(s.selector))
        return t(s, i);
    }) : this.walk((s, i) => {
      if (s.type === "rule" && s.selector === e)
        return t(s, i);
    }) : (t = e, this.walk((s, i) => {
      if (s.type === "rule")
        return t(s, i);
    }));
  }
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Cs.registerParse = (r) => {
  ix = r;
};
Cs.registerRule = (r) => {
  w0 = r;
};
Cs.registerAtRule = (r) => {
  T0 = r;
};
Cs.registerRoot = (r) => {
  nx = r;
};
var on = Cs;
Cs.default = Cs;
Cs.rebuild = (r) => {
  r.type === "atrule" ? Object.setPrototypeOf(r, T0.prototype) : r.type === "rule" ? Object.setPrototypeOf(r, w0.prototype) : r.type === "decl" ? Object.setPrototypeOf(r, rx.prototype) : r.type === "comment" ? Object.setPrototypeOf(r, sx.prototype) : r.type === "root" && Object.setPrototypeOf(r, nx.prototype), r[tx] = !0, r.nodes && r.nodes.forEach((e) => {
    Cs.rebuild(e);
  });
};
let oL = on, lx, cx, Eo = class extends oL {
  constructor(e) {
    super({ type: "document", ...e }), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new lx(new cx(), this, e).stringify();
  }
};
Eo.registerLazyResult = (r) => {
  lx = r;
};
Eo.registerProcessor = (r) => {
  cx = r;
};
var P0 = Eo;
Eo.default = Eo;
let D1 = {};
var fx = function(e) {
  D1[e] || (D1[e] = !0, typeof console < "u" && console.warn && console.warn(e));
};
let bh = class {
  constructor(e, t = {}) {
    if (this.type = "warning", this.text = e, t.node && t.node.source) {
      let s = t.node.rangeBy(t);
      this.line = s.start.line, this.column = s.start.column, this.endLine = s.end.line, this.endColumn = s.end.column;
    }
    for (let s in t) this[s] = t[s];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var px = bh;
bh.default = bh;
let uL = px, vh = class {
  constructor(e, t, s) {
    this.processor = e, this.messages = [], this.root = t, this.opts = s, this.css = void 0, this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, t = {}) {
    t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
    let s = new uL(e, t);
    return this.messages.push(s), s;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var A0 = vh;
vh.default = vh;
let hx = on, Vl = class extends hx {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var C0 = Vl;
Vl.default = Vl;
hx.registerAtRule(Vl);
let dx = on, mx, gx, jn = class extends dx {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, t, s) {
    let i = super.normalize(e);
    if (t) {
      if (s === "prepend")
        this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
      else if (this.first !== t)
        for (let n of i)
          n.raws.before = t.raws.before;
    }
    return i;
  }
  removeChild(e, t) {
    let s = this.index(e);
    return !t && s === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[s].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new mx(new gx(), this, e).stringify();
  }
};
jn.registerLazyResult = (r) => {
  mx = r;
};
jn.registerProcessor = (r) => {
  gx = r;
};
var Ko = jn;
jn.default = jn;
dx.registerRoot(jn);
let So = {
  comma(r) {
    return So.split(r, [","], !0);
  },
  space(r) {
    let e = [" ", `
`, "	"];
    return So.split(r, e);
  },
  split(r, e, t) {
    let s = [], i = "", n = !1, a = 0, o = !1, u = "", l = !1;
    for (let c of r)
      l ? l = !1 : c === "\\" ? l = !0 : o ? c === u && (o = !1) : c === '"' || c === "'" ? (o = !0, u = c) : c === "(" ? a += 1 : c === ")" ? a > 0 && (a -= 1) : a === 0 && e.includes(c) && (n = !0), n ? (i !== "" && s.push(i.trim()), i = "", n = !1) : i += c;
    return (t || i !== "") && s.push(i.trim()), s;
  }
};
var yx = So;
So.default = So;
let bx = on, lL = yx, Ul = class extends bx {
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
  get selectors() {
    return lL.comma(this.selector);
  }
  set selectors(e) {
    let t = this.selector ? this.selector.match(/,\s*/) : null, s = t ? t[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(s);
  }
};
var N0 = Ul;
Ul.default = Ul;
bx.registerRule(Ul);
let cL = rf, fL = U_, pL = nf, hL = C0, dL = Ko, L1 = N0;
const M1 = {
  empty: !0,
  space: !0
};
function mL(r) {
  for (let e = r.length - 1; e >= 0; e--) {
    let t = r[e], s = t[3] || t[2];
    if (s) return s;
  }
}
let gL = class {
  constructor(e) {
    this.input = e, this.root = new dL(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let t = new hL();
    t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
    let s, i, n, a = !1, o = !1, u = [], l = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), s = e[0], s === "(" || s === "[" ? l.push(s === "(" ? ")" : "]") : s === "{" && l.length > 0 ? l.push("}") : s === l[l.length - 1] && l.pop(), l.length === 0)
        if (s === ";") {
          t.source.end = this.getPosition(e[2]), t.source.end.offset++, this.semicolon = !0;
          break;
        } else if (s === "{") {
          o = !0;
          break;
        } else if (s === "}") {
          if (u.length > 0) {
            for (n = u.length - 1, i = u[n]; i && i[0] === "space"; )
              i = u[--n];
            i && (t.source.end = this.getPosition(i[3] || i[2]), t.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          u.push(e);
      else
        u.push(e);
      if (this.tokenizer.endOfFile()) {
        a = !0;
        break;
      }
    }
    t.raws.between = this.spacesAndCommentsFromEnd(u), u.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(u), this.raw(t, "params", u), a && (e = u[u.length - 1], t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++, this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), o && (t.nodes = [], this.current = t);
  }
  checkMissedSemicolon(e) {
    let t = this.colon(e);
    if (t === !1) return;
    let s = 0, i;
    for (let n = t - 1; n >= 0 && (i = e[n], !(i[0] !== "space" && (s += 1, s === 2))); n--)
      ;
    throw this.input.error(
      "Missed semicolon",
      i[0] === "word" ? i[3] + 1 : i[2]
    );
  }
  colon(e) {
    let t = 0, s, i, n;
    for (let [a, o] of e.entries()) {
      if (s = o, i = s[0], i === "(" && (t += 1), i === ")" && (t -= 1), t === 0 && i === ":")
        if (!n)
          this.doubleColon(s);
        else {
          if (n[0] === "word" && n[1] === "progid")
            continue;
          return a;
        }
      n = s;
    }
    return !1;
  }
  comment(e) {
    let t = new pL();
    this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++;
    let s = e[1].slice(2, -2);
    if (/^\s*$/.test(s))
      t.text = "", t.raws.left = s, t.raws.right = "";
    else {
      let i = s.match(/^(\s*)([^]*\S)(\s*)$/);
      t.text = i[2], t.raws.left = i[1], t.raws.right = i[3];
    }
  }
  createTokenizer() {
    this.tokenizer = fL(this.input);
  }
  decl(e, t) {
    let s = new cL();
    this.init(s, e[0][2]);
    let i = e[e.length - 1];
    for (i[0] === ";" && (this.semicolon = !0, e.pop()), s.source.end = this.getPosition(
      i[3] || i[2] || mL(e)
    ), s.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), s.raws.before += e.shift()[1];
    for (s.source.start = this.getPosition(e[0][2]), s.prop = ""; e.length; ) {
      let l = e[0][0];
      if (l === ":" || l === "space" || l === "comment")
        break;
      s.prop += e.shift()[1];
    }
    s.raws.between = "";
    let n;
    for (; e.length; )
      if (n = e.shift(), n[0] === ":") {
        s.raws.between += n[1];
        break;
      } else
        n[0] === "word" && /\w/.test(n[1]) && this.unknownWord([n]), s.raws.between += n[1];
    (s.prop[0] === "_" || s.prop[0] === "*") && (s.raws.before += s.prop[0], s.prop = s.prop.slice(1));
    let a = [], o;
    for (; e.length && (o = e[0][0], !(o !== "space" && o !== "comment")); )
      a.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let l = e.length - 1; l >= 0; l--) {
      if (n = e[l], n[1].toLowerCase() === "!important") {
        s.important = !0;
        let c = this.stringFrom(e, l);
        c = this.spacesFromEnd(e) + c, c !== " !important" && (s.raws.important = c);
        break;
      } else if (n[1].toLowerCase() === "important") {
        let c = e.slice(0), f = "";
        for (let p = l; p > 0; p--) {
          let h = c[p][0];
          if (f.trim().indexOf("!") === 0 && h !== "space")
            break;
          f = c.pop()[1] + f;
        }
        f.trim().indexOf("!") === 0 && (s.important = !0, s.raws.important = f, e = c);
      }
      if (n[0] !== "space" && n[0] !== "comment")
        break;
    }
    e.some((l) => l[0] !== "space" && l[0] !== "comment") && (s.raws.between += a.map((l) => l[1]).join(""), a = []), this.raw(s, "value", a.concat(e), t), s.value.includes(":") && !t && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let t = new L1();
    this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let t = this.current.nodes[this.current.nodes.length - 1];
      t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "");
    }
  }
  // Helpers
  getPosition(e) {
    let t = this.input.fromOffset(e);
    return {
      column: t.col,
      line: t.line,
      offset: e
    };
  }
  init(e, t) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(t)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let t = !1, s = null, i = !1, n = null, a = [], o = e[1].startsWith("--"), u = [], l = e;
    for (; l; ) {
      if (s = l[0], u.push(l), s === "(" || s === "[")
        n || (n = l), a.push(s === "(" ? ")" : "]");
      else if (o && i && s === "{")
        n || (n = l), a.push("}");
      else if (a.length === 0)
        if (s === ";")
          if (i) {
            this.decl(u, o);
            return;
          } else
            break;
        else if (s === "{") {
          this.rule(u);
          return;
        } else if (s === "}") {
          this.tokenizer.back(u.pop()), t = !0;
          break;
        } else s === ":" && (i = !0);
      else s === a[a.length - 1] && (a.pop(), a.length === 0 && (n = null));
      l = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (t = !0), a.length > 0 && this.unclosedBracket(n), t && i) {
      if (!o)
        for (; u.length && (l = u[u.length - 1][0], !(l !== "space" && l !== "comment")); )
          this.tokenizer.back(u.pop());
      this.decl(u, o);
    } else
      this.unknownWord(u);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, t, s, i) {
    let n, a, o = s.length, u = "", l = !0, c, f;
    for (let p = 0; p < o; p += 1)
      n = s[p], a = n[0], a === "space" && p === o - 1 && !i ? l = !1 : a === "comment" ? (f = s[p - 1] ? s[p - 1][0] : "empty", c = s[p + 1] ? s[p + 1][0] : "empty", !M1[f] && !M1[c] ? u.slice(-1) === "," ? l = !1 : u += n[1] : l = !1) : u += n[1];
    if (!l) {
      let p = s.reduce((h, m) => h + m[1], "");
      e.raws[t] = { raw: p, value: u };
    }
    e[t] = u;
  }
  rule(e) {
    e.pop();
    let t = new L1();
    this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
  }
  spacesAndCommentsFromEnd(e) {
    let t, s = "";
    for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment")); )
      s = e.pop()[1] + s;
    return s;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let t, s = "";
    for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment")); )
      s += e.shift()[1];
    return s;
  }
  spacesFromEnd(e) {
    let t, s = "";
    for (; e.length && (t = e[e.length - 1][0], t === "space"); )
      s = e.pop()[1] + s;
    return s;
  }
  stringFrom(e, t) {
    let s = "";
    for (let i = t; i < e.length; i++)
      s += e[i][1];
    return e.splice(t, e.length - t), s;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word",
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, t) {
    throw this.input.error(
      "At-rule without name",
      { offset: t[2] },
      { offset: t[2] + t[1].length }
    );
  }
};
var yL = gL;
let bL = on, vL = yL, EL = sf;
function jl(r, e) {
  let t = new EL(r, e), s = new vL(t);
  try {
    s.parse();
  } catch (i) {
    throw Zt.env.NODE_ENV !== "production" && i.name === "CssSyntaxError" && e && e.from && (/\.scss$/i.test(e.from) ? i.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(e.from) ? i.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(e.from) && (i.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), i;
  }
  return s.root;
}
var O0 = jl;
jl.default = jl;
bL.registerParse(jl);
let { isClean: Lr, my: SL } = Go, _L = Z_, xL = ef, wL = on, TL = P0, PL = fx, R1 = A0, AL = O0, CL = Ko;
const NL = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, OL = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, IL = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, qn = 0;
function _a(r) {
  return typeof r == "object" && typeof r.then == "function";
}
function vx(r) {
  let e = !1, t = NL[r.type];
  return r.type === "decl" ? e = r.prop.toLowerCase() : r.type === "atrule" && (e = r.name.toLowerCase()), e && r.append ? [
    t,
    t + "-" + e,
    qn,
    t + "Exit",
    t + "Exit-" + e
  ] : e ? [t, t + "-" + e, t + "Exit", t + "Exit-" + e] : r.append ? [t, qn, t + "Exit"] : [t, t + "Exit"];
}
function $1(r) {
  let e;
  return r.type === "document" ? e = ["Document", qn, "DocumentExit"] : r.type === "root" ? e = ["Root", qn, "RootExit"] : e = vx(r), {
    eventIndex: 0,
    events: e,
    iterator: 0,
    node: r,
    visitorIndex: 0,
    visitors: []
  };
}
function Eh(r) {
  return r[Lr] = !1, r.nodes && r.nodes.forEach((e) => Eh(e)), r;
}
let Sh = {}, Hn = class Ex {
  constructor(e, t, s) {
    this.stringified = !1, this.processed = !1;
    let i;
    if (typeof t == "object" && t !== null && (t.type === "root" || t.type === "document"))
      i = Eh(t);
    else if (t instanceof Ex || t instanceof R1)
      i = Eh(t.root), t.map && (typeof s.map > "u" && (s.map = {}), s.map.inline || (s.map.inline = !1), s.map.prev = t.map);
    else {
      let n = AL;
      s.syntax && (n = s.syntax.parse), s.parser && (n = s.parser), n.parse && (n = n.parse);
      try {
        i = n(t, s);
      } catch (a) {
        this.processed = !0, this.error = a;
      }
      i && !i[SL] && wL.rebuild(i);
    }
    this.result = new R1(e, i, s), this.helpers = { ...Sh, postcss: Sh, result: this.result }, this.plugins = this.processor.plugins.map((n) => typeof n == "object" && n.prepare ? { ...n, ...n.prepare(this.result) } : n);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, t) {
    let s = this.result.lastPlugin;
    try {
      if (t && t.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin)
        e.plugin = s.postcssPlugin, e.setMessage();
      else if (s.postcssVersion && Zt.env.NODE_ENV !== "production") {
        let i = s.postcssPlugin, n = s.postcssVersion, a = this.result.processor.version, o = n.split("."), u = a.split(".");
        (o[0] !== u[0] || parseInt(o[1]) > parseInt(u[1])) && console.error(
          "Unknown error from PostCSS plugin. Your current PostCSS version is " + a + ", but " + i + " uses " + n + ". Perhaps this is the source of the error below."
        );
      }
    } catch (i) {
      console && console.error && console.error(i);
    }
    return e;
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (t, s, i) => {
      this.listeners[s] || (this.listeners[s] = []), this.listeners[s].push([t, i]);
    };
    for (let t of this.plugins)
      if (typeof t == "object")
        for (let s in t) {
          if (!OL[s] && /^[A-Z]/.test(s))
            throw new Error(
              `Unknown event ${s} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!IL[s])
            if (typeof t[s] == "object")
              for (let i in t[s])
                i === "*" ? e(t, s, t[s][i]) : e(
                  t,
                  s + "-" + i.toLowerCase(),
                  t[s][i]
                );
            else typeof t[s] == "function" && e(t, s, t[s]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let e = 0; e < this.plugins.length; e++) {
      let t = this.plugins[e], s = this.runOnRoot(t);
      if (_a(s))
        try {
          await s;
        } catch (i) {
          throw this.handleError(i);
        }
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Lr]; ) {
        e[Lr] = !0;
        let t = [$1(e)];
        for (; t.length > 0; ) {
          let s = this.visitTick(t);
          if (_a(s))
            try {
              await s;
            } catch (i) {
              let n = t[t.length - 1].node;
              throw this.handleError(i, n);
            }
        }
      }
      if (this.listeners.OnceExit)
        for (let [t, s] of this.listeners.OnceExit) {
          this.result.lastPlugin = t;
          try {
            if (e.type === "document") {
              let i = e.nodes.map(
                (n) => s(n, this.helpers)
              );
              await Promise.all(i);
            } else
              await s(e, this.helpers);
          } catch (i) {
            throw this.handleError(i);
          }
        }
    }
    return this.processed = !0, this.stringify();
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let t = this.result.root.nodes.map(
            (s) => e.Once(s, this.helpers)
          );
          return _a(t[0]) ? Promise.all(t) : t;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (t) {
      throw this.handleError(t);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, t = xL;
    e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
    let i = new _L(t, this.result.root, this.result.opts).generate();
    return this.result.css = i[0], this.result.map = i[1], this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let t = this.runOnRoot(e);
      if (_a(t))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Lr]; )
        e[Lr] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let t of e.nodes)
            this.visitSync(this.listeners.OnceExit, t);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  then(e, t) {
    return Zt.env.NODE_ENV !== "production" && ("from" in this.opts || PL(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this.css;
  }
  visitSync(e, t) {
    for (let [s, i] of e) {
      this.result.lastPlugin = s;
      let n;
      try {
        n = i(t, this.helpers);
      } catch (a) {
        throw this.handleError(a, t.proxyOf);
      }
      if (t.type !== "root" && t.type !== "document" && !t.parent)
        return !0;
      if (_a(n))
        throw this.getAsyncError();
    }
  }
  visitTick(e) {
    let t = e[e.length - 1], { node: s, visitors: i } = t;
    if (s.type !== "root" && s.type !== "document" && !s.parent) {
      e.pop();
      return;
    }
    if (i.length > 0 && t.visitorIndex < i.length) {
      let [a, o] = i[t.visitorIndex];
      t.visitorIndex += 1, t.visitorIndex === i.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = a;
      try {
        return o(s.toProxy(), this.helpers);
      } catch (u) {
        throw this.handleError(u, s);
      }
    }
    if (t.iterator !== 0) {
      let a = t.iterator, o;
      for (; o = s.nodes[s.indexes[a]]; )
        if (s.indexes[a] += 1, !o[Lr]) {
          o[Lr] = !0, e.push($1(o));
          return;
        }
      t.iterator = 0, delete s.indexes[a];
    }
    let n = t.events;
    for (; t.eventIndex < n.length; ) {
      let a = n[t.eventIndex];
      if (t.eventIndex += 1, a === qn) {
        s.nodes && s.nodes.length && (s[Lr] = !0, t.iterator = s.getIterator());
        return;
      } else if (this.listeners[a]) {
        t.visitors = this.listeners[a];
        return;
      }
    }
    e.pop();
  }
  walkSync(e) {
    e[Lr] = !0;
    let t = vx(e);
    for (let s of t)
      if (s === qn)
        e.nodes && e.each((i) => {
          i[Lr] || this.walkSync(i);
        });
      else {
        let i = this.listeners[s];
        if (i && this.visitSync(i, e.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
Hn.registerPostcss = (r) => {
  Sh = r;
};
var Sx = Hn;
Hn.default = Hn;
CL.registerLazyResult(Hn);
TL.registerLazyResult(Hn);
let kL = Z_, DL = ef, LL = fx, ML = O0;
const RL = A0;
let _h = class {
  constructor(e, t, s) {
    t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = s, this._map = void 0;
    let i, n = DL;
    this.result = new RL(this._processor, i, this._opts), this.result.css = t;
    let a = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return a.root;
      }
    });
    let o = new kL(n, i, this._opts, t);
    if (o.isMap()) {
      let [u, l] = o.generate();
      u && (this.result.css = u), l && (this.result.map = l);
    } else
      o.clearAnnotation(), this.result.css = o.css;
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(e, t) {
    return Zt.env.NODE_ENV !== "production" && ("from" in this._opts || LL(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, t = ML;
    try {
      e = t(this._css, this._opts);
    } catch (s) {
      this.error = s;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var $L = _h;
_h.default = _h;
let FL = $L, BL = Sx, VL = P0, UL = Ko, _o = class {
  constructor(e = []) {
    this.version = "8.4.40", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let t = [];
    for (let s of e)
      if (s.postcss === !0 ? s = s() : s.postcss && (s = s.postcss), typeof s == "object" && Array.isArray(s.plugins))
        t = t.concat(s.plugins);
      else if (typeof s == "object" && s.postcssPlugin)
        t.push(s);
      else if (typeof s == "function")
        t.push(s);
      else if (typeof s == "object" && (s.parse || s.stringify)) {
        if (Zt.env.NODE_ENV !== "production")
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
      } else
        throw new Error(s + " is not a PostCSS plugin");
    return t;
  }
  process(e, t = {}) {
    return !this.plugins.length && !t.parser && !t.stringifier && !t.syntax ? new FL(this, e, t) : new BL(this, e, t);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var jL = _o;
_o.default = _o;
UL.registerProcessor(_o);
VL.registerProcessor(_o);
let qL = rf, HL = K_, WL = nf, zL = C0, GL = sf, KL = Ko, XL = N0;
function xo(r, e) {
  if (Array.isArray(r)) return r.map((i) => xo(i));
  let { inputs: t, ...s } = r;
  if (t) {
    e = [];
    for (let i of t) {
      let n = { ...i, __proto__: GL.prototype };
      n.map && (n.map = {
        ...n.map,
        __proto__: HL.prototype
      }), e.push(n);
    }
  }
  if (s.nodes && (s.nodes = r.nodes.map((i) => xo(i, e))), s.source) {
    let { inputId: i, ...n } = s.source;
    s.source = n, i != null && (s.source.input = e[i]);
  }
  if (s.type === "root")
    return new KL(s);
  if (s.type === "decl")
    return new qL(s);
  if (s.type === "rule")
    return new XL(s);
  if (s.type === "comment")
    return new WL(s);
  if (s.type === "atrule")
    return new zL(s);
  throw new Error("Unknown node type: " + r.type);
}
var JL = xo;
xo.default = xo;
let YL = x0, _x = rf, QL = Sx, ZL = on, I0 = jL, eM = ef, tM = JL, xx = P0, rM = px, wx = nf, Tx = C0, sM = A0, iM = sf, nM = O0, aM = yx, Px = N0, Ax = Ko, oM = tf;
function je(...r) {
  return r.length === 1 && Array.isArray(r[0]) && (r = r[0]), new I0(r);
}
je.plugin = function(e, t) {
  let s = !1;
  function i(...a) {
    console && console.warn && !s && (s = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), Zt.env.LANG && Zt.env.LANG.startsWith("cn") && console.warn(
      e + `: 里面 postcss.plugin 被弃用. 迁移指南:
https://www.w3ctech.com/topic/2226`
    ));
    let o = t(...a);
    return o.postcssPlugin = e, o.postcssVersion = new I0().version, o;
  }
  let n;
  return Object.defineProperty(i, "postcss", {
    get() {
      return n || (n = i()), n;
    }
  }), i.process = function(a, o, u) {
    return je([i(u)]).process(a, o);
  }, i;
};
je.stringify = eM;
je.parse = nM;
je.fromJSON = tM;
je.list = aM;
je.comment = (r) => new wx(r);
je.atRule = (r) => new Tx(r);
je.decl = (r) => new _x(r);
je.rule = (r) => new Px(r);
je.root = (r) => new Ax(r);
je.document = (r) => new xx(r);
je.CssSyntaxError = YL;
je.Declaration = _x;
je.Container = ZL;
je.Processor = I0;
je.Document = xx;
je.Comment = wx;
je.Warning = rM;
je.AtRule = Tx;
je.Result = sM;
je.Input = iM;
je.Rule = Px;
je.Root = Ax;
je.Node = oM;
QL.registerPostcss(je);
var uM = je;
je.default = je;
var Ze = /* @__PURE__ */ Dc(uM);
Ze.stringify;
Ze.fromJSON;
Ze.plugin;
Ze.parse;
Ze.list;
Ze.document;
Ze.comment;
Ze.atRule;
Ze.rule;
Ze.decl;
Ze.root;
Ze.CssSyntaxError;
Ze.Declaration;
Ze.Container;
Ze.Processor;
Ze.Document;
Ze.Comment;
Ze.Warning;
Ze.AtRule;
Ze.Result;
Ze.Input;
Ze.Rule;
Ze.Root;
Ze.Node;
const Cx = () => ({
  postcssPlugin: "vue-sfc-trim",
  Once(r) {
    r.walk(({ type: e, raws: t }) => {
      (e === "rule" || e === "atrule") && (t.before && (t.before = `
`), "after" in t && t.after && (t.after = `
`));
    });
  }
});
Cx.postcss = !0;
var xh = { exports: {} }, wh = { exports: {} }, Th = { exports: {} }, Ph = { exports: {} }, Ah = { exports: {} }, Ch = { exports: {} }, nr = {}, Nh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = i;
  function t(n) {
    for (var a = n.toLowerCase(), o = "", u = !1, l = 0; l < 6 && a[l] !== void 0; l++) {
      var c = a.charCodeAt(l), f = c >= 97 && c <= 102 || c >= 48 && c <= 57;
      if (u = c === 32, !f)
        break;
      o += a[l];
    }
    if (o.length !== 0) {
      var p = parseInt(o, 16), h = p >= 55296 && p <= 57343;
      return h || p === 0 || p > 1114111 ? ["�", o.length + (u ? 1 : 0)] : [String.fromCodePoint(p), o.length + (u ? 1 : 0)];
    }
  }
  var s = /\\/;
  function i(n) {
    var a = s.test(n);
    if (!a)
      return n;
    for (var o = "", u = 0; u < n.length; u++) {
      if (n[u] === "\\") {
        var l = t(n.slice(u + 1, u + 7));
        if (l !== void 0) {
          o += l[0], u += l[1];
          continue;
        }
        if (n[u + 1] === "\\") {
          o += "\\", u++;
          continue;
        }
        n.length === u + 1 && (o += n[u]);
        continue;
      }
      o += n[u];
    }
    return o;
  }
  r.exports = e.default;
})(Nh, Nh.exports);
var Nx = Nh.exports, Oh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = t;
  function t(s) {
    for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
      n[a - 1] = arguments[a];
    for (; n.length > 0; ) {
      var o = n.shift();
      if (!s[o])
        return;
      s = s[o];
    }
    return s;
  }
  r.exports = e.default;
})(Oh, Oh.exports);
var lM = Oh.exports, Ih = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = t;
  function t(s) {
    for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
      n[a - 1] = arguments[a];
    for (; n.length > 0; ) {
      var o = n.shift();
      s[o] || (s[o] = {}), s = s[o];
    }
  }
  r.exports = e.default;
})(Ih, Ih.exports);
var cM = Ih.exports, kh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = t;
  function t(s) {
    for (var i = "", n = s.indexOf("/*"), a = 0; n >= 0; ) {
      i = i + s.slice(a, n);
      var o = s.indexOf("*/", n + 2);
      if (o < 0)
        return i;
      a = o + 2, n = s.indexOf("/*", a);
    }
    return i = i + s.slice(a), i;
  }
  r.exports = e.default;
})(kh, kh.exports);
var fM = kh.exports;
nr.__esModule = !0;
nr.unesc = nr.stripComments = nr.getProp = nr.ensureObject = void 0;
var pM = af(Nx);
nr.unesc = pM.default;
var hM = af(lM);
nr.getProp = hM.default;
var dM = af(cM);
nr.ensureObject = dM.default;
var mM = af(fM);
nr.stripComments = mM.default;
function af(r) {
  return r && r.__esModule ? r : { default: r };
}
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = nr;
  function s(o, u) {
    for (var l = 0; l < u.length; l++) {
      var c = u[l];
      c.enumerable = c.enumerable || !1, c.configurable = !0, "value" in c && (c.writable = !0), Object.defineProperty(o, c.key, c);
    }
  }
  function i(o, u, l) {
    return u && s(o.prototype, u), Object.defineProperty(o, "prototype", { writable: !1 }), o;
  }
  var n = function o(u, l) {
    if (typeof u != "object" || u === null)
      return u;
    var c = new u.constructor();
    for (var f in u)
      if (u.hasOwnProperty(f)) {
        var p = u[f], h = typeof p;
        f === "parent" && h === "object" ? l && (c[f] = l) : p instanceof Array ? c[f] = p.map(function(m) {
          return o(m, c);
        }) : c[f] = o(p, c);
      }
    return c;
  }, a = /* @__PURE__ */ function() {
    function o(l) {
      l === void 0 && (l = {}), Object.assign(this, l), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var u = o.prototype;
    return u.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, u.replaceWith = function() {
      if (this.parent) {
        for (var c in arguments)
          this.parent.insertBefore(this, arguments[c]);
        this.remove();
      }
      return this;
    }, u.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, u.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, u.clone = function(c) {
      c === void 0 && (c = {});
      var f = n(this);
      for (var p in c)
        f[p] = c[p];
      return f;
    }, u.appendToPropertyAndEscape = function(c, f, p) {
      this.raws || (this.raws = {});
      var h = this[c], m = this.raws[c];
      this[c] = h + f, m || p !== f ? this.raws[c] = (m || h) + p : delete this.raws[c];
    }, u.setPropertyAndEscape = function(c, f, p) {
      this.raws || (this.raws = {}), this[c] = f, this.raws[c] = p;
    }, u.setPropertyWithoutEscape = function(c, f) {
      this[c] = f, this.raws && delete this.raws[c];
    }, u.isAtPosition = function(c, f) {
      if (this.source && this.source.start && this.source.end)
        return !(this.source.start.line > c || this.source.end.line < c || this.source.start.line === c && this.source.start.column > f || this.source.end.line === c && this.source.end.column < f);
    }, u.stringifyProperty = function(c) {
      return this.raws && this.raws[c] || this[c];
    }, u.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, u.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, i(o, [{
      key: "rawSpaceBefore",
      get: function() {
        var c = this.raws && this.raws.spaces && this.raws.spaces.before;
        return c === void 0 && (c = this.spaces && this.spaces.before), c || "";
      },
      set: function(c) {
        (0, t.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = c;
      }
    }, {
      key: "rawSpaceAfter",
      get: function() {
        var c = this.raws && this.raws.spaces && this.raws.spaces.after;
        return c === void 0 && (c = this.spaces.after), c || "";
      },
      set: function(c) {
        (0, t.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = c;
      }
    }]), o;
  }();
  e.default = a, r.exports = e.default;
})(Ch, Ch.exports);
var di = Ch.exports, Se = {};
Se.__esModule = !0;
Se.UNIVERSAL = Se.TAG = Se.STRING = Se.SELECTOR = Se.ROOT = Se.PSEUDO = Se.NESTING = Se.ID = Se.COMMENT = Se.COMBINATOR = Se.CLASS = Se.ATTRIBUTE = void 0;
var gM = "tag";
Se.TAG = gM;
var yM = "string";
Se.STRING = yM;
var bM = "selector";
Se.SELECTOR = bM;
var vM = "root";
Se.ROOT = vM;
var EM = "pseudo";
Se.PSEUDO = EM;
var SM = "nesting";
Se.NESTING = SM;
var _M = "id";
Se.ID = _M;
var xM = "comment";
Se.COMMENT = xM;
var wM = "combinator";
Se.COMBINATOR = wM;
var TM = "class";
Se.CLASS = TM;
var PM = "attribute";
Se.ATTRIBUTE = PM;
var AM = "universal";
Se.UNIVERSAL = AM;
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = a(di), s = n(Se);
  function i(d) {
    if (typeof WeakMap != "function") return null;
    var y = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new WeakMap();
    return (i = function(g) {
      return g ? S : y;
    })(d);
  }
  function n(d, y) {
    if (d && d.__esModule)
      return d;
    if (d === null || typeof d != "object" && typeof d != "function")
      return { default: d };
    var S = i(y);
    if (S && S.has(d))
      return S.get(d);
    var E = {}, g = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var b in d)
      if (b !== "default" && Object.prototype.hasOwnProperty.call(d, b)) {
        var v = g ? Object.getOwnPropertyDescriptor(d, b) : null;
        v && (v.get || v.set) ? Object.defineProperty(E, b, v) : E[b] = d[b];
      }
    return E.default = d, S && S.set(d, E), E;
  }
  function a(d) {
    return d && d.__esModule ? d : { default: d };
  }
  function o(d, y) {
    var S = typeof Symbol < "u" && d[Symbol.iterator] || d["@@iterator"];
    if (S) return (S = S.call(d)).next.bind(S);
    if (Array.isArray(d) || (S = u(d)) || y) {
      S && (d = S);
      var E = 0;
      return function() {
        return E >= d.length ? { done: !0 } : { done: !1, value: d[E++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function u(d, y) {
    if (d) {
      if (typeof d == "string") return l(d, y);
      var S = Object.prototype.toString.call(d).slice(8, -1);
      if (S === "Object" && d.constructor && (S = d.constructor.name), S === "Map" || S === "Set") return Array.from(d);
      if (S === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(S)) return l(d, y);
    }
  }
  function l(d, y) {
    (y == null || y > d.length) && (y = d.length);
    for (var S = 0, E = new Array(y); S < y; S++)
      E[S] = d[S];
    return E;
  }
  function c(d, y) {
    for (var S = 0; S < y.length; S++) {
      var E = y[S];
      E.enumerable = E.enumerable || !1, E.configurable = !0, "value" in E && (E.writable = !0), Object.defineProperty(d, E.key, E);
    }
  }
  function f(d, y, S) {
    return y && c(d.prototype, y), Object.defineProperty(d, "prototype", { writable: !1 }), d;
  }
  function p(d, y) {
    d.prototype = Object.create(y.prototype), d.prototype.constructor = d, h(d, y);
  }
  function h(d, y) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(E, g) {
      return E.__proto__ = g, E;
    }, h(d, y);
  }
  var m = /* @__PURE__ */ function(d) {
    p(y, d);
    function y(E) {
      var g;
      return g = d.call(this, E) || this, g.nodes || (g.nodes = []), g;
    }
    var S = y.prototype;
    return S.append = function(g) {
      return g.parent = this, this.nodes.push(g), this;
    }, S.prepend = function(g) {
      return g.parent = this, this.nodes.unshift(g), this;
    }, S.at = function(g) {
      return this.nodes[g];
    }, S.index = function(g) {
      return typeof g == "number" ? g : this.nodes.indexOf(g);
    }, S.removeChild = function(g) {
      g = this.index(g), this.at(g).parent = void 0, this.nodes.splice(g, 1);
      var b;
      for (var v in this.indexes)
        b = this.indexes[v], b >= g && (this.indexes[v] = b - 1);
      return this;
    }, S.removeAll = function() {
      for (var g = o(this.nodes), b; !(b = g()).done; ) {
        var v = b.value;
        v.parent = void 0;
      }
      return this.nodes = [], this;
    }, S.empty = function() {
      return this.removeAll();
    }, S.insertAfter = function(g, b) {
      b.parent = this;
      var v = this.index(g);
      this.nodes.splice(v + 1, 0, b), b.parent = this;
      var A;
      for (var C in this.indexes)
        A = this.indexes[C], v <= A && (this.indexes[C] = A + 1);
      return this;
    }, S.insertBefore = function(g, b) {
      b.parent = this;
      var v = this.index(g);
      this.nodes.splice(v, 0, b), b.parent = this;
      var A;
      for (var C in this.indexes)
        A = this.indexes[C], A <= v && (this.indexes[C] = A + 1);
      return this;
    }, S._findChildAtPosition = function(g, b) {
      var v = void 0;
      return this.each(function(A) {
        if (A.atPosition) {
          var C = A.atPosition(g, b);
          if (C)
            return v = C, !1;
        } else if (A.isAtPosition(g, b))
          return v = A, !1;
      }), v;
    }, S.atPosition = function(g, b) {
      if (this.isAtPosition(g, b))
        return this._findChildAtPosition(g, b) || this;
    }, S._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, S.each = function(g) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var b = this.lastEach;
      if (this.indexes[b] = 0, !!this.length) {
        for (var v, A; this.indexes[b] < this.length && (v = this.indexes[b], A = g(this.at(v), v), A !== !1); )
          this.indexes[b] += 1;
        if (delete this.indexes[b], A === !1)
          return !1;
      }
    }, S.walk = function(g) {
      return this.each(function(b, v) {
        var A = g(b, v);
        if (A !== !1 && b.length && (A = b.walk(g)), A === !1)
          return !1;
      });
    }, S.walkAttributes = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.ATTRIBUTE)
          return g.call(b, v);
      });
    }, S.walkClasses = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.CLASS)
          return g.call(b, v);
      });
    }, S.walkCombinators = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.COMBINATOR)
          return g.call(b, v);
      });
    }, S.walkComments = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.COMMENT)
          return g.call(b, v);
      });
    }, S.walkIds = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.ID)
          return g.call(b, v);
      });
    }, S.walkNesting = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.NESTING)
          return g.call(b, v);
      });
    }, S.walkPseudos = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.PSEUDO)
          return g.call(b, v);
      });
    }, S.walkTags = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.TAG)
          return g.call(b, v);
      });
    }, S.walkUniversals = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.UNIVERSAL)
          return g.call(b, v);
      });
    }, S.split = function(g) {
      var b = this, v = [];
      return this.reduce(function(A, C, x) {
        var _ = g.call(b, C);
        return v.push(C), _ ? (A.push(v), v = []) : x === b.length - 1 && A.push(v), A;
      }, []);
    }, S.map = function(g) {
      return this.nodes.map(g);
    }, S.reduce = function(g, b) {
      return this.nodes.reduce(g, b);
    }, S.every = function(g) {
      return this.nodes.every(g);
    }, S.some = function(g) {
      return this.nodes.some(g);
    }, S.filter = function(g) {
      return this.nodes.filter(g);
    }, S.sort = function(g) {
      return this.nodes.sort(g);
    }, S.toString = function() {
      return this.map(String).join("");
    }, f(y, [{
      key: "first",
      get: function() {
        return this.at(0);
      }
    }, {
      key: "last",
      get: function() {
        return this.at(this.length - 1);
      }
    }, {
      key: "length",
      get: function() {
        return this.nodes.length;
      }
    }]), y;
  }(t.default);
  e.default = m, r.exports = e.default;
})(Ah, Ah.exports);
var k0 = Ah.exports;
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(k0), s = Se;
  function i(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function n(c, f) {
    for (var p = 0; p < f.length; p++) {
      var h = f[p];
      h.enumerable = h.enumerable || !1, h.configurable = !0, "value" in h && (h.writable = !0), Object.defineProperty(c, h.key, h);
    }
  }
  function a(c, f, p) {
    return f && n(c.prototype, f), Object.defineProperty(c, "prototype", { writable: !1 }), c;
  }
  function o(c, f) {
    c.prototype = Object.create(f.prototype), c.prototype.constructor = c, u(c, f);
  }
  function u(c, f) {
    return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(h, m) {
      return h.__proto__ = m, h;
    }, u(c, f);
  }
  var l = /* @__PURE__ */ function(c) {
    o(f, c);
    function f(h) {
      var m;
      return m = c.call(this, h) || this, m.type = s.ROOT, m;
    }
    var p = f.prototype;
    return p.toString = function() {
      var m = this.reduce(function(d, y) {
        return d.push(String(y)), d;
      }, []).join(",");
      return this.trailingComma ? m + "," : m;
    }, p.error = function(m, d) {
      return this._error ? this._error(m, d) : new Error(m);
    }, a(f, [{
      key: "errorGenerator",
      set: function(m) {
        this._error = m;
      }
    }]), f;
  }(t.default);
  e.default = l, r.exports = e.default;
})(Ph, Ph.exports);
var Ox = Ph.exports, Dh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(k0), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.SELECTOR, f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(Dh, Dh.exports);
var Ix = Dh.exports, Lh = { exports: {} };
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var CM = {}, NM = CM.hasOwnProperty, OM = function(e, t) {
  if (!e)
    return t;
  var s = {};
  for (var i in t)
    s[i] = NM.call(e, i) ? e[i] : t[i];
  return s;
}, IM = /[ -,\.\/:-@\[-\^`\{-~]/, kM = /[ -,\.\/:-@\[\]\^`\{-~]/, DM = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, D0 = function r(e, t) {
  t = OM(t, r.options), t.quotes != "single" && t.quotes != "double" && (t.quotes = "single");
  for (var s = t.quotes == "double" ? '"' : "'", i = t.isIdentifier, n = e.charAt(0), a = "", o = 0, u = e.length; o < u; ) {
    var l = e.charAt(o++), c = l.charCodeAt(), f = void 0;
    if (c < 32 || c > 126) {
      if (c >= 55296 && c <= 56319 && o < u) {
        var p = e.charCodeAt(o++);
        (p & 64512) == 56320 ? c = ((c & 1023) << 10) + (p & 1023) + 65536 : o--;
      }
      f = "\\" + c.toString(16).toUpperCase() + " ";
    } else
      t.escapeEverything ? IM.test(l) ? f = "\\" + l : f = "\\" + c.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(l) ? f = "\\" + c.toString(16).toUpperCase() + " " : l == "\\" || !i && (l == '"' && s == l || l == "'" && s == l) || i && kM.test(l) ? f = "\\" + l : f = l;
    a += f;
  }
  return i && (/^-[-\d]/.test(a) ? a = "\\-" + a.slice(1) : /\d/.test(n) && (a = "\\3" + n + " " + a.slice(1))), a = a.replace(DM, function(h, m, d) {
    return m && m.length % 2 ? h : (m || "") + d;
  }), !i && t.wrap ? s + a + s : a;
};
D0.options = {
  escapeEverything: !1,
  isIdentifier: !1,
  quotes: "single",
  wrap: !1
};
D0.version = "3.0.0";
var L0 = D0;
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = a(L0), s = nr, i = a(di), n = Se;
  function a(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, h) {
    for (var m = 0; m < h.length; m++) {
      var d = h[m];
      d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(p, d.key, d);
    }
  }
  function u(p, h, m) {
    return h && o(p.prototype, h), Object.defineProperty(p, "prototype", { writable: !1 }), p;
  }
  function l(p, h) {
    p.prototype = Object.create(h.prototype), p.prototype.constructor = p, c(p, h);
  }
  function c(p, h) {
    return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, y) {
      return d.__proto__ = y, d;
    }, c(p, h);
  }
  var f = /* @__PURE__ */ function(p) {
    l(h, p);
    function h(d) {
      var y;
      return y = p.call(this, d) || this, y.type = n.CLASS, y._constructed = !0, y;
    }
    var m = h.prototype;
    return m.valueToString = function() {
      return "." + p.prototype.valueToString.call(this);
    }, u(h, [{
      key: "value",
      get: function() {
        return this._value;
      },
      set: function(y) {
        if (this._constructed) {
          var S = (0, t.default)(y, {
            isIdentifier: !0
          });
          S !== y ? ((0, s.ensureObject)(this, "raws"), this.raws.value = S) : this.raws && delete this.raws.value;
        }
        this._value = y;
      }
    }]), h;
  }(i.default);
  e.default = f, r.exports = e.default;
})(Lh, Lh.exports);
var kx = Lh.exports, Mh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(di), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.COMMENT, f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(Mh, Mh.exports);
var Dx = Mh.exports, Rh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(di), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(f) {
      var p;
      return p = u.call(this, f) || this, p.type = s.ID, p;
    }
    var c = l.prototype;
    return c.valueToString = function() {
      return "#" + u.prototype.valueToString.call(this);
    }, l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(Rh, Rh.exports);
var Lx = Rh.exports, $h = { exports: {} }, Fh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = n(L0), s = nr, i = n(di);
  function n(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function a(f, p) {
    for (var h = 0; h < p.length; h++) {
      var m = p[h];
      m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(f, m.key, m);
    }
  }
  function o(f, p, h) {
    return p && a(f.prototype, p), Object.defineProperty(f, "prototype", { writable: !1 }), f;
  }
  function u(f, p) {
    f.prototype = Object.create(p.prototype), f.prototype.constructor = f, l(f, p);
  }
  function l(f, p) {
    return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, d) {
      return m.__proto__ = d, m;
    }, l(f, p);
  }
  var c = /* @__PURE__ */ function(f) {
    u(p, f);
    function p() {
      return f.apply(this, arguments) || this;
    }
    var h = p.prototype;
    return h.qualifiedName = function(d) {
      return this.namespace ? this.namespaceString + "|" + d : d;
    }, h.valueToString = function() {
      return this.qualifiedName(f.prototype.valueToString.call(this));
    }, o(p, [{
      key: "namespace",
      get: function() {
        return this._namespace;
      },
      set: function(d) {
        if (d === !0 || d === "*" || d === "&") {
          this._namespace = d, this.raws && delete this.raws.namespace;
          return;
        }
        var y = (0, t.default)(d, {
          isIdentifier: !0
        });
        this._namespace = d, y !== d ? ((0, s.ensureObject)(this, "raws"), this.raws.namespace = y) : this.raws && delete this.raws.namespace;
      }
    }, {
      key: "ns",
      get: function() {
        return this._namespace;
      },
      set: function(d) {
        this.namespace = d;
      }
    }, {
      key: "namespaceString",
      get: function() {
        if (this.namespace) {
          var d = this.stringifyProperty("namespace");
          return d === !0 ? "" : d;
        } else
          return "";
      }
    }]), p;
  }(i.default);
  e.default = c, r.exports = e.default;
})(Fh, Fh.exports);
var M0 = Fh.exports;
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(M0), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.TAG, f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})($h, $h.exports);
var Mx = $h.exports, Bh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(di), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.STRING, f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(Bh, Bh.exports);
var Rx = Bh.exports, Vh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(k0), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(f) {
      var p;
      return p = u.call(this, f) || this, p.type = s.PSEUDO, p;
    }
    var c = l.prototype;
    return c.toString = function() {
      var p = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), p, this.rawSpaceAfter].join("");
    }, l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(Vh, Vh.exports);
var $x = Vh.exports, R0 = {}, LM = nD.deprecate;
(function(r) {
  r.__esModule = !0, r.default = void 0, r.unescapeValue = y;
  var e = a(L0), t = a(Nx), s = a(M0), i = Se, n;
  function a(v) {
    return v && v.__esModule ? v : { default: v };
  }
  function o(v, A) {
    for (var C = 0; C < A.length; C++) {
      var x = A[C];
      x.enumerable = x.enumerable || !1, x.configurable = !0, "value" in x && (x.writable = !0), Object.defineProperty(v, x.key, x);
    }
  }
  function u(v, A, C) {
    return A && o(v.prototype, A), Object.defineProperty(v, "prototype", { writable: !1 }), v;
  }
  function l(v, A) {
    v.prototype = Object.create(A.prototype), v.prototype.constructor = v, c(v, A);
  }
  function c(v, A) {
    return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(x, _) {
      return x.__proto__ = _, x;
    }, c(v, A);
  }
  var f = LM, p = /^('|")([^]*)\1$/, h = f(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), m = f(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), d = f(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function y(v) {
    var A = !1, C = null, x = v, _ = x.match(p);
    return _ && (C = _[1], x = _[2]), x = (0, t.default)(x), x !== v && (A = !0), {
      deprecatedUsage: A,
      unescaped: x,
      quoteMark: C
    };
  }
  function S(v) {
    if (v.quoteMark !== void 0 || v.value === void 0)
      return v;
    d();
    var A = y(v.value), C = A.quoteMark, x = A.unescaped;
    return v.raws || (v.raws = {}), v.raws.value === void 0 && (v.raws.value = v.value), v.value = x, v.quoteMark = C, v;
  }
  var E = /* @__PURE__ */ function(v) {
    l(A, v);
    function A(x) {
      var _;
      return x === void 0 && (x = {}), _ = v.call(this, S(x)) || this, _.type = i.ATTRIBUTE, _.raws = _.raws || {}, Object.defineProperty(_.raws, "unquoted", {
        get: f(function() {
          return _.value;
        }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
        set: f(function() {
          return _.value;
        }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
      }), _._constructed = !0, _;
    }
    var C = A.prototype;
    return C.getQuotedValue = function(_) {
      _ === void 0 && (_ = {});
      var T = this._determineQuoteMark(_), P = g[T], I = (0, e.default)(this._value, P);
      return I;
    }, C._determineQuoteMark = function(_) {
      return _.smart ? this.smartQuoteMark(_) : this.preferredQuoteMark(_);
    }, C.setValue = function(_, T) {
      T === void 0 && (T = {}), this._value = _, this._quoteMark = this._determineQuoteMark(T), this._syncRawValue();
    }, C.smartQuoteMark = function(_) {
      var T = this.value, P = T.replace(/[^']/g, "").length, I = T.replace(/[^"]/g, "").length;
      if (P + I === 0) {
        var $ = (0, e.default)(T, {
          isIdentifier: !0
        });
        if ($ === T)
          return A.NO_QUOTE;
        var Y = this.preferredQuoteMark(_);
        if (Y === A.NO_QUOTE) {
          var W = this.quoteMark || _.quoteMark || A.DOUBLE_QUOTE, F = g[W], K = (0, e.default)(T, F);
          if (K.length < $.length)
            return W;
        }
        return Y;
      } else return I === P ? this.preferredQuoteMark(_) : I < P ? A.DOUBLE_QUOTE : A.SINGLE_QUOTE;
    }, C.preferredQuoteMark = function(_) {
      var T = _.preferCurrentQuoteMark ? this.quoteMark : _.quoteMark;
      return T === void 0 && (T = _.preferCurrentQuoteMark ? _.quoteMark : this.quoteMark), T === void 0 && (T = A.DOUBLE_QUOTE), T;
    }, C._syncRawValue = function() {
      var _ = (0, e.default)(this._value, g[this.quoteMark]);
      _ === this._value ? this.raws && delete this.raws.value : this.raws.value = _;
    }, C._handleEscapes = function(_, T) {
      if (this._constructed) {
        var P = (0, e.default)(T, {
          isIdentifier: !0
        });
        P !== T ? this.raws[_] = P : delete this.raws[_];
      }
    }, C._spacesFor = function(_) {
      var T = {
        before: "",
        after: ""
      }, P = this.spaces[_] || {}, I = this.raws.spaces && this.raws.spaces[_] || {};
      return Object.assign(T, P, I);
    }, C._stringFor = function(_, T, P) {
      T === void 0 && (T = _), P === void 0 && (P = b);
      var I = this._spacesFor(T);
      return P(this.stringifyProperty(_), I);
    }, C.offsetOf = function(_) {
      var T = 1, P = this._spacesFor("attribute");
      if (T += P.before.length, _ === "namespace" || _ === "ns")
        return this.namespace ? T : -1;
      if (_ === "attributeNS" || (T += this.namespaceString.length, this.namespace && (T += 1), _ === "attribute"))
        return T;
      T += this.stringifyProperty("attribute").length, T += P.after.length;
      var I = this._spacesFor("operator");
      T += I.before.length;
      var $ = this.stringifyProperty("operator");
      if (_ === "operator")
        return $ ? T : -1;
      T += $.length, T += I.after.length;
      var Y = this._spacesFor("value");
      T += Y.before.length;
      var W = this.stringifyProperty("value");
      if (_ === "value")
        return W ? T : -1;
      T += W.length, T += Y.after.length;
      var F = this._spacesFor("insensitive");
      return T += F.before.length, _ === "insensitive" && this.insensitive ? T : -1;
    }, C.toString = function() {
      var _ = this, T = [this.rawSpaceBefore, "["];
      return T.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (T.push(this._stringFor("operator")), T.push(this._stringFor("value")), T.push(this._stringFor("insensitiveFlag", "insensitive", function(P, I) {
        return P.length > 0 && !_.quoted && I.before.length === 0 && !(_.spaces.value && _.spaces.value.after) && (I.before = " "), b(P, I);
      }))), T.push("]"), T.push(this.rawSpaceAfter), T.join("");
    }, u(A, [{
      key: "quoted",
      get: function() {
        var _ = this.quoteMark;
        return _ === "'" || _ === '"';
      },
      set: function(_) {
        m();
      }
      /**
       * returns a single (`'`) or double (`"`) quote character if the value is quoted.
       * returns `null` if the value is not quoted.
       * returns `undefined` if the quotation state is unknown (this can happen when
       * the attribute is constructed without specifying a quote mark.)
       */
    }, {
      key: "quoteMark",
      get: function() {
        return this._quoteMark;
      },
      set: function(_) {
        if (!this._constructed) {
          this._quoteMark = _;
          return;
        }
        this._quoteMark !== _ && (this._quoteMark = _, this._syncRawValue());
      }
    }, {
      key: "qualifiedAttribute",
      get: function() {
        return this.qualifiedName(this.raws.attribute || this.attribute);
      }
    }, {
      key: "insensitiveFlag",
      get: function() {
        return this.insensitive ? "i" : "";
      }
    }, {
      key: "value",
      get: function() {
        return this._value;
      },
      set: (
        /**
         * Before 3.0, the value had to be set to an escaped value including any wrapped
         * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
         * is unescaped during parsing and any quote marks are removed.
         *
         * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
         * a deprecation warning is raised when the new value contains any characters that would
         * require escaping (including if it contains wrapped quotes).
         *
         * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
         * how the new value is quoted.
         */
        function(_) {
          if (this._constructed) {
            var T = y(_), P = T.deprecatedUsage, I = T.unescaped, $ = T.quoteMark;
            if (P && h(), I === this._value && $ === this._quoteMark)
              return;
            this._value = I, this._quoteMark = $, this._syncRawValue();
          } else
            this._value = _;
        }
      )
    }, {
      key: "insensitive",
      get: function() {
        return this._insensitive;
      },
      set: function(_) {
        _ || (this._insensitive = !1, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = _;
      }
    }, {
      key: "attribute",
      get: function() {
        return this._attribute;
      },
      set: function(_) {
        this._handleEscapes("attribute", _), this._attribute = _;
      }
    }]), A;
  }(s.default);
  r.default = E, E.NO_QUOTE = null, E.SINGLE_QUOTE = "'", E.DOUBLE_QUOTE = '"';
  var g = (n = {
    "'": {
      quotes: "single",
      wrap: !0
    },
    '"': {
      quotes: "double",
      wrap: !0
    }
  }, n[null] = {
    isIdentifier: !0
  }, n);
  function b(v, A) {
    return "" + A.before + v + A.after;
  }
})(R0);
var Uh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(M0), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.UNIVERSAL, f.value = "*", f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(Uh, Uh.exports);
var Fx = Uh.exports, jh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(di), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.COMBINATOR, f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(jh, jh.exports);
var Bx = jh.exports, qh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(di), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.NESTING, f.value = "&", f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(qh, qh.exports);
var Vx = qh.exports, Hh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = t;
  function t(s) {
    return s.sort(function(i, n) {
      return i - n;
    });
  }
  r.exports = e.default;
})(Hh, Hh.exports);
var MM = Hh.exports, Ux = {}, ae = {};
ae.__esModule = !0;
ae.word = ae.tilde = ae.tab = ae.str = ae.space = ae.slash = ae.singleQuote = ae.semicolon = ae.plus = ae.pipe = ae.openSquare = ae.openParenthesis = ae.newline = ae.greaterThan = ae.feed = ae.equals = ae.doubleQuote = ae.dollar = ae.cr = ae.comment = ae.comma = ae.combinator = ae.colon = ae.closeSquare = ae.closeParenthesis = ae.caret = ae.bang = ae.backslash = ae.at = ae.asterisk = ae.ampersand = void 0;
var RM = 38;
ae.ampersand = RM;
var $M = 42;
ae.asterisk = $M;
var FM = 64;
ae.at = FM;
var BM = 44;
ae.comma = BM;
var VM = 58;
ae.colon = VM;
var UM = 59;
ae.semicolon = UM;
var jM = 40;
ae.openParenthesis = jM;
var qM = 41;
ae.closeParenthesis = qM;
var HM = 91;
ae.openSquare = HM;
var WM = 93;
ae.closeSquare = WM;
var zM = 36;
ae.dollar = zM;
var GM = 126;
ae.tilde = GM;
var KM = 94;
ae.caret = KM;
var XM = 43;
ae.plus = XM;
var JM = 61;
ae.equals = JM;
var YM = 124;
ae.pipe = YM;
var QM = 62;
ae.greaterThan = QM;
var ZM = 32;
ae.space = ZM;
var jx = 39;
ae.singleQuote = jx;
var e5 = 34;
ae.doubleQuote = e5;
var t5 = 47;
ae.slash = t5;
var r5 = 33;
ae.bang = r5;
var s5 = 92;
ae.backslash = s5;
var i5 = 13;
ae.cr = i5;
var n5 = 12;
ae.feed = n5;
var a5 = 10;
ae.newline = a5;
var o5 = 9;
ae.tab = o5;
var u5 = jx;
ae.str = u5;
var l5 = -1;
ae.comment = l5;
var c5 = -2;
ae.word = c5;
var f5 = -3;
ae.combinator = f5;
(function(r) {
  r.__esModule = !0, r.FIELDS = void 0, r.default = m;
  var e = n(ae), t, s;
  function i(d) {
    if (typeof WeakMap != "function") return null;
    var y = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new WeakMap();
    return (i = function(g) {
      return g ? S : y;
    })(d);
  }
  function n(d, y) {
    if (d && d.__esModule)
      return d;
    if (d === null || typeof d != "object" && typeof d != "function")
      return { default: d };
    var S = i(y);
    if (S && S.has(d))
      return S.get(d);
    var E = {}, g = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var b in d)
      if (b !== "default" && Object.prototype.hasOwnProperty.call(d, b)) {
        var v = g ? Object.getOwnPropertyDescriptor(d, b) : null;
        v && (v.get || v.set) ? Object.defineProperty(E, b, v) : E[b] = d[b];
      }
    return E.default = d, S && S.set(d, E), E;
  }
  for (var a = (t = {}, t[e.tab] = !0, t[e.newline] = !0, t[e.cr] = !0, t[e.feed] = !0, t), o = (s = {}, s[e.space] = !0, s[e.tab] = !0, s[e.newline] = !0, s[e.cr] = !0, s[e.feed] = !0, s[e.ampersand] = !0, s[e.asterisk] = !0, s[e.bang] = !0, s[e.comma] = !0, s[e.colon] = !0, s[e.semicolon] = !0, s[e.openParenthesis] = !0, s[e.closeParenthesis] = !0, s[e.openSquare] = !0, s[e.closeSquare] = !0, s[e.singleQuote] = !0, s[e.doubleQuote] = !0, s[e.plus] = !0, s[e.pipe] = !0, s[e.tilde] = !0, s[e.greaterThan] = !0, s[e.equals] = !0, s[e.dollar] = !0, s[e.caret] = !0, s[e.slash] = !0, s), u = {}, l = "0123456789abcdefABCDEF", c = 0; c < l.length; c++)
    u[l.charCodeAt(c)] = !0;
  function f(d, y) {
    var S = y, E;
    do {
      if (E = d.charCodeAt(S), o[E])
        return S - 1;
      E === e.backslash ? S = p(d, S) + 1 : S++;
    } while (S < d.length);
    return S - 1;
  }
  function p(d, y) {
    var S = y, E = d.charCodeAt(S + 1);
    if (!a[E]) if (u[E]) {
      var g = 0;
      do
        S++, g++, E = d.charCodeAt(S + 1);
      while (u[E] && g < 6);
      g < 6 && E === e.space && S++;
    } else
      S++;
    return S;
  }
  var h = {
    TYPE: 0,
    START_LINE: 1,
    START_COL: 2,
    END_LINE: 3,
    END_COL: 4,
    START_POS: 5,
    END_POS: 6
  };
  r.FIELDS = h;
  function m(d) {
    var y = [], S = d.css.valueOf(), E = S, g = E.length, b = -1, v = 1, A = 0, C = 0, x, _, T, P, I, $, Y, W, F, K, Z, Ce, Ve;
    function ee(k, R) {
      if (d.safe)
        S += R, F = S.length - 1;
      else
        throw d.error("Unclosed " + k, v, A - b, A);
    }
    for (; A < g; ) {
      switch (x = S.charCodeAt(A), x === e.newline && (b = A, v += 1), x) {
        case e.space:
        case e.tab:
        case e.newline:
        case e.cr:
        case e.feed:
          F = A;
          do
            F += 1, x = S.charCodeAt(F), x === e.newline && (b = F, v += 1);
          while (x === e.space || x === e.newline || x === e.tab || x === e.cr || x === e.feed);
          Ve = e.space, P = v, T = F - b - 1, C = F;
          break;
        case e.plus:
        case e.greaterThan:
        case e.tilde:
        case e.pipe:
          F = A;
          do
            F += 1, x = S.charCodeAt(F);
          while (x === e.plus || x === e.greaterThan || x === e.tilde || x === e.pipe);
          Ve = e.combinator, P = v, T = A - b, C = F;
          break;
        case e.asterisk:
        case e.ampersand:
        case e.bang:
        case e.comma:
        case e.equals:
        case e.dollar:
        case e.caret:
        case e.openSquare:
        case e.closeSquare:
        case e.colon:
        case e.semicolon:
        case e.openParenthesis:
        case e.closeParenthesis:
          F = A, Ve = x, P = v, T = A - b, C = F + 1;
          break;
        case e.singleQuote:
        case e.doubleQuote:
          Ce = x === e.singleQuote ? "'" : '"', F = A;
          do
            for (I = !1, F = S.indexOf(Ce, F + 1), F === -1 && ee("quote", Ce), $ = F; S.charCodeAt($ - 1) === e.backslash; )
              $ -= 1, I = !I;
          while (I);
          Ve = e.str, P = v, T = A - b, C = F + 1;
          break;
        default:
          x === e.slash && S.charCodeAt(A + 1) === e.asterisk ? (F = S.indexOf("*/", A + 2) + 1, F === 0 && ee("comment", "*/"), _ = S.slice(A, F + 1), W = _.split(`
`), Y = W.length - 1, Y > 0 ? (K = v + Y, Z = F - W[Y].length) : (K = v, Z = b), Ve = e.comment, v = K, P = K, T = F - Z) : x === e.slash ? (F = A, Ve = x, P = v, T = A - b, C = F + 1) : (F = f(S, A), Ve = e.word, P = v, T = F - b), C = F + 1;
          break;
      }
      y.push([
        Ve,
        // [0] Token type
        v,
        // [1] Starting line
        A - b,
        // [2] Starting column
        P,
        // [3] Ending line
        T,
        // [4] Ending column
        A,
        // [5] Start position / Source index
        C
        // [6] End position
      ]), Z && (b = Z, Z = null), A = C;
    }
    return y;
  }
})(Ux);
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = C(Ox), s = C(Ix), i = C(kx), n = C(Dx), a = C(Lx), o = C(Mx), u = C(Rx), l = C($x), c = A(R0), f = C(Fx), p = C(Bx), h = C(Vx), m = C(MM), d = A(Ux), y = A(ae), S = A(Se), E = nr, g, b;
  function v(ee) {
    if (typeof WeakMap != "function") return null;
    var k = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap();
    return (v = function(B) {
      return B ? R : k;
    })(ee);
  }
  function A(ee, k) {
    if (ee && ee.__esModule)
      return ee;
    if (ee === null || typeof ee != "object" && typeof ee != "function")
      return { default: ee };
    var R = v(k);
    if (R && R.has(ee))
      return R.get(ee);
    var D = {}, B = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var ie in ee)
      if (ie !== "default" && Object.prototype.hasOwnProperty.call(ee, ie)) {
        var L = B ? Object.getOwnPropertyDescriptor(ee, ie) : null;
        L && (L.get || L.set) ? Object.defineProperty(D, ie, L) : D[ie] = ee[ie];
      }
    return D.default = ee, R && R.set(ee, D), D;
  }
  function C(ee) {
    return ee && ee.__esModule ? ee : { default: ee };
  }
  function x(ee, k) {
    for (var R = 0; R < k.length; R++) {
      var D = k[R];
      D.enumerable = D.enumerable || !1, D.configurable = !0, "value" in D && (D.writable = !0), Object.defineProperty(ee, D.key, D);
    }
  }
  function _(ee, k, R) {
    return k && x(ee.prototype, k), Object.defineProperty(ee, "prototype", { writable: !1 }), ee;
  }
  var T = (g = {}, g[y.space] = !0, g[y.cr] = !0, g[y.feed] = !0, g[y.newline] = !0, g[y.tab] = !0, g), P = Object.assign({}, T, (b = {}, b[y.comment] = !0, b));
  function I(ee) {
    return {
      line: ee[d.FIELDS.START_LINE],
      column: ee[d.FIELDS.START_COL]
    };
  }
  function $(ee) {
    return {
      line: ee[d.FIELDS.END_LINE],
      column: ee[d.FIELDS.END_COL]
    };
  }
  function Y(ee, k, R, D) {
    return {
      start: {
        line: ee,
        column: k
      },
      end: {
        line: R,
        column: D
      }
    };
  }
  function W(ee) {
    return Y(ee[d.FIELDS.START_LINE], ee[d.FIELDS.START_COL], ee[d.FIELDS.END_LINE], ee[d.FIELDS.END_COL]);
  }
  function F(ee, k) {
    if (ee)
      return Y(ee[d.FIELDS.START_LINE], ee[d.FIELDS.START_COL], k[d.FIELDS.END_LINE], k[d.FIELDS.END_COL]);
  }
  function K(ee, k) {
    var R = ee[k];
    if (typeof R == "string")
      return R.indexOf("\\") !== -1 && ((0, E.ensureObject)(ee, "raws"), ee[k] = (0, E.unesc)(R), ee.raws[k] === void 0 && (ee.raws[k] = R)), ee;
  }
  function Z(ee, k) {
    for (var R = -1, D = []; (R = ee.indexOf(k, R + 1)) !== -1; )
      D.push(R);
    return D;
  }
  function Ce() {
    var ee = Array.prototype.concat.apply([], arguments);
    return ee.filter(function(k, R) {
      return R === ee.indexOf(k);
    });
  }
  var Ve = /* @__PURE__ */ function() {
    function ee(R, D) {
      D === void 0 && (D = {}), this.rule = R, this.options = Object.assign({
        lossy: !1,
        safe: !1
      }, D), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, d.default)({
        css: this.css,
        error: this._errorGenerator(),
        safe: this.options.safe
      });
      var B = F(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new t.default({
        source: B
      }), this.root.errorGenerator = this._errorGenerator();
      var ie = new s.default({
        source: {
          start: {
            line: 1,
            column: 1
          }
        },
        sourceIndex: 0
      });
      this.root.append(ie), this.current = ie, this.loop();
    }
    var k = ee.prototype;
    return k._errorGenerator = function() {
      var D = this;
      return function(B, ie) {
        return typeof D.rule == "string" ? new Error(B) : D.rule.error(B, ie);
      };
    }, k.attribute = function() {
      var D = [], B = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[d.FIELDS.TYPE] !== y.closeSquare; )
        D.push(this.currToken), this.position++;
      if (this.currToken[d.FIELDS.TYPE] !== y.closeSquare)
        return this.expected("closing square bracket", this.currToken[d.FIELDS.START_POS]);
      var ie = D.length, L = {
        source: Y(B[1], B[2], this.currToken[3], this.currToken[4]),
        sourceIndex: B[d.FIELDS.START_POS]
      };
      if (ie === 1 && !~[y.word].indexOf(D[0][d.FIELDS.TYPE]))
        return this.expected("attribute", D[0][d.FIELDS.START_POS]);
      for (var ne = 0, ye = "", be = "", me = null, ke = !1; ne < ie; ) {
        var Ke = D[ne], w = this.content(Ke), N = D[ne + 1];
        switch (Ke[d.FIELDS.TYPE]) {
          case y.space:
            if (ke = !0, this.options.lossy)
              break;
            if (me) {
              (0, E.ensureObject)(L, "spaces", me);
              var M = L.spaces[me].after || "";
              L.spaces[me].after = M + w;
              var q = (0, E.getProp)(L, "raws", "spaces", me, "after") || null;
              q && (L.raws.spaces[me].after = q + w);
            } else
              ye = ye + w, be = be + w;
            break;
          case y.asterisk:
            if (N[d.FIELDS.TYPE] === y.equals)
              L.operator = w, me = "operator";
            else if ((!L.namespace || me === "namespace" && !ke) && N) {
              ye && ((0, E.ensureObject)(L, "spaces", "attribute"), L.spaces.attribute.before = ye, ye = ""), be && ((0, E.ensureObject)(L, "raws", "spaces", "attribute"), L.raws.spaces.attribute.before = ye, be = ""), L.namespace = (L.namespace || "") + w;
              var V = (0, E.getProp)(L, "raws", "namespace") || null;
              V && (L.raws.namespace += w), me = "namespace";
            }
            ke = !1;
            break;
          case y.dollar:
            if (me === "value") {
              var U = (0, E.getProp)(L, "raws", "value");
              L.value += "$", U && (L.raws.value = U + "$");
              break;
            }
          case y.caret:
            N[d.FIELDS.TYPE] === y.equals && (L.operator = w, me = "operator"), ke = !1;
            break;
          case y.combinator:
            if (w === "~" && N[d.FIELDS.TYPE] === y.equals && (L.operator = w, me = "operator"), w !== "|") {
              ke = !1;
              break;
            }
            N[d.FIELDS.TYPE] === y.equals ? (L.operator = w, me = "operator") : !L.namespace && !L.attribute && (L.namespace = !0), ke = !1;
            break;
          case y.word:
            if (N && this.content(N) === "|" && D[ne + 2] && D[ne + 2][d.FIELDS.TYPE] !== y.equals && // this look-ahead probably fails with comment nodes involved.
            !L.operator && !L.namespace)
              L.namespace = w, me = "namespace";
            else if (!L.attribute || me === "attribute" && !ke) {
              ye && ((0, E.ensureObject)(L, "spaces", "attribute"), L.spaces.attribute.before = ye, ye = ""), be && ((0, E.ensureObject)(L, "raws", "spaces", "attribute"), L.raws.spaces.attribute.before = be, be = ""), L.attribute = (L.attribute || "") + w;
              var J = (0, E.getProp)(L, "raws", "attribute") || null;
              J && (L.raws.attribute += w), me = "attribute";
            } else if (!L.value && L.value !== "" || me === "value" && !(ke || L.quoteMark)) {
              var G = (0, E.unesc)(w), X = (0, E.getProp)(L, "raws", "value") || "", z = L.value || "";
              L.value = z + G, L.quoteMark = null, (G !== w || X) && ((0, E.ensureObject)(L, "raws"), L.raws.value = (X || z) + w), me = "value";
            } else {
              var re = w === "i" || w === "I";
              (L.value || L.value === "") && (L.quoteMark || ke) ? (L.insensitive = re, (!re || w === "I") && ((0, E.ensureObject)(L, "raws"), L.raws.insensitiveFlag = w), me = "insensitive", ye && ((0, E.ensureObject)(L, "spaces", "insensitive"), L.spaces.insensitive.before = ye, ye = ""), be && ((0, E.ensureObject)(L, "raws", "spaces", "insensitive"), L.raws.spaces.insensitive.before = be, be = "")) : (L.value || L.value === "") && (me = "value", L.value += w, L.raws.value && (L.raws.value += w));
            }
            ke = !1;
            break;
          case y.str:
            if (!L.attribute || !L.operator)
              return this.error("Expected an attribute followed by an operator preceding the string.", {
                index: Ke[d.FIELDS.START_POS]
              });
            var ce = (0, c.unescapeValue)(w), pe = ce.unescaped, ve = ce.quoteMark;
            L.value = pe, L.quoteMark = ve, me = "value", (0, E.ensureObject)(L, "raws"), L.raws.value = w, ke = !1;
            break;
          case y.equals:
            if (!L.attribute)
              return this.expected("attribute", Ke[d.FIELDS.START_POS], w);
            if (L.value)
              return this.error('Unexpected "=" found; an operator was already defined.', {
                index: Ke[d.FIELDS.START_POS]
              });
            L.operator = L.operator ? L.operator + w : w, me = "operator", ke = !1;
            break;
          case y.comment:
            if (me)
              if (ke || N && N[d.FIELDS.TYPE] === y.space || me === "insensitive") {
                var xe = (0, E.getProp)(L, "spaces", me, "after") || "", qe = (0, E.getProp)(L, "raws", "spaces", me, "after") || xe;
                (0, E.ensureObject)(L, "raws", "spaces", me), L.raws.spaces[me].after = qe + w;
              } else {
                var De = L[me] || "", ut = (0, E.getProp)(L, "raws", me) || De;
                (0, E.ensureObject)(L, "raws"), L.raws[me] = ut + w;
              }
            else
              be = be + w;
            break;
          default:
            return this.error('Unexpected "' + w + '" found.', {
              index: Ke[d.FIELDS.START_POS]
            });
        }
        ne++;
      }
      K(L, "attribute"), K(L, "namespace"), this.newNode(new c.default(L)), this.position++;
    }, k.parseWhitespaceEquivalentTokens = function(D) {
      D < 0 && (D = this.tokens.length);
      var B = this.position, ie = [], L = "", ne = void 0;
      do
        if (T[this.currToken[d.FIELDS.TYPE]])
          this.options.lossy || (L += this.content());
        else if (this.currToken[d.FIELDS.TYPE] === y.comment) {
          var ye = {};
          L && (ye.before = L, L = ""), ne = new n.default({
            value: this.content(),
            source: W(this.currToken),
            sourceIndex: this.currToken[d.FIELDS.START_POS],
            spaces: ye
          }), ie.push(ne);
        }
      while (++this.position < D);
      if (L) {
        if (ne)
          ne.spaces.after = L;
        else if (!this.options.lossy) {
          var be = this.tokens[B], me = this.tokens[this.position - 1];
          ie.push(new u.default({
            value: "",
            source: Y(be[d.FIELDS.START_LINE], be[d.FIELDS.START_COL], me[d.FIELDS.END_LINE], me[d.FIELDS.END_COL]),
            sourceIndex: be[d.FIELDS.START_POS],
            spaces: {
              before: L,
              after: ""
            }
          }));
        }
      }
      return ie;
    }, k.convertWhitespaceNodesToSpace = function(D, B) {
      var ie = this;
      B === void 0 && (B = !1);
      var L = "", ne = "";
      D.forEach(function(be) {
        var me = ie.lossySpace(be.spaces.before, B), ke = ie.lossySpace(be.rawSpaceBefore, B);
        L += me + ie.lossySpace(be.spaces.after, B && me.length === 0), ne += me + be.value + ie.lossySpace(be.rawSpaceAfter, B && ke.length === 0);
      }), ne === L && (ne = void 0);
      var ye = {
        space: L,
        rawSpace: ne
      };
      return ye;
    }, k.isNamedCombinator = function(D) {
      return D === void 0 && (D = this.position), this.tokens[D + 0] && this.tokens[D + 0][d.FIELDS.TYPE] === y.slash && this.tokens[D + 1] && this.tokens[D + 1][d.FIELDS.TYPE] === y.word && this.tokens[D + 2] && this.tokens[D + 2][d.FIELDS.TYPE] === y.slash;
    }, k.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var D = this.content(this.tokens[this.position + 1]), B = (0, E.unesc)(D).toLowerCase(), ie = {};
        B !== D && (ie.value = "/" + D + "/");
        var L = new p.default({
          value: "/" + B + "/",
          source: Y(this.currToken[d.FIELDS.START_LINE], this.currToken[d.FIELDS.START_COL], this.tokens[this.position + 2][d.FIELDS.END_LINE], this.tokens[this.position + 2][d.FIELDS.END_COL]),
          sourceIndex: this.currToken[d.FIELDS.START_POS],
          raws: ie
        });
        return this.position = this.position + 3, L;
      } else
        this.unexpected();
    }, k.combinator = function() {
      var D = this;
      if (this.content() === "|")
        return this.namespace();
      var B = this.locateNextMeaningfulToken(this.position);
      if (B < 0 || this.tokens[B][d.FIELDS.TYPE] === y.comma) {
        var ie = this.parseWhitespaceEquivalentTokens(B);
        if (ie.length > 0) {
          var L = this.current.last;
          if (L) {
            var ne = this.convertWhitespaceNodesToSpace(ie), ye = ne.space, be = ne.rawSpace;
            be !== void 0 && (L.rawSpaceAfter += be), L.spaces.after += ye;
          } else
            ie.forEach(function(X) {
              return D.newNode(X);
            });
        }
        return;
      }
      var me = this.currToken, ke = void 0;
      B > this.position && (ke = this.parseWhitespaceEquivalentTokens(B));
      var Ke;
      if (this.isNamedCombinator() ? Ke = this.namedCombinator() : this.currToken[d.FIELDS.TYPE] === y.combinator ? (Ke = new p.default({
        value: this.content(),
        source: W(this.currToken),
        sourceIndex: this.currToken[d.FIELDS.START_POS]
      }), this.position++) : T[this.currToken[d.FIELDS.TYPE]] || ke || this.unexpected(), Ke) {
        if (ke) {
          var w = this.convertWhitespaceNodesToSpace(ke), N = w.space, M = w.rawSpace;
          Ke.spaces.before = N, Ke.rawSpaceBefore = M;
        }
      } else {
        var q = this.convertWhitespaceNodesToSpace(ke, !0), V = q.space, U = q.rawSpace;
        U || (U = V);
        var J = {}, G = {
          spaces: {}
        };
        V.endsWith(" ") && U.endsWith(" ") ? (J.before = V.slice(0, V.length - 1), G.spaces.before = U.slice(0, U.length - 1)) : V.startsWith(" ") && U.startsWith(" ") ? (J.after = V.slice(1), G.spaces.after = U.slice(1)) : G.value = U, Ke = new p.default({
          value: " ",
          source: F(me, this.tokens[this.position - 1]),
          sourceIndex: me[d.FIELDS.START_POS],
          spaces: J,
          raws: G
        });
      }
      return this.currToken && this.currToken[d.FIELDS.TYPE] === y.space && (Ke.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(Ke);
    }, k.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = !0, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var D = new s.default({
        source: {
          start: I(this.tokens[this.position + 1])
        },
        sourceIndex: this.tokens[this.position + 1][d.FIELDS.START_POS]
      });
      this.current.parent.append(D), this.current = D, this.position++;
    }, k.comment = function() {
      var D = this.currToken;
      this.newNode(new n.default({
        value: this.content(),
        source: W(D),
        sourceIndex: D[d.FIELDS.START_POS]
      })), this.position++;
    }, k.error = function(D, B) {
      throw this.root.error(D, B);
    }, k.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", {
        index: this.currToken[d.FIELDS.START_POS]
      });
    }, k.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[d.FIELDS.START_POS]);
    }, k.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[d.FIELDS.START_POS]);
    }, k.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[d.FIELDS.START_POS]);
    }, k.unexpectedPipe = function() {
      return this.error("Unexpected '|'.", this.currToken[d.FIELDS.START_POS]);
    }, k.namespace = function() {
      var D = this.prevToken && this.content(this.prevToken) || !0;
      if (this.nextToken[d.FIELDS.TYPE] === y.word)
        return this.position++, this.word(D);
      if (this.nextToken[d.FIELDS.TYPE] === y.asterisk)
        return this.position++, this.universal(D);
      this.unexpectedPipe();
    }, k.nesting = function() {
      if (this.nextToken) {
        var D = this.content(this.nextToken);
        if (D === "|") {
          this.position++;
          return;
        }
      }
      var B = this.currToken;
      this.newNode(new h.default({
        value: this.content(),
        source: W(B),
        sourceIndex: B[d.FIELDS.START_POS]
      })), this.position++;
    }, k.parentheses = function() {
      var D = this.current.last, B = 1;
      if (this.position++, D && D.type === S.PSEUDO) {
        var ie = new s.default({
          source: {
            start: I(this.tokens[this.position])
          },
          sourceIndex: this.tokens[this.position][d.FIELDS.START_POS]
        }), L = this.current;
        for (D.append(ie), this.current = ie; this.position < this.tokens.length && B; )
          this.currToken[d.FIELDS.TYPE] === y.openParenthesis && B++, this.currToken[d.FIELDS.TYPE] === y.closeParenthesis && B--, B ? this.parse() : (this.current.source.end = $(this.currToken), this.current.parent.source.end = $(this.currToken), this.position++);
        this.current = L;
      } else {
        for (var ne = this.currToken, ye = "(", be; this.position < this.tokens.length && B; )
          this.currToken[d.FIELDS.TYPE] === y.openParenthesis && B++, this.currToken[d.FIELDS.TYPE] === y.closeParenthesis && B--, be = this.currToken, ye += this.parseParenthesisToken(this.currToken), this.position++;
        D ? D.appendToPropertyAndEscape("value", ye, ye) : this.newNode(new u.default({
          value: ye,
          source: Y(ne[d.FIELDS.START_LINE], ne[d.FIELDS.START_COL], be[d.FIELDS.END_LINE], be[d.FIELDS.END_COL]),
          sourceIndex: ne[d.FIELDS.START_POS]
        }));
      }
      if (B)
        return this.expected("closing parenthesis", this.currToken[d.FIELDS.START_POS]);
    }, k.pseudo = function() {
      for (var D = this, B = "", ie = this.currToken; this.currToken && this.currToken[d.FIELDS.TYPE] === y.colon; )
        B += this.content(), this.position++;
      if (!this.currToken)
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[d.FIELDS.TYPE] === y.word)
        this.splitWord(!1, function(L, ne) {
          B += L, D.newNode(new l.default({
            value: B,
            source: F(ie, D.currToken),
            sourceIndex: ie[d.FIELDS.START_POS]
          })), ne > 1 && D.nextToken && D.nextToken[d.FIELDS.TYPE] === y.openParenthesis && D.error("Misplaced parenthesis.", {
            index: D.nextToken[d.FIELDS.START_POS]
          });
        });
      else
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[d.FIELDS.START_POS]);
    }, k.space = function() {
      var D = this.content();
      this.position === 0 || this.prevToken[d.FIELDS.TYPE] === y.comma || this.prevToken[d.FIELDS.TYPE] === y.openParenthesis || this.current.nodes.every(function(B) {
        return B.type === "comment";
      }) ? (this.spaces = this.optionalSpace(D), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[d.FIELDS.TYPE] === y.comma || this.nextToken[d.FIELDS.TYPE] === y.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(D), this.position++) : this.combinator();
    }, k.string = function() {
      var D = this.currToken;
      this.newNode(new u.default({
        value: this.content(),
        source: W(D),
        sourceIndex: D[d.FIELDS.START_POS]
      })), this.position++;
    }, k.universal = function(D) {
      var B = this.nextToken;
      if (B && this.content(B) === "|")
        return this.position++, this.namespace();
      var ie = this.currToken;
      this.newNode(new f.default({
        value: this.content(),
        source: W(ie),
        sourceIndex: ie[d.FIELDS.START_POS]
      }), D), this.position++;
    }, k.splitWord = function(D, B) {
      for (var ie = this, L = this.nextToken, ne = this.content(); L && ~[y.dollar, y.caret, y.equals, y.word].indexOf(L[d.FIELDS.TYPE]); ) {
        this.position++;
        var ye = this.content();
        if (ne += ye, ye.lastIndexOf("\\") === ye.length - 1) {
          var be = this.nextToken;
          be && be[d.FIELDS.TYPE] === y.space && (ne += this.requiredSpace(this.content(be)), this.position++);
        }
        L = this.nextToken;
      }
      var me = Z(ne, ".").filter(function(N) {
        var M = ne[N - 1] === "\\", q = /^\d+\.\d+%$/.test(ne);
        return !M && !q;
      }), ke = Z(ne, "#").filter(function(N) {
        return ne[N - 1] !== "\\";
      }), Ke = Z(ne, "#{");
      Ke.length && (ke = ke.filter(function(N) {
        return !~Ke.indexOf(N);
      }));
      var w = (0, m.default)(Ce([0].concat(me, ke)));
      w.forEach(function(N, M) {
        var q = w[M + 1] || ne.length, V = ne.slice(N, q);
        if (M === 0 && B)
          return B.call(ie, V, w.length);
        var U, J = ie.currToken, G = J[d.FIELDS.START_POS] + w[M], X = Y(J[1], J[2] + N, J[3], J[2] + (q - 1));
        if (~me.indexOf(N)) {
          var z = {
            value: V.slice(1),
            source: X,
            sourceIndex: G
          };
          U = new i.default(K(z, "value"));
        } else if (~ke.indexOf(N)) {
          var re = {
            value: V.slice(1),
            source: X,
            sourceIndex: G
          };
          U = new a.default(K(re, "value"));
        } else {
          var ce = {
            value: V,
            source: X,
            sourceIndex: G
          };
          K(ce, "value"), U = new o.default(ce);
        }
        ie.newNode(U, D), D = null;
      }), this.position++;
    }, k.word = function(D) {
      var B = this.nextToken;
      return B && this.content(B) === "|" ? (this.position++, this.namespace()) : this.splitWord(D);
    }, k.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(!0);
      return this.current._inferEndPosition(), this.root;
    }, k.parse = function(D) {
      switch (this.currToken[d.FIELDS.TYPE]) {
        case y.space:
          this.space();
          break;
        case y.comment:
          this.comment();
          break;
        case y.openParenthesis:
          this.parentheses();
          break;
        case y.closeParenthesis:
          D && this.missingParenthesis();
          break;
        case y.openSquare:
          this.attribute();
          break;
        case y.dollar:
        case y.caret:
        case y.equals:
        case y.word:
          this.word();
          break;
        case y.colon:
          this.pseudo();
          break;
        case y.comma:
          this.comma();
          break;
        case y.asterisk:
          this.universal();
          break;
        case y.ampersand:
          this.nesting();
          break;
        case y.slash:
        case y.combinator:
          this.combinator();
          break;
        case y.str:
          this.string();
          break;
        case y.closeSquare:
          this.missingSquareBracket();
        case y.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, k.expected = function(D, B, ie) {
      if (Array.isArray(D)) {
        var L = D.pop();
        D = D.join(", ") + " or " + L;
      }
      var ne = /^[aeiou]/.test(D[0]) ? "an" : "a";
      return ie ? this.error("Expected " + ne + " " + D + ', found "' + ie + '" instead.', {
        index: B
      }) : this.error("Expected " + ne + " " + D + ".", {
        index: B
      });
    }, k.requiredSpace = function(D) {
      return this.options.lossy ? " " : D;
    }, k.optionalSpace = function(D) {
      return this.options.lossy ? "" : D;
    }, k.lossySpace = function(D, B) {
      return this.options.lossy ? B ? " " : "" : D;
    }, k.parseParenthesisToken = function(D) {
      var B = this.content(D);
      return D[d.FIELDS.TYPE] === y.space ? this.requiredSpace(B) : B;
    }, k.newNode = function(D, B) {
      return B && (/^ +$/.test(B) && (this.options.lossy || (this.spaces = (this.spaces || "") + B), B = !0), D.namespace = B, K(D, "namespace")), this.spaces && (D.spaces.before = this.spaces, this.spaces = ""), this.current.append(D);
    }, k.content = function(D) {
      return D === void 0 && (D = this.currToken), this.css.slice(D[d.FIELDS.START_POS], D[d.FIELDS.END_POS]);
    }, k.locateNextMeaningfulToken = function(D) {
      D === void 0 && (D = this.position + 1);
      for (var B = D; B < this.tokens.length; )
        if (P[this.tokens[B][d.FIELDS.TYPE]]) {
          B++;
          continue;
        } else
          return B;
      return -1;
    }, _(ee, [{
      key: "currToken",
      get: function() {
        return this.tokens[this.position];
      }
    }, {
      key: "nextToken",
      get: function() {
        return this.tokens[this.position + 1];
      }
    }, {
      key: "prevToken",
      get: function() {
        return this.tokens[this.position - 1];
      }
    }]), ee;
  }();
  e.default = Ve, r.exports = e.default;
})(Th, Th.exports);
var p5 = Th.exports;
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = s(p5);
  function s(n) {
    return n && n.__esModule ? n : { default: n };
  }
  var i = /* @__PURE__ */ function() {
    function n(o, u) {
      this.func = o || function() {
      }, this.funcRes = null, this.options = u;
    }
    var a = n.prototype;
    return a._shouldUpdateSelector = function(u, l) {
      l === void 0 && (l = {});
      var c = Object.assign({}, this.options, l);
      return c.updateSelector === !1 ? !1 : typeof u != "string";
    }, a._isLossy = function(u) {
      u === void 0 && (u = {});
      var l = Object.assign({}, this.options, u);
      return l.lossless === !1;
    }, a._root = function(u, l) {
      l === void 0 && (l = {});
      var c = new t.default(u, this._parseOptions(l));
      return c.root;
    }, a._parseOptions = function(u) {
      return {
        lossy: this._isLossy(u)
      };
    }, a._run = function(u, l) {
      var c = this;
      return l === void 0 && (l = {}), new Promise(function(f, p) {
        try {
          var h = c._root(u, l);
          Promise.resolve(c.func(h)).then(function(m) {
            var d = void 0;
            return c._shouldUpdateSelector(u, l) && (d = h.toString(), u.selector = d), {
              transform: m,
              root: h,
              string: d
            };
          }).then(f, p);
        } catch (m) {
          p(m);
          return;
        }
      });
    }, a._runSync = function(u, l) {
      l === void 0 && (l = {});
      var c = this._root(u, l), f = this.func(c);
      if (f && typeof f.then == "function")
        throw new Error("Selector processor returned a promise to a synchronous call.");
      var p = void 0;
      return l.updateSelector && typeof u != "string" && (p = c.toString(), u.selector = p), {
        transform: f,
        root: c,
        string: p
      };
    }, a.ast = function(u, l) {
      return this._run(u, l).then(function(c) {
        return c.root;
      });
    }, a.astSync = function(u, l) {
      return this._runSync(u, l).root;
    }, a.transform = function(u, l) {
      return this._run(u, l).then(function(c) {
        return c.transform;
      });
    }, a.transformSync = function(u, l) {
      return this._runSync(u, l).transform;
    }, a.process = function(u, l) {
      return this._run(u, l).then(function(c) {
        return c.string || c.root.toString();
      });
    }, a.processSync = function(u, l) {
      var c = this._runSync(u, l);
      return c.string || c.root.toString();
    }, n;
  }();
  e.default = i, r.exports = e.default;
})(wh, wh.exports);
var h5 = wh.exports, qx = {}, We = {};
We.__esModule = !0;
We.universal = We.tag = We.string = We.selector = We.root = We.pseudo = We.nesting = We.id = We.comment = We.combinator = We.className = We.attribute = void 0;
var d5 = Sr(R0), m5 = Sr(kx), g5 = Sr(Bx), y5 = Sr(Dx), b5 = Sr(Lx), v5 = Sr(Vx), E5 = Sr($x), S5 = Sr(Ox), _5 = Sr(Ix), x5 = Sr(Rx), w5 = Sr(Mx), T5 = Sr(Fx);
function Sr(r) {
  return r && r.__esModule ? r : { default: r };
}
var P5 = function(e) {
  return new d5.default(e);
};
We.attribute = P5;
var A5 = function(e) {
  return new m5.default(e);
};
We.className = A5;
var C5 = function(e) {
  return new g5.default(e);
};
We.combinator = C5;
var N5 = function(e) {
  return new y5.default(e);
};
We.comment = N5;
var O5 = function(e) {
  return new b5.default(e);
};
We.id = O5;
var I5 = function(e) {
  return new v5.default(e);
};
We.nesting = I5;
var k5 = function(e) {
  return new E5.default(e);
};
We.pseudo = k5;
var D5 = function(e) {
  return new S5.default(e);
};
We.root = D5;
var L5 = function(e) {
  return new _5.default(e);
};
We.selector = L5;
var M5 = function(e) {
  return new x5.default(e);
};
We.string = M5;
var R5 = function(e) {
  return new w5.default(e);
};
We.tag = R5;
var $5 = function(e) {
  return new T5.default(e);
};
We.universal = $5;
var $e = {};
$e.__esModule = !0;
$e.isComment = $e.isCombinator = $e.isClassName = $e.isAttribute = void 0;
$e.isContainer = X5;
$e.isIdentifier = void 0;
$e.isNamespace = J5;
$e.isNesting = void 0;
$e.isNode = $0;
$e.isPseudo = void 0;
$e.isPseudoClass = K5;
$e.isPseudoElement = zx;
$e.isUniversal = $e.isTag = $e.isString = $e.isSelector = $e.isRoot = void 0;
var et = Se, Gt, F5 = (Gt = {}, Gt[et.ATTRIBUTE] = !0, Gt[et.CLASS] = !0, Gt[et.COMBINATOR] = !0, Gt[et.COMMENT] = !0, Gt[et.ID] = !0, Gt[et.NESTING] = !0, Gt[et.PSEUDO] = !0, Gt[et.ROOT] = !0, Gt[et.SELECTOR] = !0, Gt[et.STRING] = !0, Gt[et.TAG] = !0, Gt[et.UNIVERSAL] = !0, Gt);
function $0(r) {
  return typeof r == "object" && F5[r.type];
}
function _r(r, e) {
  return $0(e) && e.type === r;
}
var Hx = _r.bind(null, et.ATTRIBUTE);
$e.isAttribute = Hx;
var B5 = _r.bind(null, et.CLASS);
$e.isClassName = B5;
var V5 = _r.bind(null, et.COMBINATOR);
$e.isCombinator = V5;
var U5 = _r.bind(null, et.COMMENT);
$e.isComment = U5;
var j5 = _r.bind(null, et.ID);
$e.isIdentifier = j5;
var q5 = _r.bind(null, et.NESTING);
$e.isNesting = q5;
var F0 = _r.bind(null, et.PSEUDO);
$e.isPseudo = F0;
var H5 = _r.bind(null, et.ROOT);
$e.isRoot = H5;
var W5 = _r.bind(null, et.SELECTOR);
$e.isSelector = W5;
var z5 = _r.bind(null, et.STRING);
$e.isString = z5;
var Wx = _r.bind(null, et.TAG);
$e.isTag = Wx;
var G5 = _r.bind(null, et.UNIVERSAL);
$e.isUniversal = G5;
function zx(r) {
  return F0(r) && r.value && (r.value.startsWith("::") || r.value.toLowerCase() === ":before" || r.value.toLowerCase() === ":after" || r.value.toLowerCase() === ":first-letter" || r.value.toLowerCase() === ":first-line");
}
function K5(r) {
  return F0(r) && !zx(r);
}
function X5(r) {
  return !!($0(r) && r.walk);
}
function J5(r) {
  return Hx(r) || Wx(r);
}
(function(r) {
  r.__esModule = !0;
  var e = Se;
  Object.keys(e).forEach(function(i) {
    i === "default" || i === "__esModule" || i in r && r[i] === e[i] || (r[i] = e[i]);
  });
  var t = We;
  Object.keys(t).forEach(function(i) {
    i === "default" || i === "__esModule" || i in r && r[i] === t[i] || (r[i] = t[i]);
  });
  var s = $e;
  Object.keys(s).forEach(function(i) {
    i === "default" || i === "__esModule" || i in r && r[i] === s[i] || (r[i] = s[i]);
  });
})(qx);
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = a(h5), s = n(qx);
  function i(l) {
    if (typeof WeakMap != "function") return null;
    var c = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap();
    return (i = function(h) {
      return h ? f : c;
    })(l);
  }
  function n(l, c) {
    if (l && l.__esModule)
      return l;
    if (l === null || typeof l != "object" && typeof l != "function")
      return { default: l };
    var f = i(c);
    if (f && f.has(l))
      return f.get(l);
    var p = {}, h = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var m in l)
      if (m !== "default" && Object.prototype.hasOwnProperty.call(l, m)) {
        var d = h ? Object.getOwnPropertyDescriptor(l, m) : null;
        d && (d.get || d.set) ? Object.defineProperty(p, m, d) : p[m] = l[m];
      }
    return p.default = l, f && f.set(l, p), p;
  }
  function a(l) {
    return l && l.__esModule ? l : { default: l };
  }
  var o = function(c) {
    return new t.default(c);
  };
  Object.assign(o, s), delete o.__esModule;
  var u = o;
  e.default = u, r.exports = e.default;
})(xh, xh.exports);
var Y5 = xh.exports, Xu = /* @__PURE__ */ Dc(Y5);
const Q5 = /^(-\w+-)?animation-name$/, Z5 = /^(-\w+-)?animation$/, Gx = (r = "") => {
  const e = /* @__PURE__ */ Object.create(null), t = r.replace(/^data-v-/, "");
  return {
    postcssPlugin: "vue-sfc-scoped",
    Rule(s) {
      eR(r, s);
    },
    AtRule(s) {
      /-?keyframes$/.test(s.name) && !s.params.endsWith(`-${t}`) && (e[s.params] = s.params = s.params + "-" + t);
    },
    OnceExit(s) {
      Object.keys(e).length && s.walkDecls((i) => {
        Q5.test(i.prop) && (i.value = i.value.split(",").map((n) => e[n.trim()] || n.trim()).join(",")), Z5.test(i.prop) && (i.value = i.value.split(",").map((n) => {
          const a = n.trim().split(/\s+/), o = a.findIndex((u) => e[u]);
          return o !== -1 ? (a.splice(o, 1, e[a[o]]), a.join(" ")) : n;
        }).join(","));
      });
    }
  };
}, F1 = /* @__PURE__ */ new WeakSet();
function eR(r, e) {
  F1.has(e) || e.parent && e.parent.type === "atrule" && /-?keyframes$/.test(e.parent.name) || (F1.add(e), e.selector = Xu((t) => {
    t.each((s) => {
      Wh(r, s, t);
    });
  }).processSync(e.selector));
}
function Wh(r, e, t, s = !1) {
  let i = null, n = !0;
  if (e.each((a) => {
    if (a.type === "combinator" && (a.value === ">>>" || a.value === "/deep/"))
      return a.value = " ", a.spaces.before = a.spaces.after = "", ah(
        "the >>> and /deep/ combinators have been deprecated. Use :deep() instead."
      ), !1;
    if (a.type === "pseudo") {
      const { value: o } = a;
      if (o === ":deep" || o === "::v-deep") {
        if (a.nodes.length) {
          let u = a;
          a.nodes[0].each((c) => {
            e.insertAfter(u, c), u = c;
          });
          const l = e.at(e.index(a) - 1);
          (!l || !B1(l)) && e.insertAfter(
            a,
            Xu.combinator({
              value: " "
            })
          ), e.removeChild(a);
        } else {
          ah(
            `${o} usage as a combinator has been deprecated. Use :deep(<inner-selector>) instead of ${o} <inner-selector>.`
          );
          const u = e.at(e.index(a) - 1);
          u && B1(u) && e.removeChild(u), e.removeChild(a);
        }
        return !1;
      }
      if (o === ":slotted" || o === "::v-slotted") {
        Wh(
          r,
          a.nodes[0],
          t,
          !0
          /* slotted */
        );
        let u = a;
        return a.nodes[0].each((l) => {
          e.insertAfter(u, l), u = l;
        }), e.removeChild(a), n = !1, !1;
      }
      if (o === ":global" || o === "::v-global")
        return t.insertAfter(e, a.nodes[0]), t.removeChild(e), !1;
    }
    if (a.type === "universal") {
      const o = e.at(e.index(a) - 1), u = e.at(e.index(a) + 1);
      if (!o)
        if (u) {
          u.type === "combinator" && u.value === " " && e.removeChild(u), e.removeChild(a);
          return;
        } else
          return i = Xu.combinator({
            value: ""
          }), e.insertBefore(a, i), e.removeChild(a), !1;
      if (i) return;
    }
    (a.type !== "pseudo" && a.type !== "combinator" || a.type === "pseudo" && (a.value === ":is" || a.value === ":where") && !i) && (i = a);
  }), i) {
    const { type: a, value: o } = i;
    a === "pseudo" && (o === ":is" || o === ":where") && (i.nodes.forEach(
      (u) => Wh(r, u, t, s)
    ), n = !1);
  }
  if (i ? i.spaces.after = "" : e.first.spaces.before = "", n) {
    const a = s ? r + "-s" : r;
    e.insertAfter(
      // If node is null it means we need to inject [id] at the start
      // insertAfter can handle `null` here
      i,
      Xu.attribute({
        attribute: a,
        value: a,
        raws: {},
        quoteMark: '"'
      })
    );
  }
}
function B1(r) {
  return r.type === "combinator" && /^\s+$/.test(r.value);
}
Gx.postcss = !0;
var of = {}, B0 = {}, uf = {}, V0 = {}, V1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
V0.encode = function(r) {
  if (0 <= r && r < V1.length)
    return V1[r];
  throw new TypeError("Must be between 0 and 63: " + r);
};
V0.decode = function(r) {
  var e = 65, t = 90, s = 97, i = 122, n = 48, a = 57, o = 43, u = 47, l = 26, c = 52;
  return e <= r && r <= t ? r - e : s <= r && r <= i ? r - s + l : n <= r && r <= a ? r - n + c : r == o ? 62 : r == u ? 63 : -1;
};
var Kx = V0, U0 = 5, Xx = 1 << U0, Jx = Xx - 1, Yx = Xx;
function tR(r) {
  return r < 0 ? (-r << 1) + 1 : (r << 1) + 0;
}
function rR(r) {
  var e = (r & 1) === 1, t = r >> 1;
  return e ? -t : t;
}
uf.encode = function(e) {
  var t = "", s, i = tR(e);
  do
    s = i & Jx, i >>>= U0, i > 0 && (s |= Yx), t += Kx.encode(s);
  while (i > 0);
  return t;
};
uf.decode = function(e, t, s) {
  var i = e.length, n = 0, a = 0, o, u;
  do {
    if (t >= i)
      throw new Error("Expected more digits in base 64 VLQ value.");
    if (u = Kx.decode(e.charCodeAt(t++)), u === -1)
      throw new Error("Invalid base64 digit: " + e.charAt(t - 1));
    o = !!(u & Yx), u &= Jx, n = n + (u << a), a += U0;
  } while (o);
  s.value = rR(n), s.rest = t;
};
var oa = {};
(function(r) {
  function e(b, v, A) {
    if (v in b)
      return b[v];
    if (arguments.length === 3)
      return A;
    throw new Error('"' + v + '" is a required argument.');
  }
  r.getArg = e;
  var t = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, s = /^data:.+\,.+$/;
  function i(b) {
    var v = b.match(t);
    return v ? {
      scheme: v[1],
      auth: v[2],
      host: v[3],
      port: v[4],
      path: v[5]
    } : null;
  }
  r.urlParse = i;
  function n(b) {
    var v = "";
    return b.scheme && (v += b.scheme + ":"), v += "//", b.auth && (v += b.auth + "@"), b.host && (v += b.host), b.port && (v += ":" + b.port), b.path && (v += b.path), v;
  }
  r.urlGenerate = n;
  function a(b) {
    var v = b, A = i(b);
    if (A) {
      if (!A.path)
        return b;
      v = A.path;
    }
    for (var C = r.isAbsolute(v), x = v.split(/\/+/), _, T = 0, P = x.length - 1; P >= 0; P--)
      _ = x[P], _ === "." ? x.splice(P, 1) : _ === ".." ? T++ : T > 0 && (_ === "" ? (x.splice(P + 1, T), T = 0) : (x.splice(P, 2), T--));
    return v = x.join("/"), v === "" && (v = C ? "/" : "."), A ? (A.path = v, n(A)) : v;
  }
  r.normalize = a;
  function o(b, v) {
    b === "" && (b = "."), v === "" && (v = ".");
    var A = i(v), C = i(b);
    if (C && (b = C.path || "/"), A && !A.scheme)
      return C && (A.scheme = C.scheme), n(A);
    if (A || v.match(s))
      return v;
    if (C && !C.host && !C.path)
      return C.host = v, n(C);
    var x = v.charAt(0) === "/" ? v : a(b.replace(/\/+$/, "") + "/" + v);
    return C ? (C.path = x, n(C)) : x;
  }
  r.join = o, r.isAbsolute = function(b) {
    return b.charAt(0) === "/" || t.test(b);
  };
  function u(b, v) {
    b === "" && (b = "."), b = b.replace(/\/$/, "");
    for (var A = 0; v.indexOf(b + "/") !== 0; ) {
      var C = b.lastIndexOf("/");
      if (C < 0 || (b = b.slice(0, C), b.match(/^([^\/]+:\/)?\/*$/)))
        return v;
      ++A;
    }
    return Array(A + 1).join("../") + v.substr(b.length + 1);
  }
  r.relative = u;
  var l = function() {
    var b = /* @__PURE__ */ Object.create(null);
    return !("__proto__" in b);
  }();
  function c(b) {
    return b;
  }
  function f(b) {
    return h(b) ? "$" + b : b;
  }
  r.toSetString = l ? c : f;
  function p(b) {
    return h(b) ? b.slice(1) : b;
  }
  r.fromSetString = l ? c : p;
  function h(b) {
    if (!b)
      return !1;
    var v = b.length;
    if (v < 9 || b.charCodeAt(v - 1) !== 95 || b.charCodeAt(v - 2) !== 95 || b.charCodeAt(v - 3) !== 111 || b.charCodeAt(v - 4) !== 116 || b.charCodeAt(v - 5) !== 111 || b.charCodeAt(v - 6) !== 114 || b.charCodeAt(v - 7) !== 112 || b.charCodeAt(v - 8) !== 95 || b.charCodeAt(v - 9) !== 95)
      return !1;
    for (var A = v - 10; A >= 0; A--)
      if (b.charCodeAt(A) !== 36)
        return !1;
    return !0;
  }
  function m(b, v, A) {
    var C = y(b.source, v.source);
    return C !== 0 || (C = b.originalLine - v.originalLine, C !== 0) || (C = b.originalColumn - v.originalColumn, C !== 0 || A) || (C = b.generatedColumn - v.generatedColumn, C !== 0) || (C = b.generatedLine - v.generatedLine, C !== 0) ? C : y(b.name, v.name);
  }
  r.compareByOriginalPositions = m;
  function d(b, v, A) {
    var C = b.generatedLine - v.generatedLine;
    return C !== 0 || (C = b.generatedColumn - v.generatedColumn, C !== 0 || A) || (C = y(b.source, v.source), C !== 0) || (C = b.originalLine - v.originalLine, C !== 0) || (C = b.originalColumn - v.originalColumn, C !== 0) ? C : y(b.name, v.name);
  }
  r.compareByGeneratedPositionsDeflated = d;
  function y(b, v) {
    return b === v ? 0 : b === null ? 1 : v === null ? -1 : b > v ? 1 : -1;
  }
  function S(b, v) {
    var A = b.generatedLine - v.generatedLine;
    return A !== 0 || (A = b.generatedColumn - v.generatedColumn, A !== 0) || (A = y(b.source, v.source), A !== 0) || (A = b.originalLine - v.originalLine, A !== 0) || (A = b.originalColumn - v.originalColumn, A !== 0) ? A : y(b.name, v.name);
  }
  r.compareByGeneratedPositionsInflated = S;
  function E(b) {
    return JSON.parse(b.replace(/^\)]}'[^\n]*\n/, ""));
  }
  r.parseSourceMapInput = E;
  function g(b, v, A) {
    if (v = v || "", b && (b[b.length - 1] !== "/" && v[0] !== "/" && (b += "/"), v = b + v), A) {
      var C = i(A);
      if (!C)
        throw new Error("sourceMapURL could not be parsed");
      if (C.path) {
        var x = C.path.lastIndexOf("/");
        x >= 0 && (C.path = C.path.substring(0, x + 1));
      }
      v = o(n(C), v);
    }
    return a(v);
  }
  r.computeSourceURL = g;
})(oa);
var j0 = {}, q0 = oa, H0 = Object.prototype.hasOwnProperty, Ui = typeof Map < "u";
function Ns() {
  this._array = [], this._set = Ui ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
}
Ns.fromArray = function(e, t) {
  for (var s = new Ns(), i = 0, n = e.length; i < n; i++)
    s.add(e[i], t);
  return s;
};
Ns.prototype.size = function() {
  return Ui ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
Ns.prototype.add = function(e, t) {
  var s = Ui ? e : q0.toSetString(e), i = Ui ? this.has(e) : H0.call(this._set, s), n = this._array.length;
  (!i || t) && this._array.push(e), i || (Ui ? this._set.set(e, n) : this._set[s] = n);
};
Ns.prototype.has = function(e) {
  if (Ui)
    return this._set.has(e);
  var t = q0.toSetString(e);
  return H0.call(this._set, t);
};
Ns.prototype.indexOf = function(e) {
  if (Ui) {
    var t = this._set.get(e);
    if (t >= 0)
      return t;
  } else {
    var s = q0.toSetString(e);
    if (H0.call(this._set, s))
      return this._set[s];
  }
  throw new Error('"' + e + '" is not in the set.');
};
Ns.prototype.at = function(e) {
  if (e >= 0 && e < this._array.length)
    return this._array[e];
  throw new Error("No element indexed by " + e);
};
Ns.prototype.toArray = function() {
  return this._array.slice();
};
j0.ArraySet = Ns;
var Qx = {}, Zx = oa;
function sR(r, e) {
  var t = r.generatedLine, s = e.generatedLine, i = r.generatedColumn, n = e.generatedColumn;
  return s > t || s == t && n >= i || Zx.compareByGeneratedPositionsInflated(r, e) <= 0;
}
function lf() {
  this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
}
lf.prototype.unsortedForEach = function(e, t) {
  this._array.forEach(e, t);
};
lf.prototype.add = function(e) {
  sR(this._last, e) ? (this._last = e, this._array.push(e)) : (this._sorted = !1, this._array.push(e));
};
lf.prototype.toArray = function() {
  return this._sorted || (this._array.sort(Zx.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
};
Qx.MappingList = lf;
var xa = uf, ft = oa, ql = j0.ArraySet, iR = Qx.MappingList;
function Er(r) {
  r || (r = {}), this._file = ft.getArg(r, "file", null), this._sourceRoot = ft.getArg(r, "sourceRoot", null), this._skipValidation = ft.getArg(r, "skipValidation", !1), this._sources = new ql(), this._names = new ql(), this._mappings = new iR(), this._sourcesContents = null;
}
Er.prototype._version = 3;
Er.fromSourceMap = function(e) {
  var t = e.sourceRoot, s = new Er({
    file: e.file,
    sourceRoot: t
  });
  return e.eachMapping(function(i) {
    var n = {
      generated: {
        line: i.generatedLine,
        column: i.generatedColumn
      }
    };
    i.source != null && (n.source = i.source, t != null && (n.source = ft.relative(t, n.source)), n.original = {
      line: i.originalLine,
      column: i.originalColumn
    }, i.name != null && (n.name = i.name)), s.addMapping(n);
  }), e.sources.forEach(function(i) {
    var n = i;
    t !== null && (n = ft.relative(t, i)), s._sources.has(n) || s._sources.add(n);
    var a = e.sourceContentFor(i);
    a != null && s.setSourceContent(i, a);
  }), s;
};
Er.prototype.addMapping = function(e) {
  var t = ft.getArg(e, "generated"), s = ft.getArg(e, "original", null), i = ft.getArg(e, "source", null), n = ft.getArg(e, "name", null);
  this._skipValidation || this._validateMapping(t, s, i, n), i != null && (i = String(i), this._sources.has(i) || this._sources.add(i)), n != null && (n = String(n), this._names.has(n) || this._names.add(n)), this._mappings.add({
    generatedLine: t.line,
    generatedColumn: t.column,
    originalLine: s != null && s.line,
    originalColumn: s != null && s.column,
    source: i,
    name: n
  });
};
Er.prototype.setSourceContent = function(e, t) {
  var s = e;
  this._sourceRoot != null && (s = ft.relative(this._sourceRoot, s)), t != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[ft.toSetString(s)] = t) : this._sourcesContents && (delete this._sourcesContents[ft.toSetString(s)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
};
Er.prototype.applySourceMap = function(e, t, s) {
  var i = t;
  if (t == null) {
    if (e.file == null)
      throw new Error(
        `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
      );
    i = e.file;
  }
  var n = this._sourceRoot;
  n != null && (i = ft.relative(n, i));
  var a = new ql(), o = new ql();
  this._mappings.unsortedForEach(function(u) {
    if (u.source === i && u.originalLine != null) {
      var l = e.originalPositionFor({
        line: u.originalLine,
        column: u.originalColumn
      });
      l.source != null && (u.source = l.source, s != null && (u.source = ft.join(s, u.source)), n != null && (u.source = ft.relative(n, u.source)), u.originalLine = l.line, u.originalColumn = l.column, l.name != null && (u.name = l.name));
    }
    var c = u.source;
    c != null && !a.has(c) && a.add(c);
    var f = u.name;
    f != null && !o.has(f) && o.add(f);
  }, this), this._sources = a, this._names = o, e.sources.forEach(function(u) {
    var l = e.sourceContentFor(u);
    l != null && (s != null && (u = ft.join(s, u)), n != null && (u = ft.relative(n, u)), this.setSourceContent(u, l));
  }, this);
};
Er.prototype._validateMapping = function(e, t, s, i) {
  if (t && typeof t.line != "number" && typeof t.column != "number")
    throw new Error(
      "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
    );
  if (!(e && "line" in e && "column" in e && e.line > 0 && e.column >= 0 && !t && !s && !i)) {
    if (e && "line" in e && "column" in e && t && "line" in t && "column" in t && e.line > 0 && e.column >= 0 && t.line > 0 && t.column >= 0 && s)
      return;
    throw new Error("Invalid mapping: " + JSON.stringify({
      generated: e,
      source: s,
      original: t,
      name: i
    }));
  }
};
Er.prototype._serializeMappings = function() {
  for (var e = 0, t = 1, s = 0, i = 0, n = 0, a = 0, o = "", u, l, c, f, p = this._mappings.toArray(), h = 0, m = p.length; h < m; h++) {
    if (l = p[h], u = "", l.generatedLine !== t)
      for (e = 0; l.generatedLine !== t; )
        u += ";", t++;
    else if (h > 0) {
      if (!ft.compareByGeneratedPositionsInflated(l, p[h - 1]))
        continue;
      u += ",";
    }
    u += xa.encode(l.generatedColumn - e), e = l.generatedColumn, l.source != null && (f = this._sources.indexOf(l.source), u += xa.encode(f - a), a = f, u += xa.encode(l.originalLine - 1 - i), i = l.originalLine - 1, u += xa.encode(l.originalColumn - s), s = l.originalColumn, l.name != null && (c = this._names.indexOf(l.name), u += xa.encode(c - n), n = c)), o += u;
  }
  return o;
};
Er.prototype._generateSourcesContent = function(e, t) {
  return e.map(function(s) {
    if (!this._sourcesContents)
      return null;
    t != null && (s = ft.relative(t, s));
    var i = ft.toSetString(s);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, i) ? this._sourcesContents[i] : null;
  }, this);
};
Er.prototype.toJSON = function() {
  var e = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  return this._file != null && (e.file = this._file), this._sourceRoot != null && (e.sourceRoot = this._sourceRoot), this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot)), e;
};
Er.prototype.toString = function() {
  return JSON.stringify(this.toJSON());
};
B0.SourceMapGenerator = Er;
var cf = {}, ew = {};
(function(r) {
  r.GREATEST_LOWER_BOUND = 1, r.LEAST_UPPER_BOUND = 2;
  function e(t, s, i, n, a, o) {
    var u = Math.floor((s - t) / 2) + t, l = a(i, n[u], !0);
    return l === 0 ? u : l > 0 ? s - u > 1 ? e(u, s, i, n, a, o) : o == r.LEAST_UPPER_BOUND ? s < n.length ? s : -1 : u : u - t > 1 ? e(t, u, i, n, a, o) : o == r.LEAST_UPPER_BOUND ? u : t < 0 ? -1 : t;
  }
  r.search = function(s, i, n, a) {
    if (i.length === 0)
      return -1;
    var o = e(
      -1,
      i.length,
      s,
      i,
      n,
      a || r.GREATEST_LOWER_BOUND
    );
    if (o < 0)
      return -1;
    for (; o - 1 >= 0 && n(i[o], i[o - 1], !0) === 0; )
      --o;
    return o;
  };
})(ew);
var tw = {};
function Zf(r, e, t) {
  var s = r[e];
  r[e] = r[t], r[t] = s;
}
function nR(r, e) {
  return Math.round(r + Math.random() * (e - r));
}
function zh(r, e, t, s) {
  if (t < s) {
    var i = nR(t, s), n = t - 1;
    Zf(r, i, s);
    for (var a = r[s], o = t; o < s; o++)
      e(r[o], a) <= 0 && (n += 1, Zf(r, n, o));
    Zf(r, n + 1, o);
    var u = n + 1;
    zh(r, e, t, u - 1), zh(r, e, u + 1, s);
  }
}
tw.quickSort = function(r, e) {
  zh(r, e, 0, r.length - 1);
};
var le = oa, W0 = ew, Wn = j0.ArraySet, aR = uf, wo = tw.quickSort;
function Qe(r, e) {
  var t = r;
  return typeof r == "string" && (t = le.parseSourceMapInput(r)), t.sections != null ? new kr(t, e) : new Ot(t, e);
}
Qe.fromSourceMap = function(r, e) {
  return Ot.fromSourceMap(r, e);
};
Qe.prototype._version = 3;
Qe.prototype.__generatedMappings = null;
Object.defineProperty(Qe.prototype, "_generatedMappings", {
  configurable: !0,
  enumerable: !0,
  get: function() {
    return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
  }
});
Qe.prototype.__originalMappings = null;
Object.defineProperty(Qe.prototype, "_originalMappings", {
  configurable: !0,
  enumerable: !0,
  get: function() {
    return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
  }
});
Qe.prototype._charIsMappingSeparator = function(e, t) {
  var s = e.charAt(t);
  return s === ";" || s === ",";
};
Qe.prototype._parseMappings = function(e, t) {
  throw new Error("Subclasses must implement _parseMappings");
};
Qe.GENERATED_ORDER = 1;
Qe.ORIGINAL_ORDER = 2;
Qe.GREATEST_LOWER_BOUND = 1;
Qe.LEAST_UPPER_BOUND = 2;
Qe.prototype.eachMapping = function(e, t, s) {
  var i = t || null, n = s || Qe.GENERATED_ORDER, a;
  switch (n) {
    case Qe.GENERATED_ORDER:
      a = this._generatedMappings;
      break;
    case Qe.ORIGINAL_ORDER:
      a = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }
  var o = this.sourceRoot;
  a.map(function(u) {
    var l = u.source === null ? null : this._sources.at(u.source);
    return l = le.computeSourceURL(o, l, this._sourceMapURL), {
      source: l,
      generatedLine: u.generatedLine,
      generatedColumn: u.generatedColumn,
      originalLine: u.originalLine,
      originalColumn: u.originalColumn,
      name: u.name === null ? null : this._names.at(u.name)
    };
  }, this).forEach(e, i);
};
Qe.prototype.allGeneratedPositionsFor = function(e) {
  var t = le.getArg(e, "line"), s = {
    source: le.getArg(e, "source"),
    originalLine: t,
    originalColumn: le.getArg(e, "column", 0)
  };
  if (s.source = this._findSourceIndex(s.source), s.source < 0)
    return [];
  var i = [], n = this._findMapping(
    s,
    this._originalMappings,
    "originalLine",
    "originalColumn",
    le.compareByOriginalPositions,
    W0.LEAST_UPPER_BOUND
  );
  if (n >= 0) {
    var a = this._originalMappings[n];
    if (e.column === void 0)
      for (var o = a.originalLine; a && a.originalLine === o; )
        i.push({
          line: le.getArg(a, "generatedLine", null),
          column: le.getArg(a, "generatedColumn", null),
          lastColumn: le.getArg(a, "lastGeneratedColumn", null)
        }), a = this._originalMappings[++n];
    else
      for (var u = a.originalColumn; a && a.originalLine === t && a.originalColumn == u; )
        i.push({
          line: le.getArg(a, "generatedLine", null),
          column: le.getArg(a, "generatedColumn", null),
          lastColumn: le.getArg(a, "lastGeneratedColumn", null)
        }), a = this._originalMappings[++n];
  }
  return i;
};
cf.SourceMapConsumer = Qe;
function Ot(r, e) {
  var t = r;
  typeof r == "string" && (t = le.parseSourceMapInput(r));
  var s = le.getArg(t, "version"), i = le.getArg(t, "sources"), n = le.getArg(t, "names", []), a = le.getArg(t, "sourceRoot", null), o = le.getArg(t, "sourcesContent", null), u = le.getArg(t, "mappings"), l = le.getArg(t, "file", null);
  if (s != this._version)
    throw new Error("Unsupported version: " + s);
  a && (a = le.normalize(a)), i = i.map(String).map(le.normalize).map(function(c) {
    return a && le.isAbsolute(a) && le.isAbsolute(c) ? le.relative(a, c) : c;
  }), this._names = Wn.fromArray(n.map(String), !0), this._sources = Wn.fromArray(i, !0), this._absoluteSources = this._sources.toArray().map(function(c) {
    return le.computeSourceURL(a, c, e);
  }), this.sourceRoot = a, this.sourcesContent = o, this._mappings = u, this._sourceMapURL = e, this.file = l;
}
Ot.prototype = Object.create(Qe.prototype);
Ot.prototype.consumer = Qe;
Ot.prototype._findSourceIndex = function(r) {
  var e = r;
  if (this.sourceRoot != null && (e = le.relative(this.sourceRoot, e)), this._sources.has(e))
    return this._sources.indexOf(e);
  var t;
  for (t = 0; t < this._absoluteSources.length; ++t)
    if (this._absoluteSources[t] == r)
      return t;
  return -1;
};
Ot.fromSourceMap = function(e, t) {
  var s = Object.create(Ot.prototype), i = s._names = Wn.fromArray(e._names.toArray(), !0), n = s._sources = Wn.fromArray(e._sources.toArray(), !0);
  s.sourceRoot = e._sourceRoot, s.sourcesContent = e._generateSourcesContent(
    s._sources.toArray(),
    s.sourceRoot
  ), s.file = e._file, s._sourceMapURL = t, s._absoluteSources = s._sources.toArray().map(function(h) {
    return le.computeSourceURL(s.sourceRoot, h, t);
  });
  for (var a = e._mappings.toArray().slice(), o = s.__generatedMappings = [], u = s.__originalMappings = [], l = 0, c = a.length; l < c; l++) {
    var f = a[l], p = new rw();
    p.generatedLine = f.generatedLine, p.generatedColumn = f.generatedColumn, f.source && (p.source = n.indexOf(f.source), p.originalLine = f.originalLine, p.originalColumn = f.originalColumn, f.name && (p.name = i.indexOf(f.name)), u.push(p)), o.push(p);
  }
  return wo(s.__originalMappings, le.compareByOriginalPositions), s;
};
Ot.prototype._version = 3;
Object.defineProperty(Ot.prototype, "sources", {
  get: function() {
    return this._absoluteSources.slice();
  }
});
function rw() {
  this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
}
Ot.prototype._parseMappings = function(e, t) {
  for (var s = 1, i = 0, n = 0, a = 0, o = 0, u = 0, l = e.length, c = 0, f = {}, p = {}, h = [], m = [], d, y, S, E, g; c < l; )
    if (e.charAt(c) === ";")
      s++, c++, i = 0;
    else if (e.charAt(c) === ",")
      c++;
    else {
      for (d = new rw(), d.generatedLine = s, E = c; E < l && !this._charIsMappingSeparator(e, E); E++)
        ;
      if (y = e.slice(c, E), S = f[y], S)
        c += y.length;
      else {
        for (S = []; c < E; )
          aR.decode(e, c, p), g = p.value, c = p.rest, S.push(g);
        if (S.length === 2)
          throw new Error("Found a source, but no line and column");
        if (S.length === 3)
          throw new Error("Found a source and line, but no column");
        f[y] = S;
      }
      d.generatedColumn = i + S[0], i = d.generatedColumn, S.length > 1 && (d.source = o + S[1], o += S[1], d.originalLine = n + S[2], n = d.originalLine, d.originalLine += 1, d.originalColumn = a + S[3], a = d.originalColumn, S.length > 4 && (d.name = u + S[4], u += S[4])), m.push(d), typeof d.originalLine == "number" && h.push(d);
    }
  wo(m, le.compareByGeneratedPositionsDeflated), this.__generatedMappings = m, wo(h, le.compareByOriginalPositions), this.__originalMappings = h;
};
Ot.prototype._findMapping = function(e, t, s, i, n, a) {
  if (e[s] <= 0)
    throw new TypeError("Line must be greater than or equal to 1, got " + e[s]);
  if (e[i] < 0)
    throw new TypeError("Column must be greater than or equal to 0, got " + e[i]);
  return W0.search(e, t, n, a);
};
Ot.prototype.computeColumnSpans = function() {
  for (var e = 0; e < this._generatedMappings.length; ++e) {
    var t = this._generatedMappings[e];
    if (e + 1 < this._generatedMappings.length) {
      var s = this._generatedMappings[e + 1];
      if (t.generatedLine === s.generatedLine) {
        t.lastGeneratedColumn = s.generatedColumn - 1;
        continue;
      }
    }
    t.lastGeneratedColumn = 1 / 0;
  }
};
Ot.prototype.originalPositionFor = function(e) {
  var t = {
    generatedLine: le.getArg(e, "line"),
    generatedColumn: le.getArg(e, "column")
  }, s = this._findMapping(
    t,
    this._generatedMappings,
    "generatedLine",
    "generatedColumn",
    le.compareByGeneratedPositionsDeflated,
    le.getArg(e, "bias", Qe.GREATEST_LOWER_BOUND)
  );
  if (s >= 0) {
    var i = this._generatedMappings[s];
    if (i.generatedLine === t.generatedLine) {
      var n = le.getArg(i, "source", null);
      n !== null && (n = this._sources.at(n), n = le.computeSourceURL(this.sourceRoot, n, this._sourceMapURL));
      var a = le.getArg(i, "name", null);
      return a !== null && (a = this._names.at(a)), {
        source: n,
        line: le.getArg(i, "originalLine", null),
        column: le.getArg(i, "originalColumn", null),
        name: a
      };
    }
  }
  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
Ot.prototype.hasContentsOfAllSources = function() {
  return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e) {
    return e == null;
  }) : !1;
};
Ot.prototype.sourceContentFor = function(e, t) {
  if (!this.sourcesContent)
    return null;
  var s = this._findSourceIndex(e);
  if (s >= 0)
    return this.sourcesContent[s];
  var i = e;
  this.sourceRoot != null && (i = le.relative(this.sourceRoot, i));
  var n;
  if (this.sourceRoot != null && (n = le.urlParse(this.sourceRoot))) {
    var a = i.replace(/^file:\/\//, "");
    if (n.scheme == "file" && this._sources.has(a))
      return this.sourcesContent[this._sources.indexOf(a)];
    if ((!n.path || n.path == "/") && this._sources.has("/" + i))
      return this.sourcesContent[this._sources.indexOf("/" + i)];
  }
  if (t)
    return null;
  throw new Error('"' + i + '" is not in the SourceMap.');
};
Ot.prototype.generatedPositionFor = function(e) {
  var t = le.getArg(e, "source");
  if (t = this._findSourceIndex(t), t < 0)
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  var s = {
    source: t,
    originalLine: le.getArg(e, "line"),
    originalColumn: le.getArg(e, "column")
  }, i = this._findMapping(
    s,
    this._originalMappings,
    "originalLine",
    "originalColumn",
    le.compareByOriginalPositions,
    le.getArg(e, "bias", Qe.GREATEST_LOWER_BOUND)
  );
  if (i >= 0) {
    var n = this._originalMappings[i];
    if (n.source === s.source)
      return {
        line: le.getArg(n, "generatedLine", null),
        column: le.getArg(n, "generatedColumn", null),
        lastColumn: le.getArg(n, "lastGeneratedColumn", null)
      };
  }
  return {
    line: null,
    column: null,
    lastColumn: null
  };
};
cf.BasicSourceMapConsumer = Ot;
function kr(r, e) {
  var t = r;
  typeof r == "string" && (t = le.parseSourceMapInput(r));
  var s = le.getArg(t, "version"), i = le.getArg(t, "sections");
  if (s != this._version)
    throw new Error("Unsupported version: " + s);
  this._sources = new Wn(), this._names = new Wn();
  var n = {
    line: -1,
    column: 0
  };
  this._sections = i.map(function(a) {
    if (a.url)
      throw new Error("Support for url field in sections not implemented.");
    var o = le.getArg(a, "offset"), u = le.getArg(o, "line"), l = le.getArg(o, "column");
    if (u < n.line || u === n.line && l < n.column)
      throw new Error("Section offsets must be ordered and non-overlapping.");
    return n = o, {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: u + 1,
        generatedColumn: l + 1
      },
      consumer: new Qe(le.getArg(a, "map"), e)
    };
  });
}
kr.prototype = Object.create(Qe.prototype);
kr.prototype.constructor = Qe;
kr.prototype._version = 3;
Object.defineProperty(kr.prototype, "sources", {
  get: function() {
    for (var r = [], e = 0; e < this._sections.length; e++)
      for (var t = 0; t < this._sections[e].consumer.sources.length; t++)
        r.push(this._sections[e].consumer.sources[t]);
    return r;
  }
});
kr.prototype.originalPositionFor = function(e) {
  var t = {
    generatedLine: le.getArg(e, "line"),
    generatedColumn: le.getArg(e, "column")
  }, s = W0.search(
    t,
    this._sections,
    function(n, a) {
      var o = n.generatedLine - a.generatedOffset.generatedLine;
      return o || n.generatedColumn - a.generatedOffset.generatedColumn;
    }
  ), i = this._sections[s];
  return i ? i.consumer.originalPositionFor({
    line: t.generatedLine - (i.generatedOffset.generatedLine - 1),
    column: t.generatedColumn - (i.generatedOffset.generatedLine === t.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),
    bias: e.bias
  }) : {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
kr.prototype.hasContentsOfAllSources = function() {
  return this._sections.every(function(e) {
    return e.consumer.hasContentsOfAllSources();
  });
};
kr.prototype.sourceContentFor = function(e, t) {
  for (var s = 0; s < this._sections.length; s++) {
    var i = this._sections[s], n = i.consumer.sourceContentFor(e, !0);
    if (n)
      return n;
  }
  if (t)
    return null;
  throw new Error('"' + e + '" is not in the SourceMap.');
};
kr.prototype.generatedPositionFor = function(e) {
  for (var t = 0; t < this._sections.length; t++) {
    var s = this._sections[t];
    if (s.consumer._findSourceIndex(le.getArg(e, "source")) !== -1) {
      var i = s.consumer.generatedPositionFor(e);
      if (i) {
        var n = {
          line: i.line + (s.generatedOffset.generatedLine - 1),
          column: i.column + (s.generatedOffset.generatedLine === i.line ? s.generatedOffset.generatedColumn - 1 : 0)
        };
        return n;
      }
    }
  }
  return {
    line: null,
    column: null
  };
};
kr.prototype._parseMappings = function(e, t) {
  this.__generatedMappings = [], this.__originalMappings = [];
  for (var s = 0; s < this._sections.length; s++)
    for (var i = this._sections[s], n = i.consumer._generatedMappings, a = 0; a < n.length; a++) {
      var o = n[a], u = i.consumer._sources.at(o.source);
      u = le.computeSourceURL(i.consumer.sourceRoot, u, this._sourceMapURL), this._sources.add(u), u = this._sources.indexOf(u);
      var l = null;
      o.name && (l = i.consumer._names.at(o.name), this._names.add(l), l = this._names.indexOf(l));
      var c = {
        source: u,
        generatedLine: o.generatedLine + (i.generatedOffset.generatedLine - 1),
        generatedColumn: o.generatedColumn + (i.generatedOffset.generatedLine === o.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),
        originalLine: o.originalLine,
        originalColumn: o.originalColumn,
        name: l
      };
      this.__generatedMappings.push(c), typeof c.originalLine == "number" && this.__originalMappings.push(c);
    }
  wo(this.__generatedMappings, le.compareByGeneratedPositionsDeflated), wo(this.__originalMappings, le.compareByOriginalPositions);
};
cf.IndexedSourceMapConsumer = kr;
var sw = {}, oR = B0.SourceMapGenerator, Hl = oa, uR = /(\r?\n)/, lR = 10, ua = "$$$isSourceNode$$$";
function cr(r, e, t, s, i) {
  this.children = [], this.sourceContents = {}, this.line = r ?? null, this.column = e ?? null, this.source = t ?? null, this.name = i ?? null, this[ua] = !0, s != null && this.add(s);
}
cr.fromStringWithSourceMap = function(e, t, s) {
  var i = new cr(), n = e.split(uR), a = 0, o = function() {
    var p = m(), h = m() || "";
    return p + h;
    function m() {
      return a < n.length ? n[a++] : void 0;
    }
  }, u = 1, l = 0, c = null;
  return t.eachMapping(function(p) {
    if (c !== null)
      if (u < p.generatedLine)
        f(c, o()), u++, l = 0;
      else {
        var h = n[a] || "", m = h.substr(0, p.generatedColumn - l);
        n[a] = h.substr(p.generatedColumn - l), l = p.generatedColumn, f(c, m), c = p;
        return;
      }
    for (; u < p.generatedLine; )
      i.add(o()), u++;
    if (l < p.generatedColumn) {
      var h = n[a] || "";
      i.add(h.substr(0, p.generatedColumn)), n[a] = h.substr(p.generatedColumn), l = p.generatedColumn;
    }
    c = p;
  }, this), a < n.length && (c && f(c, o()), i.add(n.splice(a).join(""))), t.sources.forEach(function(p) {
    var h = t.sourceContentFor(p);
    h != null && (s != null && (p = Hl.join(s, p)), i.setSourceContent(p, h));
  }), i;
  function f(p, h) {
    if (p === null || p.source === void 0)
      i.add(h);
    else {
      var m = s ? Hl.join(s, p.source) : p.source;
      i.add(new cr(
        p.originalLine,
        p.originalColumn,
        m,
        h,
        p.name
      ));
    }
  }
};
cr.prototype.add = function(e) {
  if (Array.isArray(e))
    e.forEach(function(t) {
      this.add(t);
    }, this);
  else if (e[ua] || typeof e == "string")
    e && this.children.push(e);
  else
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e
    );
  return this;
};
cr.prototype.prepend = function(e) {
  if (Array.isArray(e))
    for (var t = e.length - 1; t >= 0; t--)
      this.prepend(e[t]);
  else if (e[ua] || typeof e == "string")
    this.children.unshift(e);
  else
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e
    );
  return this;
};
cr.prototype.walk = function(e) {
  for (var t, s = 0, i = this.children.length; s < i; s++)
    t = this.children[s], t[ua] ? t.walk(e) : t !== "" && e(t, {
      source: this.source,
      line: this.line,
      column: this.column,
      name: this.name
    });
};
cr.prototype.join = function(e) {
  var t, s, i = this.children.length;
  if (i > 0) {
    for (t = [], s = 0; s < i - 1; s++)
      t.push(this.children[s]), t.push(e);
    t.push(this.children[s]), this.children = t;
  }
  return this;
};
cr.prototype.replaceRight = function(e, t) {
  var s = this.children[this.children.length - 1];
  return s[ua] ? s.replaceRight(e, t) : typeof s == "string" ? this.children[this.children.length - 1] = s.replace(e, t) : this.children.push("".replace(e, t)), this;
};
cr.prototype.setSourceContent = function(e, t) {
  this.sourceContents[Hl.toSetString(e)] = t;
};
cr.prototype.walkSourceContents = function(e) {
  for (var t = 0, s = this.children.length; t < s; t++)
    this.children[t][ua] && this.children[t].walkSourceContents(e);
  for (var i = Object.keys(this.sourceContents), t = 0, s = i.length; t < s; t++)
    e(Hl.fromSetString(i[t]), this.sourceContents[i[t]]);
};
cr.prototype.toString = function() {
  var e = "";
  return this.walk(function(t) {
    e += t;
  }), e;
};
cr.prototype.toStringWithSourceMap = function(e) {
  var t = {
    code: "",
    line: 1,
    column: 0
  }, s = new oR(e), i = !1, n = null, a = null, o = null, u = null;
  return this.walk(function(l, c) {
    t.code += l, c.source !== null && c.line !== null && c.column !== null ? ((n !== c.source || a !== c.line || o !== c.column || u !== c.name) && s.addMapping({
      source: c.source,
      original: {
        line: c.line,
        column: c.column
      },
      generated: {
        line: t.line,
        column: t.column
      },
      name: c.name
    }), n = c.source, a = c.line, o = c.column, u = c.name, i = !0) : i && (s.addMapping({
      generated: {
        line: t.line,
        column: t.column
      }
    }), n = null, i = !1);
    for (var f = 0, p = l.length; f < p; f++)
      l.charCodeAt(f) === lR ? (t.line++, t.column = 0, f + 1 === p ? (n = null, i = !1) : i && s.addMapping({
        source: c.source,
        original: {
          line: c.line,
          column: c.column
        },
        generated: {
          line: t.line,
          column: t.column
        },
        name: c.name
      })) : t.column++;
  }), this.walkSourceContents(function(l, c) {
    s.setSourceContent(l, c);
  }), { code: t.code, map: s };
};
sw.SourceNode = cr;
of.SourceMapGenerator = B0.SourceMapGenerator;
of.SourceMapConsumer = cf.SourceMapConsumer;
of.SourceNode = sw.SourceNode;
var iw = of, U1 = iw.SourceMapConsumer, cR = iw.SourceMapGenerator, fR = pR;
function pR(r, e) {
  if (!r) return e;
  if (!e) return r;
  var t = new U1(r), s = new U1(e), i = new cR();
  s.eachMapping(function(a) {
    if (a.originalLine != null) {
      var o = t.originalPositionFor({
        line: a.originalLine,
        column: a.originalColumn
      });
      o.source != null && i.addMapping({
        original: {
          line: o.line,
          column: o.column
        },
        generated: {
          line: a.generatedLine,
          column: a.generatedColumn
        },
        source: o.source,
        name: o.name
      });
    }
  });
  var n = [t, s];
  return n.forEach(function(a) {
    a.sources.forEach(function(o) {
      i._sources.add(o);
      var u = a.sourceContentFor(o);
      u != null && i.setSourceContent(o, u);
    });
  }), i._sourceRoot = r.sourceRoot, i._file = r.file, JSON.parse(i.toString());
}
var z0 = /* @__PURE__ */ Dc(fR), hR = Object.defineProperty, dR = Object.defineProperties, mR = Object.getOwnPropertyDescriptors, j1 = Object.getOwnPropertySymbols, gR = Object.prototype.hasOwnProperty, yR = Object.prototype.propertyIsEnumerable, q1 = (r, e, t) => e in r ? hR(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, G0 = (r, e) => {
  for (var t in e || (e = {}))
    gR.call(e, t) && q1(r, t, e[t]);
  if (j1)
    for (var t of j1(e))
      yR.call(e, t) && q1(r, t, e[t]);
  return r;
}, K0 = (r, e) => dR(r, mR(e));
const nw = (r, e, t, s = require) => {
  const i = s("sass"), n = K0(G0({}, t), {
    data: aw(r, t.filename, t.additionalData),
    file: t.filename,
    outFile: t.filename,
    sourceMap: !!e
  });
  try {
    const a = i.renderSync(n), o = a.stats.includedFiles;
    return e ? {
      code: a.css.toString(),
      map: z0(e, JSON.parse(a.map.toString())),
      errors: [],
      dependencies: o
    } : { code: a.css.toString(), errors: [], dependencies: o };
  } catch (a) {
    return { code: "", errors: [a], dependencies: [] };
  }
}, bR = (r, e, t, s) => nw(
  r,
  e,
  K0(G0({}, t), {
    indentedSyntax: !0
  }),
  s
), vR = (r, e, t, s = require) => {
  const i = s("less");
  let n, a = null;
  if (i.render(
    aw(r, t.filename, t.additionalData),
    K0(G0({}, t), { syncImport: !0 }),
    (u, l) => {
      a = u, n = l;
    }
  ), a) return { code: "", errors: [a], dependencies: [] };
  const o = n.imports;
  return e ? {
    code: n.css.toString(),
    map: z0(e, n.map),
    errors: [],
    dependencies: o
  } : {
    code: n.css.toString(),
    errors: [],
    dependencies: o
  };
}, H1 = (r, e, t, s = require) => {
  const i = s("stylus");
  try {
    const n = i(r, t);
    e && n.set("sourcemap", { inline: !1, comment: !1 });
    const a = n.render(), o = n.deps();
    return e ? {
      code: a,
      map: z0(e, n.sourcemap),
      errors: [],
      dependencies: o
    } : { code: a, errors: [], dependencies: o };
  } catch (n) {
    return { code: "", errors: [n], dependencies: [] };
  }
};
function aw(r, e, t) {
  return t ? LE(t) ? t(r, e) : t + r : r;
}
const ER = {
  less: vR,
  sass: bR,
  scss: nw,
  styl: H1,
  stylus: H1
};
var SR = Object.defineProperty, _R = Object.defineProperties, xR = Object.getOwnPropertyDescriptors, W1 = Object.getOwnPropertySymbols, wR = Object.prototype.hasOwnProperty, TR = Object.prototype.propertyIsEnumerable, z1 = (r, e, t) => e in r ? SR(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, ff = (r, e) => {
  for (var t in e || (e = {}))
    wR.call(e, t) && z1(r, t, e[t]);
  if (W1)
    for (var t of W1(e))
      TR.call(e, t) && z1(r, t, e[t]);
  return r;
}, X0 = (r, e) => _R(r, xR(e));
function PR(r) {
  return ow(X0(ff({}, r), {
    isAsync: !1
  }));
}
function AR(r) {
  return ow(X0(ff({}, r), {
    isAsync: !0
  }));
}
function ow(r) {
  const {
    filename: e,
    id: t,
    scoped: s = !1,
    trim: i = !0,
    isProd: n = !1,
    modules: a = !1,
    modulesOptions: o = {},
    preprocessLang: u,
    postcssOptions: l,
    postcssPlugins: c
  } = r, f = u && ER[u], p = f && CR(r, f), h = p ? p.map : r.inMap || r.map, m = p ? p.code : r.source, d = t.replace(/^data-v-/, ""), y = `data-v-${d}`, S = (c || []).slice();
  S.unshift(b2({ id: d, isProd: n })), i && S.push(Cx()), s && S.push(Gx(y));
  let E;
  if (a)
    throw new Error(
      "[@vue/compiler-sfc] `modules` option is not supported in the browser build."
    );
  const g = X0(ff({}, l), {
    to: e,
    from: e
  });
  h && (g.map = {
    inline: !1,
    annotation: !1,
    prev: h
  });
  let b, v, A;
  const C = new Set(
    p ? p.dependencies : []
  );
  C.delete(e);
  const x = [];
  p && p.errors.length && x.push(...p.errors);
  const _ = (T) => (T.forEach((P) => {
    P.type === "dependency" && C.add(P.file);
  }), C);
  try {
    if (b = Ze(S).process(m, g), r.isAsync)
      return b.then((T) => ({
        code: T.css || "",
        map: T.map && T.map.toJSON(),
        errors: x,
        modules: E,
        rawResult: T,
        dependencies: _(T.messages)
      })).catch((T) => ({
        code: "",
        map: void 0,
        errors: [...x, T],
        rawResult: void 0,
        dependencies: C
      }));
    _(b.messages), v = b.css, A = b.map;
  } catch (T) {
    x.push(T);
  }
  return {
    code: v || "",
    map: A && A.toJSON(),
    errors: x,
    rawResult: b,
    dependencies: C
  };
}
function CR(r, e) {
  if (!r.preprocessCustomRequire)
    throw new Error(
      "[@vue/compiler-sfc] Style preprocessing in the browser build must provide the `preprocessCustomRequire` option to return the in-browser version of the preprocessor."
    );
  return e(
    r.source,
    r.inMap || r.map,
    ff({
      filename: r.filename
    }, r.preprocessOptions),
    r.preprocessCustomRequire
  );
}
function uw(r) {
  for (const e of r)
    if (e.type === "ExportDefaultDeclaration" && e.declaration.type === "ObjectExpression")
      return NR(e.declaration);
  return {};
}
function NR(r) {
  const e = {};
  Object.defineProperty(e, "__isScriptSetup", {
    enumerable: !1,
    value: !1
  });
  for (const t of r.properties)
    if (t.type === "ObjectProperty" && !t.computed && t.key.type === "Identifier") {
      if (t.key.name === "props")
        for (const s of Kh(t.value))
          e[s] = "props";
      else if (t.key.name === "inject")
        for (const s of Kh(t.value))
          e[s] = "options";
      else if (t.value.type === "ObjectExpression" && (t.key.name === "computed" || t.key.name === "methods"))
        for (const s of Gh(t.value))
          e[s] = "options";
    } else if (t.type === "ObjectMethod" && t.key.type === "Identifier" && (t.key.name === "setup" || t.key.name === "data")) {
      for (const s of t.body.body)
        if (s.type === "ReturnStatement" && s.argument && s.argument.type === "ObjectExpression")
          for (const i of Gh(s.argument))
            e[i] = t.key.name === "setup" ? "setup-maybe-ref" : "data";
    }
  return e;
}
function Gh(r) {
  const e = [];
  for (const t of r.properties) {
    if (t.type === "SpreadElement") continue;
    const s = n0(t.key, t.computed);
    s && e.push(String(s));
  }
  return e;
}
function OR(r) {
  const e = [];
  for (const t of r.elements)
    t && t.type === "StringLiteral" && e.push(t.value);
  return e;
}
function Kh(r) {
  return r.type === "ArrayExpression" ? OR(r) : r.type === "ObjectExpression" ? Gh(r) : [];
}
const IR = 44, kR = 59, G1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lw = new Uint8Array(64), DR = new Uint8Array(128);
for (let r = 0; r < G1.length; r++) {
  const e = G1.charCodeAt(r);
  lw[r] = e, DR[e] = r;
}
const ep = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
  decode(r) {
    return Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString();
  }
} : {
  decode(r) {
    let e = "";
    for (let t = 0; t < r.length; t++)
      e += String.fromCharCode(r[t]);
    return e;
  }
};
function LR(r) {
  const e = new Int32Array(5), t = 1024 * 16, s = t - 36, i = new Uint8Array(t), n = i.subarray(0, s);
  let a = 0, o = "";
  for (let u = 0; u < r.length; u++) {
    const l = r[u];
    if (u > 0 && (a === t && (o += ep.decode(i), a = 0), i[a++] = kR), l.length !== 0) {
      e[0] = 0;
      for (let c = 0; c < l.length; c++) {
        const f = l[c];
        a > s && (o += ep.decode(n), i.copyWithin(0, s, a), a -= s), c > 0 && (i[a++] = IR), a = wa(i, a, e, f, 0), f.length !== 1 && (a = wa(i, a, e, f, 1), a = wa(i, a, e, f, 2), a = wa(i, a, e, f, 3), f.length !== 4 && (a = wa(i, a, e, f, 4)));
      }
    }
  }
  return o + ep.decode(i.subarray(0, a));
}
function wa(r, e, t, s, i) {
  const n = s[i];
  let a = n - t[i];
  t[i] = n, a = a < 0 ? -a << 1 | 1 : a << 1;
  do {
    let o = a & 31;
    a >>>= 5, a > 0 && (o |= 32), r[e++] = lw[o];
  } while (a > 0);
  return e;
}
class Wl {
  constructor(e) {
    this.bits = e instanceof Wl ? e.bits.slice() : [];
  }
  add(e) {
    this.bits[e >> 5] |= 1 << (e & 31);
  }
  has(e) {
    return !!(this.bits[e >> 5] & 1 << (e & 31));
  }
}
class To {
  constructor(e, t, s) {
    this.start = e, this.end = t, this.original = s, this.intro = "", this.outro = "", this.content = s, this.storeName = !1, this.edited = !1, this.previous = null, this.next = null;
  }
  appendLeft(e) {
    this.outro += e;
  }
  appendRight(e) {
    this.intro = this.intro + e;
  }
  clone() {
    const e = new To(this.start, this.end, this.original);
    return e.intro = this.intro, e.outro = this.outro, e.content = this.content, e.storeName = this.storeName, e.edited = this.edited, e;
  }
  contains(e) {
    return this.start < e && e < this.end;
  }
  eachNext(e) {
    let t = this;
    for (; t; )
      e(t), t = t.next;
  }
  eachPrevious(e) {
    let t = this;
    for (; t; )
      e(t), t = t.previous;
  }
  edit(e, t, s) {
    return this.content = e, s || (this.intro = "", this.outro = ""), this.storeName = t, this.edited = !0, this;
  }
  prependLeft(e) {
    this.outro = e + this.outro;
  }
  prependRight(e) {
    this.intro = e + this.intro;
  }
  reset() {
    this.intro = "", this.outro = "", this.edited && (this.content = this.original, this.storeName = !1, this.edited = !1);
  }
  split(e) {
    const t = e - this.start, s = this.original.slice(0, t), i = this.original.slice(t);
    this.original = s;
    const n = new To(e, this.end, i);
    return n.outro = this.outro, this.outro = "", this.end = e, this.edited ? (n.edit("", !1), this.content = "") : this.content = s, n.next = this.next, n.next && (n.next.previous = n), n.previous = this, this.next = n, n;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(e) {
    if (this.outro = this.outro.replace(e, ""), this.outro.length) return !0;
    const t = this.content.replace(e, "");
    if (t.length)
      return t !== this.content && (this.split(this.start + t.length).edit("", void 0, !0), this.edited && this.edit(t, this.storeName, !0)), !0;
    if (this.edit("", void 0, !0), this.intro = this.intro.replace(e, ""), this.intro.length) return !0;
  }
  trimStart(e) {
    if (this.intro = this.intro.replace(e, ""), this.intro.length) return !0;
    const t = this.content.replace(e, "");
    if (t.length) {
      if (t !== this.content) {
        const s = this.split(this.end - t.length);
        this.edited && s.edit(t, this.storeName, !0), this.edit("", void 0, !0);
      }
      return !0;
    } else if (this.edit("", void 0, !0), this.outro = this.outro.replace(e, ""), this.outro.length) return !0;
  }
}
function MR() {
  return typeof globalThis < "u" && typeof globalThis.btoa == "function" ? (r) => globalThis.btoa(unescape(encodeURIComponent(r))) : typeof Buffer == "function" ? (r) => Buffer.from(r, "utf-8").toString("base64") : () => {
    throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
  };
}
const RR = /* @__PURE__ */ MR();
class $R {
  constructor(e) {
    this.version = 3, this.file = e.file, this.sources = e.sources, this.sourcesContent = e.sourcesContent, this.names = e.names, this.mappings = LR(e.mappings), typeof e.x_google_ignoreList < "u" && (this.x_google_ignoreList = e.x_google_ignoreList);
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + RR(this.toString());
  }
}
function FR(r) {
  const e = r.split(`
`), t = e.filter((n) => /^\t+/.test(n)), s = e.filter((n) => /^ {2,}/.test(n));
  if (t.length === 0 && s.length === 0)
    return null;
  if (t.length >= s.length)
    return "	";
  const i = s.reduce((n, a) => {
    const o = /^ +/.exec(a)[0].length;
    return Math.min(o, n);
  }, 1 / 0);
  return new Array(i + 1).join(" ");
}
function BR(r, e) {
  const t = r.split(/[/\\]/), s = e.split(/[/\\]/);
  for (t.pop(); t[0] === s[0]; )
    t.shift(), s.shift();
  if (t.length) {
    let i = t.length;
    for (; i--; ) t[i] = "..";
  }
  return t.concat(s).join("/");
}
const VR = Object.prototype.toString;
function UR(r) {
  return VR.call(r) === "[object Object]";
}
function K1(r) {
  const e = r.split(`
`), t = [];
  for (let s = 0, i = 0; s < e.length; s++)
    t.push(i), i += e[s].length + 1;
  return function(i) {
    let n = 0, a = t.length;
    for (; n < a; ) {
      const l = n + a >> 1;
      i < t[l] ? a = l : n = l + 1;
    }
    const o = n - 1, u = i - t[o];
    return { line: o, column: u };
  };
}
const jR = /\w/;
class qR {
  constructor(e) {
    this.hires = e, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
  }
  addEdit(e, t, s, i) {
    if (t.length) {
      const n = t.length - 1;
      let a = t.indexOf(`
`, 0), o = -1;
      for (; a >= 0 && n > a; ) {
        const l = [this.generatedCodeColumn, e, s.line, s.column];
        i >= 0 && l.push(i), this.rawSegments.push(l), this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, o = a, a = t.indexOf(`
`, a + 1);
      }
      const u = [this.generatedCodeColumn, e, s.line, s.column];
      i >= 0 && u.push(i), this.rawSegments.push(u), this.advance(t.slice(o + 1));
    } else this.pending && (this.rawSegments.push(this.pending), this.advance(t));
    this.pending = null;
  }
  addUneditedChunk(e, t, s, i, n) {
    let a = t.start, o = !0, u = !1;
    for (; a < t.end; ) {
      if (this.hires || o || n.has(a)) {
        const l = [this.generatedCodeColumn, e, i.line, i.column];
        this.hires === "boundary" ? jR.test(s[a]) ? u || (this.rawSegments.push(l), u = !0) : (this.rawSegments.push(l), u = !1) : this.rawSegments.push(l);
      }
      s[a] === `
` ? (i.line += 1, i.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, o = !0) : (i.column += 1, this.generatedCodeColumn += 1, o = !1), a += 1;
    }
    this.pending = null;
  }
  advance(e) {
    if (!e) return;
    const t = e.split(`
`);
    if (t.length > 1) {
      for (let s = 0; s < t.length - 1; s++)
        this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += t[t.length - 1].length;
  }
}
const Ta = `
`, ln = {
  insertLeft: !1,
  insertRight: !1,
  storeName: !1
};
class la {
  constructor(e, t = {}) {
    const s = new To(0, e.length, e);
    Object.defineProperties(this, {
      original: { writable: !0, value: e },
      outro: { writable: !0, value: "" },
      intro: { writable: !0, value: "" },
      firstChunk: { writable: !0, value: s },
      lastChunk: { writable: !0, value: s },
      lastSearchedChunk: { writable: !0, value: s },
      byStart: { writable: !0, value: {} },
      byEnd: { writable: !0, value: {} },
      filename: { writable: !0, value: t.filename },
      indentExclusionRanges: { writable: !0, value: t.indentExclusionRanges },
      sourcemapLocations: { writable: !0, value: new Wl() },
      storedNames: { writable: !0, value: {} },
      indentStr: { writable: !0, value: void 0 },
      ignoreList: { writable: !0, value: t.ignoreList }
    }), this.byStart[0] = s, this.byEnd[e.length] = s;
  }
  addSourcemapLocation(e) {
    this.sourcemapLocations.add(e);
  }
  append(e) {
    if (typeof e != "string") throw new TypeError("outro content must be a string");
    return this.outro += e, this;
  }
  appendLeft(e, t) {
    if (typeof t != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    const s = this.byEnd[e];
    return s ? s.appendLeft(t) : this.intro += t, this;
  }
  appendRight(e, t) {
    if (typeof t != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    const s = this.byStart[e];
    return s ? s.appendRight(t) : this.outro += t, this;
  }
  clone() {
    const e = new la(this.original, { filename: this.filename });
    let t = this.firstChunk, s = e.firstChunk = e.lastSearchedChunk = t.clone();
    for (; t; ) {
      e.byStart[s.start] = s, e.byEnd[s.end] = s;
      const i = t.next, n = i && i.clone();
      n && (s.next = n, n.previous = s, s = n), t = i;
    }
    return e.lastChunk = s, this.indentExclusionRanges && (e.indentExclusionRanges = this.indentExclusionRanges.slice()), e.sourcemapLocations = new Wl(this.sourcemapLocations), e.intro = this.intro, e.outro = this.outro, e;
  }
  generateDecodedMap(e) {
    e = e || {};
    const t = 0, s = Object.keys(this.storedNames), i = new qR(e.hires), n = K1(this.original);
    return this.intro && i.advance(this.intro), this.firstChunk.eachNext((a) => {
      const o = n(a.start);
      a.intro.length && i.advance(a.intro), a.edited ? i.addEdit(
        t,
        a.content,
        o,
        a.storeName ? s.indexOf(a.original) : -1
      ) : i.addUneditedChunk(t, a, this.original, o, this.sourcemapLocations), a.outro.length && i.advance(a.outro);
    }), {
      file: e.file ? e.file.split(/[/\\]/).pop() : void 0,
      sources: [
        e.source ? BR(e.file || "", e.source) : e.file || ""
      ],
      sourcesContent: e.includeContent ? [this.original] : void 0,
      names: s,
      mappings: i.raw,
      x_google_ignoreList: this.ignoreList ? [t] : void 0
    };
  }
  generateMap(e) {
    return new $R(this.generateDecodedMap(e));
  }
  _ensureindentStr() {
    this.indentStr === void 0 && (this.indentStr = FR(this.original));
  }
  _getRawIndentString() {
    return this._ensureindentStr(), this.indentStr;
  }
  getIndentString() {
    return this._ensureindentStr(), this.indentStr === null ? "	" : this.indentStr;
  }
  indent(e, t) {
    const s = /^[^\r\n]/gm;
    if (UR(e) && (t = e, e = void 0), e === void 0 && (this._ensureindentStr(), e = this.indentStr || "	"), e === "") return this;
    t = t || {};
    const i = {};
    t.exclude && (typeof t.exclude[0] == "number" ? [t.exclude] : t.exclude).forEach((c) => {
      for (let f = c[0]; f < c[1]; f += 1)
        i[f] = !0;
    });
    let n = t.indentStart !== !1;
    const a = (l) => n ? `${e}${l}` : (n = !0, l);
    this.intro = this.intro.replace(s, a);
    let o = 0, u = this.firstChunk;
    for (; u; ) {
      const l = u.end;
      if (u.edited)
        i[o] || (u.content = u.content.replace(s, a), u.content.length && (n = u.content[u.content.length - 1] === `
`));
      else
        for (o = u.start; o < l; ) {
          if (!i[o]) {
            const c = this.original[o];
            c === `
` ? n = !0 : c !== "\r" && n && (n = !1, o === u.start || (this._splitChunk(u, o), u = u.next), u.prependRight(e));
          }
          o += 1;
        }
      o = u.end, u = u.next;
    }
    return this.outro = this.outro.replace(s, a), this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(e, t) {
    return ln.insertLeft || (console.warn(
      "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
    ), ln.insertLeft = !0), this.appendLeft(e, t);
  }
  insertRight(e, t) {
    return ln.insertRight || (console.warn(
      "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
    ), ln.insertRight = !0), this.prependRight(e, t);
  }
  move(e, t, s) {
    if (s >= e && s <= t) throw new Error("Cannot move a selection inside itself");
    this._split(e), this._split(t), this._split(s);
    const i = this.byStart[e], n = this.byEnd[t], a = i.previous, o = n.next, u = this.byStart[s];
    if (!u && n === this.lastChunk) return this;
    const l = u ? u.previous : this.lastChunk;
    return a && (a.next = o), o && (o.previous = a), l && (l.next = i), u && (u.previous = n), i.previous || (this.firstChunk = n.next), n.next || (this.lastChunk = i.previous, this.lastChunk.next = null), i.previous = l, n.next = u || null, l || (this.firstChunk = i), u || (this.lastChunk = n), this;
  }
  overwrite(e, t, s, i) {
    return i = i || {}, this.update(e, t, s, { ...i, overwrite: !i.contentOnly });
  }
  update(e, t, s, i) {
    if (typeof s != "string") throw new TypeError("replacement content must be a string");
    for (; e < 0; ) e += this.original.length;
    for (; t < 0; ) t += this.original.length;
    if (t > this.original.length) throw new Error("end is out of bounds");
    if (e === t)
      throw new Error(
        "Cannot overwrite a zero-length range – use appendLeft or prependRight instead"
      );
    this._split(e), this._split(t), i === !0 && (ln.storeName || (console.warn(
      "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
    ), ln.storeName = !0), i = { storeName: !0 });
    const n = i !== void 0 ? i.storeName : !1, a = i !== void 0 ? i.overwrite : !1;
    if (n) {
      const l = this.original.slice(e, t);
      Object.defineProperty(this.storedNames, l, {
        writable: !0,
        value: !0,
        enumerable: !0
      });
    }
    const o = this.byStart[e], u = this.byEnd[t];
    if (o) {
      let l = o;
      for (; l !== u; ) {
        if (l.next !== this.byStart[l.end])
          throw new Error("Cannot overwrite across a split point");
        l = l.next, l.edit("", !1);
      }
      o.edit(s, n, !a);
    } else {
      const l = new To(e, t, "").edit(s, n);
      u.next = l, l.previous = u;
    }
    return this;
  }
  prepend(e) {
    if (typeof e != "string") throw new TypeError("outro content must be a string");
    return this.intro = e + this.intro, this;
  }
  prependLeft(e, t) {
    if (typeof t != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    const s = this.byEnd[e];
    return s ? s.prependLeft(t) : this.intro = t + this.intro, this;
  }
  prependRight(e, t) {
    if (typeof t != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    const s = this.byStart[e];
    return s ? s.prependRight(t) : this.outro = t + this.outro, this;
  }
  remove(e, t) {
    for (; e < 0; ) e += this.original.length;
    for (; t < 0; ) t += this.original.length;
    if (e === t) return this;
    if (e < 0 || t > this.original.length) throw new Error("Character is out of bounds");
    if (e > t) throw new Error("end must be greater than start");
    this._split(e), this._split(t);
    let s = this.byStart[e];
    for (; s; )
      s.intro = "", s.outro = "", s.edit(""), s = t > s.end ? this.byStart[s.end] : null;
    return this;
  }
  reset(e, t) {
    for (; e < 0; ) e += this.original.length;
    for (; t < 0; ) t += this.original.length;
    if (e === t) return this;
    if (e < 0 || t > this.original.length) throw new Error("Character is out of bounds");
    if (e > t) throw new Error("end must be greater than start");
    this._split(e), this._split(t);
    let s = this.byStart[e];
    for (; s; )
      s.reset(), s = t > s.end ? this.byStart[s.end] : null;
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let e = this.lastChunk;
    do {
      if (e.outro.length) return e.outro[e.outro.length - 1];
      if (e.content.length) return e.content[e.content.length - 1];
      if (e.intro.length) return e.intro[e.intro.length - 1];
    } while (e = e.previous);
    return this.intro.length ? this.intro[this.intro.length - 1] : "";
  }
  lastLine() {
    let e = this.outro.lastIndexOf(Ta);
    if (e !== -1) return this.outro.substr(e + 1);
    let t = this.outro, s = this.lastChunk;
    do {
      if (s.outro.length > 0) {
        if (e = s.outro.lastIndexOf(Ta), e !== -1) return s.outro.substr(e + 1) + t;
        t = s.outro + t;
      }
      if (s.content.length > 0) {
        if (e = s.content.lastIndexOf(Ta), e !== -1) return s.content.substr(e + 1) + t;
        t = s.content + t;
      }
      if (s.intro.length > 0) {
        if (e = s.intro.lastIndexOf(Ta), e !== -1) return s.intro.substr(e + 1) + t;
        t = s.intro + t;
      }
    } while (s = s.previous);
    return e = this.intro.lastIndexOf(Ta), e !== -1 ? this.intro.substr(e + 1) + t : this.intro + t;
  }
  slice(e = 0, t = this.original.length) {
    for (; e < 0; ) e += this.original.length;
    for (; t < 0; ) t += this.original.length;
    let s = "", i = this.firstChunk;
    for (; i && (i.start > e || i.end <= e); ) {
      if (i.start < t && i.end >= t)
        return s;
      i = i.next;
    }
    if (i && i.edited && i.start !== e)
      throw new Error(`Cannot use replaced character ${e} as slice start anchor.`);
    const n = i;
    for (; i; ) {
      i.intro && (n !== i || i.start === e) && (s += i.intro);
      const a = i.start < t && i.end >= t;
      if (a && i.edited && i.end !== t)
        throw new Error(`Cannot use replaced character ${t} as slice end anchor.`);
      const o = n === i ? e - i.start : 0, u = a ? i.content.length + t - i.end : i.content.length;
      if (s += i.content.slice(o, u), i.outro && (!a || i.end === t) && (s += i.outro), a)
        break;
      i = i.next;
    }
    return s;
  }
  // TODO deprecate this? not really very useful
  snip(e, t) {
    const s = this.clone();
    return s.remove(0, e), s.remove(t, s.original.length), s;
  }
  _split(e) {
    if (this.byStart[e] || this.byEnd[e]) return;
    let t = this.lastSearchedChunk;
    const s = e > t.end;
    for (; t; ) {
      if (t.contains(e)) return this._splitChunk(t, e);
      t = s ? this.byStart[t.end] : this.byEnd[t.start];
    }
  }
  _splitChunk(e, t) {
    if (e.edited && e.content.length) {
      const i = K1(this.original)(t);
      throw new Error(
        `Cannot split a chunk that has already been edited (${i.line}:${i.column} – "${e.original}")`
      );
    }
    const s = e.split(t);
    return this.byEnd[t] = e, this.byStart[t] = s, this.byEnd[s.end] = s, e === this.lastChunk && (this.lastChunk = s), this.lastSearchedChunk = e, !0;
  }
  toString() {
    let e = this.intro, t = this.firstChunk;
    for (; t; )
      e += t.toString(), t = t.next;
    return e + this.outro;
  }
  isEmpty() {
    let e = this.firstChunk;
    do
      if (e.intro.length && e.intro.trim() || e.content.length && e.content.trim() || e.outro.length && e.outro.trim())
        return !1;
    while (e = e.next);
    return !0;
  }
  length() {
    let e = this.firstChunk, t = 0;
    do
      t += e.intro.length + e.content.length + e.outro.length;
    while (e = e.next);
    return t;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(e) {
    return this.trimStart(e).trimEnd(e);
  }
  trimEndAborted(e) {
    const t = new RegExp((e || "\\s") + "+$");
    if (this.outro = this.outro.replace(t, ""), this.outro.length) return !0;
    let s = this.lastChunk;
    do {
      const i = s.end, n = s.trimEnd(t);
      if (s.end !== i && (this.lastChunk === s && (this.lastChunk = s.next), this.byEnd[s.end] = s, this.byStart[s.next.start] = s.next, this.byEnd[s.next.end] = s.next), n) return !0;
      s = s.previous;
    } while (s);
    return !1;
  }
  trimEnd(e) {
    return this.trimEndAborted(e), this;
  }
  trimStartAborted(e) {
    const t = new RegExp("^" + (e || "\\s") + "+");
    if (this.intro = this.intro.replace(t, ""), this.intro.length) return !0;
    let s = this.firstChunk;
    do {
      const i = s.end, n = s.trimStart(t);
      if (s.end !== i && (s === this.lastChunk && (this.lastChunk = s.next), this.byEnd[s.end] = s, this.byStart[s.next.start] = s.next, this.byEnd[s.next.end] = s.next), n) return !0;
      s = s.next;
    } while (s);
    return !1;
  }
  trimStart(e) {
    return this.trimStartAborted(e), this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(e, t) {
    function s(n, a) {
      return typeof t == "string" ? t.replace(/\$(\$|&|\d+)/g, (o, u) => u === "$" ? "$" : u === "&" ? n[0] : +u < n.length ? n[+u] : `$${u}`) : t(...n, n.index, a, n.groups);
    }
    function i(n, a) {
      let o;
      const u = [];
      for (; o = n.exec(a); )
        u.push(o);
      return u;
    }
    if (e.global)
      i(e, this.original).forEach((a) => {
        if (a.index != null) {
          const o = s(a, this.original);
          o !== a[0] && this.overwrite(
            a.index,
            a.index + a[0].length,
            o
          );
        }
      });
    else {
      const n = this.original.match(e);
      if (n && n.index != null) {
        const a = s(n, this.original);
        a !== n[0] && this.overwrite(
          n.index,
          n.index + n[0].length,
          a
        );
      }
    }
    return this;
  }
  _replaceString(e, t) {
    const { original: s } = this, i = s.indexOf(e);
    return i !== -1 && this.overwrite(i, i + e.length, t), this;
  }
  replace(e, t) {
    return typeof e == "string" ? this._replaceString(e, t) : this._replaceRegexp(e, t);
  }
  _replaceAllString(e, t) {
    const { original: s } = this, i = e.length;
    for (let n = s.indexOf(e); n !== -1; n = s.indexOf(e, n + i))
      s.slice(n, n + i) !== t && this.overwrite(n, n + i, t);
    return this;
  }
  replaceAll(e, t) {
    if (typeof e == "string")
      return this._replaceAllString(e, t);
    if (!e.global)
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    return this._replaceRegexp(e, t);
  }
}
var X1, J1;
class HR {
  constructor(e, t) {
    this.descriptor = e, this.options = t, this.isCE = !1, this.source = this.descriptor.source, this.filename = this.descriptor.filename, this.s = new la(this.source), this.startOffset = (X1 = this.descriptor.scriptSetup) == null ? void 0 : X1.loc.start.offset, this.endOffset = (J1 = this.descriptor.scriptSetup) == null ? void 0 : J1.loc.end.offset, this.userImports = /* @__PURE__ */ Object.create(null), this.hasDefinePropsCall = !1, this.hasDefineEmitCall = !1, this.hasDefineExposeCall = !1, this.hasDefaultExportName = !1, this.hasDefaultExportRender = !1, this.hasDefineOptionsCall = !1, this.hasDefineSlotsCall = !1, this.hasDefineModelCall = !1, this.propsDestructuredBindings = /* @__PURE__ */ Object.create(null), this.modelDecls = /* @__PURE__ */ Object.create(null), this.bindingMetadata = {}, this.helperImports = /* @__PURE__ */ new Set();
    const { script: s, scriptSetup: i } = e, n = s && s.lang, a = i && i.lang;
    this.isJS = n === "js" || n === "jsx" || a === "js" || a === "jsx", this.isTS = n === "ts" || n === "tsx" || a === "ts" || a === "tsx";
    const o = t.customElement, u = this.descriptor.filename;
    o && (this.isCE = typeof o == "boolean" ? o : o(u));
    const l = zl(
      n || a,
      t.babelParserPlugins
    );
    function c(f, p) {
      try {
        return $n(f, {
          plugins: l,
          sourceType: "module"
        }).program;
      } catch (h) {
        throw h.message = `[vue/compiler-sfc] ${h.message}

${e.filename}
${kn(
          e.source,
          h.pos + p,
          h.pos + p + 1
        )}`, h;
      }
    }
    this.scriptAst = e.script && c(e.script.content, e.script.loc.start.offset), this.scriptSetupAst = e.scriptSetup && c(e.scriptSetup.content, this.startOffset);
  }
  helper(e) {
    return this.helperImports.add(e), `_${e}`;
  }
  getString(e, t = !0) {
    return (t ? this.descriptor.scriptSetup : this.descriptor.script).content.slice(e.start, e.end);
  }
  error(e, t, s) {
    const i = s ? s.offset : this.startOffset;
    throw new Error(
      `[@vue/compiler-sfc] ${e}

${(s || this.descriptor).filename}
${kn(
        (s || this.descriptor).source,
        t.start + i,
        t.end + i
      )}`
    );
  }
}
function zl(r, e, t = !1) {
  const s = [];
  return (!e || !e.some(
    (i) => i === "importAssertions" || i === "importAttributes" || er(i) && i[0] === "importAttributes"
  )) && s.push("importAttributes"), r === "jsx" || r === "tsx" || r === "mtsx" ? s.push("jsx") : e && (e = e.filter((i) => i !== "jsx")), (r === "ts" || r === "mts" || r === "tsx" || r === "mtsx") && (s.push(["typescript", { dts: t }], "explicitResourceManagement"), (!e || !e.includes("decorators")) && s.push("decorators-legacy")), e && s.push(...e), s;
}
function WR(r, e, t) {
  const s = $n(r, {
    sourceType: "module",
    plugins: zl("js", t)
  }).program.body, i = new la(r);
  return J0(s, i, e), i.toString();
}
function J0(r, e, t) {
  if (!zR(r)) {
    e.append(`
const ${t} = {}`);
    return;
  }
  r.forEach((s) => {
    if (s.type === "ExportDefaultDeclaration")
      if (s.declaration.type === "ClassDeclaration" && s.declaration.id) {
        let i = s.declaration.decorators && s.declaration.decorators.length > 0 ? s.declaration.decorators[s.declaration.decorators.length - 1].end : s.start;
        e.overwrite(i, s.declaration.id.start, " class "), e.append(`
const ${t} = ${s.declaration.id.name}`);
      } else
        e.overwrite(s.start, s.declaration.start, `const ${t} = `);
    else if (s.type === "ExportNamedDeclaration") {
      for (const i of s.specifiers)
        if (i.type === "ExportSpecifier" && i.exported.type === "Identifier" && i.exported.name === "default") {
          if (s.source)
            if (i.local.name === "default") {
              e.prepend(
                `import { default as __VUE_DEFAULT__ } from '${s.source.value}'
`
              );
              const a = tp(e, i.local.end, s.end);
              e.remove(i.start, a), e.append(`
const ${t} = __VUE_DEFAULT__`);
              continue;
            } else {
              e.prepend(
                `import { ${e.slice(
                  i.local.start,
                  i.local.end
                )} as __VUE_DEFAULT__ } from '${s.source.value}'
`
              );
              const a = tp(e, i.exported.end, s.end);
              e.remove(i.start, a), e.append(`
const ${t} = __VUE_DEFAULT__`);
              continue;
            }
          const n = tp(e, i.end, s.end);
          e.remove(i.start, n), e.append(`
const ${t} = ${i.local.name}`);
        }
    }
  });
}
function zR(r) {
  for (const e of r) {
    if (e.type === "ExportDefaultDeclaration")
      return !0;
    if (e.type === "ExportNamedDeclaration" && e.specifiers.some(
      (t) => t.exported.name === "default"
    ))
      return !0;
  }
  return !1;
}
function tp(r, e, t) {
  let s = !1, i = e;
  for (; e < t; )
    if (/\s/.test(r.slice(e, e + 1)))
      e++;
    else if (r.slice(e, e + 1) === ",") {
      e++, s = !0;
      break;
    } else if (r.slice(e, e + 1) === "}")
      break;
  return s ? e : i;
}
var GR = Object.defineProperty, KR = Object.defineProperties, XR = Object.getOwnPropertyDescriptors, Y1 = Object.getOwnPropertySymbols, JR = Object.prototype.hasOwnProperty, YR = Object.prototype.propertyIsEnumerable, Q1 = (r, e, t) => e in r ? GR(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, QR = (r, e) => {
  for (var t in e || (e = {}))
    JR.call(e, t) && Q1(r, t, e[t]);
  if (Y1)
    for (var t of Y1(e))
      YR.call(e, t) && Q1(r, t, e[t]);
  return r;
}, ZR = (r, e) => KR(r, XR(e));
const fn = "__default__";
function e9(r, e) {
  var t;
  const s = r.descriptor.script;
  if (s.lang && !r.isJS && !r.isTS)
    return s;
  try {
    let i = s.content, n = s.map;
    const a = r.scriptAst, o = uw(a.body), { cssVars: u } = r.descriptor, { genDefaultAs: l, isProd: c } = r.options;
    if (u.length || l) {
      const f = l || fn, p = new la(i);
      J0(a.body, p, f), i = p.toString(), u.length && !((t = r.options.templateOptions) != null && t.ssr) && (i += U6(
        u,
        o,
        e,
        !!c,
        f
      )), l || (i += `
export default ${f}`);
    }
    return ZR(QR({}, s), {
      content: i,
      map: n,
      bindings: o,
      scriptAst: a.body
    });
  } catch {
    return s;
  }
}
var t9 = Object.defineProperty, r9 = Object.defineProperties, s9 = Object.getOwnPropertyDescriptors, Z1 = Object.getOwnPropertySymbols, i9 = Object.prototype.hasOwnProperty, n9 = Object.prototype.propertyIsEnumerable, eb = (r, e, t) => e in r ? t9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Gl = (r, e) => {
  for (var t in e || (e = {}))
    i9.call(e, t) && eb(r, t, e[t]);
  if (Z1)
    for (var t of Z1(e))
      n9.call(e, t) && eb(r, t, e[t]);
  return r;
}, Kl = (r, e) => r9(r, s9(e));
class Y0 {
  constructor(e, t, s = 0, i = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null)) {
    this.filename = e, this.source = t, this.offset = s, this.imports = i, this.types = n, this.declares = a, this.isGenericScope = !1, this.resolvedImportSources = /* @__PURE__ */ Object.create(null), this.exportedTypes = /* @__PURE__ */ Object.create(null), this.exportedDeclares = /* @__PURE__ */ Object.create(null);
  }
}
function wt(r, e, t, s) {
  const i = !s;
  if (i && e._resolvedElements)
    return e._resolvedElements;
  const n = a9(
    r,
    e,
    e._ownerScope || t || hf(r),
    s
  );
  return i ? e._resolvedElements = n : n;
}
function a9(r, e, t, s) {
  var i, n;
  if (e.leadingComments && e.leadingComments.some((a) => a.value.includes("@vue-ignore")))
    return { props: {} };
  switch (e.type) {
    case "TSTypeLiteral":
      return cw(r, e.members, t, s);
    case "TSInterfaceDeclaration":
      return o9(r, e, t, s);
    case "TSTypeAliasDeclaration":
    case "TSTypeAnnotation":
    case "TSParenthesizedType":
      return wt(
        r,
        e.typeAnnotation,
        t,
        s
      );
    case "TSFunctionType":
      return { props: {}, calls: [e] };
    case "TSUnionType":
    case "TSIntersectionType":
      return tb(
        e.types.map((a) => wt(r, a, t, s)),
        e.type
      );
    case "TSMappedType":
      return u9(r, e, t, s);
    case "TSIndexedAccessType": {
      const a = fw(r, e, t);
      return tb(
        a.map((o) => wt(r, o, o._ownerScope)),
        "TSUnionType"
      );
    }
    case "TSExpressionWithTypeArguments":
    case "TSTypeReference": {
      const a = Z0(e);
      if ((a === "ExtractPropTypes" || a === "ExtractPublicPropTypes") && e.typeParameters && ((i = t.imports[a]) == null ? void 0 : i.source) === "vue")
        return nb(
          wt(
            r,
            e.typeParameters.params[0],
            t,
            s
          ),
          t
        );
      const o = Qr(r, e, t);
      if (o) {
        let u;
        return (o.type === "TSTypeAliasDeclaration" || o.type === "TSInterfaceDeclaration") && o.typeParameters && e.typeParameters && (u = /* @__PURE__ */ Object.create(null), o.typeParameters.params.forEach((l, c) => {
          let f = s && s[l.name];
          f || (f = e.typeParameters.params[c]), u[l.name] = f;
        })), wt(
          r,
          o,
          o._ownerScope,
          u
        );
      } else {
        if (typeof a == "string") {
          if (s && s[a])
            return wt(
              r,
              s[a],
              t,
              s
            );
          if (
            // @ts-expect-error
            l9.has(a)
          )
            return c9(
              r,
              e,
              a,
              t,
              s
            );
          if (a === "ReturnType" && e.typeParameters) {
            const u = _9(
              r,
              e.typeParameters.params[0],
              t
            );
            if (u)
              return wt(r, u, t);
          }
        }
        return r.error(
          "Unresolvable type reference or unsupported built-in utility type",
          e,
          t
        );
      }
    }
    case "TSImportType": {
      if (Ji(e.argument) === "vue" && ((n = e.qualifier) == null ? void 0 : n.type) === "Identifier" && e.qualifier.name === "ExtractPropTypes" && e.typeParameters)
        return nb(
          wt(r, e.typeParameters.params[0], t),
          t
        );
      const a = pf(
        r,
        e.argument,
        t,
        e.argument.value
      ), o = Qr(r, e, a);
      if (o)
        return wt(r, o, o._ownerScope);
      break;
    }
    case "TSTypeQuery":
      {
        const a = Qr(r, e, t);
        if (a)
          return wt(r, a, a._ownerScope);
      }
      break;
  }
  return r.error(`Unresolvable type: ${e.type}`, e, t);
}
function cw(r, e, t = hf(r), s) {
  const i = { props: {} };
  for (const n of e)
    if (n.type === "TSPropertySignature" || n.type === "TSMethodSignature") {
      s && (t = tg(t), t.isGenericScope = !0, Object.assign(t.types, s)), n._ownerScope = t;
      const a = Ji(n.key);
      if (a && !n.computed)
        i.props[a] = n;
      else if (n.key.type === "TemplateLiteral")
        for (const o of Q0(r, n.key, t))
          i.props[o] = n;
      else
        r.error(
          "Unsupported computed key in type referenced by a macro",
          n.key,
          t
        );
    } else n.type === "TSCallSignatureDeclaration" && (i.calls || (i.calls = [])).push(n);
  return i;
}
function tb(r, e) {
  if (r.length === 1) return r[0];
  const t = { props: {} }, { props: s } = t;
  for (const { props: i, calls: n } of r) {
    for (const a in i)
      qd(s, a) ? s[a] = Ya(
        s[a].key,
        {
          type: e,
          // @ts-expect-error
          types: [s[a], i[a]]
        },
        s[a]._ownerScope,
        s[a].optional || i[a].optional
      ) : s[a] = i[a];
    n && (t.calls || (t.calls = [])).push(...n);
  }
  return t;
}
function Ya(r, e, t, s) {
  return {
    type: "TSPropertySignature",
    key: r,
    kind: "get",
    optional: s,
    typeAnnotation: {
      type: "TSTypeAnnotation",
      typeAnnotation: e
    },
    _ownerScope: t
  };
}
function o9(r, e, t, s) {
  const i = cw(
    r,
    e.body.body,
    e._ownerScope,
    s
  );
  if (e.extends)
    for (const n of e.extends)
      try {
        const { props: a, calls: o } = wt(r, n, t);
        for (const u in a)
          qd(i.props, u) || (i.props[u] = a[u]);
        o && (i.calls || (i.calls = [])).push(...o);
      } catch {
        r.error(
          `Failed to resolve extends base type.
If this previously worked in 3.2, you can instruct the compiler to ignore this extend by adding /* @vue-ignore */ before it, for example:

interface Props extends /* @vue-ignore */ Base {}

Note: both in 3.2 or with the ignore, the properties in the base type are treated as fallthrough attrs at runtime.`,
          n,
          t
        );
      }
  return i;
}
function u9(r, e, t, s) {
  const i = { props: {} };
  let n;
  if (e.nameType) {
    const { name: a, constraint: o } = e.typeParameter;
    t = tg(t), Object.assign(t.types, Kl(Gl({}, s), { [a]: o })), n = Hr(r, e.nameType, t);
  } else
    n = Hr(r, e.typeParameter.constraint, t);
  for (const a of n)
    i.props[a] = Ya(
      {
        type: "Identifier",
        name: a
      },
      e.typeAnnotation,
      t,
      !!e.optional
    );
  return i;
}
function fw(r, e, t) {
  var s, i;
  if (e.indexType.type === "TSNumberKeyword")
    return pw(r, e.objectType, t);
  const { indexType: n, objectType: a } = e, o = [];
  let u, l;
  n.type === "TSStringKeyword" ? (l = wt(r, a, t), u = Object.keys(l.props)) : (u = Hr(r, n, t), l = wt(r, a, t));
  for (const c of u) {
    const f = (i = (s = l.props[c]) == null ? void 0 : s.typeAnnotation) == null ? void 0 : i.typeAnnotation;
    f && (f._ownerScope = l.props[c]._ownerScope, o.push(f));
  }
  return o;
}
function pw(r, e, t) {
  if (e.type === "TSArrayType")
    return [e.elementType];
  if (e.type === "TSTupleType")
    return e.elementTypes.map(
      (s) => s.type === "TSNamedTupleMember" ? s.elementType : s
    );
  if (e.type === "TSTypeReference") {
    if (Z0(e) === "Array" && e.typeParameters)
      return e.typeParameters.params;
    {
      const s = Qr(r, e, t);
      if (s)
        return pw(r, s, t);
    }
  }
  return r.error(
    "Failed to resolve element type from target type",
    e,
    t
  );
}
function Hr(r, e, t) {
  switch (e.type) {
    case "StringLiteral":
      return [e.value];
    case "TSLiteralType":
      return Hr(r, e.literal, t);
    case "TSUnionType":
      return e.types.map((s) => Hr(r, s, t)).flat();
    case "TemplateLiteral":
      return Q0(r, e, t);
    case "TSTypeReference": {
      const s = Qr(r, e, t);
      if (s)
        return Hr(r, s, t);
      if (e.typeName.type === "Identifier") {
        const i = (n = 0) => Hr(r, e.typeParameters.params[n], t);
        switch (e.typeName.name) {
          case "Extract":
            return i(1);
          case "Exclude": {
            const n = i(1);
            return i().filter((a) => !n.includes(a));
          }
          case "Uppercase":
            return i().map((n) => n.toUpperCase());
          case "Lowercase":
            return i().map((n) => n.toLowerCase());
          case "Capitalize":
            return i().map(oi);
          case "Uncapitalize":
            return i().map((n) => n[0].toLowerCase() + n.slice(1));
          default:
            r.error(
              "Unsupported type when resolving index type",
              e.typeName,
              t
            );
        }
      }
    }
  }
  return r.error("Failed to resolve index type into finite keys", e, t);
}
function Q0(r, e, t) {
  if (!e.expressions.length)
    return [e.quasis[0].value.raw];
  const s = [], i = e.expressions[0], n = e.quasis[0], a = n ? n.value.raw : "", o = Hr(r, i, t), u = Q0(
    r,
    Kl(Gl({}, e), {
      expressions: e.expressions.slice(1),
      quasis: n ? e.quasis.slice(1) : e.quasis
    }),
    t
  );
  for (const l of o)
    for (const c of u)
      s.push(a + l + c);
  return s;
}
const l9 = /* @__PURE__ */ new Set([
  "Partial",
  "Required",
  "Readonly",
  "Pick",
  "Omit"
]);
function c9(r, e, t, s, i) {
  const n = wt(
    r,
    e.typeParameters.params[0],
    s,
    i
  );
  switch (t) {
    case "Partial": {
      const u = { props: {}, calls: n.calls };
      return Object.keys(n.props).forEach((l) => {
        u.props[l] = Kl(Gl({}, n.props[l]), { optional: !0 });
      }), u;
    }
    case "Required": {
      const u = { props: {}, calls: n.calls };
      return Object.keys(n.props).forEach((l) => {
        u.props[l] = Kl(Gl({}, n.props[l]), { optional: !1 });
      }), u;
    }
    case "Readonly":
      return n;
    case "Pick": {
      const u = Hr(
        r,
        e.typeParameters.params[1],
        s
      ), l = { props: {}, calls: n.calls };
      for (const c of u)
        l.props[c] = n.props[c];
      return l;
    }
    case "Omit":
      const a = Hr(
        r,
        e.typeParameters.params[1],
        s
      ), o = { props: {}, calls: n.calls };
      for (const u in n.props)
        a.includes(u) || (o.props[u] = n.props[u]);
      return o;
  }
}
function Qr(r, e, t, s, i = !1) {
  const n = !(t != null && t.isGenericScope);
  if (n && e._resolvedReference)
    return e._resolvedReference;
  const a = Xh(
    r,
    t || hf(r),
    s || Z0(e),
    e,
    i
  );
  return n ? e._resolvedReference = a : a;
}
function Xh(r, e, t, s, i) {
  if (typeof t == "string") {
    if (e.imports[t])
      return h9(r, s, t, e);
    {
      const n = s.type === "TSTypeQuery" ? i ? e.exportedDeclares : e.declares : i ? e.exportedTypes : e.types;
      if (n[t])
        return n[t];
      {
        const a = f9(r);
        if (a)
          for (const o of a) {
            const u = s.type === "TSTypeQuery" ? o.declares : o.types;
            if (u[t])
              return (r.deps || (r.deps = /* @__PURE__ */ new Set())).add(o.filename), u[t];
          }
      }
    }
  } else {
    let n = Xh(r, e, t[0], s, i);
    if (n && (n.type !== "TSModuleDeclaration" && (n = n._ns), n)) {
      const a = y9(r, n, n._ownerScope || e);
      return Xh(
        r,
        a,
        t.length > 2 ? t.slice(1) : t[t.length - 1],
        s,
        !n.declare
      );
    }
  }
}
function Z0(r) {
  const e = r.type === "TSTypeReference" ? r.typeName : r.type === "TSExpressionWithTypeArguments" ? r.expression : r.type === "TSImportType" ? r.qualifier : r.exprName;
  return (e == null ? void 0 : e.type) === "Identifier" ? e.name : (e == null ? void 0 : e.type) === "TSQualifiedName" ? hw(e) : "default";
}
function hw(r) {
  return r.type === "Identifier" ? [r.name] : [...hw(r.left), r.right.name];
}
function f9(r) {
  if (r.options.globalTypeFiles) {
    if (!eg(r))
      throw new Error("[vue/compiler-sfc] globalTypeFiles requires fs access.");
    return r.options.globalTypeFiles.map(
      (t) => dw(r, a0(t), !0)
    );
  }
}
let Pu, Jh;
function p9(r) {
  Jh = () => {
    try {
      return r();
    } catch (e) {
      throw typeof e.message == "string" && e.message.includes("Cannot find module") ? new Error(
        'Failed to load TypeScript, which is required for resolving imported types. Please make sure "typescript" is installed as a project dependency.'
      ) : new Error(
        "Failed to load TypeScript for resolving imported types."
      );
    }
  };
}
function eg(r) {
  if (r.fs)
    return r.fs;
  !Pu && Jh && (Pu = Jh());
  const e = r.options.fs || (Pu == null ? void 0 : Pu.sys);
  if (e)
    return r.fs = {
      fileExists(t) {
        return t.endsWith(".vue.ts") && (t = t.replace(/\.ts$/, "")), e.fileExists(t);
      },
      readFile(t) {
        return t.endsWith(".vue.ts") && (t = t.replace(/\.ts$/, "")), e.readFile(t);
      },
      realpath: e.realpath
    };
}
function h9(r, e, t, s) {
  const { source: i, imported: n } = s.imports[t], a = pf(r, e, s, i);
  return Qr(r, e, a, n, !0);
}
function pf(r, e, t, s) {
  let i;
  try {
    i = eg(r);
  } catch (a) {
    return r.error(a.message, e, t);
  }
  if (!i)
    return r.error(
      "No fs option provided to `compileScript` in non-Node environment. File system access is required for resolving imported types.",
      e,
      t
    );
  let n = t.resolvedImportSources[s];
  if (!n) {
    if (s.startsWith("..")) {
      const o = za(Nl(t.filename), s);
      n = rb(o, i);
    } else if (s[0] === ".") {
      const a = za(Nl(t.filename), s);
      n = rb(a, i);
    } else
      return r.error(
        "Type import from non-relative sources is not supported in the browser build.",
        e,
        t
      );
    n && (n = t.resolvedImportSources[s] = a0(n));
  }
  return n ? ((r.deps || (r.deps = /* @__PURE__ */ new Set())).add(n), dw(r, n)) : r.error(
    `Failed to resolve import source ${JSON.stringify(s)}.`,
    e,
    t
  );
}
function rb(r, e) {
  r = r.replace(/\.js$/, "");
  const t = (s) => {
    if (e.fileExists(s)) return s;
  };
  return t(r) || t(r + ".ts") || t(r + ".tsx") || t(r + ".d.ts") || t(za(r, "index.ts")) || t(za(r, "index.tsx")) || t(za(r, "index.d.ts"));
}
const sb = Gc(), d9 = /* @__PURE__ */ new Map(), Yh = Gc();
function m9(r) {
  r = a0(r), Yh.delete(r), sb.delete(r);
  const e = d9.get(r);
  e && sb.delete(e);
}
function dw(r, e, t = !1) {
  const s = Yh.get(e);
  if (s)
    return s;
  const n = eg(r).readFile(e) || "", a = g9(e, n, r.options.babelParserPlugins), o = new Y0(e, n, 0, mw(a));
  return rg(r, a, o, t), Yh.set(e, o), o;
}
function g9(r, e, t) {
  const s = s0(r);
  if (s === ".ts" || s === ".mts" || s === ".tsx" || s === ".mtsx")
    return $n(e, {
      plugins: zl(
        s.slice(1),
        t,
        /\.d\.m?ts$/.test(r)
      ),
      sourceType: "module"
    }).program.body;
  if (s === ".vue") {
    const {
      descriptor: { script: i, scriptSetup: n }
    } = N2(e);
    if (!i && !n)
      return [];
    const a = i ? i.loc.start.offset : 1 / 0, o = n ? n.loc.start.offset : 1 / 0, u = a < o ? i : n, l = a < o ? n : i;
    let c = " ".repeat(Math.min(a, o)) + u.content;
    l && (c += " ".repeat(l.loc.start.offset - i.loc.end.offset) + l.content);
    const f = (i == null ? void 0 : i.lang) || (n == null ? void 0 : n.lang);
    return $n(c, {
      plugins: zl(f, t),
      sourceType: "module"
    }).program.body;
  }
  return [];
}
function hf(r) {
  if (r.scope)
    return r.scope;
  const e = "ast" in r ? r.ast : r.scriptAst ? [...r.scriptAst.body, ...r.scriptSetupAst.body] : r.scriptSetupAst.body, t = new Y0(
    r.filename,
    r.source,
    "startOffset" in r ? r.startOffset : 0,
    "userImports" in r ? Object.create(r.userImports) : mw(e)
  );
  return rg(r, e, t), r.scope = t;
}
function y9(r, e, t) {
  if (e._resolvedChildScope)
    return e._resolvedChildScope;
  const s = tg(t);
  if (e.body.type === "TSModuleDeclaration") {
    const i = e.body;
    i._ownerScope = s;
    const n = Ji(i.id);
    s.types[n] = s.exportedTypes[n] = i;
  } else
    rg(r, e.body.body, s);
  return e._resolvedChildScope = s;
}
function tg(r) {
  return new Y0(
    r.filename,
    r.source,
    r.offset,
    Object.create(r.imports),
    Object.create(r.types),
    Object.create(r.declares)
  );
}
const b9 = /^Import|^Export/;
function rg(r, e, t, s = !1) {
  const { types: i, declares: n, exportedTypes: a, exportedDeclares: o, imports: u } = t, l = s ? !e.some((c) => b9.test(c.type)) : !1;
  for (const c of e)
    if (s) {
      if (l)
        c.declare && Ei(c, i, n);
      else if (c.type === "TSModuleDeclaration" && c.global)
        for (const f of c.body.body)
          Ei(f, i, n);
    } else
      Ei(c, i, n);
  if (!s)
    for (const c of e)
      if (c.type === "ExportNamedDeclaration") {
        if (c.declaration)
          Ei(c.declaration, i, n), Ei(c.declaration, a, o);
        else
          for (const f of c.specifiers)
            if (f.type === "ExportSpecifier") {
              const p = f.local.name, h = Ji(f.exported);
              c.source ? (u[h] = {
                source: c.source.value,
                imported: p
              }, a[h] = {
                type: "TSTypeReference",
                typeName: {
                  type: "Identifier",
                  name: p
                },
                _ownerScope: t
              }) : i[p] && (a[h] = i[p]);
            }
      } else if (c.type === "ExportAllDeclaration") {
        const f = pf(
          r,
          c.source,
          t,
          c.source.value
        );
        Object.assign(t.exportedTypes, f.exportedTypes);
      } else c.type === "ExportDefaultDeclaration" && c.declaration && (c.declaration.type !== "Identifier" ? (Ei(c.declaration, i, n, "default"), Ei(
        c.declaration,
        a,
        o,
        "default"
      )) : i[c.declaration.name] && (a.default = i[c.declaration.name]));
  for (const c of Object.keys(i)) {
    const f = i[c];
    f._ownerScope = t, f._ns && (f._ns._ownerScope = t);
  }
  for (const c of Object.keys(n))
    n[c]._ownerScope = t;
}
function Ei(r, e, t, s) {
  switch (r.type) {
    case "TSInterfaceDeclaration":
    case "TSEnumDeclaration":
    case "TSModuleDeclaration": {
      const i = s || Ji(r.id);
      let n = e[i];
      if (n) {
        if (r.type === "TSModuleDeclaration") {
          n.type === "TSModuleDeclaration" ? sg(n, r) : ib(n, r);
          break;
        }
        if (n.type === "TSModuleDeclaration") {
          e[i] = r, ib(r, n);
          break;
        }
        if (n.type !== r.type)
          break;
        r.type === "TSInterfaceDeclaration" ? n.body.body.push(...r.body.body) : n.members.push(...r.members);
      } else
        e[i] = r;
      break;
    }
    case "ClassDeclaration":
      (s || r.id) && (e[s || Ji(r.id)] = r);
      break;
    case "TSTypeAliasDeclaration":
      e[r.id.name] = r.typeParameters ? r : r.typeAnnotation;
      break;
    case "TSDeclareFunction":
      r.id && (t[r.id.name] = r);
      break;
    case "VariableDeclaration": {
      if (r.declare)
        for (const i of r.declarations)
          i.id.type === "Identifier" && i.id.typeAnnotation && (t[i.id.name] = i.id.typeAnnotation.typeAnnotation);
      break;
    }
  }
}
function sg(r, e) {
  const t = r.body, s = e.body;
  t.type === "TSModuleDeclaration" ? s.type === "TSModuleDeclaration" ? sg(t, s) : s.body.push({
    type: "ExportNamedDeclaration",
    declaration: t,
    exportKind: "type",
    specifiers: []
  }) : s.type === "TSModuleDeclaration" ? t.body.push({
    type: "ExportNamedDeclaration",
    declaration: s,
    exportKind: "type",
    specifiers: []
  }) : t.body.push(...s.body);
}
function ib(r, e) {
  r._ns ? sg(r._ns, e) : r._ns = e;
}
function mw(r) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const t of r)
    v9(t, e);
  return e;
}
function v9(r, e) {
  if (r.type === "ImportDeclaration")
    for (const t of r.specifiers)
      e[t.local.name] = {
        imported: Gp(t),
        source: r.source.value
      };
}
function xt(r, e, t = e._ownerScope || hf(r), s = !1) {
  try {
    switch (e.type) {
      case "TSStringKeyword":
        return ["String"];
      case "TSNumberKeyword":
        return ["Number"];
      case "TSBooleanKeyword":
        return ["Boolean"];
      case "TSObjectKeyword":
        return ["Object"];
      case "TSNullKeyword":
        return ["null"];
      case "TSTypeLiteral":
      case "TSInterfaceDeclaration": {
        const i = /* @__PURE__ */ new Set(), n = e.type === "TSTypeLiteral" ? e.members : e.body.body;
        for (const a of n)
          if (s)
            if (a.type === "TSPropertySignature" && a.key.type === "NumericLiteral")
              i.add("Number");
            else if (a.type === "TSIndexSignature") {
              const o = a.parameters[0].typeAnnotation;
              if (o && o.type !== "Noop") {
                const u = xt(
                  r,
                  o.typeAnnotation,
                  t
                )[0];
                if (u === $r) return [$r];
                i.add(u);
              }
            } else
              i.add("String");
          else a.type === "TSCallSignatureDeclaration" || a.type === "TSConstructSignatureDeclaration" ? i.add("Function") : i.add("Object");
        return i.size ? Array.from(i) : [s ? $r : "Object"];
      }
      case "TSPropertySignature":
        if (e.typeAnnotation)
          return xt(
            r,
            e.typeAnnotation.typeAnnotation,
            t
          );
        break;
      case "TSMethodSignature":
      case "TSFunctionType":
        return ["Function"];
      case "TSArrayType":
      case "TSTupleType":
        return ["Array"];
      case "TSLiteralType":
        switch (e.literal.type) {
          case "StringLiteral":
            return ["String"];
          case "BooleanLiteral":
            return ["Boolean"];
          case "NumericLiteral":
          case "BigIntLiteral":
            return ["Number"];
          default:
            return [$r];
        }
      case "TSTypeReference": {
        const i = Qr(r, e, t);
        if (i)
          return xt(r, i, i._ownerScope, s);
        if (e.typeName.type === "Identifier")
          if (s)
            switch (e.typeName.name) {
              case "String":
              case "Array":
              case "ArrayLike":
              case "Parameters":
              case "ConstructorParameters":
              case "ReadonlyArray":
                return ["String", "Number"];
              case "Record":
              case "Partial":
              case "Required":
              case "Readonly":
                if (e.typeParameters && e.typeParameters.params[0])
                  return xt(
                    r,
                    e.typeParameters.params[0],
                    t,
                    !0
                  );
                break;
              case "Pick":
              case "Extract":
                if (e.typeParameters && e.typeParameters.params[1])
                  return xt(
                    r,
                    e.typeParameters.params[1],
                    t
                  );
                break;
              case "Function":
              case "Object":
              case "Set":
              case "Map":
              case "WeakSet":
              case "WeakMap":
              case "Date":
              case "Promise":
              case "Error":
              case "Uppercase":
              case "Lowercase":
              case "Capitalize":
              case "Uncapitalize":
              case "ReadonlyMap":
              case "ReadonlySet":
                return ["String"];
            }
          else
            switch (e.typeName.name) {
              case "Array":
              case "Function":
              case "Object":
              case "Set":
              case "Map":
              case "WeakSet":
              case "WeakMap":
              case "Date":
              case "Promise":
              case "Error":
                return [e.typeName.name];
              case "Partial":
              case "Required":
              case "Readonly":
              case "Record":
              case "Pick":
              case "Omit":
              case "InstanceType":
                return ["Object"];
              case "Uppercase":
              case "Lowercase":
              case "Capitalize":
              case "Uncapitalize":
                return ["String"];
              case "Parameters":
              case "ConstructorParameters":
              case "ReadonlyArray":
                return ["Array"];
              case "ReadonlyMap":
                return ["Map"];
              case "ReadonlySet":
                return ["Set"];
              case "NonNullable":
                if (e.typeParameters && e.typeParameters.params[0])
                  return xt(
                    r,
                    e.typeParameters.params[0],
                    t
                  ).filter((n) => n !== "null");
                break;
              case "Extract":
                if (e.typeParameters && e.typeParameters.params[1])
                  return xt(
                    r,
                    e.typeParameters.params[1],
                    t
                  );
                break;
              case "Exclude":
              case "OmitThisParameter":
                if (e.typeParameters && e.typeParameters.params[0])
                  return xt(
                    r,
                    e.typeParameters.params[0],
                    t
                  );
                break;
            }
        break;
      }
      case "TSParenthesizedType":
        return xt(r, e.typeAnnotation, t);
      case "TSUnionType":
        return rp(r, e.types, t, s);
      case "TSIntersectionType":
        return rp(r, e.types, t, s).filter(
          (i) => i !== $r
        );
      case "TSEnumDeclaration":
        return E9(e);
      case "TSSymbolKeyword":
        return ["Symbol"];
      case "TSIndexedAccessType": {
        const i = fw(r, e, t);
        return rp(r, i, t);
      }
      case "ClassDeclaration":
        return ["Object"];
      case "TSImportType": {
        const i = pf(
          r,
          e.argument,
          t,
          e.argument.value
        ), n = Qr(r, e, i);
        if (n)
          return xt(r, n, n._ownerScope);
        break;
      }
      case "TSTypeQuery": {
        const i = e.exprName;
        if (i.type === "Identifier") {
          const n = t.declares[i.name];
          if (n)
            return xt(r, n, n._ownerScope, s);
        }
        break;
      }
      case "TSTypeOperator":
        return xt(
          r,
          e.typeAnnotation,
          t,
          e.operator === "keyof"
        );
      case "TSAnyKeyword": {
        if (s)
          return ["String", "Number", "Symbol"];
        break;
      }
    }
  } catch {
  }
  return [$r];
}
function rp(r, e, t, s = !1) {
  return e.length === 1 ? xt(r, e[0], t, s) : [
    ...new Set(
      [].concat(
        ...e.map((i) => xt(r, i, t, s))
      )
    )
  ];
}
function E9(r) {
  const e = /* @__PURE__ */ new Set();
  for (const t of r.members)
    if (t.initializer)
      switch (t.initializer.type) {
        case "StringLiteral":
          e.add("String");
          break;
        case "NumericLiteral":
          e.add("Number");
          break;
      }
  return e.size ? [...e] : ["Number"];
}
function nb({ props: r }, e) {
  const t = { props: {} };
  for (const s in r) {
    const i = r[s];
    t.props[s] = Qh(
      i.key,
      i.typeAnnotation.typeAnnotation,
      e
    );
  }
  return t;
}
function Qh(r, e, t, s = !0, i = !0) {
  if (i && e.type === "TSTypeLiteral") {
    const n = ab(e, "type");
    if (n) {
      const a = ab(e, "required"), o = a && a.type === "TSLiteralType" && a.literal.type === "BooleanLiteral" ? !a.literal.value : !0;
      return Qh(r, n, t, o, !1);
    }
  } else if (e.type === "TSTypeReference" && e.typeName.type === "Identifier") {
    if (e.typeName.name.endsWith("Constructor"))
      return Ya(
        r,
        S9(e.typeName.name),
        t,
        s
      );
    if (e.typeName.name === "PropType" && e.typeParameters)
      return Ya(r, e.typeParameters.params[0], t, s);
  }
  if ((e.type === "TSTypeReference" || e.type === "TSImportType") && e.typeParameters)
    for (const n of e.typeParameters.params) {
      const a = Qh(r, n, t, s);
      if (a) return a;
    }
  return Ya(r, { type: "TSNullKeyword" }, t, s);
}
function S9(r) {
  const e = r.slice(0, -11);
  switch (e) {
    case "String":
    case "Number":
    case "Boolean":
      return { type: `TS${e}Keyword` };
    case "Array":
    case "Function":
    case "Object":
    case "Set":
    case "Map":
    case "WeakSet":
    case "WeakMap":
    case "Date":
    case "Promise":
      return {
        type: "TSTypeReference",
        typeName: { type: "Identifier", name: e }
      };
  }
  return { type: "TSNullKeyword" };
}
function ab(r, e) {
  const t = r.members.find(
    (s) => s.type === "TSPropertySignature" && !s.computed && Ji(s.key) === e && s.typeAnnotation
  );
  return t && t.typeAnnotation.typeAnnotation;
}
function _9(r, e, t) {
  var s;
  let i = e;
  if ((e.type === "TSTypeReference" || e.type === "TSTypeQuery" || e.type === "TSImportType") && (i = Qr(r, e, t)), !!i) {
    if (i.type === "TSFunctionType")
      return (s = i.typeAnnotation) == null ? void 0 : s.typeAnnotation;
    if (i.type === "TSDeclareFunction")
      return i.returnType;
  }
}
function gw(r, e, t) {
  if (e.type === "TSTypeReference") {
    const i = Qr(r, e, t);
    i && (e = i);
  }
  let s;
  return e.type === "TSUnionType" ? s = e.types.flatMap((i) => gw(r, i, t)) : s = [e], s;
}
const df = "defineModel";
function ob(r, e, t) {
  if (!Wt(e, df))
    return !1;
  r.hasDefineModelCall = !0;
  const s = e.typeParameters && e.typeParameters.params[0] || void 0;
  let i, n;
  const a = e.arguments[0] && br(e.arguments[0]), o = a && a.type === "StringLiteral";
  o ? (i = a.value, n = e.arguments[1]) : (i = "modelValue", n = a), r.modelDecls[i] && r.error(`duplicate model name ${JSON.stringify(i)}`, e);
  let u = n && r.getString(n), l = !n;
  const c = [];
  if (n && n.type === "ObjectExpression" && !n.properties.some((f) => f.type === "SpreadElement" || f.computed)) {
    let f = 0;
    for (let p = n.properties.length - 1; p >= 0; p--) {
      const h = n.properties[p], m = n.properties[p + 1], d = h.start, y = m ? m.start : n.end - 1;
      (h.type === "ObjectProperty" || h.type === "ObjectMethod") && (h.key.type === "Identifier" && (h.key.name === "get" || h.key.name === "set") || h.key.type === "StringLiteral" && (h.key.value === "get" || h.key.value === "set")) ? u = u.slice(0, d - n.start) + u.slice(y - n.start) : (f++, r.s.remove(r.startOffset + d, r.startOffset + y), c.push(h));
    }
    f === n.properties.length && (l = !0, r.s.remove(
      r.startOffset + (o ? a.end : n.start),
      r.startOffset + n.end
    ));
  }
  return r.modelDecls[i] = {
    type: s,
    options: u,
    runtimeOptionNodes: c,
    identifier: t && t.type === "Identifier" ? t.name : void 0
  }, r.bindingMetadata[i] = "props", r.s.overwrite(
    r.startOffset + e.callee.start,
    r.startOffset + e.callee.end,
    r.helper("useModel")
  ), r.s.appendLeft(
    r.startOffset + (e.arguments.length ? e.arguments[0].start : e.end - 1),
    "__props, " + (o ? "" : `${JSON.stringify(i)}${l ? "" : ", "}`)
  ), !0;
}
function x9(r) {
  if (!r.hasDefineModelCall) return;
  const e = !!r.options.isProd;
  let t = "";
  for (const [s, { type: i, options: n }] of Object.entries(
    r.modelDecls
  )) {
    let a = !1, o = "", u = i && xt(r, i);
    if (u) {
      const f = u.includes("Boolean"), p = u.includes("Function");
      u.includes($r) && (f || p ? (u = u.filter((m) => m !== $r), a = !0) : u = ["null"]), e ? (f || n && p) && (o = `type: ${dn(u)}`) : o = `type: ${dn(u)}` + (a ? ", skipCheck: true" : "");
    }
    let l;
    o && n ? l = r.isTS ? `{ ${o}, ...${n} }` : `Object.assign({ ${o} }, ${n})` : o ? l = `{ ${o} }` : n ? l = n : l = "{}", t += `
    ${JSON.stringify(s)}: ${l},`;
    const c = JSON.stringify(
      s === "modelValue" ? "modelModifiers" : `${s}Modifiers`
    );
    t += `
    ${c}: {},`;
  }
  return `{${t}
  }`;
}
const At = "defineProps", wi = "withDefaults";
function Zh(r, e, t) {
  if (!Wt(e, At))
    return w9(r, e, t);
  if (r.hasDefinePropsCall && r.error(`duplicate ${At}() call`, e), r.hasDefinePropsCall = !0, r.propsRuntimeDecl = e.arguments[0], r.propsRuntimeDecl)
    for (const s of Kh(r.propsRuntimeDecl))
      s in r.bindingMetadata || (r.bindingMetadata[s] = "props");
  return e.typeParameters && (r.propsRuntimeDecl && r.error(
    `${At}() cannot accept both type and non-type arguments at the same time. Use one or the other.`,
    e
  ), r.propsTypeDecl = e.typeParameters.params[0]), t && t.type === "ObjectPattern" && O9(r, t), r.propsCall = e, r.propsDecl = t, !0;
}
function w9(r, e, t) {
  return Wt(e, wi) ? (Zh(r, e.arguments[0], t) || r.error(
    `${wi}' first argument must be a ${At} call.`,
    e.arguments[0] || e
  ), r.propsRuntimeDecl && r.error(
    `${wi} can only be used with type-based ${At} declaration.`,
    e
  ), r.propsDestructureDecl && r.error(
    `${wi}() is unnecessary when using destructure with ${At}().
Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...).`,
    e.callee
  ), r.propsRuntimeDefaults = e.arguments[1], r.propsRuntimeDefaults || r.error(`The 2nd argument of ${wi} is required.`, e), r.propsCall = e, !0) : !1;
}
function T9(r) {
  let e;
  if (r.propsRuntimeDecl) {
    if (e = r.getString(r.propsRuntimeDecl).trim(), r.propsDestructureDecl) {
      const s = [];
      for (const i in r.propsDestructuredBindings) {
        const n = bw(r, i), a = p2(i);
        n && s.push(
          `${a}: ${n.valueString}${n.needSkipFactory ? `, __skip_${a}: true` : ""}`
        );
      }
      s.length && (e = `/*#__PURE__*/${r.helper(
        "mergeDefaults"
      )}(${e}, {
  ${s.join(`,
  `)}
})`);
    }
  } else r.propsTypeDecl && (e = yw(r));
  const t = x9(r);
  return e && t ? `/*#__PURE__*/${r.helper(
    "mergeModels"
  )}(${e}, ${t})` : t || e;
}
function yw(r) {
  const e = P9(r, r.propsTypeDecl);
  if (!e.length)
    return;
  const t = [], s = C9(r);
  for (const n of e)
    t.push(A9(r, n, s)), "bindingMetadata" in r && !(n.key in r.bindingMetadata) && (r.bindingMetadata[n.key] = "props");
  let i = `{
    ${t.join(`,
    `)}
  }`;
  return r.propsRuntimeDefaults && !s && (i = `/*#__PURE__*/${r.helper(
    "mergeDefaults"
  )}(${i}, ${r.getString(r.propsRuntimeDefaults)})`), i;
}
function P9(r, e) {
  const t = [], s = wt(r, e);
  for (const i in s.props) {
    const n = s.props[i];
    let a = xt(r, n), o = !1;
    a.includes($r) && (a.includes("Boolean") || a.includes("Function") ? (a = a.filter((u) => u !== $r), o = !0) : a = ["null"]), t.push({
      key: i,
      required: !n.optional,
      type: a || ["null"],
      skipCheck: o
    });
  }
  return t;
}
function A9(r, { key: e, required: t, type: s, skipCheck: i }, n) {
  let a;
  const o = bw(r, e, s);
  if (o)
    a = `default: ${o.valueString}${o.needSkipFactory ? ", skipFactory: true" : ""}`;
  else if (n) {
    const l = r.propsRuntimeDefaults.properties.find(
      (c) => c.type === "SpreadElement" ? !1 : n0(c.key, c.computed) === e
    );
    l && (l.type === "ObjectProperty" ? a = `default: ${r.getString(l.value)}` : a = `${l.async ? "async " : ""}${l.kind !== "method" ? `${l.kind} ` : ""}default() ${r.getString(l.body)}`);
  }
  const u = p2(e);
  return r.options.isProd ? s.some(
    (l) => l === "Boolean" || (!n || a) && l === "Function"
  ) ? `${u}: { ${Wy([
    `type: ${dn(s)}`,
    a
  ])} }` : r.isCE ? a ? `${u}: ${`{ ${a}, type: ${dn(
    s
  )} }`}` : `${u}: {type: ${dn(s)}}` : `${u}: ${a ? `{ ${a} }` : "{}"}` : `${u}: { ${Wy([
    `type: ${dn(s)}`,
    `required: ${t}`,
    i && "skipCheck: true",
    a
  ])} }`;
}
function C9(r) {
  return !!(r.propsRuntimeDefaults && r.propsRuntimeDefaults.type === "ObjectExpression" && r.propsRuntimeDefaults.properties.every(
    (e) => e.type !== "SpreadElement" && (!e.computed || e.key.type.endsWith("Literal"))
  ));
}
function bw(r, e, t) {
  const s = r.propsDestructuredBindings[e], i = s && s.default;
  if (i) {
    const n = r.getString(i), a = br(i);
    if (t && t.length && !t.includes("null")) {
      const l = N9(a);
      l && !t.includes(l) && r.error(
        `Default value of prop "${e}" does not match declared type.`,
        a
      );
    }
    const o = !t && (Ys(a) || a.type === "Identifier");
    return {
      valueString: !o && !f2(a) && !(t != null && t.includes("Function")) ? `() => (${n})` : n,
      needSkipFactory: o
    };
  }
}
function N9(r) {
  switch (r.type) {
    case "StringLiteral":
      return "String";
    case "NumericLiteral":
      return "Number";
    case "BooleanLiteral":
      return "Boolean";
    case "ObjectExpression":
      return "Object";
    case "ArrayExpression":
      return "Array";
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      return "Function";
  }
}
function O9(r, e) {
  if (!r.options.propsDestructure)
    return;
  wn(
    `This project is using reactive props destructure, which is an experimental feature. It may receive breaking changes or be removed in the future, so use at your own risk.
To stay updated, follow the RFC at https://github.com/vuejs/rfcs/discussions/502.`
  ), r.propsDestructureDecl = e;
  const t = (s, i, n) => {
    r.propsDestructuredBindings[s] = { local: i, default: n }, i !== s && (r.bindingMetadata[i] = "props-aliased", (r.bindingMetadata.__propsAliases || (r.bindingMetadata.__propsAliases = {}))[i] = s);
  };
  for (const s of e.properties)
    if (s.type === "ObjectProperty") {
      const i = n0(s.key, s.computed);
      if (i || r.error(
        `${At}() destructure cannot use computed key.`,
        s.key
      ), s.value.type === "AssignmentPattern") {
        const { left: n, right: a } = s.value;
        n.type !== "Identifier" && r.error(
          `${At}() destructure does not support nested patterns.`,
          n
        ), t(i, n.name, a);
      } else s.value.type === "Identifier" ? t(i, s.value.name) : r.error(
        `${At}() destructure does not support nested patterns.`,
        s.value
      );
    } else
      r.propsDestructureRestId = s.argument.name, r.bindingMetadata[r.propsDestructureRestId] = "setup-reactive-const";
}
function I9(r, e) {
  if (!r.options.propsDestructure)
    return;
  const t = {}, s = [t];
  let i = t;
  const n = /* @__PURE__ */ new WeakSet(), a = [], o = /* @__PURE__ */ Object.create(null);
  for (const y in r.propsDestructuredBindings) {
    const { local: S } = r.propsDestructuredBindings[y];
    t[S] = !0, o[S] = y;
  }
  function u() {
    s.push(i = Object.create(i));
  }
  function l() {
    s.pop(), i = s[s.length - 1] || null;
  }
  function c(y) {
    n.add(y), i ? i[y.name] = !1 : r.error(
      "registerBinding called without active scope, something is wrong.",
      y
    );
  }
  function f(y, S = !1) {
    for (const E of y.body)
      if (E.type === "VariableDeclaration")
        p(E, S);
      else if (E.type === "FunctionDeclaration" || E.type === "ClassDeclaration") {
        if (E.declare || !E.id) continue;
        c(E.id);
      } else (E.type === "ForOfStatement" || E.type === "ForInStatement") && E.left.type === "VariableDeclaration" ? p(E.left) : E.type === "ExportNamedDeclaration" && E.declaration && E.declaration.type === "VariableDeclaration" ? p(E.declaration, S) : E.type === "LabeledStatement" && E.body.type === "VariableDeclaration" && p(E.body, S);
  }
  function p(y, S = !1) {
    if (!y.declare)
      for (const E of y.declarations) {
        const g = S && E.init && Wt(br(E.init), "defineProps");
        for (const b of mr(E.id))
          g ? n.add(b) : c(b);
      }
  }
  function h(y, S, E) {
    (S.type === "AssignmentExpression" && y === S.left || S.type === "UpdateExpression") && r.error("Cannot assign to destructured props as they are readonly.", y), qo(S) && S.shorthand ? (!S.inPattern || jo(S, E)) && r.s.appendLeft(
      y.end + r.startOffset,
      `: ${hl(o[y.name])}`
    ) : r.s.overwrite(
      y.start + r.startOffset,
      y.end + r.startOffset,
      hl(o[y.name])
    );
  }
  function m(y, S, E = S) {
    if (Wt(y, E)) {
      const g = br(y.arguments[0]);
      g.type === "Identifier" && i[g.name] && r.error(
        `"${g.name}" is a destructured prop and should not be passed directly to ${S}(). Pass a getter () => ${g.name} instead.`,
        g
      );
    }
  }
  const d = r.scriptSetupAst;
  f(d, !0), Rc(d, {
    enter(y, S) {
      if (S && a.push(S), S && S.type.startsWith("TS") && S.type !== "TSAsExpression" && S.type !== "TSNonNullExpression" && S.type !== "TSTypeAssertion")
        return this.skip();
      if (m(y, "watch", e.watch), m(y, "toRef", e.toRef), Ys(y)) {
        u(), gm(y, c), y.body.type === "BlockStatement" && f(y.body);
        return;
      }
      if (y.type === "CatchClause") {
        u(), y.param && y.param.type === "Identifier" && c(y.param), f(y.body);
        return;
      }
      if (y.type === "BlockStatement" && !Ys(S)) {
        u(), f(y);
        return;
      }
      y.type === "Identifier" && mm(y, S, a) && !n.has(y) && i[y.name] && h(y, S, a);
    },
    leave(y, S) {
      S && a.pop(), (y.type === "BlockStatement" && !Ys(S) || Ys(y)) && l();
    }
  });
}
const ji = "defineEmits";
function ub(r, e, t) {
  return Wt(e, ji) ? (r.hasDefineEmitCall && r.error(`duplicate ${ji}() call`, e), r.hasDefineEmitCall = !0, r.emitsRuntimeDecl = e.arguments[0], e.typeParameters && (r.emitsRuntimeDecl && r.error(
    `${ji}() cannot accept both type and non-type arguments at the same time. Use one or the other.`,
    e
  ), r.emitsTypeDecl = e.typeParameters.params[0]), r.emitDecl = t, !0) : !1;
}
function k9(r) {
  let e = "";
  if (r.emitsRuntimeDecl)
    e = r.getString(r.emitsRuntimeDecl).trim();
  else if (r.emitsTypeDecl) {
    const t = vw(r);
    e = t.size ? `[${Array.from(t).map((s) => JSON.stringify(s)).join(", ")}]` : "";
  }
  if (r.hasDefineModelCall) {
    let t = `[${Object.keys(r.modelDecls).map((s) => JSON.stringify(`update:${s}`)).join(", ")}]`;
    e = e ? `/*#__PURE__*/${r.helper(
      "mergeModels"
    )}(${e}, ${t})` : t;
  }
  return e;
}
function vw(r) {
  const e = /* @__PURE__ */ new Set(), t = r.emitsTypeDecl;
  if (t.type === "TSFunctionType")
    return lb(r, t.parameters[0], e), e;
  const { props: s, calls: i } = wt(r, t);
  let n = !1;
  for (const a in s)
    e.add(a), n = !0;
  if (i) {
    n && r.error(
      "defineEmits() type cannot mixed call signature and property syntax.",
      t
    );
    for (const a of i)
      lb(r, a.parameters[0], e);
  }
  return e;
}
function lb(r, e, t) {
  if (e.type === "Identifier" && e.typeAnnotation && e.typeAnnotation.type === "TSTypeAnnotation") {
    const s = gw(r, e.typeAnnotation.typeAnnotation);
    for (const i of s)
      i.type === "TSLiteralType" && i.literal.type !== "UnaryExpression" && i.literal.type !== "TemplateLiteral" && t.add(String(i.literal.value));
  }
}
const Xl = "defineExpose";
function D9(r, e) {
  return Wt(e, Xl) ? (r.hasDefineExposeCall && r.error(`duplicate ${Xl}() call`, e), r.hasDefineExposeCall = !0, !0) : !1;
}
const Tn = "defineSlots";
function cb(r, e, t) {
  return Wt(e, Tn) ? (r.hasDefineSlotsCall && r.error(`duplicate ${Tn}() call`, e), r.hasDefineSlotsCall = !0, e.arguments.length > 0 && r.error(`${Tn}() cannot accept arguments`, e), t && r.s.overwrite(
    r.startOffset + e.start,
    r.startOffset + e.end,
    `${r.helper("useSlots")}()`
  ), !0) : !1;
}
const Rr = "defineOptions";
function fb(r, e) {
  if (!Wt(e, Rr))
    return !1;
  if (r.hasDefineOptionsCall && r.error(`duplicate ${Rr}() call`, e), e.typeParameters && r.error(`${Rr}() cannot accept type arguments`, e), !e.arguments[0]) return !0;
  r.hasDefineOptionsCall = !0, r.optionsRuntimeDecl = br(e.arguments[0]);
  let t, s, i, n;
  if (r.optionsRuntimeDecl.type === "ObjectExpression") {
    for (const a of r.optionsRuntimeDecl.properties)
      if ((a.type === "ObjectProperty" || a.type === "ObjectMethod") && a.key.type === "Identifier")
        switch (a.key.name) {
          case "props":
            t = a;
            break;
          case "emits":
            s = a;
            break;
          case "expose":
            i = a;
            break;
          case "slots":
            n = a;
            break;
        }
  }
  return t && r.error(
    `${Rr}() cannot be used to declare props. Use ${At}() instead.`,
    t
  ), s && r.error(
    `${Rr}() cannot be used to declare emits. Use ${ji}() instead.`,
    s
  ), i && r.error(
    `${Rr}() cannot be used to declare expose. Use ${Xl}() instead.`,
    i
  ), n && r.error(
    `${Rr}() cannot be used to declare slots. Use ${Tn}() instead.`,
    n
  ), !0;
}
function L9(r, e, t, s) {
  const i = e.argument.extra && e.argument.extra.parenthesized ? e.argument.extra.parenStart : e.argument.start, n = r.startOffset, a = r.descriptor.source.slice(
    i + n,
    e.argument.end + n
  ), o = /\bawait\b/.test(a);
  r.s.overwrite(
    e.start + n,
    i + n,
    `${t ? ";" : ""}(
  ([__temp,__restore] = ${r.helper(
      "withAsyncContext"
    )}(${o ? "async " : ""}() => `
  ), r.s.appendLeft(
    e.end + n,
    `)),
  ${s ? "" : "__temp = "}await __temp,
  __restore()${s ? "" : `,
  __temp`}
)`
  );
}
var M9 = Object.defineProperty, R9 = Object.defineProperties, $9 = Object.getOwnPropertyDescriptors, pb = Object.getOwnPropertySymbols, F9 = Object.prototype.hasOwnProperty, B9 = Object.prototype.propertyIsEnumerable, hb = (r, e, t) => e in r ? M9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Pa = (r, e) => {
  for (var t in e || (e = {}))
    F9.call(e, t) && hb(r, t, e[t]);
  if (pb)
    for (var t of pb(e))
      B9.call(e, t) && hb(r, t, e[t]);
  return r;
}, sp = (r, e) => R9(r, $9(e));
const V9 = [
  At,
  ji,
  Xl,
  Rr,
  Tn,
  df,
  wi
];
function U9(r, e) {
  var t, s, i;
  e.id || wn(
    "compileScript now requires passing the `id` option.\nUpgrade your vite or vue-loader version for compatibility with the latest experimental proposals."
  );
  const n = new HR(r, e), { script: a, scriptSetup: o, source: u, filename: l } = r, c = e.hoistStatic !== !1 && !a, f = e.id ? e.id.replace(/^data-v-/, "") : "", p = a && a.lang, h = o && o.lang;
  if (!o) {
    if (!a)
      throw new Error("[@vue/compiler-sfc] SFC contains no <script> tags.");
    return e9(n, f);
  }
  if (a && p !== h)
    throw new Error(
      "[@vue/compiler-sfc] <script> and <script setup> must have the same language type."
    );
  if (h && !n.isJS && !n.isTS)
    return o;
  const m = /* @__PURE__ */ Object.create(null), d = /* @__PURE__ */ Object.create(null);
  let y, S = !1, E = !1;
  const g = n.startOffset, b = n.endOffset, v = a && a.loc.start.offset, A = a && a.loc.end.offset;
  function C(k) {
    const R = k.start + g;
    let D = k.end + g;
    for (k.trailingComments && k.trailingComments.length > 0 && (D = k.trailingComments[k.trailingComments.length - 1].end + g); D <= u.length && /\s/.test(u.charAt(D)); )
      D++;
    n.s.move(R, D, 0);
  }
  function x(k, R, D, B, ie, L) {
    let ne = L;
    L && n.isTS && r.template && !r.template.src && !r.template.lang && (ne = T2(R, r)), n.userImports[R] = {
      isType: B,
      imported: D,
      local: R,
      source: k,
      isFromSetup: ie,
      isUsedInTemplate: ne
    };
  }
  function _(k, R) {
    k && Uo(k, (D) => {
      const B = d[D.name];
      B && B !== "literal-const" && n.error(
        `\`${R}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options require initialization in the module scope, use a separate normal <script> to export the options instead.`,
        D
      );
    });
  }
  const T = n.scriptAst, P = n.scriptSetupAst;
  if (T) {
    for (const k of T.body)
      if (k.type === "ImportDeclaration")
        for (const R of k.specifiers) {
          const D = Gp(R);
          x(
            k.source.value,
            R.local.name,
            D,
            k.importKind === "type" || R.type === "ImportSpecifier" && R.importKind === "type",
            !1,
            !e.inlineTemplate
          );
        }
  }
  for (const k of P.body)
    if (k.type === "ImportDeclaration") {
      C(k);
      let R = 0;
      const D = (B) => {
        const ie = B > R;
        R++;
        const L = k.specifiers[B], ne = k.specifiers[B + 1];
        n.s.remove(
          ie ? k.specifiers[B - 1].end + g : L.start + g,
          ne && !ie ? ne.start + g : L.end + g
        );
      };
      for (let B = 0; B < k.specifiers.length; B++) {
        const ie = k.specifiers[B], L = ie.local.name, ne = Gp(ie), ye = k.source.value, be = n.userImports[L];
        ye === "vue" && V9.includes(ne) ? (L === ne ? wn(
          `\`${ne}\` is a compiler macro and no longer needs to be imported.`
        ) : n.error(
          `\`${ne}\` is a compiler macro and cannot be aliased to a different name.`,
          ie
        ), D(B)) : be ? be.source === ye && be.imported === ne ? D(B) : n.error(
          "different imports aliased to same local name.",
          ie
        ) : x(
          ye,
          L,
          ne,
          k.importKind === "type" || ie.type === "ImportSpecifier" && ie.importKind === "type",
          !0,
          !e.inlineTemplate
        );
      }
      k.specifiers.length && R === k.specifiers.length && n.s.remove(k.start + g, k.end + g);
    }
  const I = {};
  for (const k in n.userImports) {
    const { source: R, imported: D, local: B } = n.userImports[k];
    R === "vue" && (I[D] = B);
  }
  if (a && T) {
    for (const k of T.body)
      if (k.type === "ExportDefaultDeclaration") {
        y = k;
        let R;
        if (y.declaration.type === "ObjectExpression" ? R = y.declaration.properties : y.declaration.type === "CallExpression" && y.declaration.arguments[0] && y.declaration.arguments[0].type === "ObjectExpression" && (R = y.declaration.arguments[0].properties), R)
          for (const ie of R)
            ie.type === "ObjectProperty" && ie.key.type === "Identifier" && ie.key.name === "name" && (n.hasDefaultExportName = !0), (ie.type === "ObjectMethod" || ie.type === "ObjectProperty") && ie.key.type === "Identifier" && ie.key.name === "render" && (n.hasDefaultExportRender = !0);
        const D = k.start + v, B = k.declaration.start + v;
        n.s.overwrite(D, B, `const ${fn} = `);
      } else if (k.type === "ExportNamedDeclaration") {
        const R = k.specifiers.find(
          (D) => D.exported.type === "Identifier" && D.exported.name === "default"
        );
        R && (y = k, k.specifiers.length > 1 ? n.s.remove(
          R.start + v,
          R.end + v
        ) : n.s.remove(
          k.start + v,
          k.end + v
        ), k.source ? n.s.prepend(
          `import { ${R.local.name} as ${fn} } from '${k.source.value}'
`
        ) : n.s.appendLeft(
          A,
          `
const ${fn} = ${R.local.name}
`
        )), k.declaration && ip(
          "script",
          k.declaration,
          m,
          I,
          c
        );
      } else (k.type === "VariableDeclaration" || k.type === "FunctionDeclaration" || k.type === "ClassDeclaration" || k.type === "TSEnumDeclaration") && !k.declare && ip(
        "script",
        k,
        m,
        I,
        c
      );
    v > g && (/\n$/.test(a.content.trim()) || n.s.appendLeft(A, `
`), n.s.move(v, A, 0));
  }
  for (const k of P.body) {
    if (k.type === "ExpressionStatement") {
      const D = br(k.expression);
      if (Zh(n, D) || ub(n, D) || fb(n, D) || cb(n, D))
        n.s.remove(k.start + g, k.end + g);
      else if (D9(n, D)) {
        const B = D.callee;
        n.s.overwrite(
          B.start + g,
          B.end + g,
          "__expose"
        );
      } else
        ob(n, D);
    }
    if (k.type === "VariableDeclaration" && !k.declare) {
      const D = k.declarations.length;
      let B = D, ie;
      for (let L = 0; L < D; L++) {
        const ne = k.declarations[L], ye = ne.init && br(ne.init);
        if (ye) {
          fb(n, ye) && n.error(
            `${Rr}() has no returning value, it cannot be assigned.`,
            k
          );
          const be = Zh(n, ye, ne.id);
          n.propsDestructureRestId && (d[n.propsDestructureRestId] = "setup-reactive-const");
          const me = !be && ub(n, ye, ne.id);
          if (!me && (cb(n, ye, ne.id) || ob(n, ye, ne.id)), be && !n.propsDestructureRestId && n.propsDestructureDecl)
            if (B === 1)
              n.s.remove(k.start + g, k.end + g);
            else {
              let ke = ne.start + g, Ke = ne.end + g;
              L === D - 1 ? ke = k.declarations[ie].end + g : Ke = k.declarations[L + 1].start + g, n.s.remove(ke, Ke), B--;
            }
          else me ? n.s.overwrite(
            g + ye.start,
            g + ye.end,
            "__emit"
          ) : ie = L;
        }
      }
    }
    let R = !1;
    if ((k.type === "VariableDeclaration" || k.type === "FunctionDeclaration" || k.type === "ClassDeclaration" || k.type === "TSEnumDeclaration") && !k.declare && (R = ip(
      "scriptSetup",
      k,
      d,
      I,
      c
    )), c && R && C(k), k.type === "VariableDeclaration" && !k.declare || k.type.endsWith("Statement")) {
      const D = [P.body];
      Rc(k, {
        enter(B, ie) {
          if (Ys(B) && this.skip(), B.type === "BlockStatement" && D.push(B.body), B.type === "AwaitExpression") {
            S = !0;
            const ne = D[D.length - 1].some((ye, be) => (D.length === 1 || be > 0) && ye.type === "ExpressionStatement" && ye.start === B.start);
            L9(
              n,
              B,
              ne,
              ie.type === "ExpressionStatement"
            );
          }
        },
        exit(B) {
          B.type === "BlockStatement" && D.pop();
        }
      });
    }
    (k.type === "ExportNamedDeclaration" && k.exportKind !== "type" || k.type === "ExportAllDeclaration" || k.type === "ExportDefaultDeclaration") && n.error(
      "<script setup> cannot contain ES module exports. If you are using a previous version of <script setup>, please consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.",
      k
    ), n.isTS && (k.type.startsWith("TS") || k.type === "ExportNamedDeclaration" && k.exportKind === "type" || k.type === "VariableDeclaration" && k.declare) && k.type !== "TSEnumDeclaration" && C(k);
  }
  n.propsDestructureDecl && I9(n, I), _(n.propsRuntimeDecl, At), _(n.propsRuntimeDefaults, At), _(n.propsDestructureDecl, At), _(n.emitsRuntimeDecl, ji), _(n.optionsRuntimeDecl, Rr);
  for (const { runtimeOptionNodes: k } of Object.values(n.modelDecls))
    for (const R of k)
      _(R, df);
  a ? g < v ? (n.s.remove(0, g), n.s.remove(b, v), n.s.remove(A, u.length)) : (n.s.remove(0, v), n.s.remove(A, g), n.s.remove(b, u.length)) : (n.s.remove(0, g), n.s.remove(b, u.length)), T && Object.assign(n.bindingMetadata, uw(T.body));
  for (const [k, { isType: R, imported: D, source: B }] of Object.entries(
    n.userImports
  ))
    R || (n.bindingMetadata[k] = D === "*" || D === "default" && B.endsWith(".vue") || B === "vue" ? "setup-const" : "setup-maybe-ref");
  for (const k in m)
    n.bindingMetadata[k] = m[k];
  for (const k in d)
    n.bindingMetadata[k] = d[k];
  r.cssVars.length && // no need to do this when targeting SSR
  !((t = e.templateOptions) != null && t.ssr) && (n.helperImports.add(Ol), n.helperImports.add("unref"), n.s.prependLeft(
    g,
    `
${v2(
      r.cssVars,
      n.bindingMetadata,
      f,
      !!e.isProd
    )}
`
  ));
  let $ = "__props";
  if (n.propsTypeDecl && ($ += ": any"), n.propsDecl && (n.propsDestructureRestId ? (n.s.overwrite(
    g + n.propsCall.start,
    g + n.propsCall.end,
    `${n.helper("createPropsRestProxy")}(__props, ${JSON.stringify(
      Object.keys(n.propsDestructuredBindings)
    )})`
  ), n.s.overwrite(
    g + n.propsDestructureDecl.start,
    g + n.propsDestructureDecl.end,
    n.propsDestructureRestId
  )) : n.propsDestructureDecl || n.s.overwrite(
    g + n.propsCall.start,
    g + n.propsCall.end,
    "__props"
  )), S) {
    const k = n.isTS ? ": any" : "";
    n.s.prependLeft(g, `
let __temp${k}, __restore${k}
`);
  }
  const Y = n.hasDefineExposeCall || !e.inlineTemplate ? ["expose: __expose"] : [];
  n.emitDecl && Y.push("emit: __emit"), Y.length && ($ += `, { ${Y.join(", ")} }`);
  let W;
  if (!e.inlineTemplate || !r.template && n.hasDefaultExportRender) {
    const k = Pa(Pa({}, m), d);
    for (const R in n.userImports)
      !n.userImports[R].isType && n.userImports[R].isUsedInTemplate && (k[R] = !0);
    W = "{ ";
    for (const R in k)
      if (k[R] === !0 && n.userImports[R].source !== "vue" && !n.userImports[R].source.endsWith(".vue"))
        W += `get ${R}() { return ${R} }, `;
      else if (n.bindingMetadata[R] === "setup-let") {
        const D = R === "v" ? "_v" : "v";
        W += `get ${R}() { return ${R} }, set ${R}(${D}) { ${R} = ${D} }, `;
      } else
        W += `${R}, `;
    W = W.replace(/, $/, "") + " }";
  } else if (r.template && !r.template.src) {
    e.templateOptions && e.templateOptions.ssr && (E = !0);
    const { code: k, ast: R, preamble: D, tips: B, errors: ie } = M_(sp(Pa({
      filename: l,
      ast: r.template.ast,
      source: r.template.content,
      inMap: r.template.map
    }, e.templateOptions), {
      id: f,
      scoped: r.styles.some((ne) => ne.scoped),
      isProd: e.isProd,
      ssrCssVars: r.cssVars,
      compilerOptions: sp(Pa({}, e.templateOptions && e.templateOptions.compilerOptions), {
        inline: !0,
        isTS: n.isTS,
        bindingMetadata: n.bindingMetadata
      })
    }));
    B.length && B.forEach(wn);
    const L = ie[0];
    if (typeof L == "string")
      throw new Error(L);
    if (L)
      throw L.loc && (L.message += `

` + r.filename + `
` + kn(
        u,
        L.loc.start.offset,
        L.loc.end.offset
      ) + `
`), L;
    D && n.s.prepend(D), R && R.helpers.has(Mn) && n.helperImports.delete("unref"), W = k;
  } else
    W = "() => {}";
  e.inlineTemplate ? n.s.appendRight(b, `
return ${W}
}

`) : n.s.appendRight(
    b,
    `
const __returned__ = ${W}
Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
return __returned__
}

`
  );
  const F = e.genDefaultAs ? `const ${e.genDefaultAs} =` : "export default";
  let K = "";
  if (!n.hasDefaultExportName && l && l !== C2) {
    const k = l.match(/([^/\\]+)\.\w+$/);
    k && (K += `
  __name: '${k[1]}',`);
  }
  E && (K += `
  __ssrInlineRender: true,`);
  const Z = T9(n);
  Z && (K += `
  props: ${Z},`);
  const Ce = k9(n);
  Ce && (K += `
  emits: ${Ce},`);
  let Ve = "";
  n.optionsRuntimeDecl && (Ve = o.content.slice(n.optionsRuntimeDecl.start, n.optionsRuntimeDecl.end).trim());
  const ee = n.hasDefineExposeCall || e.inlineTemplate ? "" : `  __expose();
`;
  if (n.isTS) {
    const k = (y ? `
  ...${fn},` : "") + (Ve ? `
  ...${Ve},` : "");
    n.s.prependLeft(
      g,
      `
${F} /*#__PURE__*/${n.helper(
        "defineComponent"
      )}({${k}${K}
  ${S ? "async " : ""}setup(${$}) {
${ee}`
    ), n.s.appendRight(b, "})");
  } else
    y || Ve ? (n.s.prependLeft(
      g,
      `
${F} /*#__PURE__*/Object.assign(${y ? `${fn}, ` : ""}${Ve ? `${Ve}, ` : ""}{${K}
  ${S ? "async " : ""}setup(${$}) {
${ee}`
    ), n.s.appendRight(b, "})")) : (n.s.prependLeft(
      g,
      `
${F} {${K}
  ${S ? "async " : ""}setup(${$}) {
${ee}`
    ), n.s.appendRight(b, "}"));
  if (n.helperImports.size > 0) {
    const k = (i = (s = e.templateOptions) == null ? void 0 : s.compilerOptions) == null ? void 0 : i.runtimeModuleName, R = k ? JSON.stringify(k) : "'vue'";
    n.s.prepend(
      `import { ${[...n.helperImports].map((D) => `${D} as _${D}`).join(", ")} } from ${R}
`
    );
  }
  return sp(Pa({}, o), {
    bindings: n.bindingMetadata,
    imports: n.userImports,
    content: n.s.toString(),
    map: e.sourceMap !== !1 ? n.s.generateMap({
      source: l,
      hires: !0,
      includeContent: !0
    }) : void 0,
    scriptAst: T == null ? void 0 : T.body,
    scriptSetupAst: P == null ? void 0 : P.body,
    deps: n.deps ? [...n.deps] : void 0
  });
}
function Pn(r, e, t) {
  r[e.name] = t;
}
function ip(r, e, t, s, i) {
  let n = !1;
  if (e.type === "VariableDeclaration") {
    const a = e.kind === "const";
    n = a && e.declarations.every(
      (o) => o.id.type === "Identifier" && wr(o.init)
    );
    for (const { id: o, init: u } of e.declarations) {
      const l = u && br(u), c = a && Wt(
        l,
        (f) => f === At || f === ji || f === wi || f === Tn
      );
      if (o.type === "Identifier") {
        let f;
        const p = s.reactive;
        (i || r === "script") && (n || a && wr(l)) ? f = "literal-const" : Wt(l, p) ? f = a ? "setup-reactive-const" : "setup-let" : /* if a declaration is a const literal, we can mark it so that */ /* the generated render fn code doesn't need to unref() it */ c || a && _w(l, p) ? f = Wt(l, At) ? "setup-reactive-const" : "setup-const" : a ? Wt(
          l,
          (h) => h === s.ref || h === s.computed || h === s.shallowRef || h === s.customRef || h === s.toRef || h === df
        ) ? f = "setup-ref" : f = "setup-maybe-ref" : f = "setup-let", Pn(t, o, f);
      } else {
        if (Wt(l, At))
          continue;
        o.type === "ObjectPattern" ? Ew(o, t, a, c) : o.type === "ArrayPattern" && Sw(o, t, a, c);
      }
    }
  } else e.type === "TSEnumDeclaration" ? (n = e.members.every(
    (a) => !a.initializer || wr(a.initializer)
  ), t[e.id.name] = n ? "literal-const" : "setup-const") : (e.type === "FunctionDeclaration" || e.type === "ClassDeclaration") && (t[e.id.name] = "setup-const");
  return n;
}
function Ew(r, e, t, s = !1) {
  for (const i of r.properties)
    if (i.type === "ObjectProperty")
      if (i.key.type === "Identifier" && i.key === i.value) {
        const n = s ? "setup-const" : t ? "setup-maybe-ref" : "setup-let";
        Pn(e, i.key, n);
      } else
        ig(i.value, e, t, s);
    else {
      const n = t ? "setup-const" : "setup-let";
      Pn(e, i.argument, n);
    }
}
function Sw(r, e, t, s = !1) {
  for (const i of r.elements)
    i && ig(i, e, t, s);
}
function ig(r, e, t, s = !1) {
  if (r.type === "Identifier")
    Pn(e, r, s ? "setup-const" : t ? "setup-maybe-ref" : "setup-let");
  else if (r.type === "RestElement") {
    const i = t ? "setup-const" : "setup-let";
    Pn(e, r.argument, i);
  } else if (r.type === "ObjectPattern")
    Ew(r, e, t);
  else if (r.type === "ArrayPattern")
    Sw(r, e, t);
  else if (r.type === "AssignmentPattern")
    if (r.left.type === "Identifier") {
      const i = s ? "setup-const" : t ? "setup-maybe-ref" : "setup-let";
      Pn(e, r.left, i);
    } else
      ig(r.left, e, t);
}
function _w(r, e) {
  if (Wt(r, e))
    return !0;
  switch (r.type) {
    case "UnaryExpression":
    case "BinaryExpression":
    case "ArrayExpression":
    case "ObjectExpression":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "UpdateExpression":
    case "ClassExpression":
    case "TaggedTemplateExpression":
      return !0;
    case "SequenceExpression":
      return _w(
        r.expressions[r.expressions.length - 1],
        e
      );
    default:
      return !!f2(r);
  }
}
function wr(r) {
  switch (r = br(r), r.type) {
    case "UnaryExpression":
      return wr(r.argument);
    case "LogicalExpression":
    case "BinaryExpression":
      return wr(r.left) && wr(r.right);
    case "ConditionalExpression":
      return wr(r.test) && wr(r.consequent) && wr(r.alternate);
    case "SequenceExpression":
    case "TemplateLiteral":
      return r.expressions.every((e) => wr(e));
    case "ParenthesizedExpression":
      return wr(r.expression);
    case "StringLiteral":
    case "NumericLiteral":
    case "BooleanLiteral":
    case "NullLiteral":
    case "BigIntLiteral":
      return !0;
  }
  return !1;
}
var j9 = Object.defineProperty, db = Object.getOwnPropertySymbols, q9 = Object.prototype.hasOwnProperty, H9 = Object.prototype.propertyIsEnumerable, mb = (r, e, t) => e in r ? j9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, gb = (r, e) => {
  for (var t in e || (e = {}))
    q9.call(e, t) && mb(r, t, e[t]);
  if (db)
    for (var t of db(e))
      H9.call(e, t) && mb(r, t, e[t]);
  return r;
};
const W9 = "3.4.37", z9 = Kp, G9 = gb(gb({}, tm), Jm), K9 = Rc, X9 = () => !1, c$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MagicString: la,
  babelParse: $n,
  compileScript: U9,
  compileStyle: PR,
  compileStyleAsync: AR,
  compileTemplate: M_,
  errorMessages: G9,
  extractIdentifiers: mr,
  extractRuntimeEmits: vw,
  extractRuntimeProps: yw,
  generateCodeFrame: kn,
  inferRuntimeType: xt,
  invalidateTypeCache: m9,
  isInDestructureAssignment: jo,
  isStaticProperty: qo,
  parse: N2,
  parseCache: z9,
  registerTS: p9,
  resolveTypeElements: wt,
  rewriteDefault: WR,
  rewriteDefaultAST: J0,
  shouldTransformRef: X9,
  version: W9,
  walk: K9,
  walkIdentifiers: Uo
}, Symbol.toStringTag, { value: "Module" }));
/**
* @vue/server-renderer v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const J9 = /* @__PURE__ */ zt(
  ",key,ref,innerHTML,textContent,ref_key,ref_for"
);
function xw(r, e) {
  let t = "";
  for (const s in r) {
    if (J9(s) || Yi(s) || e === "textarea" && s === "value")
      continue;
    const i = r[s];
    s === "class" ? t += ` class="${Pw(i)}"` : s === "style" ? t += ` style="${Aw(i)}"` : t += ww(s, i, e);
  }
  return t;
}
function ww(r, e, t) {
  if (!id(e))
    return "";
  const s = t && (t.indexOf("-") > 0 || Pb(t)) ? r : mT[r] || r.toLowerCase();
  return ap(s) ? Ao(e) ? ` ${s}` : "" : dT(s) ? e === "" ? ` ${s}` : ` ${s}="${Wr(e)}"` : (console.warn(
    `[@vue/server-renderer] Skipped rendering unsafe attribute name: ${s}`
  ), "");
}
function Tw(r, e) {
  return id(e) ? ` ${r}="${Wr(e)}"` : "";
}
function Pw(r) {
  return Wr(en(r));
}
function Aw(r) {
  if (!r)
    return "";
  if (_e(r))
    return Wr(r);
  const e = Zi(r);
  return Wr(Tb(e));
}
function Y9(r, e = null, t = null, s = null, i) {
  return mf(
    He(r, e, t),
    s,
    i
  );
}
const { ensureValidVNode: Q9 } = Kn;
function Z9(r, e, t, s, i, n, a) {
  i("<!--[-->"), Cw(
    r,
    e,
    t,
    s,
    i,
    n,
    a
  ), i("<!--]-->");
}
function Cw(r, e, t, s, i, n, a, o) {
  const u = r[e];
  if (u) {
    const l = [], f = u(
      t,
      (p) => {
        l.push(p);
      },
      n,
      a ? " " + a : ""
    );
    if (se(f)) {
      const p = Q9(f);
      p ? gf(
        i,
        p,
        n,
        a
      ) : s && s();
    } else {
      let p = !0;
      if (o)
        p = !1;
      else
        for (let h = 0; h < l.length; h++)
          if (!r7(l[h])) {
            p = !1;
            break;
          }
      if (p)
        s && s();
      else {
        let h = 0, m = l.length;
        o && l[0] === "<!--[-->" && l[m - 1] === "<!--]-->" && (h++, m--);
        for (let d = h; d < m; d++)
          i(l[d]);
      }
    }
  } else s && s();
}
const e7 = /^<!--[\s\S]*-->$/, t7 = /<!--[^]*?-->/gm;
function r7(r) {
  return typeof r != "string" || !e7.test(r) ? !1 : r.length <= 8 ? !0 : !r.replace(t7, "").trim();
}
function Nw(r, e, t, s, i) {
  r("<!--teleport start-->");
  const n = i.appContext.provides[ko], a = n.__teleportBuffers || (n.__teleportBuffers = {}), o = a[t] || (a[t] = []), u = o.length;
  let l;
  if (s)
    e(r), l = "<!--teleport start anchor--><!--teleport anchor-->";
  else {
    const { getBuffer: c, push: f } = Fw();
    f("<!--teleport start anchor-->"), e(f), f("<!--teleport anchor-->"), l = c();
  }
  o.splice(u, 0, l), r("<!--teleport end-->");
}
function s7(r) {
  return Wr(nd(r));
}
let yb, Jl = !0;
const Ow = [];
function Iw() {
  Ow.push(Jl), Jl = !1;
}
function kw() {
  const r = Ow.pop();
  Jl = r === void 0 ? !0 : r;
}
function i7(r, e, t) {
  var s;
  e.get(r) !== r._trackId && (e.set(r, r._trackId), r.deps[r._depsLength] !== e ? r.deps[r._depsLength++] = e : r._depsLength++, process.env.NODE_ENV !== "production" && ((s = r.onTrack) == null || s.call(r, Be({ effect: r }, t))));
}
const n7 = (r, e) => {
  const t = /* @__PURE__ */ new Map();
  return t.cleanup = r, t.computed = e, t;
}, bb = /* @__PURE__ */ new WeakMap();
Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
function vb(r, e, t) {
  if (Jl && yb) {
    let s = bb.get(r);
    s || bb.set(r, s = /* @__PURE__ */ new Map());
    let i = s.get(t);
    i || s.set(t, i = n7(() => s.delete(t))), i7(
      yb,
      i,
      process.env.NODE_ENV !== "production" ? {
        target: r,
        type: e,
        key: t
      } : void 0
    );
  }
}
function ed(r) {
  const e = r && r.__v_raw;
  return e ? ed(e) : r;
}
function a7(r) {
  return !!(r && r.__v_isRef === !0);
}
const qi = [];
function o7(r) {
  qi.push(r);
}
function u7() {
  qi.pop();
}
let np = !1;
function Yl(r, ...e) {
  if (np) return;
  np = !0, Iw();
  const t = qi.length ? qi[qi.length - 1].component : null, s = t && t.appContext.config.warnHandler, i = l7();
  if (s)
    Mw(
      s,
      t,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        r + e.map((n) => {
          var a, o;
          return (o = (a = n.toString) == null ? void 0 : a.call(n)) != null ? o : JSON.stringify(n);
        }).join(""),
        t && t.proxy,
        i.map(
          ({ vnode: n }) => `at <${$w(t, n.type)}>`
        ).join(`
`),
        i
      ]
    );
  else {
    const n = [`[Vue warn]: ${r}`, ...e];
    i.length && n.push(`
`, ...c7(i)), console.warn(...n);
  }
  kw(), np = !1;
}
function l7() {
  let r = qi[qi.length - 1];
  if (!r)
    return [];
  const e = [];
  for (; r; ) {
    const t = e[0];
    t && t.vnode === r ? t.recurseCount++ : e.push({
      vnode: r,
      recurseCount: 0
    });
    const s = r.component && r.component.parent;
    r = s && s.vnode;
  }
  return e;
}
function c7(r) {
  const e = [];
  return r.forEach((t, s) => {
    e.push(...s === 0 ? [] : [`
`], ...f7(t));
  }), e;
}
function f7({ vnode: r, recurseCount: e }) {
  const t = e > 0 ? `... (${e} recursive calls)` : "", s = r.component ? r.component.parent == null : !1, i = ` at <${$w(
    r.component,
    r.type,
    s
  )}`, n = ">" + t;
  return r.props ? [i, ...p7(r.props), n] : [i + n];
}
function p7(r) {
  const e = [], t = Object.keys(r);
  return t.slice(0, 3).forEach((s) => {
    e.push(...Dw(s, r[s]));
  }), t.length > 3 && e.push(" ..."), e;
}
function Dw(r, e, t) {
  return _e(e) ? (e = JSON.stringify(e), t ? e : [`${r}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? t ? e : [`${r}=${e}`] : a7(e) ? (e = Dw(r, ed(e.value), !0), t ? e : [`${r}=Ref<`, e, ">"]) : fe(e) ? [`${r}=fn${e.name ? `<${e.name}>` : ""}`] : (e = ed(e), t ? e : [`${r}=`, e]);
}
const Lw = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update"
};
function Mw(r, e, t, s) {
  try {
    return s ? r(...s) : r();
  } catch (i) {
    h7(i, e, t);
  }
}
function h7(r, e, t, s = !0) {
  const i = e ? e.vnode : null;
  if (e) {
    let n = e.parent;
    const a = e.proxy, o = process.env.NODE_ENV !== "production" ? Lw[t] : `https://vuejs.org/error-reference/#runtime-${t}`;
    for (; n; ) {
      const l = n.ec;
      if (l) {
        for (let c = 0; c < l.length; c++)
          if (l[c](r, a, o) === !1)
            return;
      }
      n = n.parent;
    }
    const u = e.appContext.config.errorHandler;
    if (u) {
      Iw(), Mw(
        u,
        null,
        10,
        [r, a, o]
      ), kw();
      return;
    }
  }
  d7(r, t, i, s);
}
function d7(r, e, t, s = !0) {
  if (process.env.NODE_ENV !== "production") {
    const i = Lw[e];
    if (t && o7(t), Yl(`Unhandled error${i ? ` during execution of ${i}` : ""}`), t && u7(), s)
      throw r;
    console.error(r);
  } else
    console.error(r);
}
let pn, Au = [];
function Rw(r, e) {
  var t, s;
  pn = r, pn ? (pn.enabled = !0, Au.forEach(({ event: i, args: n }) => pn.emit(i, ...n)), Au = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((s = (t = window.navigator) == null ? void 0 : t.userAgent) != null && s.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((n) => {
    Rw(n, e);
  }), setTimeout(() => {
    pn || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Au = []);
  }, 3e3)) : Au = [];
}
{
  const r = Zl(), e = (t, s) => {
    let i;
    return (i = r[t]) || (i = r[t] = []), i.push(s), (n) => {
      i.length > 1 ? i.forEach((a) => a(n)) : i[0](n);
    };
  };
  e(
    "__VUE_INSTANCE_SETTERS__",
    (t) => t
  ), e(
    "__VUE_SSR_SETTERS__",
    (t) => t
  );
}
process.env.NODE_ENV;
const m7 = /(?:^|[-_])(\w)/g, g7 = (r) => r.replace(m7, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function y7(r, e = !0) {
  return fe(r) ? r.displayName || r.name : r.name || e && r.__name;
}
function $w(r, e, t = !1) {
  let s = y7(e);
  if (!s && e.__file) {
    const i = e.__file.match(/([^/\\]+)\.\w+$/);
    i && (s = i[1]);
  }
  if (!s && r && r.parent) {
    const i = (n) => {
      for (const a in n)
        if (n[a] === e)
          return a;
    };
    s = i(
      r.components || r.parent.type.components
    ) || i(r.appContext.components);
  }
  return s ? g7(s) : t ? "App" : "Anonymous";
}
const b7 = process.env.NODE_ENV !== "production" ? Yl : Ge;
process.env.NODE_ENV;
process.env.NODE_ENV;
function v7(r, e) {
  if (se(r) || _e(r))
    for (let t = 0, s = r.length; t < s; t++)
      e(r[t], t);
  else if (typeof r == "number") {
    if (process.env.NODE_ENV !== "production" && !Number.isInteger(r)) {
      b7(`The v-for range expect an integer value but got ${r}.`);
      return;
    }
    for (let t = 0; t < r; t++)
      e(t + 1, t);
  } else if (Ae(r))
    if (r[Symbol.iterator]) {
      const t = Array.from(r);
      for (let s = 0, i = t.length; s < i; s++)
        e(t[s], s);
    } else {
      const t = Object.keys(r);
      for (let s = 0, i = t.length; s < i; s++) {
        const n = t[s];
        e(r[n], n, s);
      }
    }
}
async function E7(r, { default: e }) {
  e ? e() : r("<!---->");
}
function S7(r, e, t, s, i = {}) {
  return typeof e != "function" && e.getSSRProps ? e.getSSRProps(
    {
      dir: e,
      instance: Kn.getComponentPublicInstance(r.$),
      value: t,
      oldValue: void 0,
      arg: s,
      modifiers: i
    },
    null
  ) || {} : {};
}
const _7 = Or;
function ng(r, e) {
  return Co(r, e) > -1;
}
function x7(r, e, t) {
  switch (r) {
    case "radio":
      return Or(e, t) ? " checked" : "";
    case "checkbox":
      return (se(e) ? ng(e, t) : e) ? " checked" : "";
    default:
      return Tw("value", e);
  }
}
function w7(r = {}, e) {
  const { type: t, value: s } = r;
  switch (t) {
    case "radio":
      return Or(e, s) ? { checked: !0 } : null;
    case "checkbox":
      return (se(e) ? ng(e, s) : e) ? { checked: !0 } : null;
    default:
      return { value: e };
  }
}
function T7(r, e) {
  throw new Error(
    "On-the-fly template compilation is not supported in the ESM build of @vue/server-renderer. All templates must be pre-compiled into render functions."
  );
}
const {
  createComponentInstance: P7,
  setCurrentRenderingInstance: Eb,
  setupComponent: A7,
  renderComponentRoot: Sb,
  normalizeVNode: C7
} = Kn;
function Fw() {
  let r = !1;
  const e = [];
  return {
    getBuffer() {
      return e;
    },
    push(t) {
      const s = _e(t);
      if (r && s) {
        e[e.length - 1] += t;
        return;
      }
      e.push(t), r = s, (es(t) || se(t) && t.hasAsync) && (e.hasAsync = !0);
    }
  };
}
function mf(r, e = null, t) {
  const s = P7(r, e, null), i = A7(
    s,
    !0
    /* isSSR */
  ), n = es(i), a = s.sp;
  if (n || a) {
    let o = n ? i : Promise.resolve();
    return a && (o = o.then(
      () => Promise.all(
        a.map((u) => u.call(s.proxy))
      )
    ).catch(Ge)), o.then(() => _b(s, t));
  } else
    return _b(s, t);
}
function _b(r, e) {
  const t = r.type, { getBuffer: s, push: i } = Fw();
  if (fe(t)) {
    let n = Sb(r);
    if (!t.props)
      for (const a in r.attrs)
        a.startsWith("data-v-") && ((n.props || (n.props = {}))[a] = "");
    Po(i, r.subTree = n, r, e);
  } else {
    (!r.render || r.render === Ge) && !r.ssrRender && !t.ssrRender && _e(t.template) && (t.ssrRender = T7(t.template));
    for (const a of r.scope.effects)
      a.computed && (a.computed._dirty = !0, a.computed._cacheable = !0);
    const n = r.ssrRender || t.ssrRender;
    if (n) {
      let a = r.inheritAttrs !== !1 ? r.attrs : void 0, o = !1, u = r;
      for (; ; ) {
        const c = u.vnode.scopeId;
        c && (o || (a = { ...a }, o = !0), a[c] = "");
        const f = u.parent;
        if (f && f.subTree && f.subTree === u.vnode)
          u = f;
        else
          break;
      }
      if (e) {
        o || (a = { ...a });
        const c = e.trim().split(" ");
        for (let f = 0; f < c.length; f++)
          a[c[f]] = "";
      }
      const l = Eb(r);
      try {
        n(
          r.proxy,
          i,
          r,
          a,
          // compiler-optimized bindings
          r.props,
          r.setupState,
          r.data,
          r.ctx
        );
      } finally {
        Eb(l);
      }
    } else if (r.render && r.render !== Ge)
      Po(
        i,
        r.subTree = Sb(r),
        r,
        e
      );
    else {
      const a = t.name || t.__file || "<Anonymous>";
      ot(`Component ${a} is missing template or render function.`), i("<!---->");
    }
  }
  return s();
}
function Po(r, e, t, s) {
  const { type: i, shapeFlag: n, children: a } = e;
  switch (i) {
    case Xr:
      r(Wr(a));
      break;
    case Je:
      r(
        a ? `<!--${ET(a)}-->` : "<!---->"
      );
      break;
    case Es:
      r(a);
      break;
    case ct:
      e.slotScopeIds && (s = (s ? s + " " : "") + e.slotScopeIds.join(" ")), r("<!--[-->"), gf(
        r,
        a,
        t,
        s
      ), r("<!--]-->");
      break;
    default:
      n & 1 ? N7(r, e, t, s) : n & 6 ? r(mf(e, t, s)) : n & 64 ? I7(r, e, t, s) : n & 128 ? Po(r, e.ssContent, t, s) : ot(
        "[@vue/server-renderer] Invalid VNode type:",
        i,
        `(${typeof i})`
      );
  }
}
function gf(r, e, t, s) {
  for (let i = 0; i < e.length; i++)
    Po(r, C7(e[i]), t, s);
}
function N7(r, e, t, s) {
  const i = e.type;
  let { props: n, children: a, shapeFlag: o, scopeId: u, dirs: l } = e, c = `<${i}`;
  l && (n = O7(e, n, l)), n && (c += xw(n, i)), u && (c += ` ${u}`);
  let f = t, p = e;
  for (; f && p === f.subTree; )
    p = f.vnode, p.scopeId && (c += ` ${p.scopeId}`), f = f.parent;
  if (s && (c += ` ${s}`), r(c + ">"), !fT(i)) {
    let h = !1;
    n && (n.innerHTML ? (h = !0, r(n.innerHTML)) : n.textContent ? (h = !0, r(Wr(n.textContent))) : i === "textarea" && n.value && (h = !0, r(Wr(n.value)))), h || (o & 8 ? r(Wr(a)) : o & 16 && gf(
      r,
      a,
      t,
      s
    )), r(`</${i}>`);
  }
}
function O7(r, e, t) {
  const s = [];
  for (let i = 0; i < t.length; i++) {
    const n = t[i], {
      dir: { getSSRProps: a }
    } = n;
    if (a) {
      const o = a(n, r);
      o && s.push(o);
    }
  }
  return Rd(e || {}, ...s);
}
function I7(r, e, t, s) {
  const i = e.props && e.props.to, n = e.props && e.props.disabled;
  if (!i)
    return n || ot("[@vue/server-renderer] Teleport is missing target prop."), [];
  if (!_e(i))
    return ot(
      "[@vue/server-renderer] Teleport target must be a query selector string."
    ), [];
  Nw(
    r,
    (a) => {
      gf(
        a,
        e.children,
        t,
        s
      );
    },
    i,
    n || n === "",
    t
  );
}
const { isVNode: k7 } = Kn;
function Ju(r, e, t) {
  if (!r.hasAsync)
    return e + Vw(r);
  let s = e;
  for (let i = t; i < r.length; i += 1) {
    const n = r[i];
    if (_e(n)) {
      s += n;
      continue;
    }
    if (es(n))
      return n.then((o) => (r[i] = o, Ju(r, s, i)));
    const a = Ju(n, s, 0);
    if (es(a))
      return a.then((o) => (r[i] = o, Ju(r, "", i)));
    s = a;
  }
  return s;
}
function Bw(r) {
  return Ju(r, "", 0);
}
function Vw(r) {
  let e = "";
  for (let t = 0; t < r.length; t++) {
    let s = r[t];
    _e(s) ? e += s : e += Vw(s);
  }
  return e;
}
async function Uw(r, e = {}) {
  if (k7(r))
    return Uw(jd({ render: () => r }), e);
  const t = He(r._component, r._props);
  t.appContext = r._context, r.provide(ko, e);
  const s = await mf(t), i = await Bw(s);
  if (await jw(e), e.__watcherHandles)
    for (const n of e.__watcherHandles)
      n();
  return i;
}
async function jw(r) {
  if (r.__teleportBuffers) {
    r.teleports = r.teleports || {};
    for (const e in r.__teleportBuffers)
      r.teleports[e] = await Bw(
        await Promise.all([r.__teleportBuffers[e]])
      );
  }
}
const { isVNode: D7 } = Kn;
async function qw(r, e) {
  if (r.hasAsync)
    for (let t = 0; t < r.length; t++) {
      let s = r[t];
      es(s) && (s = await s), _e(s) ? e.push(s) : await qw(s, e);
    }
  else
    Hw(r, e);
}
function Hw(r, e) {
  for (let t = 0; t < r.length; t++) {
    let s = r[t];
    _e(s) ? e.push(s) : Hw(s, e);
  }
}
function Xo(r, e, t) {
  if (D7(r))
    return Xo(
      jd({ render: () => r }),
      e,
      t
    );
  const s = He(r._component, r._props);
  return s.appContext = r._context, r.provide(ko, e), Promise.resolve(mf(s)).then((i) => qw(i, t)).then(() => jw(e)).then(() => {
    if (e.__watcherHandles)
      for (const i of e.__watcherHandles)
        i();
  }).then(() => t.push(null)).catch((i) => {
    t.destroy(i);
  }), t;
}
function L7(r, e = {}) {
  return console.warn(
    "[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead."
  ), Ww(r, e);
}
function Ww(r, e = {}) {
  throw new Error(
    "ESM build of renderToStream() does not support renderToNodeStream(). Use pipeToNodeWritable() with an existing Node.js Writable stream instance instead."
  );
}
function M7(r, e = {}, t) {
  Xo(r, e, {
    push(s) {
      s != null ? t.write(s) : t.end();
    },
    destroy(s) {
      t.destroy(s);
    }
  });
}
function R7(r, e = {}) {
  if (typeof ReadableStream != "function")
    throw new Error(
      "ReadableStream constructor is not available in the global scope. If the target environment does support web streams, consider using pipeToWebWritable() with an existing WritableStream instance instead."
    );
  const t = new TextEncoder();
  let s = !1;
  return new ReadableStream({
    start(i) {
      Xo(r, e, {
        push(n) {
          s || (n != null ? i.enqueue(t.encode(n)) : i.close());
        },
        destroy(n) {
          i.error(n);
        }
      });
    },
    cancel() {
      s = !0;
    }
  });
}
function $7(r, e = {}, t) {
  const s = t.getWriter(), i = new TextEncoder();
  let n = !1;
  try {
    n = es(s.ready);
  } catch {
  }
  Xo(r, e, {
    async push(a) {
      return n && await s.ready, a != null ? s.write(i.encode(a)) : s.close();
    },
    destroy(a) {
      console.log(a), s.close();
    }
  });
}
kE();
const f$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  pipeToNodeWritable: M7,
  pipeToWebWritable: $7,
  renderToNodeStream: Ww,
  renderToSimpleStream: Xo,
  renderToStream: L7,
  renderToString: Uw,
  renderToWebStream: R7,
  ssrGetDirectiveProps: S7,
  ssrGetDynamicModelProps: w7,
  ssrIncludeBooleanAttr: Ao,
  ssrInterpolate: s7,
  ssrLooseContain: ng,
  ssrLooseEqual: _7,
  ssrRenderAttr: Tw,
  ssrRenderAttrs: xw,
  ssrRenderClass: Pw,
  ssrRenderComponent: Y9,
  ssrRenderDynamicAttr: ww,
  ssrRenderDynamicModel: x7,
  ssrRenderList: v7,
  ssrRenderSlot: Z9,
  ssrRenderSlotInner: Cw,
  ssrRenderStyle: Aw,
  ssrRenderSuspense: E7,
  ssrRenderTeleport: Nw,
  ssrRenderVNode: Po
}, Symbol.toStringTag, { value: "Module" }));
export {
  iC as A,
  Zi as B,
  nd as C,
  YT as D,
  $n as E,
  ct as F,
  mr as G,
  Uo as H,
  qo as I,
  jo as J,
  K9 as K,
  VP as L,
  la as M,
  pl as N,
  aC as O,
  q3 as P,
  AP as Q,
  CP as R,
  f$ as S,
  Fd as T,
  oC as U,
  F7 as V,
  Uw as W,
  rc as a,
  tA as b,
  aE as c,
  xd as d,
  He as e,
  Io as f,
  Fa as g,
  fc as h,
  Ra as i,
  U3 as j,
  OP as k,
  Bd as l,
  Dd as m,
  en as n,
  dc as o,
  Ev as p,
  kd as q,
  Ii as r,
  KT as s,
  sP as t,
  hd as u,
  Np as v,
  Ed as w,
  nA as x,
  c$ as y,
  jP as z
};
