/**
* @vue/shared v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function zt(r, e) {
  const t = new Set(r.split(","));
  return (s) => t.has(s);
}
const Oe = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, gn = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], Ge = () => {
}, zw = () => !1, Yi = (r) => r.charCodeAt(0) === 111 && r.charCodeAt(1) === 110 && // uppercase letter
(r.charCodeAt(2) > 122 || r.charCodeAt(2) < 97), Yu = (r) => r.startsWith("onUpdate:"), Be = Object.assign, td = (r, e) => {
  const t = r.indexOf(e);
  t > -1 && r.splice(t, 1);
}, Gw = Object.prototype.hasOwnProperty, Pe = (r, e) => Gw.call(r, e), se = Array.isArray, Ci = (r) => zn(r) === "[object Map]", Qi = (r) => zn(r) === "[object Set]", lg = (r) => zn(r) === "[object Date]", Kw = (r) => zn(r) === "[object RegExp]", fe = (r) => typeof r == "function", _e = (r) => typeof r == "string", Zr = (r) => typeof r == "symbol", Ae = (r) => r !== null && typeof r == "object", es = (r) => (Ae(r) || fe(r)) && fe(r.then) && fe(r.catch), xb = Object.prototype.toString, zn = (r) => xb.call(r), rd = (r) => zn(r).slice(8, -1), wb = (r) => zn(r) === "[object Object]", sd = (r) => _e(r) && r !== "NaN" && r[0] !== "-" && "" + parseInt(r, 10) === r, yn = /* @__PURE__ */ zt(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Xw = /* @__PURE__ */ zt(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), Ql = (r) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = r(t));
}, Jw = /-(\w)/g, Et = Ql((r) => r.replace(Jw, (e, t) => t ? t.toUpperCase() : "")), Yw = /\B([A-Z])/g, Tt = Ql(
  (r) => r.replace(Yw, "-$1").toLowerCase()
), ii = Ql((r) => r.charAt(0).toUpperCase() + r.slice(1)), ps = Ql((r) => r ? `on${ii(r)}` : ""), jt = (r, e) => !Object.is(r, e), Gs = (r, ...e) => {
  for (let t = 0; t < r.length; t++)
    r[t](...e);
}, An = (r, e, t, s = !1) => {
  Object.defineProperty(r, e, {
    configurable: !0,
    enumerable: !1,
    writable: s,
    value: t
  });
}, Qu = (r) => {
  const e = parseFloat(r);
  return isNaN(e) ? r : e;
}, Zu = (r) => {
  const e = _e(r) ? Number(r) : NaN;
  return isNaN(e) ? r : e;
};
let cg;
const Zl = () => cg || (cg = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), Qw = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error", Zw = /* @__PURE__ */ zt(Qw);
function Zi(r) {
  if (se(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
      const s = r[t], i = _e(s) ? sT(s) : Zi(s);
      if (i)
        for (const n in i)
          e[n] = i[n];
    }
    return e;
  } else if (_e(r) || Ae(r))
    return r;
}
const eT = /;(?![^(]*\))/g, tT = /:([^]+)/, rT = /\/\*[^]*?\*\//g;
function sT(r) {
  const e = {};
  return r.replace(rT, "").split(eT).forEach((t) => {
    if (t) {
      const s = t.split(tT);
      s.length > 1 && (e[s[0].trim()] = s[1].trim());
    }
  }), e;
}
function Tb(r) {
  let e = "";
  if (!r || _e(r))
    return e;
  for (const t in r) {
    const s = r[t];
    if (_e(s) || typeof s == "number") {
      const i = t.startsWith("--") ? t : Tt(t);
      e += `${i}:${s};`;
    }
  }
  return e;
}
function en(r) {
  let e = "";
  if (_e(r))
    e = r;
  else if (se(r))
    for (let t = 0; t < r.length; t++) {
      const s = en(r[t]);
      s && (e += s + " ");
    }
  else if (Ae(r))
    for (const t in r)
      r[t] && (e += t + " ");
  return e.trim();
}
function iT(r) {
  if (!r) return null;
  let { class: e, style: t } = r;
  return e && !_e(e) && (r.class = en(e)), t && (r.style = Zi(t)), r;
}
const nT = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", aT = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", oT = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", uT = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr", lT = /* @__PURE__ */ zt(nT), Pb = /* @__PURE__ */ zt(aT), cT = /* @__PURE__ */ zt(oT), fT = /* @__PURE__ */ zt(uT), Ab = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", pT = /* @__PURE__ */ zt(Ab), ap = /* @__PURE__ */ zt(
  Ab + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"
);
function Ao(r) {
  return !!r || r === "";
}
const hT = /[>/="'\u0009\u000a\u000c\u0020]/, yf = {};
function dT(r) {
  if (yf.hasOwnProperty(r))
    return yf[r];
  const e = hT.test(r);
  return e && console.error(`unsafe attribute name: ${r}`), yf[r] = !e;
}
const mT = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
}, gT = /* @__PURE__ */ zt(
  "accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"
), yT = /* @__PURE__ */ zt(
  "xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"
);
function id(r) {
  if (r == null)
    return !1;
  const e = typeof r;
  return e === "string" || e === "number" || e === "boolean";
}
const bT = /["'&<>]/;
function Wr(r) {
  const e = "" + r, t = bT.exec(e);
  if (!t)
    return e;
  let s = "", i, n, a = 0;
  for (n = t.index; n < e.length; n++) {
    switch (e.charCodeAt(n)) {
      case 34:
        i = "&quot;";
        break;
      case 38:
        i = "&amp;";
        break;
      case 39:
        i = "&#39;";
        break;
      case 60:
        i = "&lt;";
        break;
      case 62:
        i = "&gt;";
        break;
      default:
        continue;
    }
    a !== n && (s += e.slice(a, n)), a = n + 1, s += i;
  }
  return a !== n ? s + e.slice(a, n) : s;
}
const vT = /^-?>|<!--|-->|--!>|<!-$/g;
function ET(r) {
  return r.replace(vT, "");
}
function ST(r, e) {
  if (r.length !== e.length) return !1;
  let t = !0;
  for (let s = 0; t && s < r.length; s++)
    t = Or(r[s], e[s]);
  return t;
}
function Or(r, e) {
  if (r === e) return !0;
  let t = lg(r), s = lg(e);
  if (t || s)
    return t && s ? r.getTime() === e.getTime() : !1;
  if (t = Zr(r), s = Zr(e), t || s)
    return r === e;
  if (t = se(r), s = se(e), t || s)
    return t && s ? ST(r, e) : !1;
  if (t = Ae(r), s = Ae(e), t || s) {
    if (!t || !s)
      return !1;
    const i = Object.keys(r).length, n = Object.keys(e).length;
    if (i !== n)
      return !1;
    for (const a in r) {
      const o = r.hasOwnProperty(a), u = e.hasOwnProperty(a);
      if (o && !u || !o && u || !Or(r[a], e[a]))
        return !1;
    }
  }
  return String(r) === String(e);
}
function Co(r, e) {
  return r.findIndex((t) => Or(t, e));
}
const Cb = (r) => !!(r && r.__v_isRef === !0), nd = (r) => _e(r) ? r : r == null ? "" : se(r) || Ae(r) && (r.toString === xb || !fe(r.toString)) ? Cb(r) ? nd(r.value) : JSON.stringify(r, Nb, 2) : String(r), Nb = (r, e) => Cb(e) ? Nb(r, e.value) : Ci(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (t, [s, i], n) => (t[bf(s, n) + " =>"] = i, t),
    {}
  )
} : Qi(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((t) => bf(t))
} : Zr(e) ? bf(e) : Ae(e) && !se(e) && !wb(e) ? String(e) : e, bf = (r, e = "") => {
  var t;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Zr(r) ? `Symbol(${(t = r.description) != null ? t : e})` : r
  );
};
/**
* @vue/reactivity v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function ts(r, ...e) {
  console.warn(`[Vue warn] ${r}`, ...e);
}
let rr;
class ad {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = rr, !e && rr && (this.index = (rr.scopes || (rr.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const t = rr;
      try {
        return rr = this, e();
      } finally {
        rr = t;
      }
    } else process.env.NODE_ENV !== "production" && ts("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    rr = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    rr = this.parent;
  }
  stop(e) {
    if (this._active) {
      let t, s;
      for (t = 0, s = this.effects.length; t < s; t++)
        this.effects[t].stop();
      for (t = 0, s = this.cleanups.length; t < s; t++)
        this.cleanups[t]();
      if (this.scopes)
        for (t = 0, s = this.scopes.length; t < s; t++)
          this.scopes[t].stop(!0);
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function _T(r) {
  return new ad(r);
}
function Ob(r, e = rr) {
  e && e.active && e.effects.push(r);
}
function Ib() {
  return rr;
}
function xT(r) {
  rr ? rr.cleanups.push(r) : process.env.NODE_ENV !== "production" && ts(
    "onScopeDispose() is called when there is no active effect scope to be associated with."
  );
}
let Ni;
class Cn {
  constructor(e, t, s, i) {
    this.fn = e, this.trigger = t, this.scheduler = s, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, Ob(this, i);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1, Os();
      for (let e = 0; e < this._depsLength; e++) {
        const t = this.deps[e];
        if (t.computed && (wT(t.computed), this._dirtyLevel >= 4))
          break;
      }
      this._dirtyLevel === 1 && (this._dirtyLevel = 0), Is();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(e) {
    this._dirtyLevel = e ? 4 : 0;
  }
  run() {
    if (this._dirtyLevel = 0, !this.active)
      return this.fn();
    let e = Qs, t = Ni;
    try {
      return Qs = !0, Ni = this, this._runnings++, fg(this), this.fn();
    } finally {
      pg(this), this._runnings--, Ni = t, Qs = e;
    }
  }
  stop() {
    this.active && (fg(this), pg(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function wT(r) {
  return r.value;
}
function fg(r) {
  r._trackId++, r._depsLength = 0;
}
function pg(r) {
  if (r.deps.length > r._depsLength) {
    for (let e = r._depsLength; e < r.deps.length; e++)
      kb(r.deps[e], r);
    r.deps.length = r._depsLength;
  }
}
function kb(r, e) {
  const t = r.get(e);
  t !== void 0 && e._trackId !== t && (r.delete(e), r.size === 0 && r.cleanup());
}
function TT(r, e) {
  r.effect instanceof Cn && (r = r.effect.fn);
  const t = new Cn(r, Ge, () => {
    t.dirty && t.run();
  });
  e && (Be(t, e), e.scope && Ob(t, e.scope)), (!e || !e.lazy) && t.run();
  const s = t.run.bind(t);
  return s.effect = t, s;
}
function PT(r) {
  r.effect.stop();
}
let Qs = !0, op = 0;
const Db = [];
function Os() {
  Db.push(Qs), Qs = !1;
}
function Is() {
  const r = Db.pop();
  Qs = r === void 0 ? !0 : r;
}
function od() {
  op++;
}
function ud() {
  for (op--; !op && up.length; )
    up.shift()();
}
function Lb(r, e, t) {
  var s;
  if (e.get(r) !== r._trackId) {
    e.set(r, r._trackId);
    const i = r.deps[r._depsLength];
    i !== e ? (i && kb(i, r), r.deps[r._depsLength++] = e) : r._depsLength++, process.env.NODE_ENV !== "production" && ((s = r.onTrack) == null || s.call(r, Be({ effect: r }, t)));
  }
}
const up = [];
function Mb(r, e, t) {
  var s;
  od();
  for (const i of r.keys()) {
    let n;
    i._dirtyLevel < e && (n ?? (n = r.get(i) === i._trackId)) && (i._shouldSchedule || (i._shouldSchedule = i._dirtyLevel === 0), i._dirtyLevel = e), i._shouldSchedule && (n ?? (n = r.get(i) === i._trackId)) && (process.env.NODE_ENV !== "production" && ((s = i.onTrigger) == null || s.call(i, Be({ effect: i }, t))), i.trigger(), (!i._runnings || i.allowRecurse) && i._dirtyLevel !== 2 && (i._shouldSchedule = !1, i.scheduler && up.push(i.scheduler)));
  }
  ud();
}
const Rb = (r, e) => {
  const t = /* @__PURE__ */ new Map();
  return t.cleanup = r, t.computed = e, t;
}, el = /* @__PURE__ */ new WeakMap(), Oi = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : ""), lp = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
function Ct(r, e, t) {
  if (Qs && Ni) {
    let s = el.get(r);
    s || el.set(r, s = /* @__PURE__ */ new Map());
    let i = s.get(t);
    i || s.set(t, i = Rb(() => s.delete(t))), Lb(
      Ni,
      i,
      process.env.NODE_ENV !== "production" ? {
        target: r,
        type: e,
        key: t
      } : void 0
    );
  }
}
function zr(r, e, t, s, i, n) {
  const a = el.get(r);
  if (!a)
    return;
  let o = [];
  if (e === "clear")
    o = [...a.values()];
  else if (t === "length" && se(r)) {
    const u = Number(s);
    a.forEach((l, c) => {
      (c === "length" || !Zr(c) && c >= u) && o.push(l);
    });
  } else
    switch (t !== void 0 && o.push(a.get(t)), e) {
      case "add":
        se(r) ? sd(t) && o.push(a.get("length")) : (o.push(a.get(Oi)), Ci(r) && o.push(a.get(lp)));
        break;
      case "delete":
        se(r) || (o.push(a.get(Oi)), Ci(r) && o.push(a.get(lp)));
        break;
      case "set":
        Ci(r) && o.push(a.get(Oi));
        break;
    }
  od();
  for (const u of o)
    u && Mb(
      u,
      4,
      process.env.NODE_ENV !== "production" ? {
        target: r,
        type: e,
        key: t,
        newValue: s,
        oldValue: i,
        oldTarget: n
      } : void 0
    );
  ud();
}
function AT(r, e) {
  const t = el.get(r);
  return t && t.get(e);
}
const CT = /* @__PURE__ */ zt("__proto__,__v_isRef,__isVue"), $b = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((r) => r !== "arguments" && r !== "caller").map((r) => Symbol[r]).filter(Zr)
), hg = /* @__PURE__ */ NT();
function NT() {
  const r = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    r[e] = function(...t) {
      const s = Ee(this);
      for (let n = 0, a = this.length; n < a; n++)
        Ct(s, "get", n + "");
      const i = s[e](...t);
      return i === -1 || i === !1 ? s[e](...t.map(Ee)) : i;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    r[e] = function(...t) {
      Os(), od();
      const s = Ee(this)[e].apply(this, t);
      return ud(), Is(), s;
    };
  }), r;
}
function OT(r) {
  Zr(r) || (r = String(r));
  const e = Ee(this);
  return Ct(e, "has", r), e.hasOwnProperty(r);
}
class Fb {
  constructor(e = !1, t = !1) {
    this._isReadonly = e, this._isShallow = t;
  }
  get(e, t, s) {
    const i = this._isReadonly, n = this._isShallow;
    if (t === "__v_isReactive")
      return !i;
    if (t === "__v_isReadonly")
      return i;
    if (t === "__v_isShallow")
      return n;
    if (t === "__v_raw")
      return s === (i ? n ? Wb : Hb : n ? qb : jb).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(s) ? e : void 0;
    const a = se(e);
    if (!i) {
      if (a && Pe(hg, t))
        return Reflect.get(hg, t, s);
      if (t === "hasOwnProperty")
        return OT;
    }
    const o = Reflect.get(e, t, s);
    return (Zr(t) ? $b.has(t) : CT(t)) || (i || Ct(e, "get", t), n) ? o : pt(o) ? a && sd(t) ? o : o.value : Ae(o) ? i ? cd(o) : rc(o) : o;
  }
}
class Bb extends Fb {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, t, s, i) {
    let n = e[t];
    if (!this._isShallow) {
      const u = rs(n);
      if (!Gr(s) && !rs(s) && (n = Ee(n), s = Ee(s)), !se(e) && pt(n) && !pt(s))
        return u ? !1 : (n.value = s, !0);
    }
    const a = se(e) && sd(t) ? Number(t) < e.length : Pe(e, t), o = Reflect.set(e, t, s, i);
    return e === Ee(i) && (a ? jt(s, n) && zr(e, "set", t, s, n) : zr(e, "add", t, s)), o;
  }
  deleteProperty(e, t) {
    const s = Pe(e, t), i = e[t], n = Reflect.deleteProperty(e, t);
    return n && s && zr(e, "delete", t, void 0, i), n;
  }
  has(e, t) {
    const s = Reflect.has(e, t);
    return (!Zr(t) || !$b.has(t)) && Ct(e, "has", t), s;
  }
  ownKeys(e) {
    return Ct(
      e,
      "iterate",
      se(e) ? "length" : Oi
    ), Reflect.ownKeys(e);
  }
}
class Vb extends Fb {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, t) {
    return process.env.NODE_ENV !== "production" && ts(
      `Set operation on key "${String(t)}" failed: target is readonly.`,
      e
    ), !0;
  }
  deleteProperty(e, t) {
    return process.env.NODE_ENV !== "production" && ts(
      `Delete operation on key "${String(t)}" failed: target is readonly.`,
      e
    ), !0;
  }
}
const IT = /* @__PURE__ */ new Bb(), kT = /* @__PURE__ */ new Vb(), DT = /* @__PURE__ */ new Bb(
  !0
), LT = /* @__PURE__ */ new Vb(!0), ld = (r) => r, ec = (r) => Reflect.getPrototypeOf(r);
function Jo(r, e, t = !1, s = !1) {
  r = r.__v_raw;
  const i = Ee(r), n = Ee(e);
  t || (jt(e, n) && Ct(i, "get", e), Ct(i, "get", n));
  const { has: a } = ec(i), o = s ? ld : t ? fd : Za;
  if (a.call(i, e))
    return o(r.get(e));
  if (a.call(i, n))
    return o(r.get(n));
  r !== i && r.get(e);
}
function Yo(r, e = !1) {
  const t = this.__v_raw, s = Ee(t), i = Ee(r);
  return e || (jt(r, i) && Ct(s, "has", r), Ct(s, "has", i)), r === i ? t.has(r) : t.has(r) || t.has(i);
}
function Qo(r, e = !1) {
  return r = r.__v_raw, !e && Ct(Ee(r), "iterate", Oi), Reflect.get(r, "size", r);
}
function dg(r, e = !1) {
  !e && !Gr(r) && !rs(r) && (r = Ee(r));
  const t = Ee(this);
  return ec(t).has.call(t, r) || (t.add(r), zr(t, "add", r, r)), this;
}
function mg(r, e, t = !1) {
  !t && !Gr(e) && !rs(e) && (e = Ee(e));
  const s = Ee(this), { has: i, get: n } = ec(s);
  let a = i.call(s, r);
  a ? process.env.NODE_ENV !== "production" && Ub(s, i, r) : (r = Ee(r), a = i.call(s, r));
  const o = n.call(s, r);
  return s.set(r, e), a ? jt(e, o) && zr(s, "set", r, e, o) : zr(s, "add", r, e), this;
}
function gg(r) {
  const e = Ee(this), { has: t, get: s } = ec(e);
  let i = t.call(e, r);
  i ? process.env.NODE_ENV !== "production" && Ub(e, t, r) : (r = Ee(r), i = t.call(e, r));
  const n = s ? s.call(e, r) : void 0, a = e.delete(r);
  return i && zr(e, "delete", r, void 0, n), a;
}
function yg() {
  const r = Ee(this), e = r.size !== 0, t = process.env.NODE_ENV !== "production" ? Ci(r) ? new Map(r) : new Set(r) : void 0, s = r.clear();
  return e && zr(r, "clear", void 0, void 0, t), s;
}
function Zo(r, e) {
  return function(s, i) {
    const n = this, a = n.__v_raw, o = Ee(a), u = e ? ld : r ? fd : Za;
    return !r && Ct(o, "iterate", Oi), a.forEach((l, c) => s.call(i, u(l), u(c), n));
  };
}
function eu(r, e, t) {
  return function(...s) {
    const i = this.__v_raw, n = Ee(i), a = Ci(n), o = r === "entries" || r === Symbol.iterator && a, u = r === "keys" && a, l = i[r](...s), c = t ? ld : e ? fd : Za;
    return !e && Ct(
      n,
      "iterate",
      u ? lp : Oi
    ), {
      // iterator protocol
      next() {
        const { value: f, done: p } = l.next();
        return p ? { value: f, done: p } : {
          value: o ? [c(f[0]), c(f[1])] : c(f),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Ls(r) {
  return function(...e) {
    if (process.env.NODE_ENV !== "production") {
      const t = e[0] ? `on key "${e[0]}" ` : "";
      ts(
        `${ii(r)} operation ${t}failed: target is readonly.`,
        Ee(this)
      );
    }
    return r === "delete" ? !1 : r === "clear" ? void 0 : this;
  };
}
function MT() {
  const r = {
    get(n) {
      return Jo(this, n);
    },
    get size() {
      return Qo(this);
    },
    has: Yo,
    add: dg,
    set: mg,
    delete: gg,
    clear: yg,
    forEach: Zo(!1, !1)
  }, e = {
    get(n) {
      return Jo(this, n, !1, !0);
    },
    get size() {
      return Qo(this);
    },
    has: Yo,
    add(n) {
      return dg.call(this, n, !0);
    },
    set(n, a) {
      return mg.call(this, n, a, !0);
    },
    delete: gg,
    clear: yg,
    forEach: Zo(!1, !0)
  }, t = {
    get(n) {
      return Jo(this, n, !0);
    },
    get size() {
      return Qo(this, !0);
    },
    has(n) {
      return Yo.call(this, n, !0);
    },
    add: Ls("add"),
    set: Ls("set"),
    delete: Ls("delete"),
    clear: Ls("clear"),
    forEach: Zo(!0, !1)
  }, s = {
    get(n) {
      return Jo(this, n, !0, !0);
    },
    get size() {
      return Qo(this, !0);
    },
    has(n) {
      return Yo.call(this, n, !0);
    },
    add: Ls("add"),
    set: Ls("set"),
    delete: Ls("delete"),
    clear: Ls("clear"),
    forEach: Zo(!0, !0)
  };
  return [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((n) => {
    r[n] = eu(n, !1, !1), t[n] = eu(n, !0, !1), e[n] = eu(n, !1, !0), s[n] = eu(
      n,
      !0,
      !0
    );
  }), [
    r,
    t,
    e,
    s
  ];
}
const [
  RT,
  $T,
  FT,
  BT
] = /* @__PURE__ */ MT();
function tc(r, e) {
  const t = e ? r ? BT : FT : r ? $T : RT;
  return (s, i, n) => i === "__v_isReactive" ? !r : i === "__v_isReadonly" ? r : i === "__v_raw" ? s : Reflect.get(
    Pe(t, i) && i in s ? t : s,
    i,
    n
  );
}
const VT = {
  get: /* @__PURE__ */ tc(!1, !1)
}, UT = {
  get: /* @__PURE__ */ tc(!1, !0)
}, jT = {
  get: /* @__PURE__ */ tc(!0, !1)
}, qT = {
  get: /* @__PURE__ */ tc(!0, !0)
};
function Ub(r, e, t) {
  const s = Ee(t);
  if (s !== t && e.call(r, s)) {
    const i = rd(r);
    ts(
      `Reactive ${i} contains both the raw and reactive versions of the same object${i === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const jb = /* @__PURE__ */ new WeakMap(), qb = /* @__PURE__ */ new WeakMap(), Hb = /* @__PURE__ */ new WeakMap(), Wb = /* @__PURE__ */ new WeakMap();
function HT(r) {
  switch (r) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function WT(r) {
  return r.__v_skip || !Object.isExtensible(r) ? 0 : HT(rd(r));
}
function rc(r) {
  return rs(r) ? r : sc(
    r,
    !1,
    IT,
    VT,
    jb
  );
}
function zb(r) {
  return sc(
    r,
    !1,
    DT,
    UT,
    qb
  );
}
function cd(r) {
  return sc(
    r,
    !0,
    kT,
    jT,
    Hb
  );
}
function Ar(r) {
  return sc(
    r,
    !0,
    LT,
    qT,
    Wb
  );
}
function sc(r, e, t, s, i) {
  if (!Ae(r))
    return process.env.NODE_ENV !== "production" && ts(
      `value cannot be made ${e ? "readonly" : "reactive"}: ${String(
        r
      )}`
    ), r;
  if (r.__v_raw && !(e && r.__v_isReactive))
    return r;
  const n = i.get(r);
  if (n)
    return n;
  const a = WT(r);
  if (a === 0)
    return r;
  const o = new Proxy(
    r,
    a === 2 ? s : t
  );
  return i.set(r, o), o;
}
function Zs(r) {
  return rs(r) ? Zs(r.__v_raw) : !!(r && r.__v_isReactive);
}
function rs(r) {
  return !!(r && r.__v_isReadonly);
}
function Gr(r) {
  return !!(r && r.__v_isShallow);
}
function Qa(r) {
  return r ? !!r.__v_raw : !1;
}
function Ee(r) {
  const e = r && r.__v_raw;
  return e ? Ee(e) : r;
}
function Gb(r) {
  return Object.isExtensible(r) && An(r, "__v_skip", !0), r;
}
const Za = (r) => Ae(r) ? rc(r) : r, fd = (r) => Ae(r) ? cd(r) : r, zT = "Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free";
class Kb {
  constructor(e, t, s, i) {
    this.getter = e, this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new Cn(
      () => e(this._value),
      () => bn(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    ), this.effect.computed = this, this.effect.active = this._cacheable = !i, this.__v_isReadonly = s;
  }
  get value() {
    const e = Ee(this);
    return (!e._cacheable || e.effect.dirty) && jt(e._value, e._value = e.effect.run()) && bn(e, 4), pd(e), e.effect._dirtyLevel >= 2 && (process.env.NODE_ENV !== "production" && this._warnRecursive && ts(zT, `

getter: `, this.getter), bn(e, 2)), e._value;
  }
  set value(e) {
    this._setter(e);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(e) {
    this.effect.dirty = e;
  }
  // #endregion
}
function GT(r, e, t = !1) {
  let s, i;
  const n = fe(r);
  n ? (s = r, i = process.env.NODE_ENV !== "production" ? () => {
    ts("Write operation failed: computed value is readonly");
  } : Ge) : (s = r.get, i = r.set);
  const a = new Kb(s, i, n || !i, t);
  return process.env.NODE_ENV !== "production" && e && !t && (a.effect.onTrack = e.onTrack, a.effect.onTrigger = e.onTrigger), a;
}
function pd(r) {
  var e;
  Qs && Ni && (r = Ee(r), Lb(
    Ni,
    (e = r.dep) != null ? e : r.dep = Rb(
      () => r.dep = void 0,
      r instanceof Kb ? r : void 0
    ),
    process.env.NODE_ENV !== "production" ? {
      target: r,
      type: "get",
      key: "value"
    } : void 0
  ));
}
function bn(r, e = 4, t, s) {
  r = Ee(r);
  const i = r.dep;
  i && Mb(
    i,
    e,
    process.env.NODE_ENV !== "production" ? {
      target: r,
      type: "set",
      key: "value",
      newValue: t,
      oldValue: s
    } : void 0
  );
}
function pt(r) {
  return !!(r && r.__v_isRef === !0);
}
function Ii(r) {
  return Xb(r, !1);
}
function KT(r) {
  return Xb(r, !0);
}
function Xb(r, e) {
  return pt(r) ? r : new XT(r, e);
}
class XT {
  constructor(e, t) {
    this.__v_isShallow = t, this.dep = void 0, this.__v_isRef = !0, this._rawValue = t ? e : Ee(e), this._value = t ? e : Za(e);
  }
  get value() {
    return pd(this), this._value;
  }
  set value(e) {
    const t = this.__v_isShallow || Gr(e) || rs(e);
    if (e = t ? e : Ee(e), jt(e, this._rawValue)) {
      const s = this._rawValue;
      this._rawValue = e, this._value = t ? e : Za(e), bn(this, 4, e, s);
    }
  }
}
function JT(r) {
  bn(r, 4, process.env.NODE_ENV !== "production" ? r.value : void 0);
}
function hd(r) {
  return pt(r) ? r.value : r;
}
function YT(r) {
  return fe(r) ? r() : hd(r);
}
const QT = {
  get: (r, e, t) => hd(Reflect.get(r, e, t)),
  set: (r, e, t, s) => {
    const i = r[e];
    return pt(i) && !pt(t) ? (i.value = t, !0) : Reflect.set(r, e, t, s);
  }
};
function dd(r) {
  return Zs(r) ? r : new Proxy(r, QT);
}
class ZT {
  constructor(e) {
    this.dep = void 0, this.__v_isRef = !0;
    const { get: t, set: s } = e(
      () => pd(this),
      () => bn(this)
    );
    this._get = t, this._set = s;
  }
  get value() {
    return this._get();
  }
  set value(e) {
    this._set(e);
  }
}
function Jb(r) {
  return new ZT(r);
}
function eP(r) {
  process.env.NODE_ENV !== "production" && !Qa(r) && ts("toRefs() expects a reactive object but received a plain one.");
  const e = se(r) ? new Array(r.length) : {};
  for (const t in r)
    e[t] = Yb(r, t);
  return e;
}
class tP {
  constructor(e, t, s) {
    this._object = e, this._key = t, this._defaultValue = s, this.__v_isRef = !0;
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return AT(Ee(this._object), this._key);
  }
}
class rP {
  constructor(e) {
    this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0;
  }
  get value() {
    return this._getter();
  }
}
function sP(r, e, t) {
  return pt(r) ? r : fe(r) ? new rP(r) : Ae(r) && arguments.length > 1 ? Yb(r, e, t) : Ii(r);
}
function Yb(r, e, t) {
  const s = r[e];
  return pt(s) ? s : new tP(r, e, t);
}
const iP = {
  GET: "get",
  HAS: "has",
  ITERATE: "iterate"
}, nP = {
  SET: "set",
  ADD: "add",
  DELETE: "delete",
  CLEAR: "clear"
};
/**
* @vue/runtime-core v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const ki = [];
function Da(r) {
  ki.push(r);
}
function La() {
  ki.pop();
}
let vf = !1;
function j(r, ...e) {
  if (vf) return;
  vf = !0, Os();
  const t = ki.length ? ki[ki.length - 1].component : null, s = t && t.appContext.config.warnHandler, i = aP();
  if (s)
    Kr(
      s,
      t,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        r + e.map((n) => {
          var a, o;
          return (o = (a = n.toString) == null ? void 0 : a.call(n)) != null ? o : JSON.stringify(n);
        }).join(""),
        t && t.proxy,
        i.map(
          ({ vnode: n }) => `at <${mc(t, n.type)}>`
        ).join(`
`),
        i
      ]
    );
  else {
    const n = [`[Vue warn]: ${r}`, ...e];
    i.length && n.push(`
`, ...oP(i)), console.warn(...n);
  }
  Is(), vf = !1;
}
function aP() {
  let r = ki[ki.length - 1];
  if (!r)
    return [];
  const e = [];
  for (; r; ) {
    const t = e[0];
    t && t.vnode === r ? t.recurseCount++ : e.push({
      vnode: r,
      recurseCount: 0
    });
    const s = r.component && r.component.parent;
    r = s && s.vnode;
  }
  return e;
}
function oP(r) {
  const e = [];
  return r.forEach((t, s) => {
    e.push(...s === 0 ? [] : [`
`], ...uP(t));
  }), e;
}
function uP({ vnode: r, recurseCount: e }) {
  const t = e > 0 ? `... (${e} recursive calls)` : "", s = r.component ? r.component.parent == null : !1, i = ` at <${mc(
    r.component,
    r.type,
    s
  )}`, n = ">" + t;
  return r.props ? [i, ...lP(r.props), n] : [i + n];
}
function lP(r) {
  const e = [], t = Object.keys(r);
  return t.slice(0, 3).forEach((s) => {
    e.push(...Qb(s, r[s]));
  }), t.length > 3 && e.push(" ..."), e;
}
function Qb(r, e, t) {
  return _e(e) ? (e = JSON.stringify(e), t ? e : [`${r}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? t ? e : [`${r}=${e}`] : pt(e) ? (e = Qb(r, Ee(e.value), !0), t ? e : [`${r}=Ref<`, e, ">"]) : fe(e) ? [`${r}=fn${e.name ? `<${e.name}>` : ""}`] : (e = Ee(e), t ? e : [`${r}=`, e]);
}
function md(r, e) {
  process.env.NODE_ENV !== "production" && r !== void 0 && (typeof r != "number" ? j(`${e} is not a valid number - got ${JSON.stringify(r)}.`) : isNaN(r) && j(`${e} is NaN - the duration expression might be incorrect.`));
}
const cP = {
  SETUP_FUNCTION: 0,
  0: "SETUP_FUNCTION",
  RENDER_FUNCTION: 1,
  1: "RENDER_FUNCTION",
  WATCH_GETTER: 2,
  2: "WATCH_GETTER",
  WATCH_CALLBACK: 3,
  3: "WATCH_CALLBACK",
  WATCH_CLEANUP: 4,
  4: "WATCH_CLEANUP",
  NATIVE_EVENT_HANDLER: 5,
  5: "NATIVE_EVENT_HANDLER",
  COMPONENT_EVENT_HANDLER: 6,
  6: "COMPONENT_EVENT_HANDLER",
  VNODE_HOOK: 7,
  7: "VNODE_HOOK",
  DIRECTIVE_HOOK: 8,
  8: "DIRECTIVE_HOOK",
  TRANSITION_HOOK: 9,
  9: "TRANSITION_HOOK",
  APP_ERROR_HANDLER: 10,
  10: "APP_ERROR_HANDLER",
  APP_WARN_HANDLER: 11,
  11: "APP_WARN_HANDLER",
  FUNCTION_REF: 12,
  12: "FUNCTION_REF",
  ASYNC_COMPONENT_LOADER: 13,
  13: "ASYNC_COMPONENT_LOADER",
  SCHEDULER: 14,
  14: "SCHEDULER",
  COMPONENT_UPDATE: 15,
  15: "COMPONENT_UPDATE"
}, ic = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update"
};
function Kr(r, e, t, s) {
  try {
    return s ? r(...s) : r();
  } catch (i) {
    ci(i, e, t);
  }
}
function ar(r, e, t, s) {
  if (fe(r)) {
    const i = Kr(r, e, t, s);
    return i && es(i) && i.catch((n) => {
      ci(n, e, t);
    }), i;
  }
  if (se(r)) {
    const i = [];
    for (let n = 0; n < r.length; n++)
      i.push(ar(r[n], e, t, s));
    return i;
  } else process.env.NODE_ENV !== "production" && j(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof r}`
  );
}
function ci(r, e, t, s = !0) {
  const i = e ? e.vnode : null;
  if (e) {
    let n = e.parent;
    const a = e.proxy, o = process.env.NODE_ENV !== "production" ? ic[t] : `https://vuejs.org/error-reference/#runtime-${t}`;
    for (; n; ) {
      const l = n.ec;
      if (l) {
        for (let c = 0; c < l.length; c++)
          if (l[c](r, a, o) === !1)
            return;
      }
      n = n.parent;
    }
    const u = e.appContext.config.errorHandler;
    if (u) {
      Os(), Kr(
        u,
        null,
        10,
        [r, a, o]
      ), Is();
      return;
    }
  }
  fP(r, t, i, s);
}
function fP(r, e, t, s = !0) {
  if (process.env.NODE_ENV !== "production") {
    const i = ic[e];
    if (t && Da(t), j(`Unhandled error${i ? ` during execution of ${i}` : ""}`), t && La(), s)
      throw r;
    console.error(r);
  } else
    console.error(r);
}
let eo = !1, cp = !1;
const Dt = [];
let Fr = 0;
const vn = [];
let qs = null, xi = 0;
const Zb = /* @__PURE__ */ Promise.resolve();
let gd = null;
const pP = 100;
function nc(r) {
  const e = gd || Zb;
  return r ? e.then(this ? r.bind(this) : r) : e;
}
function hP(r) {
  let e = Fr + 1, t = Dt.length;
  for (; e < t; ) {
    const s = e + t >>> 1, i = Dt[s], n = ro(i);
    n < r || n === r && i.pre ? e = s + 1 : t = s;
  }
  return e;
}
function No(r) {
  (!Dt.length || !Dt.includes(
    r,
    eo && r.allowRecurse ? Fr + 1 : Fr
  )) && (r.id == null ? Dt.push(r) : Dt.splice(hP(r.id), 0, r), ev());
}
function ev() {
  !eo && !cp && (cp = !0, gd = Zb.then(tv));
}
function dP(r) {
  const e = Dt.indexOf(r);
  e > Fr && Dt.splice(e, 1);
}
function to(r) {
  se(r) ? vn.push(...r) : (!qs || !qs.includes(
    r,
    r.allowRecurse ? xi + 1 : xi
  )) && vn.push(r), ev();
}
function bg(r, e, t = eo ? Fr + 1 : 0) {
  for (process.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()); t < Dt.length; t++) {
    const s = Dt[t];
    if (s && s.pre) {
      if (r && s.id !== r.uid || process.env.NODE_ENV !== "production" && yd(e, s))
        continue;
      Dt.splice(t, 1), t--, s();
    }
  }
}
function tl(r) {
  if (vn.length) {
    const e = [...new Set(vn)].sort(
      (t, s) => ro(t) - ro(s)
    );
    if (vn.length = 0, qs) {
      qs.push(...e);
      return;
    }
    for (qs = e, process.env.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()), xi = 0; xi < qs.length; xi++) {
      const t = qs[xi];
      process.env.NODE_ENV !== "production" && yd(r, t) || t.active !== !1 && t();
    }
    qs = null, xi = 0;
  }
}
const ro = (r) => r.id == null ? 1 / 0 : r.id, mP = (r, e) => {
  const t = ro(r) - ro(e);
  if (t === 0) {
    if (r.pre && !e.pre) return -1;
    if (e.pre && !r.pre) return 1;
  }
  return t;
};
function tv(r) {
  cp = !1, eo = !0, process.env.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()), Dt.sort(mP);
  const e = process.env.NODE_ENV !== "production" ? (t) => yd(r, t) : Ge;
  try {
    for (Fr = 0; Fr < Dt.length; Fr++) {
      const t = Dt[Fr];
      if (t && t.active !== !1) {
        if (process.env.NODE_ENV !== "production" && e(t))
          continue;
        Kr(
          t,
          t.i,
          t.i ? 15 : 14
        );
      }
    }
  } finally {
    Fr = 0, Dt.length = 0, tl(r), eo = !1, gd = null, (Dt.length || vn.length) && tv(r);
  }
}
function yd(r, e) {
  if (!r.has(e))
    r.set(e, 1);
  else {
    const t = r.get(e);
    if (t > pP) {
      const s = e.i, i = s && ao(s.type);
      return ci(
        `Maximum recursive updates exceeded${i ? ` in component <${i}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      ), !0;
    } else
      r.set(e, t + 1);
  }
}
let ei = !1;
const Cu = /* @__PURE__ */ new Map();
process.env.NODE_ENV !== "production" && (Zl().__VUE_HMR_RUNTIME__ = {
  createRecord: Ef(rv),
  rerender: Ef(bP),
  reload: Ef(vP)
});
const Hi = /* @__PURE__ */ new Map();
function gP(r) {
  const e = r.type.__hmrId;
  let t = Hi.get(e);
  t || (rv(e, r.type), t = Hi.get(e)), t.instances.add(r);
}
function yP(r) {
  Hi.get(r.type.__hmrId).instances.delete(r);
}
function rv(r, e) {
  return Hi.has(r) ? !1 : (Hi.set(r, {
    initialDef: rl(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function rl(r) {
  return nE(r) ? r.__vccOpts : r;
}
function bP(r, e) {
  const t = Hi.get(r);
  t && (t.initialDef.render = e, [...t.instances].forEach((s) => {
    e && (s.render = e, rl(s.type).render = e), s.renderCache = [], ei = !0, s.effect.dirty = !0, s.update(), ei = !1;
  }));
}
function vP(r, e) {
  const t = Hi.get(r);
  if (!t) return;
  e = rl(e), vg(t.initialDef, e);
  const s = [...t.instances];
  for (let i = 0; i < s.length; i++) {
    const n = s[i], a = rl(n.type);
    let o = Cu.get(a);
    o || (a !== t.initialDef && vg(a, e), Cu.set(a, o = /* @__PURE__ */ new Set())), o.add(n), n.appContext.propsCache.delete(n.type), n.appContext.emitsCache.delete(n.type), n.appContext.optionsCache.delete(n.type), n.ceReload ? (o.add(n), n.ceReload(e.styles), o.delete(n)) : n.parent ? (n.parent.effect.dirty = !0, No(() => {
      n.parent.update(), o.delete(n);
    })) : n.appContext.reload ? n.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    );
  }
  to(() => {
    Cu.clear();
  });
}
function vg(r, e) {
  Be(r, e);
  for (const t in r)
    t !== "__file" && !(t in e) && delete r[t];
}
function Ef(r) {
  return (e, t) => {
    try {
      return r(e, t);
    } catch (s) {
      console.error(s), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let Tr, Aa = [], fp = !1;
function Oo(r, ...e) {
  Tr ? Tr.emit(r, ...e) : fp || Aa.push({ event: r, args: e });
}
function bd(r, e) {
  var t, s;
  Tr = r, Tr ? (Tr.enabled = !0, Aa.forEach(({ event: i, args: n }) => Tr.emit(i, ...n)), Aa = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((s = (t = window.navigator) == null ? void 0 : t.userAgent) != null && s.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((n) => {
    bd(n, e);
  }), setTimeout(() => {
    Tr || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, fp = !0, Aa = []);
  }, 3e3)) : (fp = !0, Aa = []);
}
function EP(r, e) {
  Oo("app:init", r, e, {
    Fragment: ct,
    Text: Xr,
    Comment: Je,
    Static: Es
  });
}
function SP(r) {
  Oo("app:unmount", r);
}
const pp = /* @__PURE__ */ vd(
  "component:added"
  /* COMPONENT_ADDED */
), sv = /* @__PURE__ */ vd(
  "component:updated"
  /* COMPONENT_UPDATED */
), _P = /* @__PURE__ */ vd(
  "component:removed"
  /* COMPONENT_REMOVED */
), xP = (r) => {
  Tr && typeof Tr.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !Tr.cleanupBuffer(r) && _P(r);
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function vd(r) {
  return (e) => {
    Oo(
      r,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
const wP = /* @__PURE__ */ iv(
  "perf:start"
  /* PERFORMANCE_START */
), TP = /* @__PURE__ */ iv(
  "perf:end"
  /* PERFORMANCE_END */
);
function iv(r) {
  return (e, t, s) => {
    Oo(r, e.appContext.app, e.uid, e, t, s);
  };
}
function PP(r, e, t) {
  Oo(
    "component:emit",
    r.appContext.app,
    r,
    e,
    t
  );
}
let st = null, ac = null;
function so(r) {
  const e = st;
  return st = r, ac = r && r.type.__scopeId || null, e;
}
function AP(r) {
  ac = r;
}
function CP() {
  ac = null;
}
const NP = (r) => Ed;
function Ed(r, e = st, t) {
  if (!e || r._n)
    return r;
  const s = (...i) => {
    s._d && _p(-1);
    const n = so(e);
    let a;
    try {
      a = r(...i);
    } finally {
      so(n), s._d && _p(1);
    }
    return process.env.NODE_ENV !== "production" && sv(e), a;
  };
  return s._n = !0, s._c = !0, s._d = !0, s;
}
function nv(r) {
  Xw(r) && j("Do not use built-in directive ids as custom directive id: " + r);
}
function OP(r, e) {
  if (st === null)
    return process.env.NODE_ENV !== "production" && j("withDirectives can only be used inside render functions."), r;
  const t = Mo(st), s = r.dirs || (r.dirs = []);
  for (let i = 0; i < e.length; i++) {
    let [n, a, o, u = Oe] = e[i];
    n && (fe(n) && (n = {
      mounted: n,
      updated: n
    }), n.deep && Xs(a), s.push({
      dir: n,
      instance: t,
      value: a,
      oldValue: void 0,
      arg: o,
      modifiers: u
    }));
  }
  return r;
}
function Mr(r, e, t, s) {
  const i = r.dirs, n = e && e.dirs;
  for (let a = 0; a < i.length; a++) {
    const o = i[a];
    n && (o.oldValue = n[a].value);
    let u = o.dir[s];
    u && (Os(), ar(u, t, 8, [
      r.el,
      o,
      r,
      e
    ]), Is());
  }
}
const Hs = Symbol("_leaveCb"), tu = Symbol("_enterCb");
function Sd() {
  const r = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return Io(() => {
    r.isMounted = !0;
  }), cc(() => {
    r.isUnmounting = !0;
  }), r;
}
const pr = [Function, Array], _d = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: pr,
  onEnter: pr,
  onAfterEnter: pr,
  onEnterCancelled: pr,
  // leave
  onBeforeLeave: pr,
  onLeave: pr,
  onAfterLeave: pr,
  onLeaveCancelled: pr,
  // appear
  onBeforeAppear: pr,
  onAppear: pr,
  onAfterAppear: pr,
  onAppearCancelled: pr
}, av = (r) => {
  const e = r.subTree;
  return e.component ? av(e.component) : e;
}, IP = {
  name: "BaseTransition",
  props: _d,
  setup(r, { slots: e }) {
    const t = is(), s = Sd();
    return () => {
      const i = e.default && oc(e.default(), !0);
      if (!i || !i.length)
        return;
      let n = i[0];
      if (i.length > 1) {
        let p = !1;
        for (const h of i)
          if (h.type !== Je) {
            if (process.env.NODE_ENV !== "production" && p) {
              j(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            if (n = h, p = !0, process.env.NODE_ENV === "production") break;
          }
      }
      const a = Ee(r), { mode: o } = a;
      if (process.env.NODE_ENV !== "production" && o && o !== "in-out" && o !== "out-in" && o !== "default" && j(`invalid <transition> mode: ${o}`), s.isLeaving)
        return Sf(n);
      const u = Eg(n);
      if (!u)
        return Sf(n);
      let l = Nn(
        u,
        a,
        s,
        t,
        // #11061, ensure enterHooks is fresh after clone
        (p) => l = p
      );
      ni(u, l);
      const c = t.subTree, f = c && Eg(c);
      if (f && f.type !== Je && !Pr(u, f) && av(t).type !== Je) {
        const p = Nn(
          f,
          a,
          s,
          t
        );
        if (ni(f, p), o === "out-in" && u.type !== Je)
          return s.isLeaving = !0, p.afterLeave = () => {
            s.isLeaving = !1, t.update.active !== !1 && (t.effect.dirty = !0, t.update());
          }, Sf(n);
        o === "in-out" && u.type !== Je && (p.delayLeave = (h, m, d) => {
          const y = uv(
            s,
            f
          );
          y[String(f.key)] = f, h[Hs] = () => {
            m(), h[Hs] = void 0, delete l.delayedLeave;
          }, l.delayedLeave = d;
        });
      }
      return n;
    };
  }
}, ov = IP;
function uv(r, e) {
  const { leavingVNodes: t } = r;
  let s = t.get(e.type);
  return s || (s = /* @__PURE__ */ Object.create(null), t.set(e.type, s)), s;
}
function Nn(r, e, t, s, i) {
  const {
    appear: n,
    mode: a,
    persisted: o = !1,
    onBeforeEnter: u,
    onEnter: l,
    onAfterEnter: c,
    onEnterCancelled: f,
    onBeforeLeave: p,
    onLeave: h,
    onAfterLeave: m,
    onLeaveCancelled: d,
    onBeforeAppear: y,
    onAppear: S,
    onAfterAppear: E,
    onAppearCancelled: g
  } = e, b = String(r.key), v = uv(t, r), A = (_, T) => {
    _ && ar(
      _,
      s,
      9,
      T
    );
  }, C = (_, T) => {
    const P = T[1];
    A(_, T), se(_) ? _.every((I) => I.length <= 1) && P() : _.length <= 1 && P();
  }, x = {
    mode: a,
    persisted: o,
    beforeEnter(_) {
      let T = u;
      if (!t.isMounted)
        if (n)
          T = y || u;
        else
          return;
      _[Hs] && _[Hs](
        !0
        /* cancelled */
      );
      const P = v[b];
      P && Pr(r, P) && P.el[Hs] && P.el[Hs](), A(T, [_]);
    },
    enter(_) {
      let T = l, P = c, I = f;
      if (!t.isMounted)
        if (n)
          T = S || l, P = E || c, I = g || f;
        else
          return;
      let $ = !1;
      const Y = _[tu] = (W) => {
        $ || ($ = !0, W ? A(I, [_]) : A(P, [_]), x.delayedLeave && x.delayedLeave(), _[tu] = void 0);
      };
      T ? C(T, [_, Y]) : Y();
    },
    leave(_, T) {
      const P = String(r.key);
      if (_[tu] && _[tu](
        !0
        /* cancelled */
      ), t.isUnmounting)
        return T();
      A(p, [_]);
      let I = !1;
      const $ = _[Hs] = (Y) => {
        I || (I = !0, T(), Y ? A(d, [_]) : A(m, [_]), _[Hs] = void 0, v[P] === r && delete v[P]);
      };
      v[P] = r, h ? C(h, [_, $]) : $();
    },
    clone(_) {
      const T = Nn(
        _,
        e,
        t,
        s,
        i
      );
      return i && i(T), T;
    }
  };
  return x;
}
function Sf(r) {
  if (Gn(r))
    return r = yr(r), r.children = null, r;
}
function Eg(r) {
  if (!Gn(r))
    return r;
  if (process.env.NODE_ENV !== "production" && r.component)
    return r.component.subTree;
  const { shapeFlag: e, children: t } = r;
  if (t) {
    if (e & 16)
      return t[0];
    if (e & 32 && fe(t.default))
      return t.default();
  }
}
function ni(r, e) {
  r.shapeFlag & 6 && r.component ? ni(r.component.subTree, e) : r.shapeFlag & 128 ? (r.ssContent.transition = e.clone(r.ssContent), r.ssFallback.transition = e.clone(r.ssFallback)) : r.transition = e;
}
function oc(r, e = !1, t) {
  let s = [], i = 0;
  for (let n = 0; n < r.length; n++) {
    let a = r[n];
    const o = t == null ? a.key : String(t) + String(a.key != null ? a.key : n);
    a.type === ct ? (a.patchFlag & 128 && i++, s = s.concat(
      oc(a.children, e, o)
    )) : (e || a.type !== Je) && s.push(o != null ? yr(a, { key: o }) : a);
  }
  if (i > 1)
    for (let n = 0; n < s.length; n++)
      s[n].patchFlag = -2;
  return s;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function xd(r, e) {
  return fe(r) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Be({ name: r.name }, e, { setup: r })
  ) : r;
}
const Di = (r) => !!r.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function kP(r) {
  fe(r) && (r = { loader: r });
  const {
    loader: e,
    loadingComponent: t,
    errorComponent: s,
    delay: i = 200,
    timeout: n,
    // undefined = never times out
    suspensible: a = !0,
    onError: o
  } = r;
  let u = null, l, c = 0;
  const f = () => (c++, u = null, p()), p = () => {
    let h;
    return u || (h = u = e().catch((m) => {
      if (m = m instanceof Error ? m : new Error(String(m)), o)
        return new Promise((d, y) => {
          o(m, () => d(f()), () => y(m), c + 1);
        });
      throw m;
    }).then((m) => {
      if (h !== u && u)
        return u;
      if (process.env.NODE_ENV !== "production" && !m && j(
        "Async component loader resolved to undefined. If you are using retry(), make sure to return its return value."
      ), m && (m.__esModule || m[Symbol.toStringTag] === "Module") && (m = m.default), process.env.NODE_ENV !== "production" && m && !Ae(m) && !fe(m))
        throw new Error(`Invalid async component load result: ${m}`);
      return l = m, m;
    }));
  };
  return /* @__PURE__ */ xd({
    name: "AsyncComponentWrapper",
    __asyncLoader: p,
    get __asyncResolved() {
      return l;
    },
    setup() {
      const h = nt;
      if (l)
        return () => _f(l, h);
      const m = (E) => {
        u = null, ci(
          E,
          h,
          13,
          !s
        );
      };
      if (a && h.suspense || Lo)
        return p().then((E) => () => _f(E, h)).catch((E) => (m(E), () => s ? He(s, {
          error: E
        }) : null));
      const d = Ii(!1), y = Ii(), S = Ii(!!i);
      return i && setTimeout(() => {
        S.value = !1;
      }, i), n != null && setTimeout(() => {
        if (!d.value && !y.value) {
          const E = new Error(
            `Async component timed out after ${n}ms.`
          );
          m(E), y.value = E;
        }
      }, n), p().then(() => {
        d.value = !0, h.parent && Gn(h.parent.vnode) && (h.parent.effect.dirty = !0, No(h.parent.update));
      }).catch((E) => {
        m(E), y.value = E;
      }), () => {
        if (d.value && l)
          return _f(l, h);
        if (y.value && s)
          return He(s, {
            error: y.value
          });
        if (t && !S.value)
          return He(t);
      };
    }
  });
}
function _f(r, e) {
  const { ref: t, props: s, children: i, ce: n } = e.vnode, a = He(r, s, i);
  return a.ref = t, a.ce = n, delete e.vnode.ce, a;
}
const Gn = (r) => r.type.__isKeepAlive, DP = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: !0,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(r, { slots: e }) {
    const t = is(), s = t.ctx;
    if (!s.renderer)
      return () => {
        const E = e.default && e.default();
        return E && E.length === 1 ? E[0] : E;
      };
    const i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set();
    let a = null;
    process.env.NODE_ENV !== "production" && (t.__v_cache = i);
    const o = t.suspense, {
      renderer: {
        p: u,
        m: l,
        um: c,
        o: { createElement: f }
      }
    } = s, p = f("div");
    s.activate = (E, g, b, v, A) => {
      const C = E.component;
      l(E, g, b, 0, o), u(
        C.vnode,
        E,
        g,
        b,
        C,
        o,
        v,
        E.slotScopeIds,
        A
      ), mt(() => {
        C.isDeactivated = !1, C.a && Gs(C.a);
        const x = E.props && E.props.onVnodeMounted;
        x && Kt(x, C.parent, E);
      }, o), process.env.NODE_ENV !== "production" && pp(C);
    }, s.deactivate = (E) => {
      const g = E.component;
      ol(g.m), ol(g.a), l(E, p, null, 1, o), mt(() => {
        g.da && Gs(g.da);
        const b = E.props && E.props.onVnodeUnmounted;
        b && Kt(b, g.parent, E), g.isDeactivated = !0;
      }, o), process.env.NODE_ENV !== "production" && pp(g);
    };
    function h(E) {
      xf(E), c(E, t, o, !0);
    }
    function m(E) {
      i.forEach((g, b) => {
        const v = ao(g.type);
        v && (!E || !E(v)) && d(b);
      });
    }
    function d(E) {
      const g = i.get(E);
      g && (!a || !Pr(g, a)) ? h(g) : a && xf(a), i.delete(E), n.delete(E);
    }
    Fa(
      () => [r.include, r.exclude],
      ([E, g]) => {
        E && m((b) => Ca(E, b)), g && m((b) => !Ca(g, b));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: !0 }
    );
    let y = null;
    const S = () => {
      y != null && (Ep(t.subTree.type) ? mt(() => {
        i.set(y, ru(t.subTree));
      }, t.subTree.suspense) : i.set(y, ru(t.subTree)));
    };
    return Io(S), lc(S), cc(() => {
      i.forEach((E) => {
        const { subTree: g, suspense: b } = t, v = ru(g);
        if (E.type === v.type && E.key === v.key) {
          xf(v);
          const A = v.component.da;
          A && mt(A, b);
          return;
        }
        h(E);
      });
    }), () => {
      if (y = null, !e.default)
        return null;
      const E = e.default(), g = E[0];
      if (E.length > 1)
        return process.env.NODE_ENV !== "production" && j("KeepAlive should contain exactly one component child."), a = null, E;
      if (!ws(g) || !(g.shapeFlag & 4) && !(g.shapeFlag & 128))
        return a = null, g;
      let b = ru(g);
      if (b.type === Je)
        return a = null, b;
      const v = b.type, A = ao(
        Di(b) ? b.type.__asyncResolved || {} : v
      ), { include: C, exclude: x, max: _ } = r;
      if (C && (!A || !Ca(C, A)) || x && A && Ca(x, A))
        return a = b, g;
      const T = b.key == null ? v : b.key, P = i.get(T);
      return b.el && (b = yr(b), g.shapeFlag & 128 && (g.ssContent = b)), y = T, P ? (b.el = P.el, b.component = P.component, b.transition && ni(b, b.transition), b.shapeFlag |= 512, n.delete(T), n.add(T)) : (n.add(T), _ && n.size > parseInt(_, 10) && d(n.values().next().value)), b.shapeFlag |= 256, a = b, Ep(g.type) ? g : b;
    };
  }
}, LP = DP;
function Ca(r, e) {
  return se(r) ? r.some((t) => Ca(t, e)) : _e(r) ? r.split(",").includes(e) : Kw(r) ? r.test(e) : !1;
}
function lv(r, e) {
  fv(r, "a", e);
}
function cv(r, e) {
  fv(r, "da", e);
}
function fv(r, e, t = nt) {
  const s = r.__wdc || (r.__wdc = () => {
    let i = t;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return r();
  });
  if (uc(e, s, t), t) {
    let i = t.parent;
    for (; i && i.parent; )
      Gn(i.parent.vnode) && MP(s, e, t, i), i = i.parent;
  }
}
function MP(r, e, t, s) {
  const i = uc(
    e,
    r,
    s,
    !0
    /* prepend */
  );
  fc(() => {
    td(s[e], i);
  }, t);
}
function xf(r) {
  r.shapeFlag &= -257, r.shapeFlag &= -513;
}
function ru(r) {
  return r.shapeFlag & 128 ? r.ssContent : r;
}
function uc(r, e, t = nt, s = !1) {
  if (t) {
    const i = t[r] || (t[r] = []), n = e.__weh || (e.__weh = (...a) => {
      Os();
      const o = zi(t), u = ar(e, t, r, a);
      return o(), Is(), u;
    });
    return s ? i.unshift(n) : i.push(n), n;
  } else if (process.env.NODE_ENV !== "production") {
    const i = ps(ic[r].replace(/ hook$/, ""));
    j(
      `${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const ks = (r) => (e, t = nt) => {
  (!Lo || r === "sp") && uc(r, (...s) => e(...s), t);
}, wd = ks("bm"), Io = ks("m"), pv = ks("bu"), lc = ks("u"), cc = ks("bum"), fc = ks("um"), hv = ks("sp"), dv = ks(
  "rtg"
), mv = ks(
  "rtc"
);
function gv(r, e = nt) {
  uc("ec", r, e);
}
const sl = "components", RP = "directives";
function $P(r, e) {
  return Pd(sl, r, !0, e) || r;
}
const Td = Symbol.for("v-ndc");
function FP(r) {
  return _e(r) ? Pd(sl, r, !1) || r : r || Td;
}
function BP(r) {
  return Pd(RP, r);
}
function Pd(r, e, t = !0, s = !1) {
  const i = st || nt;
  if (i) {
    const n = i.type;
    if (r === sl) {
      const o = ao(
        n,
        !1
      );
      if (o && (o === e || o === Et(e) || o === ii(Et(e))))
        return n;
    }
    const a = (
      // local registration
      // check instance[type] first which is resolved for options API
      Sg(i[r] || n[r], e) || // global registration
      Sg(i.appContext[r], e)
    );
    if (!a && s)
      return n;
    if (process.env.NODE_ENV !== "production" && t && !a) {
      const o = r === sl ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      j(`Failed to resolve ${r.slice(0, -1)}: ${e}${o}`);
    }
    return a;
  } else process.env.NODE_ENV !== "production" && j(
    `resolve${ii(r.slice(0, -1))} can only be used in render() or setup().`
  );
}
function Sg(r, e) {
  return r && (r[e] || r[Et(e)] || r[ii(Et(e))]);
}
function VP(r, e, t, s) {
  let i;
  const n = t && t[s];
  if (se(r) || _e(r)) {
    i = new Array(r.length);
    for (let a = 0, o = r.length; a < o; a++)
      i[a] = e(r[a], a, void 0, n && n[a]);
  } else if (typeof r == "number") {
    process.env.NODE_ENV !== "production" && !Number.isInteger(r) && j(`The v-for range expect an integer value but got ${r}.`), i = new Array(r);
    for (let a = 0; a < r; a++)
      i[a] = e(a + 1, a, void 0, n && n[a]);
  } else if (Ae(r))
    if (r[Symbol.iterator])
      i = Array.from(
        r,
        (a, o) => e(a, o, void 0, n && n[o])
      );
    else {
      const a = Object.keys(r);
      i = new Array(a.length);
      for (let o = 0, u = a.length; o < u; o++) {
        const l = a[o];
        i[o] = e(r[l], l, o, n && n[o]);
      }
    }
  else
    i = [];
  return t && (t[s] = i), i;
}
function UP(r, e) {
  for (let t = 0; t < e.length; t++) {
    const s = e[t];
    if (se(s))
      for (let i = 0; i < s.length; i++)
        r[s[i].name] = s[i].fn;
    else s && (r[s.name] = s.key ? (...i) => {
      const n = s.fn(...i);
      return n && (n.key = s.key), n;
    } : s.fn);
  }
  return r;
}
function jP(r, e, t = {}, s, i) {
  if (st.isCE || st.parent && Di(st.parent) && st.parent.isCE)
    return e !== "default" && (t.name = e), He("slot", t, s && s());
  let n = r[e];
  process.env.NODE_ENV !== "production" && n && n.length > 1 && (j(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), n = () => []), n && n._c && (n._d = !1), dc();
  const a = n && Ad(n(t)), o = kd(
    ct,
    {
      key: (t.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      a && a.key || `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!a && s ? "_fb" : "")
    },
    a || (s ? s() : []),
    a && r._ === 1 ? 64 : -2
  );
  return !i && o.scopeId && (o.slotScopeIds = [o.scopeId + "-s"]), n && n._c && (n._d = !0), o;
}
function Ad(r) {
  return r.some((e) => ws(e) ? !(e.type === Je || e.type === ct && !Ad(e.children)) : !0) ? r : null;
}
function qP(r, e) {
  const t = {};
  if (process.env.NODE_ENV !== "production" && !Ae(r))
    return j("v-on with no argument expects an object value."), t;
  for (const s in r)
    t[e && /[A-Z]/.test(s) ? `on:${s}` : ps(s)] = r[s];
  return t;
}
const hp = (r) => r ? tE(r) ? Mo(r) : hp(r.parent) : null, Li = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Be(/* @__PURE__ */ Object.create(null), {
    $: (r) => r,
    $el: (r) => r.vnode.el,
    $data: (r) => r.data,
    $props: (r) => process.env.NODE_ENV !== "production" ? Ar(r.props) : r.props,
    $attrs: (r) => process.env.NODE_ENV !== "production" ? Ar(r.attrs) : r.attrs,
    $slots: (r) => process.env.NODE_ENV !== "production" ? Ar(r.slots) : r.slots,
    $refs: (r) => process.env.NODE_ENV !== "production" ? Ar(r.refs) : r.refs,
    $parent: (r) => hp(r.parent),
    $root: (r) => hp(r.root),
    $emit: (r) => r.emit,
    $options: (r) => Nd(r),
    $forceUpdate: (r) => r.f || (r.f = () => {
      r.effect.dirty = !0, No(r.update);
    }),
    $nextTick: (r) => r.n || (r.n = nc.bind(r.proxy)),
    $watch: (r) => j3.bind(r)
  })
), Cd = (r) => r === "_" || r === "$", wf = (r, e) => r !== Oe && !r.__isScriptSetup && Pe(r, e), Ma = {
  get({ _: r }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: t, setupState: s, data: i, props: n, accessCache: a, type: o, appContext: u } = r;
    if (process.env.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    let l;
    if (e[0] !== "$") {
      const h = a[e];
      if (h !== void 0)
        switch (h) {
          case 1:
            return s[e];
          case 2:
            return i[e];
          case 4:
            return t[e];
          case 3:
            return n[e];
        }
      else {
        if (wf(s, e))
          return a[e] = 1, s[e];
        if (i !== Oe && Pe(i, e))
          return a[e] = 2, i[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (l = r.propsOptions[0]) && Pe(l, e)
        )
          return a[e] = 3, n[e];
        if (t !== Oe && Pe(t, e))
          return a[e] = 4, t[e];
        dp && (a[e] = 0);
      }
    }
    const c = Li[e];
    let f, p;
    if (c)
      return e === "$attrs" ? (Ct(r.attrs, "get", ""), process.env.NODE_ENV !== "production" && ul()) : process.env.NODE_ENV !== "production" && e === "$slots" && Ct(r, "get", e), c(r);
    if (
      // css module (injected by vue-loader)
      (f = o.__cssModules) && (f = f[e])
    )
      return f;
    if (t !== Oe && Pe(t, e))
      return a[e] = 4, t[e];
    if (
      // global properties
      p = u.config.globalProperties, Pe(p, e)
    )
      return p[e];
    process.env.NODE_ENV !== "production" && st && (!_e(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (i !== Oe && Cd(e[0]) && Pe(i, e) ? j(
      `Property ${JSON.stringify(
        e
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : r === st && j(
      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: r }, e, t) {
    const { data: s, setupState: i, ctx: n } = r;
    return wf(i, e) ? (i[e] = t, !0) : process.env.NODE_ENV !== "production" && i.__isScriptSetup && Pe(i, e) ? (j(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : s !== Oe && Pe(s, e) ? (s[e] = t, !0) : Pe(r.props, e) ? (process.env.NODE_ENV !== "production" && j(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in r ? (process.env.NODE_ENV !== "production" && j(
      `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
    ), !1) : (process.env.NODE_ENV !== "production" && e in r.appContext.config.globalProperties ? Object.defineProperty(n, e, {
      enumerable: !0,
      configurable: !0,
      value: t
    }) : n[e] = t, !0);
  },
  has({
    _: { data: r, setupState: e, accessCache: t, ctx: s, appContext: i, propsOptions: n }
  }, a) {
    let o;
    return !!t[a] || r !== Oe && Pe(r, a) || wf(e, a) || (o = n[0]) && Pe(o, a) || Pe(s, a) || Pe(Li, a) || Pe(i.config.globalProperties, a);
  },
  defineProperty(r, e, t) {
    return t.get != null ? r._.accessCache[e] = 0 : Pe(t, "value") && this.set(r, e, t.value, null), Reflect.defineProperty(r, e, t);
  }
};
process.env.NODE_ENV !== "production" && (Ma.ownKeys = (r) => (j(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(r)));
const HP = /* @__PURE__ */ Be(
  {},
  Ma,
  {
    get(r, e) {
      if (e !== Symbol.unscopables)
        return Ma.get(r, e, r);
    },
    has(r, e) {
      const t = e[0] !== "_" && !Zw(e);
      return process.env.NODE_ENV !== "production" && !t && Ma.has(r, e) && j(
        `Property ${JSON.stringify(
          e
        )} should not start with _ which is a reserved prefix for Vue internals.`
      ), t;
    }
  }
);
function WP(r) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => r
  }), Object.keys(Li).forEach((t) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      get: () => Li[t](r),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: Ge
    });
  }), e;
}
function zP(r) {
  const {
    ctx: e,
    propsOptions: [t]
  } = r;
  t && Object.keys(t).forEach((s) => {
    Object.defineProperty(e, s, {
      enumerable: !0,
      configurable: !0,
      get: () => r.props[s],
      set: Ge
    });
  });
}
function GP(r) {
  const { ctx: e, setupState: t } = r;
  Object.keys(Ee(t)).forEach((s) => {
    if (!t.__isScriptSetup) {
      if (Cd(s[0])) {
        j(
          `setup() return property ${JSON.stringify(
            s
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(e, s, {
        enumerable: !0,
        configurable: !0,
        get: () => t[s],
        set: Ge
      });
    }
  });
}
const tn = (r) => j(
  `${r}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
);
function KP() {
  return process.env.NODE_ENV !== "production" && tn("defineProps"), null;
}
function XP() {
  return process.env.NODE_ENV !== "production" && tn("defineEmits"), null;
}
function JP(r) {
  process.env.NODE_ENV !== "production" && tn("defineExpose");
}
function YP(r) {
  process.env.NODE_ENV !== "production" && tn("defineOptions");
}
function QP() {
  return process.env.NODE_ENV !== "production" && tn("defineSlots"), null;
}
function ZP() {
  process.env.NODE_ENV !== "production" && tn("defineModel");
}
function e3(r, e) {
  return process.env.NODE_ENV !== "production" && tn("withDefaults"), null;
}
function t3() {
  return yv().slots;
}
function r3() {
  return yv().attrs;
}
function yv() {
  const r = is();
  return process.env.NODE_ENV !== "production" && !r && j("useContext() called without active instance."), r.setupContext || (r.setupContext = iE(r));
}
function io(r) {
  return se(r) ? r.reduce(
    (e, t) => (e[t] = null, e),
    {}
  ) : r;
}
function s3(r, e) {
  const t = io(r);
  for (const s in e) {
    if (s.startsWith("__skip")) continue;
    let i = t[s];
    i ? se(i) || fe(i) ? i = t[s] = { type: i, default: e[s] } : i.default = e[s] : i === null ? i = t[s] = { default: e[s] } : process.env.NODE_ENV !== "production" && j(`props default key "${s}" has no corresponding declaration.`), i && e[`__skip_${s}`] && (i.skipFactory = !0);
  }
  return t;
}
function i3(r, e) {
  return !r || !e ? r || e : se(r) && se(e) ? r.concat(e) : Be({}, io(r), io(e));
}
function n3(r, e) {
  const t = {};
  for (const s in r)
    e.includes(s) || Object.defineProperty(t, s, {
      enumerable: !0,
      get: () => r[s]
    });
  return t;
}
function a3(r) {
  const e = is();
  process.env.NODE_ENV !== "production" && !e && j(
    "withAsyncContext called without active current instance. This is likely a bug."
  );
  let t = r();
  return Tp(), es(t) && (t = t.catch((s) => {
    throw zi(e), s;
  })), [t, () => zi(e)];
}
function o3() {
  const r = /* @__PURE__ */ Object.create(null);
  return (e, t) => {
    r[t] ? j(`${e} property "${t}" is already defined in ${r[t]}.`) : r[t] = e;
  };
}
let dp = !0;
function u3(r) {
  const e = Nd(r), t = r.proxy, s = r.ctx;
  dp = !1, e.beforeCreate && _g(e.beforeCreate, r, "bc");
  const {
    // state
    data: i,
    computed: n,
    methods: a,
    watch: o,
    provide: u,
    inject: l,
    // lifecycle
    created: c,
    beforeMount: f,
    mounted: p,
    beforeUpdate: h,
    updated: m,
    activated: d,
    deactivated: y,
    beforeDestroy: S,
    beforeUnmount: E,
    destroyed: g,
    unmounted: b,
    render: v,
    renderTracked: A,
    renderTriggered: C,
    errorCaptured: x,
    serverPrefetch: _,
    // public API
    expose: T,
    inheritAttrs: P,
    // assets
    components: I,
    directives: $,
    filters: Y
  } = e, W = process.env.NODE_ENV !== "production" ? o3() : null;
  if (process.env.NODE_ENV !== "production") {
    const [K] = r.propsOptions;
    if (K)
      for (const Z in K)
        W("Props", Z);
  }
  if (l && l3(l, s, W), a)
    for (const K in a) {
      const Z = a[K];
      fe(Z) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(s, K, {
        value: Z.bind(t),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : s[K] = Z.bind(t), process.env.NODE_ENV !== "production" && W("Methods", K)) : process.env.NODE_ENV !== "production" && j(
        `Method "${K}" has type "${typeof Z}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (i) {
    process.env.NODE_ENV !== "production" && !fe(i) && j(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const K = i.call(t, t);
    if (process.env.NODE_ENV !== "production" && es(K) && j(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !Ae(K))
      process.env.NODE_ENV !== "production" && j("data() should return an object.");
    else if (r.data = rc(K), process.env.NODE_ENV !== "production")
      for (const Z in K)
        W("Data", Z), Cd(Z[0]) || Object.defineProperty(s, Z, {
          configurable: !0,
          enumerable: !0,
          get: () => K[Z],
          set: Ge
        });
  }
  if (dp = !0, n)
    for (const K in n) {
      const Z = n[K], Ce = fe(Z) ? Z.bind(t, t) : fe(Z.get) ? Z.get.bind(t, t) : Ge;
      process.env.NODE_ENV !== "production" && Ce === Ge && j(`Computed property "${K}" has no getter.`);
      const Ve = !fe(Z) && fe(Z.set) ? Z.set.bind(t) : process.env.NODE_ENV !== "production" ? () => {
        j(
          `Write operation failed: computed property "${K}" is readonly.`
        );
      } : Ge, ee = aE({
        get: Ce,
        set: Ve
      });
      Object.defineProperty(s, K, {
        enumerable: !0,
        configurable: !0,
        get: () => ee.value,
        set: (k) => ee.value = k
      }), process.env.NODE_ENV !== "production" && W("Computed", K);
    }
  if (o)
    for (const K in o)
      bv(o[K], s, t, K);
  if (u) {
    const K = fe(u) ? u.call(t) : u;
    Reflect.ownKeys(K).forEach((Z) => {
      Ev(Z, K[Z]);
    });
  }
  c && _g(c, r, "c");
  function F(K, Z) {
    se(Z) ? Z.forEach((Ce) => K(Ce.bind(t))) : Z && K(Z.bind(t));
  }
  if (F(wd, f), F(Io, p), F(pv, h), F(lc, m), F(lv, d), F(cv, y), F(gv, x), F(mv, A), F(dv, C), F(cc, E), F(fc, b), F(hv, _), se(T))
    if (T.length) {
      const K = r.exposed || (r.exposed = {});
      T.forEach((Z) => {
        Object.defineProperty(K, Z, {
          get: () => t[Z],
          set: (Ce) => t[Z] = Ce
        });
      });
    } else r.exposed || (r.exposed = {});
  v && r.render === Ge && (r.render = v), P != null && (r.inheritAttrs = P), I && (r.components = I), $ && (r.directives = $);
}
function l3(r, e, t = Ge) {
  se(r) && (r = mp(r));
  for (const s in r) {
    const i = r[s];
    let n;
    Ae(i) ? "default" in i ? n = Ra(
      i.from || s,
      i.default,
      !0
    ) : n = Ra(i.from || s) : n = Ra(i), pt(n) ? Object.defineProperty(e, s, {
      enumerable: !0,
      configurable: !0,
      get: () => n.value,
      set: (a) => n.value = a
    }) : e[s] = n, process.env.NODE_ENV !== "production" && t("Inject", s);
  }
}
function _g(r, e, t) {
  ar(
    se(r) ? r.map((s) => s.bind(e.proxy)) : r.bind(e.proxy),
    e,
    t
  );
}
function bv(r, e, t, s) {
  const i = s.includes(".") ? jv(t, s) : () => t[s];
  if (_e(r)) {
    const n = e[r];
    fe(n) ? Fa(i, n) : process.env.NODE_ENV !== "production" && j(`Invalid watch handler specified by key "${r}"`, n);
  } else if (fe(r))
    Fa(i, r.bind(t));
  else if (Ae(r))
    if (se(r))
      r.forEach((n) => bv(n, e, t, s));
    else {
      const n = fe(r.handler) ? r.handler.bind(t) : e[r.handler];
      fe(n) ? Fa(i, n, r) : process.env.NODE_ENV !== "production" && j(`Invalid watch handler specified by key "${r.handler}"`, n);
    }
  else process.env.NODE_ENV !== "production" && j(`Invalid watch option: "${s}"`, r);
}
function Nd(r) {
  const e = r.type, { mixins: t, extends: s } = e, {
    mixins: i,
    optionsCache: n,
    config: { optionMergeStrategies: a }
  } = r.appContext, o = n.get(e);
  let u;
  return o ? u = o : !i.length && !t && !s ? u = e : (u = {}, i.length && i.forEach(
    (l) => il(u, l, a, !0)
  ), il(u, e, a)), Ae(e) && n.set(e, u), u;
}
function il(r, e, t, s = !1) {
  const { mixins: i, extends: n } = e;
  n && il(r, n, t, !0), i && i.forEach(
    (a) => il(r, a, t, !0)
  );
  for (const a in e)
    if (s && a === "expose")
      process.env.NODE_ENV !== "production" && j(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const o = c3[a] || t && t[a];
      r[a] = o ? o(r[a], e[a]) : e[a];
    }
  return r;
}
const c3 = {
  data: xg,
  props: wg,
  emits: wg,
  // objects
  methods: Na,
  computed: Na,
  // lifecycle
  beforeCreate: Vt,
  created: Vt,
  beforeMount: Vt,
  mounted: Vt,
  beforeUpdate: Vt,
  updated: Vt,
  beforeDestroy: Vt,
  beforeUnmount: Vt,
  destroyed: Vt,
  unmounted: Vt,
  activated: Vt,
  deactivated: Vt,
  errorCaptured: Vt,
  serverPrefetch: Vt,
  // assets
  components: Na,
  directives: Na,
  // watch
  watch: p3,
  // provide / inject
  provide: xg,
  inject: f3
};
function xg(r, e) {
  return e ? r ? function() {
    return Be(
      fe(r) ? r.call(this, this) : r,
      fe(e) ? e.call(this, this) : e
    );
  } : e : r;
}
function f3(r, e) {
  return Na(mp(r), mp(e));
}
function mp(r) {
  if (se(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++)
      e[r[t]] = r[t];
    return e;
  }
  return r;
}
function Vt(r, e) {
  return r ? [...new Set([].concat(r, e))] : e;
}
function Na(r, e) {
  return r ? Be(/* @__PURE__ */ Object.create(null), r, e) : e;
}
function wg(r, e) {
  return r ? se(r) && se(e) ? [.../* @__PURE__ */ new Set([...r, ...e])] : Be(
    /* @__PURE__ */ Object.create(null),
    io(r),
    io(e ?? {})
  ) : e;
}
function p3(r, e) {
  if (!r) return e;
  if (!e) return r;
  const t = Be(/* @__PURE__ */ Object.create(null), r);
  for (const s in e)
    t[s] = Vt(r[s], e[s]);
  return t;
}
function vv() {
  return {
    app: null,
    config: {
      isNativeTag: zw,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let h3 = 0;
function d3(r, e) {
  return function(s, i = null) {
    fe(s) || (s = Be({}, s)), i != null && !Ae(i) && (process.env.NODE_ENV !== "production" && j("root props passed to app.mount() must be an object."), i = null);
    const n = vv(), a = /* @__PURE__ */ new WeakSet();
    let o = !1;
    const u = n.app = {
      _uid: h3++,
      _component: s,
      _props: i,
      _container: null,
      _context: n,
      _instance: null,
      version: Np,
      get config() {
        return n.config;
      },
      set config(l) {
        process.env.NODE_ENV !== "production" && j(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(l, ...c) {
        return a.has(l) ? process.env.NODE_ENV !== "production" && j("Plugin has already been applied to target app.") : l && fe(l.install) ? (a.add(l), l.install(u, ...c)) : fe(l) ? (a.add(l), l(u, ...c)) : process.env.NODE_ENV !== "production" && j(
          'A plugin must either be a function or an object with an "install" function.'
        ), u;
      },
      mixin(l) {
        return n.mixins.includes(l) ? process.env.NODE_ENV !== "production" && j(
          "Mixin has already been applied to target app" + (l.name ? `: ${l.name}` : "")
        ) : n.mixins.push(l), u;
      },
      component(l, c) {
        return process.env.NODE_ENV !== "production" && Pp(l, n.config), c ? (process.env.NODE_ENV !== "production" && n.components[l] && j(`Component "${l}" has already been registered in target app.`), n.components[l] = c, u) : n.components[l];
      },
      directive(l, c) {
        return process.env.NODE_ENV !== "production" && nv(l), c ? (process.env.NODE_ENV !== "production" && n.directives[l] && j(`Directive "${l}" has already been registered in target app.`), n.directives[l] = c, u) : n.directives[l];
      },
      mount(l, c, f) {
        if (o)
          process.env.NODE_ENV !== "production" && j(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          process.env.NODE_ENV !== "production" && l.__vue_app__ && j(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const p = He(s, i);
          return p.appContext = n, f === !0 ? f = "svg" : f === !1 && (f = void 0), process.env.NODE_ENV !== "production" && (n.reload = () => {
            r(
              yr(p),
              l,
              f
            );
          }), c && e ? e(p, l) : r(p, l, f), o = !0, u._container = l, l.__vue_app__ = u, process.env.NODE_ENV !== "production" && (u._instance = p.component, EP(u, Np)), Mo(p.component);
        }
      },
      unmount() {
        o ? (r(null, u._container), process.env.NODE_ENV !== "production" && (u._instance = null, SP(u)), delete u._container.__vue_app__) : process.env.NODE_ENV !== "production" && j("Cannot unmount an app that is not mounted.");
      },
      provide(l, c) {
        return process.env.NODE_ENV !== "production" && l in n.provides && j(
          `App already provides property with key "${String(l)}". It will be overwritten with the new value.`
        ), n.provides[l] = c, u;
      },
      runWithContext(l) {
        const c = Mi;
        Mi = u;
        try {
          return l();
        } finally {
          Mi = c;
        }
      }
    };
    return u;
  };
}
let Mi = null;
function Ev(r, e) {
  if (!nt)
    process.env.NODE_ENV !== "production" && j("provide() can only be used inside setup().");
  else {
    let t = nt.provides;
    const s = nt.parent && nt.parent.provides;
    s === t && (t = nt.provides = Object.create(s)), t[r] = e;
  }
}
function Ra(r, e, t = !1) {
  const s = nt || st;
  if (s || Mi) {
    const i = Mi ? Mi._context.provides : s ? s.parent == null ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0;
    if (i && r in i)
      return i[r];
    if (arguments.length > 1)
      return t && fe(e) ? e.call(s && s.proxy) : e;
    process.env.NODE_ENV !== "production" && j(`injection "${String(r)}" not found.`);
  } else process.env.NODE_ENV !== "production" && j("inject() can only be used inside setup() or functional components.");
}
function m3() {
  return !!(nt || st || Mi);
}
const Sv = {}, _v = () => Object.create(Sv), xv = (r) => Object.getPrototypeOf(r) === Sv;
function g3(r, e, t, s = !1) {
  const i = {}, n = _v();
  r.propsDefaults = /* @__PURE__ */ Object.create(null), wv(r, e, i, n);
  for (const a in r.propsOptions[0])
    a in i || (i[a] = void 0);
  process.env.NODE_ENV !== "production" && Pv(e || {}, i, r), t ? r.props = s ? i : zb(i) : r.type.props ? r.props = i : r.props = n, r.attrs = n;
}
function y3(r) {
  for (; r; ) {
    if (r.type.__hmrId) return !0;
    r = r.parent;
  }
}
function b3(r, e, t, s) {
  const {
    props: i,
    attrs: n,
    vnode: { patchFlag: a }
  } = r, o = Ee(i), [u] = r.propsOptions;
  let l = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(process.env.NODE_ENV !== "production" && y3(r)) && (s || a > 0) && !(a & 16)
  ) {
    if (a & 8) {
      const c = r.vnode.dynamicProps;
      for (let f = 0; f < c.length; f++) {
        let p = c[f];
        if (pc(r.emitsOptions, p))
          continue;
        const h = e[p];
        if (u)
          if (Pe(n, p))
            h !== n[p] && (n[p] = h, l = !0);
          else {
            const m = Et(p);
            i[m] = gp(
              u,
              o,
              m,
              h,
              r,
              !1
            );
          }
        else
          h !== n[p] && (n[p] = h, l = !0);
      }
    }
  } else {
    wv(r, e, i, n) && (l = !0);
    let c;
    for (const f in o)
      (!e || // for camelCase
      !Pe(e, f) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((c = Tt(f)) === f || !Pe(e, c))) && (u ? t && // for camelCase
      (t[f] !== void 0 || // for kebab-case
      t[c] !== void 0) && (i[f] = gp(
        u,
        o,
        f,
        void 0,
        r,
        !0
      )) : delete i[f]);
    if (n !== o)
      for (const f in n)
        (!e || !Pe(e, f)) && (delete n[f], l = !0);
  }
  l && zr(r.attrs, "set", ""), process.env.NODE_ENV !== "production" && Pv(e || {}, i, r);
}
function wv(r, e, t, s) {
  const [i, n] = r.propsOptions;
  let a = !1, o;
  if (e)
    for (let u in e) {
      if (yn(u))
        continue;
      const l = e[u];
      let c;
      i && Pe(i, c = Et(u)) ? !n || !n.includes(c) ? t[c] = l : (o || (o = {}))[c] = l : pc(r.emitsOptions, u) || (!(u in s) || l !== s[u]) && (s[u] = l, a = !0);
    }
  if (n) {
    const u = Ee(t), l = o || Oe;
    for (let c = 0; c < n.length; c++) {
      const f = n[c];
      t[f] = gp(
        i,
        u,
        f,
        l[f],
        r,
        !Pe(l, f)
      );
    }
  }
  return a;
}
function gp(r, e, t, s, i, n) {
  const a = r[t];
  if (a != null) {
    const o = Pe(a, "default");
    if (o && s === void 0) {
      const u = a.default;
      if (a.type !== Function && !a.skipFactory && fe(u)) {
        const { propsDefaults: l } = i;
        if (t in l)
          s = l[t];
        else {
          const c = zi(i);
          s = l[t] = u.call(
            null,
            e
          ), c();
        }
      } else
        s = u;
    }
    a[
      0
      /* shouldCast */
    ] && (n && !o ? s = !1 : a[
      1
      /* shouldCastTrue */
    ] && (s === "" || s === Tt(t)) && (s = !0));
  }
  return s;
}
const v3 = /* @__PURE__ */ new WeakMap();
function Tv(r, e, t = !1) {
  const s = t ? v3 : e.propsCache, i = s.get(r);
  if (i)
    return i;
  const n = r.props, a = {}, o = [];
  let u = !1;
  if (!fe(r)) {
    const c = (f) => {
      u = !0;
      const [p, h] = Tv(f, e, !0);
      Be(a, p), h && o.push(...h);
    };
    !t && e.mixins.length && e.mixins.forEach(c), r.extends && c(r.extends), r.mixins && r.mixins.forEach(c);
  }
  if (!n && !u)
    return Ae(r) && s.set(r, gn), gn;
  if (se(n))
    for (let c = 0; c < n.length; c++) {
      process.env.NODE_ENV !== "production" && !_e(n[c]) && j("props must be strings when using array syntax.", n[c]);
      const f = Et(n[c]);
      Tg(f) && (a[f] = Oe);
    }
  else if (n) {
    process.env.NODE_ENV !== "production" && !Ae(n) && j("invalid props options", n);
    for (const c in n) {
      const f = Et(c);
      if (Tg(f)) {
        const p = n[c], h = a[f] = se(p) || fe(p) ? { type: p } : Be({}, p), m = h.type;
        let d = !1, y = !0;
        if (se(m))
          for (let S = 0; S < m.length; ++S) {
            const E = m[S], g = fe(E) && E.name;
            if (g === "Boolean") {
              d = !0;
              break;
            } else g === "String" && (y = !1);
          }
        else
          d = fe(m) && m.name === "Boolean";
        h[
          0
          /* shouldCast */
        ] = d, h[
          1
          /* shouldCastTrue */
        ] = y, (d || Pe(h, "default")) && o.push(f);
      }
    }
  }
  const l = [a, o];
  return Ae(r) && s.set(r, l), l;
}
function Tg(r) {
  return r[0] !== "$" && !yn(r) ? !0 : (process.env.NODE_ENV !== "production" && j(`Invalid prop name: "${r}" is a reserved property.`), !1);
}
function E3(r) {
  return r === null ? "null" : typeof r == "function" ? r.name || "" : typeof r == "object" && r.constructor && r.constructor.name || "";
}
function Pv(r, e, t) {
  const s = Ee(e), i = t.propsOptions[0];
  for (const n in i) {
    let a = i[n];
    a != null && S3(
      n,
      s[n],
      a,
      process.env.NODE_ENV !== "production" ? Ar(s) : s,
      !Pe(r, n) && !Pe(r, Tt(n))
    );
  }
}
function S3(r, e, t, s, i) {
  const { type: n, required: a, validator: o, skipCheck: u } = t;
  if (a && i) {
    j('Missing required prop: "' + r + '"');
    return;
  }
  if (!(e == null && !a)) {
    if (n != null && n !== !0 && !u) {
      let l = !1;
      const c = se(n) ? n : [n], f = [];
      for (let p = 0; p < c.length && !l; p++) {
        const { valid: h, expectedType: m } = x3(e, c[p]);
        f.push(m || ""), l = h;
      }
      if (!l) {
        j(w3(r, e, f));
        return;
      }
    }
    o && !o(e, s) && j('Invalid prop: custom validator check failed for prop "' + r + '".');
  }
}
const _3 = /* @__PURE__ */ zt(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function x3(r, e) {
  let t;
  const s = E3(e);
  if (_3(s)) {
    const i = typeof r;
    t = i === s.toLowerCase(), !t && i === "object" && (t = r instanceof e);
  } else s === "Object" ? t = Ae(r) : s === "Array" ? t = se(r) : s === "null" ? t = r === null : t = r instanceof e;
  return {
    valid: t,
    expectedType: s
  };
}
function w3(r, e, t) {
  if (t.length === 0)
    return `Prop type [] for prop "${r}" won't match anything. Did you mean to use type Array instead?`;
  let s = `Invalid prop: type check failed for prop "${r}". Expected ${t.map(ii).join(" | ")}`;
  const i = t[0], n = rd(e), a = Pg(e, i), o = Pg(e, n);
  return t.length === 1 && Ag(i) && !T3(i, n) && (s += ` with value ${a}`), s += `, got ${n} `, Ag(n) && (s += `with value ${o}.`), s;
}
function Pg(r, e) {
  return e === "String" ? `"${r}"` : e === "Number" ? `${Number(r)}` : `${r}`;
}
function Ag(r) {
  return ["string", "number", "boolean"].some((t) => r.toLowerCase() === t);
}
function T3(...r) {
  return r.some((e) => e.toLowerCase() === "boolean");
}
const Av = (r) => r[0] === "_" || r === "$stable", Od = (r) => se(r) ? r.map(qt) : [qt(r)], P3 = (r, e, t) => {
  if (e._n)
    return e;
  const s = Ed((...i) => (process.env.NODE_ENV !== "production" && nt && (!t || t.root === nt.root) && j(
    `Slot "${r}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), Od(e(...i))), t);
  return s._c = !1, s;
}, Cv = (r, e, t) => {
  const s = r._ctx;
  for (const i in r) {
    if (Av(i)) continue;
    const n = r[i];
    if (fe(n))
      e[i] = P3(i, n, s);
    else if (n != null) {
      process.env.NODE_ENV !== "production" && j(
        `Non-function value encountered for slot "${i}". Prefer function slots for better performance.`
      );
      const a = Od(n);
      e[i] = () => a;
    }
  }
}, Nv = (r, e) => {
  process.env.NODE_ENV !== "production" && !Gn(r.vnode) && j(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const t = Od(e);
  r.slots.default = () => t;
}, yp = (r, e, t) => {
  for (const s in e)
    (t || s !== "_") && (r[s] = e[s]);
}, A3 = (r, e, t) => {
  const s = r.slots = _v();
  if (r.vnode.shapeFlag & 32) {
    const i = e._;
    i ? (yp(s, e, t), t && An(s, "_", i, !0)) : Cv(e, s);
  } else e && Nv(r, e);
}, C3 = (r, e, t) => {
  const { vnode: s, slots: i } = r;
  let n = !0, a = Oe;
  if (s.shapeFlag & 32) {
    const o = e._;
    o ? process.env.NODE_ENV !== "production" && ei ? (yp(i, e, t), zr(r, "set", "$slots")) : t && o === 1 ? n = !1 : yp(i, e, t) : (n = !e.$stable, Cv(e, i)), a = e;
  } else e && (Nv(r, e), a = { default: 1 });
  if (n)
    for (const o in i)
      !Av(o) && a[o] == null && delete i[o];
};
function nl(r, e, t, s, i = !1) {
  if (se(r)) {
    r.forEach(
      (p, h) => nl(
        p,
        e && (se(e) ? e[h] : e),
        t,
        s,
        i
      )
    );
    return;
  }
  if (Di(s) && !i)
    return;
  const n = s.shapeFlag & 4 ? Mo(s.component) : s.el, a = i ? null : n, { i: o, r: u } = r;
  if (process.env.NODE_ENV !== "production" && !o) {
    j(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const l = e && e.r, c = o.refs === Oe ? o.refs = {} : o.refs, f = o.setupState;
  if (l != null && l !== u && (_e(l) ? (c[l] = null, Pe(f, l) && (f[l] = null)) : pt(l) && (l.value = null)), fe(u))
    Kr(u, o, 12, [a, c]);
  else {
    const p = _e(u), h = pt(u);
    if (p || h) {
      const m = () => {
        if (r.f) {
          const d = p ? Pe(f, u) ? f[u] : c[u] : u.value;
          i ? se(d) && td(d, n) : se(d) ? d.includes(n) || d.push(n) : p ? (c[u] = [n], Pe(f, u) && (f[u] = c[u])) : (u.value = [n], r.k && (c[r.k] = u.value));
        } else p ? (c[u] = a, Pe(f, u) && (f[u] = a)) : h ? (u.value = a, r.k && (c[r.k] = a)) : process.env.NODE_ENV !== "production" && j("Invalid template ref type:", u, `(${typeof u})`);
      };
      a ? (m.id = -1, mt(m, t)) : m();
    } else process.env.NODE_ENV !== "production" && j("Invalid template ref type:", u, `(${typeof u})`);
  }
}
const Ov = Symbol("_vte"), N3 = (r) => r.__isTeleport, Ri = (r) => r && (r.disabled || r.disabled === ""), Cg = (r) => typeof SVGElement < "u" && r instanceof SVGElement, Ng = (r) => typeof MathMLElement == "function" && r instanceof MathMLElement, bp = (r, e) => {
  const t = r && r.to;
  if (_e(t))
    if (e) {
      const s = e(t);
      return process.env.NODE_ENV !== "production" && !s && !Ri(r) && j(
        `Failed to locate Teleport target with selector "${t}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), s;
    } else
      return process.env.NODE_ENV !== "production" && j(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return process.env.NODE_ENV !== "production" && !t && !Ri(r) && j(`Invalid Teleport target: ${t}`), t;
}, O3 = {
  name: "Teleport",
  __isTeleport: !0,
  process(r, e, t, s, i, n, a, o, u, l) {
    const {
      mc: c,
      pc: f,
      pbc: p,
      o: { insert: h, querySelector: m, createText: d, createComment: y }
    } = l, S = Ri(e.props);
    let { shapeFlag: E, children: g, dynamicChildren: b } = e;
    if (process.env.NODE_ENV !== "production" && ei && (u = !1, b = null), r == null) {
      const v = e.el = process.env.NODE_ENV !== "production" ? y("teleport start") : d(""), A = e.anchor = process.env.NODE_ENV !== "production" ? y("teleport end") : d("");
      h(v, t, s), h(A, t, s);
      const C = e.target = bp(e.props, m), x = kv(C, e, d, h);
      C ? a === "svg" || Cg(C) ? a = "svg" : (a === "mathml" || Ng(C)) && (a = "mathml") : process.env.NODE_ENV !== "production" && !S && j("Invalid Teleport target on mount:", C, `(${typeof C})`);
      const _ = (T, P) => {
        E & 16 && c(
          g,
          T,
          P,
          i,
          n,
          a,
          o,
          u
        );
      };
      S ? _(t, A) : C && _(C, x);
    } else {
      e.el = r.el, e.targetStart = r.targetStart;
      const v = e.anchor = r.anchor, A = e.target = r.target, C = e.targetAnchor = r.targetAnchor, x = Ri(r.props), _ = x ? t : A, T = x ? v : C;
      if (a === "svg" || Cg(A) ? a = "svg" : (a === "mathml" || Ng(A)) && (a = "mathml"), b ? (p(
        r.dynamicChildren,
        b,
        _,
        i,
        n,
        a,
        o
      ), $a(r, e, !0)) : u || f(
        r,
        e,
        _,
        T,
        i,
        n,
        a,
        o,
        !1
      ), S)
        x ? e.props && r.props && e.props.to !== r.props.to && (e.props.to = r.props.to) : su(
          e,
          t,
          v,
          l,
          1
        );
      else if ((e.props && e.props.to) !== (r.props && r.props.to)) {
        const P = e.target = bp(
          e.props,
          m
        );
        P ? su(
          e,
          P,
          null,
          l,
          0
        ) : process.env.NODE_ENV !== "production" && j(
          "Invalid Teleport target on update:",
          A,
          `(${typeof A})`
        );
      } else x && su(
        e,
        A,
        C,
        l,
        1
      );
    }
    Iv(e);
  },
  remove(r, e, t, { um: s, o: { remove: i } }, n) {
    const {
      shapeFlag: a,
      children: o,
      anchor: u,
      targetStart: l,
      targetAnchor: c,
      target: f,
      props: p
    } = r;
    if (f && (i(l), i(c)), n && i(u), a & 16) {
      const h = n || !Ri(p);
      for (let m = 0; m < o.length; m++) {
        const d = o[m];
        s(
          d,
          e,
          t,
          h,
          !!d.dynamicChildren
        );
      }
    }
  },
  move: su,
  hydrate: I3
};
function su(r, e, t, { o: { insert: s }, m: i }, n = 2) {
  n === 0 && s(r.targetAnchor, e, t);
  const { el: a, anchor: o, shapeFlag: u, children: l, props: c } = r, f = n === 2;
  if (f && s(a, e, t), (!f || Ri(c)) && u & 16)
    for (let p = 0; p < l.length; p++)
      i(
        l[p],
        e,
        t,
        2
      );
  f && s(o, e, t);
}
function I3(r, e, t, s, i, n, {
  o: { nextSibling: a, parentNode: o, querySelector: u, insert: l, createText: c }
}, f) {
  const p = e.target = bp(
    e.props,
    u
  );
  if (p) {
    const h = p._lpa || p.firstChild;
    if (e.shapeFlag & 16)
      if (Ri(e.props))
        e.anchor = f(
          a(r),
          e,
          o(r),
          t,
          s,
          i,
          n
        ), e.targetStart = h, e.targetAnchor = h && a(h);
      else {
        e.anchor = a(r);
        let m = h;
        for (; m; ) {
          if (m && m.nodeType === 8) {
            if (m.data === "teleport start anchor")
              e.targetStart = m;
            else if (m.data === "teleport anchor") {
              e.targetAnchor = m, p._lpa = e.targetAnchor && a(e.targetAnchor);
              break;
            }
          }
          m = a(m);
        }
        e.targetAnchor || kv(p, e, c, l), f(
          h && a(h),
          e,
          p,
          t,
          s,
          i,
          n
        );
      }
    Iv(e);
  }
  return e.anchor && a(e.anchor);
}
const k3 = O3;
function Iv(r) {
  const e = r.ctx;
  if (e && e.ut) {
    let t = r.children[0].el;
    for (; t && t !== r.targetAnchor; )
      t.nodeType === 1 && t.setAttribute("data-v-owner", e.uid), t = t.nextSibling;
    e.ut();
  }
}
function kv(r, e, t, s) {
  const i = e.targetStart = t(""), n = e.targetAnchor = t("");
  return i[Ov] = n, r && (s(i, r), s(n, r)), n;
}
let Og = !1;
const mi = () => {
  Og || (console.error("Hydration completed but contains mismatches."), Og = !0);
}, D3 = (r) => r.namespaceURI.includes("svg") && r.tagName !== "foreignObject", L3 = (r) => r.namespaceURI.includes("MathML"), iu = (r) => {
  if (D3(r)) return "svg";
  if (L3(r)) return "mathml";
}, fa = (r) => r.nodeType === 8;
function M3(r) {
  const {
    mt: e,
    p: t,
    o: {
      patchProp: s,
      createText: i,
      nextSibling: n,
      parentNode: a,
      remove: o,
      insert: u,
      createComment: l
    }
  } = r, c = (g, b) => {
    if (!b.hasChildNodes()) {
      process.env.NODE_ENV !== "production" && j(
        "Attempting to hydrate existing markup but container is empty. Performing full mount instead."
      ), t(null, g, b), tl(), b._vnode = g;
      return;
    }
    f(b.firstChild, g, null, null, null), tl(), b._vnode = g;
  }, f = (g, b, v, A, C, x = !1) => {
    x = x || !!b.dynamicChildren;
    const _ = fa(g) && g.data === "[", T = () => d(
      g,
      b,
      v,
      A,
      C,
      _
    ), { type: P, ref: I, shapeFlag: $, patchFlag: Y } = b;
    let W = g.nodeType;
    b.el = g, process.env.NODE_ENV !== "production" && (An(g, "__vnode", b, !0), An(g, "__vueParentComponent", v, !0)), Y === -2 && (x = !1, b.dynamicChildren = null);
    let F = null;
    switch (P) {
      case Xr:
        W !== 3 ? b.children === "" ? (u(b.el = i(""), a(g), g), F = g) : F = T() : (g.data !== b.children && (process.env.NODE_ENV !== "production" && j(
          "Hydration text mismatch in",
          g.parentNode,
          `
  - rendered on server: ${JSON.stringify(
            g.data
          )}
  - expected on client: ${JSON.stringify(b.children)}`
        ), mi(), g.data = b.children), F = n(g));
        break;
      case Je:
        E(g) ? (F = n(g), S(
          b.el = g.content.firstChild,
          g,
          v
        )) : W !== 8 || _ ? F = T() : F = n(g);
        break;
      case Es:
        if (_ && (g = n(g), W = g.nodeType), W === 1 || W === 3) {
          F = g;
          const K = !b.children.length;
          for (let Z = 0; Z < b.staticCount; Z++)
            K && (b.children += F.nodeType === 1 ? F.outerHTML : F.data), Z === b.staticCount - 1 && (b.anchor = F), F = n(F);
          return _ ? n(F) : F;
        } else
          T();
        break;
      case ct:
        _ ? F = m(
          g,
          b,
          v,
          A,
          C,
          x
        ) : F = T();
        break;
      default:
        if ($ & 1)
          (W !== 1 || b.type.toLowerCase() !== g.tagName.toLowerCase()) && !E(g) ? F = T() : F = p(
            g,
            b,
            v,
            A,
            C,
            x
          );
        else if ($ & 6) {
          b.slotScopeIds = C;
          const K = a(g);
          if (_ ? F = y(g) : fa(g) && g.data === "teleport start" ? F = y(g, g.data, "teleport end") : F = n(g), e(
            b,
            K,
            null,
            v,
            A,
            iu(K),
            x
          ), Di(b)) {
            let Z;
            _ ? (Z = He(ct), Z.anchor = F ? F.previousSibling : K.lastChild) : Z = g.nodeType === 3 ? Ld("") : He("div"), Z.el = g, b.component.subTree = Z;
          }
        } else $ & 64 ? W !== 8 ? F = T() : F = b.type.hydrate(
          g,
          b,
          v,
          A,
          C,
          x,
          r,
          h
        ) : $ & 128 ? F = b.type.hydrate(
          g,
          b,
          v,
          A,
          iu(a(g)),
          C,
          x,
          r,
          f
        ) : process.env.NODE_ENV !== "production" && j("Invalid HostVNode type:", P, `(${typeof P})`);
    }
    return I != null && nl(I, null, A, b), F;
  }, p = (g, b, v, A, C, x) => {
    x = x || !!b.dynamicChildren;
    const { type: _, props: T, patchFlag: P, shapeFlag: I, dirs: $, transition: Y } = b, W = _ === "input" || _ === "option";
    if (process.env.NODE_ENV !== "production" || W || P !== -1) {
      $ && Mr(b, null, v, "created");
      let F = !1;
      if (E(g)) {
        F = $v(A, Y) && v && v.vnode.props && v.vnode.props.appear;
        const Z = g.content.firstChild;
        F && Y.beforeEnter(Z), S(Z, g, v), b.el = g = Z;
      }
      if (I & 16 && // skip if element has innerHTML / textContent
      !(T && (T.innerHTML || T.textContent))) {
        let Z = h(
          g.firstChild,
          b,
          g,
          v,
          A,
          C,
          x
        ), Ce = !1;
        for (; Z; ) {
          process.env.NODE_ENV !== "production" && !Ce && (j(
            "Hydration children mismatch on",
            g,
            `
Server rendered element contains more child nodes than client vdom.`
          ), Ce = !0), mi();
          const Ve = Z;
          Z = Z.nextSibling, o(Ve);
        }
      } else I & 8 && g.textContent !== b.children && (process.env.NODE_ENV !== "production" && j(
        "Hydration text content mismatch on",
        g,
        `
  - rendered on server: ${g.textContent}
  - expected on client: ${b.children}`
      ), mi(), g.textContent = b.children);
      if (T) {
        if (process.env.NODE_ENV !== "production" || W || !x || P & 48) {
          const Z = g.tagName.includes("-");
          for (const Ce in T)
            process.env.NODE_ENV !== "production" && // #11189 skip if this node has directives that have created hooks
            // as it could have mutated the DOM in any possible way
            !($ && $.some((Ve) => Ve.dir.created)) && R3(g, Ce, T[Ce], b, v) && mi(), (W && (Ce.endsWith("value") || Ce === "indeterminate") || Yi(Ce) && !yn(Ce) || // force hydrate v-bind with .prop modifiers
            Ce[0] === "." || Z) && s(g, Ce, null, T[Ce], void 0, v);
        } else if (T.onClick)
          s(
            g,
            "onClick",
            null,
            T.onClick,
            void 0,
            v
          );
        else if (P & 4 && Zs(T.style))
          for (const Z in T.style) T.style[Z];
      }
      let K;
      (K = T && T.onVnodeBeforeMount) && Kt(K, v, b), $ && Mr(b, null, v, "beforeMount"), ((K = T && T.onVnodeMounted) || $ || F) && Gv(() => {
        K && Kt(K, v, b), F && Y.enter(g), $ && Mr(b, null, v, "mounted");
      }, A);
    }
    return g.nextSibling;
  }, h = (g, b, v, A, C, x, _) => {
    _ = _ || !!b.dynamicChildren;
    const T = b.children, P = T.length;
    let I = !1;
    for (let $ = 0; $ < P; $++) {
      const Y = _ ? T[$] : T[$] = qt(T[$]), W = Y.type === Xr;
      if (g) {
        if (W && !_) {
          let F = T[$ + 1];
          F && (F = qt(F)).type === Xr && (u(
            i(
              g.data.slice(Y.children.length)
            ),
            v,
            n(g)
          ), g.data = Y.children);
        }
        g = f(
          g,
          Y,
          A,
          C,
          x,
          _
        );
      } else W && !Y.children ? u(Y.el = i(""), v) : (process.env.NODE_ENV !== "production" && !I && (j(
        "Hydration children mismatch on",
        v,
        `
Server rendered element contains fewer child nodes than client vdom.`
      ), I = !0), mi(), t(
        null,
        Y,
        v,
        null,
        A,
        C,
        iu(v),
        x
      ));
    }
    return g;
  }, m = (g, b, v, A, C, x) => {
    const { slotScopeIds: _ } = b;
    _ && (C = C ? C.concat(_) : _);
    const T = a(g), P = h(
      n(g),
      b,
      T,
      v,
      A,
      C,
      x
    );
    return P && fa(P) && P.data === "]" ? n(b.anchor = P) : (mi(), u(b.anchor = l("]"), T, P), P);
  }, d = (g, b, v, A, C, x) => {
    if (process.env.NODE_ENV !== "production" && j(
      `Hydration node mismatch:
- rendered on server:`,
      g,
      g.nodeType === 3 ? "(text)" : fa(g) && g.data === "[" ? "(start of fragment)" : "",
      `
- expected on client:`,
      b.type
    ), mi(), b.el = null, x) {
      const P = y(g);
      for (; ; ) {
        const I = n(g);
        if (I && I !== P)
          o(I);
        else
          break;
      }
    }
    const _ = n(g), T = a(g);
    return o(g), t(
      null,
      b,
      T,
      _,
      v,
      A,
      iu(T),
      C
    ), _;
  }, y = (g, b = "[", v = "]") => {
    let A = 0;
    for (; g; )
      if (g = n(g), g && fa(g) && (g.data === b && A++, g.data === v)) {
        if (A === 0)
          return n(g);
        A--;
      }
    return g;
  }, S = (g, b, v) => {
    const A = b.parentNode;
    A && A.replaceChild(g, b);
    let C = v;
    for (; C; )
      C.vnode.el === b && (C.vnode.el = C.subTree.el = g), C = C.parent;
  }, E = (g) => g.nodeType === 1 && g.tagName.toLowerCase() === "template";
  return [c, f];
}
function R3(r, e, t, s, i) {
  let n, a, o, u;
  if (e === "class")
    o = r.getAttribute("class"), u = en(t), $3(Ig(o || ""), Ig(u)) || (n = a = "class");
  else if (e === "style") {
    o = r.getAttribute("style") || "", u = _e(t) ? t : Tb(Zi(t));
    const l = kg(o), c = kg(u);
    if (s.dirs)
      for (const { dir: f, value: p } of s.dirs)
        f.name === "show" && !p && c.set("display", "none");
    i && Dv(i, s, c), F3(l, c) || (n = a = "style");
  } else (r instanceof SVGElement && yT(e) || r instanceof HTMLElement && (ap(e) || gT(e))) && (ap(e) ? (o = r.hasAttribute(e), u = Ao(t)) : t == null ? (o = r.hasAttribute(e), u = !1) : (r.hasAttribute(e) ? o = r.getAttribute(e) : e === "value" && r.tagName === "TEXTAREA" ? o = r.value : o = !1, u = id(t) ? String(t) : !1), o !== u && (n = "attribute", a = e));
  if (n) {
    const l = (p) => p === !1 ? "(not rendered)" : `${a}="${p}"`, c = `Hydration ${n} mismatch on`, f = `
  - rendered on server: ${l(o)}
  - expected on client: ${l(u)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
    return j(c, r, f), !0;
  }
  return !1;
}
function Ig(r) {
  return new Set(r.trim().split(/\s+/));
}
function $3(r, e) {
  if (r.size !== e.size)
    return !1;
  for (const t of r)
    if (!e.has(t))
      return !1;
  return !0;
}
function kg(r) {
  const e = /* @__PURE__ */ new Map();
  for (const t of r.split(";")) {
    let [s, i] = t.split(":");
    s = s.trim(), i = i && i.trim(), s && i && e.set(s, i);
  }
  return e;
}
function F3(r, e) {
  if (r.size !== e.size)
    return !1;
  for (const [t, s] of r)
    if (s !== e.get(t))
      return !1;
  return !0;
}
function Dv(r, e, t) {
  const s = r.subTree;
  if (r.getCssVars && (e === s || s && s.type === ct && s.children.includes(e))) {
    const i = r.getCssVars();
    for (const n in i)
      t.set(`--${n}`, String(i[n]));
  }
  e === s && r.parent && Dv(r.parent, r.vnode, t);
}
let pa, Ks;
function as(r, e) {
  r.appContext.config.performance && al() && Ks.mark(`vue-${e}-${r.uid}`), process.env.NODE_ENV !== "production" && wP(r, e, al() ? Ks.now() : Date.now());
}
function os(r, e) {
  if (r.appContext.config.performance && al()) {
    const t = `vue-${e}-${r.uid}`, s = t + ":end";
    Ks.mark(s), Ks.measure(
      `<${mc(r, r.type)}> ${e}`,
      t,
      s
    ), Ks.clearMarks(t), Ks.clearMarks(s);
  }
  process.env.NODE_ENV !== "production" && TP(r, e, al() ? Ks.now() : Date.now());
}
function al() {
  return pa !== void 0 || (typeof window < "u" && window.performance ? (pa = !0, Ks = window.performance) : pa = !1), pa;
}
function B3() {
  const r = [];
  if (process.env.NODE_ENV !== "production" && r.length) {
    const e = r.length > 1;
    console.warn(
      `Feature flag${e ? "s" : ""} ${r.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const mt = Gv;
function Lv(r) {
  return Rv(r);
}
function Mv(r) {
  return Rv(r, M3);
}
function Rv(r, e) {
  B3();
  const t = Zl();
  t.__VUE__ = !0, process.env.NODE_ENV !== "production" && bd(t.__VUE_DEVTOOLS_GLOBAL_HOOK__, t);
  const {
    insert: s,
    remove: i,
    patchProp: n,
    createElement: a,
    createText: o,
    createComment: u,
    setText: l,
    setElementText: c,
    parentNode: f,
    nextSibling: p,
    setScopeId: h = Ge,
    insertStaticContent: m
  } = r, d = (w, N, M, q = null, V = null, U = null, J = void 0, G = null, X = process.env.NODE_ENV !== "production" && ei ? !1 : !!N.dynamicChildren) => {
    if (w === N)
      return;
    w && !Pr(w, N) && (q = ne(w), R(w, V, U, !0), w = null), N.patchFlag === -2 && (X = !1, N.dynamicChildren = null);
    const { type: z, ref: re, shapeFlag: ce } = N;
    switch (z) {
      case Xr:
        y(w, N, M, q);
        break;
      case Je:
        S(w, N, M, q);
        break;
      case Es:
        w == null ? E(N, M, q, J) : process.env.NODE_ENV !== "production" && g(w, N, M, J);
        break;
      case ct:
        $(
          w,
          N,
          M,
          q,
          V,
          U,
          J,
          G,
          X
        );
        break;
      default:
        ce & 1 ? A(
          w,
          N,
          M,
          q,
          V,
          U,
          J,
          G,
          X
        ) : ce & 6 ? Y(
          w,
          N,
          M,
          q,
          V,
          U,
          J,
          G,
          X
        ) : ce & 64 || ce & 128 ? z.process(
          w,
          N,
          M,
          q,
          V,
          U,
          J,
          G,
          X,
          me
        ) : process.env.NODE_ENV !== "production" && j("Invalid VNode type:", z, `(${typeof z})`);
    }
    re != null && V && nl(re, w && w.ref, U, N || w, !N);
  }, y = (w, N, M, q) => {
    if (w == null)
      s(
        N.el = o(N.children),
        M,
        q
      );
    else {
      const V = N.el = w.el;
      N.children !== w.children && l(V, N.children);
    }
  }, S = (w, N, M, q) => {
    w == null ? s(
      N.el = u(N.children || ""),
      M,
      q
    ) : N.el = w.el;
  }, E = (w, N, M, q) => {
    [w.el, w.anchor] = m(
      w.children,
      N,
      M,
      q,
      w.el,
      w.anchor
    );
  }, g = (w, N, M, q) => {
    if (N.children !== w.children) {
      const V = p(w.anchor);
      v(w), [N.el, N.anchor] = m(
        N.children,
        M,
        V,
        q
      );
    } else
      N.el = w.el, N.anchor = w.anchor;
  }, b = ({ el: w, anchor: N }, M, q) => {
    let V;
    for (; w && w !== N; )
      V = p(w), s(w, M, q), w = V;
    s(N, M, q);
  }, v = ({ el: w, anchor: N }) => {
    let M;
    for (; w && w !== N; )
      M = p(w), i(w), w = M;
    i(N);
  }, A = (w, N, M, q, V, U, J, G, X) => {
    N.type === "svg" ? J = "svg" : N.type === "math" && (J = "mathml"), w == null ? C(
      N,
      M,
      q,
      V,
      U,
      J,
      G,
      X
    ) : T(
      w,
      N,
      V,
      U,
      J,
      G,
      X
    );
  }, C = (w, N, M, q, V, U, J, G) => {
    let X, z;
    const { props: re, shapeFlag: ce, transition: pe, dirs: ve } = w;
    if (X = w.el = a(
      w.type,
      U,
      re && re.is,
      re
    ), ce & 8 ? c(X, w.children) : ce & 16 && _(
      w.children,
      X,
      null,
      q,
      V,
      Tf(w, U),
      J,
      G
    ), ve && Mr(w, null, q, "created"), x(X, w, w.scopeId, J, q), re) {
      for (const qe in re)
        qe !== "value" && !yn(qe) && n(X, qe, null, re[qe], U, q);
      "value" in re && n(X, "value", null, re.value, U), (z = re.onVnodeBeforeMount) && Kt(z, q, w);
    }
    process.env.NODE_ENV !== "production" && (An(X, "__vnode", w, !0), An(X, "__vueParentComponent", q, !0)), ve && Mr(w, null, q, "beforeMount");
    const xe = $v(V, pe);
    xe && pe.beforeEnter(X), s(X, N, M), ((z = re && re.onVnodeMounted) || xe || ve) && mt(() => {
      z && Kt(z, q, w), xe && pe.enter(X), ve && Mr(w, null, q, "mounted");
    }, V);
  }, x = (w, N, M, q, V) => {
    if (M && h(w, M), q)
      for (let U = 0; U < q.length; U++)
        h(w, q[U]);
    if (V) {
      let U = V.subTree;
      if (process.env.NODE_ENV !== "production" && U.patchFlag > 0 && U.patchFlag & 2048 && (U = hc(U.children) || U), N === U) {
        const J = V.vnode;
        x(
          w,
          J,
          J.scopeId,
          J.slotScopeIds,
          V.parent
        );
      }
    }
  }, _ = (w, N, M, q, V, U, J, G, X = 0) => {
    for (let z = X; z < w.length; z++) {
      const re = w[z] = G ? Ws(w[z]) : qt(w[z]);
      d(
        null,
        re,
        N,
        M,
        q,
        V,
        U,
        J,
        G
      );
    }
  }, T = (w, N, M, q, V, U, J) => {
    const G = N.el = w.el;
    process.env.NODE_ENV !== "production" && (G.__vnode = N);
    let { patchFlag: X, dynamicChildren: z, dirs: re } = N;
    X |= w.patchFlag & 16;
    const ce = w.props || Oe, pe = N.props || Oe;
    let ve;
    if (M && gi(M, !1), (ve = pe.onVnodeBeforeUpdate) && Kt(ve, M, N, w), re && Mr(N, w, M, "beforeUpdate"), M && gi(M, !0), process.env.NODE_ENV !== "production" && ei && (X = 0, J = !1, z = null), (ce.innerHTML && pe.innerHTML == null || ce.textContent && pe.textContent == null) && c(G, ""), z ? (P(
      w.dynamicChildren,
      z,
      G,
      M,
      q,
      Tf(N, V),
      U
    ), process.env.NODE_ENV !== "production" && $a(w, N)) : J || Ce(
      w,
      N,
      G,
      null,
      M,
      q,
      Tf(N, V),
      U,
      !1
    ), X > 0) {
      if (X & 16)
        I(G, ce, pe, M, V);
      else if (X & 2 && ce.class !== pe.class && n(G, "class", null, pe.class, V), X & 4 && n(G, "style", ce.style, pe.style, V), X & 8) {
        const xe = N.dynamicProps;
        for (let qe = 0; qe < xe.length; qe++) {
          const De = xe[qe], ut = ce[De], xr = pe[De];
          (xr !== ut || De === "value") && n(G, De, ut, xr, V, M);
        }
      }
      X & 1 && w.children !== N.children && c(G, N.children);
    } else !J && z == null && I(G, ce, pe, M, V);
    ((ve = pe.onVnodeUpdated) || re) && mt(() => {
      ve && Kt(ve, M, N, w), re && Mr(N, w, M, "updated");
    }, q);
  }, P = (w, N, M, q, V, U, J) => {
    for (let G = 0; G < N.length; G++) {
      const X = w[G], z = N[G], re = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        X.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (X.type === ct || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Pr(X, z) || // - In the case of a component, it could contain anything.
        X.shapeFlag & 70) ? f(X.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          M
        )
      );
      d(
        X,
        z,
        re,
        null,
        q,
        V,
        U,
        J,
        !0
      );
    }
  }, I = (w, N, M, q, V) => {
    if (N !== M) {
      if (N !== Oe)
        for (const U in N)
          !yn(U) && !(U in M) && n(
            w,
            U,
            N[U],
            null,
            V,
            q
          );
      for (const U in M) {
        if (yn(U)) continue;
        const J = M[U], G = N[U];
        J !== G && U !== "value" && n(w, U, G, J, V, q);
      }
      "value" in M && n(w, "value", N.value, M.value, V);
    }
  }, $ = (w, N, M, q, V, U, J, G, X) => {
    const z = N.el = w ? w.el : o(""), re = N.anchor = w ? w.anchor : o("");
    let { patchFlag: ce, dynamicChildren: pe, slotScopeIds: ve } = N;
    process.env.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (ei || ce & 2048) && (ce = 0, X = !1, pe = null), ve && (G = G ? G.concat(ve) : ve), w == null ? (s(z, M, q), s(re, M, q), _(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      N.children || [],
      M,
      re,
      V,
      U,
      J,
      G,
      X
    )) : ce > 0 && ce & 64 && pe && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    w.dynamicChildren ? (P(
      w.dynamicChildren,
      pe,
      M,
      V,
      U,
      J,
      G
    ), process.env.NODE_ENV !== "production" ? $a(w, N) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (N.key != null || V && N === V.subTree) && $a(
        w,
        N,
        !0
        /* shallow */
      )
    )) : Ce(
      w,
      N,
      M,
      re,
      V,
      U,
      J,
      G,
      X
    );
  }, Y = (w, N, M, q, V, U, J, G, X) => {
    N.slotScopeIds = G, w == null ? N.shapeFlag & 512 ? V.ctx.activate(
      N,
      M,
      q,
      J,
      X
    ) : W(
      N,
      M,
      q,
      V,
      U,
      J,
      X
    ) : F(w, N, X);
  }, W = (w, N, M, q, V, U, J) => {
    const G = w.component = eE(
      w,
      q,
      V
    );
    if (process.env.NODE_ENV !== "production" && G.type.__hmrId && gP(G), process.env.NODE_ENV !== "production" && (Da(w), as(G, "mount")), Gn(w) && (G.ctx.renderer = me), process.env.NODE_ENV !== "production" && as(G, "init"), rE(G, !1, J), process.env.NODE_ENV !== "production" && os(G, "init"), G.asyncDep) {
      if (V && V.registerDep(G, K, J), !w.el) {
        const X = G.subTree = He(Je);
        S(null, X, N, M);
      }
    } else
      K(
        G,
        w,
        N,
        M,
        V,
        U,
        J
      );
    process.env.NODE_ENV !== "production" && (La(), os(G, "mount"));
  }, F = (w, N, M) => {
    const q = N.component = w.component;
    if (G3(w, N, M))
      if (q.asyncDep && !q.asyncResolved) {
        process.env.NODE_ENV !== "production" && Da(N), Z(q, N, M), process.env.NODE_ENV !== "production" && La();
        return;
      } else
        q.next = N, dP(q.update), q.effect.dirty = !0, q.update();
    else
      N.el = w.el, q.vnode = N;
  }, K = (w, N, M, q, V, U, J) => {
    const G = () => {
      if (w.isMounted) {
        let { next: re, bu: ce, u: pe, parent: ve, vnode: xe } = w;
        {
          const un = Fv(w);
          if (un) {
            re && (re.el = xe.el, Z(w, re, J)), un.asyncDep.then(() => {
              w.isUnmounted || G();
            });
            return;
          }
        }
        let qe = re, De;
        process.env.NODE_ENV !== "production" && Da(re || w.vnode), gi(w, !1), re ? (re.el = xe.el, Z(w, re, J)) : re = xe, ce && Gs(ce), (De = re.props && re.props.onVnodeBeforeUpdate) && Kt(De, ve, re, xe), gi(w, !0), process.env.NODE_ENV !== "production" && as(w, "render");
        const ut = Nu(w);
        process.env.NODE_ENV !== "production" && os(w, "render");
        const xr = w.subTree;
        w.subTree = ut, process.env.NODE_ENV !== "production" && as(w, "patch"), d(
          xr,
          ut,
          // parent may have changed if it's in a teleport
          f(xr.el),
          // anchor may have changed if it's in a fragment
          ne(xr),
          w,
          V,
          U
        ), process.env.NODE_ENV !== "production" && os(w, "patch"), re.el = ut.el, qe === null && Id(w, ut.el), pe && mt(pe, V), (De = re.props && re.props.onVnodeUpdated) && mt(
          () => Kt(De, ve, re, xe),
          V
        ), process.env.NODE_ENV !== "production" && sv(w), process.env.NODE_ENV !== "production" && La();
      } else {
        let re;
        const { el: ce, props: pe } = N, { bm: ve, m: xe, parent: qe } = w, De = Di(N);
        if (gi(w, !1), ve && Gs(ve), !De && (re = pe && pe.onVnodeBeforeMount) && Kt(re, qe, N), gi(w, !0), ce && Ke) {
          const ut = () => {
            process.env.NODE_ENV !== "production" && as(w, "render"), w.subTree = Nu(w), process.env.NODE_ENV !== "production" && os(w, "render"), process.env.NODE_ENV !== "production" && as(w, "hydrate"), Ke(
              ce,
              w.subTree,
              w,
              V,
              null
            ), process.env.NODE_ENV !== "production" && os(w, "hydrate");
          };
          De ? N.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !w.isUnmounted && ut()
          ) : ut();
        } else {
          process.env.NODE_ENV !== "production" && as(w, "render");
          const ut = w.subTree = Nu(w);
          process.env.NODE_ENV !== "production" && os(w, "render"), process.env.NODE_ENV !== "production" && as(w, "patch"), d(
            null,
            ut,
            M,
            q,
            w,
            V,
            U
          ), process.env.NODE_ENV !== "production" && os(w, "patch"), N.el = ut.el;
        }
        if (xe && mt(xe, V), !De && (re = pe && pe.onVnodeMounted)) {
          const ut = N;
          mt(
            () => Kt(re, qe, ut),
            V
          );
        }
        (N.shapeFlag & 256 || qe && Di(qe.vnode) && qe.vnode.shapeFlag & 256) && w.a && mt(w.a, V), w.isMounted = !0, process.env.NODE_ENV !== "production" && pp(w), N = M = q = null;
      }
    }, X = w.effect = new Cn(
      G,
      Ge,
      () => No(z),
      w.scope
      // track it in component's effect scope
    ), z = w.update = () => {
      X.dirty && X.run();
    };
    z.i = w, z.id = w.uid, gi(w, !0), process.env.NODE_ENV !== "production" && (X.onTrack = w.rtc ? (re) => Gs(w.rtc, re) : void 0, X.onTrigger = w.rtg ? (re) => Gs(w.rtg, re) : void 0), z();
  }, Z = (w, N, M) => {
    N.component = w;
    const q = w.vnode.props;
    w.vnode = N, w.next = null, b3(w, N.props, q, M), C3(w, N.children, M), Os(), bg(w), Is();
  }, Ce = (w, N, M, q, V, U, J, G, X = !1) => {
    const z = w && w.children, re = w ? w.shapeFlag : 0, ce = N.children, { patchFlag: pe, shapeFlag: ve } = N;
    if (pe > 0) {
      if (pe & 128) {
        ee(
          z,
          ce,
          M,
          q,
          V,
          U,
          J,
          G,
          X
        );
        return;
      } else if (pe & 256) {
        Ve(
          z,
          ce,
          M,
          q,
          V,
          U,
          J,
          G,
          X
        );
        return;
      }
    }
    ve & 8 ? (re & 16 && L(z, V, U), ce !== z && c(M, ce)) : re & 16 ? ve & 16 ? ee(
      z,
      ce,
      M,
      q,
      V,
      U,
      J,
      G,
      X
    ) : L(z, V, U, !0) : (re & 8 && c(M, ""), ve & 16 && _(
      ce,
      M,
      q,
      V,
      U,
      J,
      G,
      X
    ));
  }, Ve = (w, N, M, q, V, U, J, G, X) => {
    w = w || gn, N = N || gn;
    const z = w.length, re = N.length, ce = Math.min(z, re);
    let pe;
    for (pe = 0; pe < ce; pe++) {
      const ve = N[pe] = X ? Ws(N[pe]) : qt(N[pe]);
      d(
        w[pe],
        ve,
        M,
        null,
        V,
        U,
        J,
        G,
        X
      );
    }
    z > re ? L(
      w,
      V,
      U,
      !0,
      !1,
      ce
    ) : _(
      N,
      M,
      q,
      V,
      U,
      J,
      G,
      X,
      ce
    );
  }, ee = (w, N, M, q, V, U, J, G, X) => {
    let z = 0;
    const re = N.length;
    let ce = w.length - 1, pe = re - 1;
    for (; z <= ce && z <= pe; ) {
      const ve = w[z], xe = N[z] = X ? Ws(N[z]) : qt(N[z]);
      if (Pr(ve, xe))
        d(
          ve,
          xe,
          M,
          null,
          V,
          U,
          J,
          G,
          X
        );
      else
        break;
      z++;
    }
    for (; z <= ce && z <= pe; ) {
      const ve = w[ce], xe = N[pe] = X ? Ws(N[pe]) : qt(N[pe]);
      if (Pr(ve, xe))
        d(
          ve,
          xe,
          M,
          null,
          V,
          U,
          J,
          G,
          X
        );
      else
        break;
      ce--, pe--;
    }
    if (z > ce) {
      if (z <= pe) {
        const ve = pe + 1, xe = ve < re ? N[ve].el : q;
        for (; z <= pe; )
          d(
            null,
            N[z] = X ? Ws(N[z]) : qt(N[z]),
            M,
            xe,
            V,
            U,
            J,
            G,
            X
          ), z++;
      }
    } else if (z > pe)
      for (; z <= ce; )
        R(w[z], V, U, !0), z++;
    else {
      const ve = z, xe = z, qe = /* @__PURE__ */ new Map();
      for (z = xe; z <= pe; z++) {
        const $t = N[z] = X ? Ws(N[z]) : qt(N[z]);
        $t.key != null && (process.env.NODE_ENV !== "production" && qe.has($t.key) && j(
          "Duplicate keys found during update:",
          JSON.stringify($t.key),
          "Make sure keys are unique."
        ), qe.set($t.key, z));
      }
      let De, ut = 0;
      const xr = pe - xe + 1;
      let un = !1, ag = 0;
      const ca = new Array(xr);
      for (z = 0; z < xr; z++) ca[z] = 0;
      for (z = ve; z <= ce; z++) {
        const $t = w[z];
        if (ut >= xr) {
          R($t, V, U, !0);
          continue;
        }
        let Dr;
        if ($t.key != null)
          Dr = qe.get($t.key);
        else
          for (De = xe; De <= pe; De++)
            if (ca[De - xe] === 0 && Pr($t, N[De])) {
              Dr = De;
              break;
            }
        Dr === void 0 ? R($t, V, U, !0) : (ca[Dr - xe] = z + 1, Dr >= ag ? ag = Dr : un = !0, d(
          $t,
          N[Dr],
          M,
          null,
          V,
          U,
          J,
          G,
          X
        ), ut++);
      }
      const og = un ? V3(ca) : gn;
      for (De = og.length - 1, z = xr - 1; z >= 0; z--) {
        const $t = xe + z, Dr = N[$t], ug = $t + 1 < re ? N[$t + 1].el : q;
        ca[z] === 0 ? d(
          null,
          Dr,
          M,
          ug,
          V,
          U,
          J,
          G,
          X
        ) : un && (De < 0 || z !== og[De] ? k(Dr, M, ug, 2) : De--);
      }
    }
  }, k = (w, N, M, q, V = null) => {
    const { el: U, type: J, transition: G, children: X, shapeFlag: z } = w;
    if (z & 6) {
      k(w.component.subTree, N, M, q);
      return;
    }
    if (z & 128) {
      w.suspense.move(N, M, q);
      return;
    }
    if (z & 64) {
      J.move(w, N, M, me);
      return;
    }
    if (J === ct) {
      s(U, N, M);
      for (let ce = 0; ce < X.length; ce++)
        k(X[ce], N, M, q);
      s(w.anchor, N, M);
      return;
    }
    if (J === Es) {
      b(w, N, M);
      return;
    }
    if (q !== 2 && z & 1 && G)
      if (q === 0)
        G.beforeEnter(U), s(U, N, M), mt(() => G.enter(U), V);
      else {
        const { leave: ce, delayLeave: pe, afterLeave: ve } = G, xe = () => s(U, N, M), qe = () => {
          ce(U, () => {
            xe(), ve && ve();
          });
        };
        pe ? pe(U, xe, qe) : qe();
      }
    else
      s(U, N, M);
  }, R = (w, N, M, q = !1, V = !1) => {
    const {
      type: U,
      props: J,
      ref: G,
      children: X,
      dynamicChildren: z,
      shapeFlag: re,
      patchFlag: ce,
      dirs: pe,
      cacheIndex: ve
    } = w;
    if (ce === -2 && (V = !1), G != null && nl(G, null, M, w, !0), ve != null && (N.renderCache[ve] = void 0), re & 256) {
      N.ctx.deactivate(w);
      return;
    }
    const xe = re & 1 && pe, qe = !Di(w);
    let De;
    if (qe && (De = J && J.onVnodeBeforeUnmount) && Kt(De, N, w), re & 6)
      ie(w.component, M, q);
    else {
      if (re & 128) {
        w.suspense.unmount(M, q);
        return;
      }
      xe && Mr(w, null, N, "beforeUnmount"), re & 64 ? w.type.remove(
        w,
        N,
        M,
        me,
        q
      ) : z && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !z.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (U !== ct || ce > 0 && ce & 64) ? L(
        z,
        N,
        M,
        !1,
        !0
      ) : (U === ct && ce & 384 || !V && re & 16) && L(X, N, M), q && D(w);
    }
    (qe && (De = J && J.onVnodeUnmounted) || xe) && mt(() => {
      De && Kt(De, N, w), xe && Mr(w, null, N, "unmounted");
    }, M);
  }, D = (w) => {
    const { type: N, el: M, anchor: q, transition: V } = w;
    if (N === ct) {
      process.env.NODE_ENV !== "production" && w.patchFlag > 0 && w.patchFlag & 2048 && V && !V.persisted ? w.children.forEach((J) => {
        J.type === Je ? i(J.el) : D(J);
      }) : B(M, q);
      return;
    }
    if (N === Es) {
      v(w);
      return;
    }
    const U = () => {
      i(M), V && !V.persisted && V.afterLeave && V.afterLeave();
    };
    if (w.shapeFlag & 1 && V && !V.persisted) {
      const { leave: J, delayLeave: G } = V, X = () => J(M, U);
      G ? G(w.el, U, X) : X();
    } else
      U();
  }, B = (w, N) => {
    let M;
    for (; w !== N; )
      M = p(w), i(w), w = M;
    i(N);
  }, ie = (w, N, M) => {
    process.env.NODE_ENV !== "production" && w.type.__hmrId && yP(w);
    const { bum: q, scope: V, update: U, subTree: J, um: G, m: X, a: z } = w;
    ol(X), ol(z), q && Gs(q), V.stop(), U && (U.active = !1, R(J, w, N, M)), G && mt(G, N), mt(() => {
      w.isUnmounted = !0;
    }, N), N && N.pendingBranch && !N.isUnmounted && w.asyncDep && !w.asyncResolved && w.suspenseId === N.pendingId && (N.deps--, N.deps === 0 && N.resolve()), process.env.NODE_ENV !== "production" && xP(w);
  }, L = (w, N, M, q = !1, V = !1, U = 0) => {
    for (let J = U; J < w.length; J++)
      R(w[J], N, M, q, V);
  }, ne = (w) => {
    if (w.shapeFlag & 6)
      return ne(w.component.subTree);
    if (w.shapeFlag & 128)
      return w.suspense.next();
    const N = p(w.anchor || w.el), M = N && N[Ov];
    return M ? p(M) : N;
  };
  let ye = !1;
  const be = (w, N, M) => {
    w == null ? N._vnode && R(N._vnode, null, null, !0) : d(
      N._vnode || null,
      w,
      N,
      null,
      null,
      null,
      M
    ), N._vnode = w, ye || (ye = !0, bg(), tl(), ye = !1);
  }, me = {
    p: d,
    um: R,
    m: k,
    r: D,
    mt: W,
    mc: _,
    pc: Ce,
    pbc: P,
    n: ne,
    o: r
  };
  let ke, Ke;
  return e && ([ke, Ke] = e(
    me
  )), {
    render: be,
    hydrate: ke,
    createApp: d3(be, ke)
  };
}
function Tf({ type: r, props: e }, t) {
  return t === "svg" && r === "foreignObject" || t === "mathml" && r === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t;
}
function gi({ effect: r, update: e }, t) {
  r.allowRecurse = e.allowRecurse = t;
}
function $v(r, e) {
  return (!r || r && !r.pendingBranch) && e && !e.persisted;
}
function $a(r, e, t = !1) {
  const s = r.children, i = e.children;
  if (se(s) && se(i))
    for (let n = 0; n < s.length; n++) {
      const a = s[n];
      let o = i[n];
      o.shapeFlag & 1 && !o.dynamicChildren && ((o.patchFlag <= 0 || o.patchFlag === 32) && (o = i[n] = Ws(i[n]), o.el = a.el), !t && o.patchFlag !== -2 && $a(a, o)), o.type === Xr && (o.el = a.el), process.env.NODE_ENV !== "production" && o.type === Je && !o.el && (o.el = a.el);
    }
}
function V3(r) {
  const e = r.slice(), t = [0];
  let s, i, n, a, o;
  const u = r.length;
  for (s = 0; s < u; s++) {
    const l = r[s];
    if (l !== 0) {
      if (i = t[t.length - 1], r[i] < l) {
        e[s] = i, t.push(s);
        continue;
      }
      for (n = 0, a = t.length - 1; n < a; )
        o = n + a >> 1, r[t[o]] < l ? n = o + 1 : a = o;
      l < r[t[n]] && (n > 0 && (e[s] = t[n - 1]), t[n] = s);
    }
  }
  for (n = t.length, a = t[n - 1]; n-- > 0; )
    t[n] = a, a = e[a];
  return t;
}
function Fv(r) {
  const e = r.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : Fv(e);
}
function ol(r) {
  if (r)
    for (let e = 0; e < r.length; e++) r[e].active = !1;
}
const ko = Symbol.for("v-scx"), Bv = () => {
  {
    const r = Ra(ko);
    return r || process.env.NODE_ENV !== "production" && j(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), r;
  }
};
function U3(r, e) {
  return Do(r, null, e);
}
function Vv(r, e) {
  return Do(
    r,
    null,
    process.env.NODE_ENV !== "production" ? Be({}, e, { flush: "post" }) : { flush: "post" }
  );
}
function Uv(r, e) {
  return Do(
    r,
    null,
    process.env.NODE_ENV !== "production" ? Be({}, e, { flush: "sync" }) : { flush: "sync" }
  );
}
const nu = {};
function Fa(r, e, t) {
  return process.env.NODE_ENV !== "production" && !fe(e) && j(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), Do(r, e, t);
}
function Do(r, e, {
  immediate: t,
  deep: s,
  flush: i,
  once: n,
  onTrack: a,
  onTrigger: o
} = Oe) {
  if (e && n) {
    const C = e;
    e = (...x) => {
      C(...x), A();
    };
  }
  process.env.NODE_ENV !== "production" && s !== void 0 && typeof s == "number" && j(
    'watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.'
  ), process.env.NODE_ENV !== "production" && !e && (t !== void 0 && j(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), s !== void 0 && j(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), n !== void 0 && j(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const u = (C) => {
    j(
      "Invalid watch source: ",
      C,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, l = nt, c = (C) => s === !0 ? C : (
    // for deep: false, only traverse root-level properties
    Xs(C, s === !1 ? 1 : void 0)
  );
  let f, p = !1, h = !1;
  if (pt(r) ? (f = () => r.value, p = Gr(r)) : Zs(r) ? (f = () => c(r), p = !0) : se(r) ? (h = !0, p = r.some((C) => Zs(C) || Gr(C)), f = () => r.map((C) => {
    if (pt(C))
      return C.value;
    if (Zs(C))
      return c(C);
    if (fe(C))
      return Kr(C, l, 2);
    process.env.NODE_ENV !== "production" && u(C);
  })) : fe(r) ? e ? f = () => Kr(r, l, 2) : f = () => (m && m(), ar(
    r,
    l,
    3,
    [d]
  )) : (f = Ge, process.env.NODE_ENV !== "production" && u(r)), e && s) {
    const C = f;
    f = () => Xs(C());
  }
  let m, d = (C) => {
    m = b.onStop = () => {
      Kr(C, l, 4), m = b.onStop = void 0;
    };
  }, y;
  if (Lo)
    if (d = Ge, e ? t && ar(e, l, 3, [
      f(),
      h ? [] : void 0,
      d
    ]) : f(), i === "sync") {
      const C = Bv();
      y = C.__watcherHandles || (C.__watcherHandles = []);
    } else
      return Ge;
  let S = h ? new Array(r.length).fill(nu) : nu;
  const E = () => {
    if (!(!b.active || !b.dirty))
      if (e) {
        const C = b.run();
        (s || p || (h ? C.some((x, _) => jt(x, S[_])) : jt(C, S))) && (m && m(), ar(e, l, 3, [
          C,
          // pass undefined as the old value when it's changed for the first time
          S === nu ? void 0 : h && S[0] === nu ? [] : S,
          d
        ]), S = C);
      } else
        b.run();
  };
  E.allowRecurse = !!e;
  let g;
  i === "sync" ? g = E : i === "post" ? g = () => mt(E, l && l.suspense) : (E.pre = !0, l && (E.id = l.uid), g = () => No(E));
  const b = new Cn(f, Ge, g), v = Ib(), A = () => {
    b.stop(), v && td(v.effects, b);
  };
  return process.env.NODE_ENV !== "production" && (b.onTrack = a, b.onTrigger = o), e ? t ? E() : S = b.run() : i === "post" ? mt(
    b.run.bind(b),
    l && l.suspense
  ) : b.run(), y && y.push(A), A;
}
function j3(r, e, t) {
  const s = this.proxy, i = _e(r) ? r.includes(".") ? jv(s, r) : () => s[r] : r.bind(s, s);
  let n;
  fe(e) ? n = e : (n = e.handler, t = e);
  const a = zi(this), o = Do(i, n.bind(s), t);
  return a(), o;
}
function jv(r, e) {
  const t = e.split(".");
  return () => {
    let s = r;
    for (let i = 0; i < t.length && s; i++)
      s = s[t[i]];
    return s;
  };
}
function Xs(r, e = 1 / 0, t) {
  if (e <= 0 || !Ae(r) || r.__v_skip || (t = t || /* @__PURE__ */ new Set(), t.has(r)))
    return r;
  if (t.add(r), e--, pt(r))
    Xs(r.value, e, t);
  else if (se(r))
    for (let s = 0; s < r.length; s++)
      Xs(r[s], e, t);
  else if (Qi(r) || Ci(r))
    r.forEach((s) => {
      Xs(s, e, t);
    });
  else if (wb(r)) {
    for (const s in r)
      Xs(r[s], e, t);
    for (const s of Object.getOwnPropertySymbols(r))
      Object.prototype.propertyIsEnumerable.call(r, s) && Xs(r[s], e, t);
  }
  return r;
}
function q3(r, e, t = Oe) {
  const s = is();
  if (process.env.NODE_ENV !== "production" && !s)
    return j("useModel() called without active instance."), Ii();
  if (process.env.NODE_ENV !== "production" && !s.propsOptions[0][e])
    return j(`useModel() called with prop "${e}" which is not declared.`), Ii();
  const i = Et(e), n = Tt(e), a = qv(r, e), o = Jb((u, l) => {
    let c, f = Oe, p;
    return Uv(() => {
      const h = r[e];
      jt(c, h) && (c = h, l());
    }), {
      get() {
        return u(), t.get ? t.get(c) : c;
      },
      set(h) {
        const m = t.set ? t.set(h) : h;
        if (!jt(m, c) && !(f !== Oe && jt(h, f)))
          return;
        const d = s.vnode.props;
        d && // check if parent has passed v-model
        (e in d || i in d || n in d) && (`onUpdate:${e}` in d || `onUpdate:${i}` in d || `onUpdate:${n}` in d) || (c = h, l()), s.emit(`update:${e}`, m), jt(h, m) && jt(h, f) && !jt(m, p) && l(), f = h, p = m;
      }
    };
  });
  return o[Symbol.iterator] = () => {
    let u = 0;
    return {
      next() {
        return u < 2 ? { value: u++ ? a || Oe : o, done: !1 } : { done: !0 };
      }
    };
  }, o;
}
const qv = (r, e) => e === "modelValue" || e === "model-value" ? r.modelModifiers : r[`${e}Modifiers`] || r[`${Et(e)}Modifiers`] || r[`${Tt(e)}Modifiers`];
function H3(r, e, ...t) {
  if (r.isUnmounted) return;
  const s = r.vnode.props || Oe;
  if (process.env.NODE_ENV !== "production") {
    const {
      emitsOptions: c,
      propsOptions: [f]
    } = r;
    if (c)
      if (!(e in c))
        (!f || !(ps(Et(e)) in f)) && j(
          `Component emitted event "${e}" but it is neither declared in the emits option nor as an "${ps(Et(e))}" prop.`
        );
      else {
        const p = c[e];
        fe(p) && (p(...t) || j(
          `Invalid event arguments: event validation failed for event "${e}".`
        ));
      }
  }
  let i = t;
  const n = e.startsWith("update:"), a = n && qv(s, e.slice(7));
  if (a && (a.trim && (i = t.map((c) => _e(c) ? c.trim() : c)), a.number && (i = t.map(Qu))), process.env.NODE_ENV !== "production" && PP(r, e, i), process.env.NODE_ENV !== "production") {
    const c = e.toLowerCase();
    c !== e && s[ps(c)] && j(
      `Event "${c}" is emitted in component ${mc(
        r,
        r.type
      )} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Tt(
        e
      )}" instead of "${e}".`
    );
  }
  let o, u = s[o = ps(e)] || // also try camelCase event handler (#2249)
  s[o = ps(Et(e))];
  !u && n && (u = s[o = ps(Tt(e))]), u && ar(
    u,
    r,
    6,
    i
  );
  const l = s[o + "Once"];
  if (l) {
    if (!r.emitted)
      r.emitted = {};
    else if (r.emitted[o])
      return;
    r.emitted[o] = !0, ar(
      l,
      r,
      6,
      i
    );
  }
}
function Hv(r, e, t = !1) {
  const s = e.emitsCache, i = s.get(r);
  if (i !== void 0)
    return i;
  const n = r.emits;
  let a = {}, o = !1;
  if (!fe(r)) {
    const u = (l) => {
      const c = Hv(l, e, !0);
      c && (o = !0, Be(a, c));
    };
    !t && e.mixins.length && e.mixins.forEach(u), r.extends && u(r.extends), r.mixins && r.mixins.forEach(u);
  }
  return !n && !o ? (Ae(r) && s.set(r, null), null) : (se(n) ? n.forEach((u) => a[u] = null) : Be(a, n), Ae(r) && s.set(r, a), a);
}
function pc(r, e) {
  return !r || !Yi(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Pe(r, e[0].toLowerCase() + e.slice(1)) || Pe(r, Tt(e)) || Pe(r, e));
}
let vp = !1;
function ul() {
  vp = !0;
}
function Nu(r) {
  const {
    type: e,
    vnode: t,
    proxy: s,
    withProxy: i,
    propsOptions: [n],
    slots: a,
    attrs: o,
    emit: u,
    render: l,
    renderCache: c,
    props: f,
    data: p,
    setupState: h,
    ctx: m,
    inheritAttrs: d
  } = r, y = so(r);
  let S, E;
  process.env.NODE_ENV !== "production" && (vp = !1);
  try {
    if (t.shapeFlag & 4) {
      const v = i || s, A = process.env.NODE_ENV !== "production" && h.__isScriptSetup ? new Proxy(v, {
        get(C, x, _) {
          return j(
            `Property '${String(
              x
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(C, x, _);
        }
      }) : v;
      S = qt(
        l.call(
          A,
          v,
          c,
          process.env.NODE_ENV !== "production" ? Ar(f) : f,
          h,
          p,
          m
        )
      ), E = o;
    } else {
      const v = e;
      process.env.NODE_ENV !== "production" && o === f && ul(), S = qt(
        v.length > 1 ? v(
          process.env.NODE_ENV !== "production" ? Ar(f) : f,
          process.env.NODE_ENV !== "production" ? {
            get attrs() {
              return ul(), Ar(o);
            },
            slots: a,
            emit: u
          } : { attrs: o, slots: a, emit: u }
        ) : v(
          process.env.NODE_ENV !== "production" ? Ar(f) : f,
          null
        )
      ), E = e.props ? o : W3(o);
    }
  } catch (v) {
    Ba.length = 0, ci(v, r, 1), S = He(Je);
  }
  let g = S, b;
  if (process.env.NODE_ENV !== "production" && S.patchFlag > 0 && S.patchFlag & 2048 && ([g, b] = Wv(S)), E && d !== !1) {
    const v = Object.keys(E), { shapeFlag: A } = g;
    if (v.length) {
      if (A & 7)
        n && v.some(Yu) && (E = z3(
          E,
          n
        )), g = yr(g, E, !1, !0);
      else if (process.env.NODE_ENV !== "production" && !vp && g.type !== Je) {
        const C = Object.keys(o), x = [], _ = [];
        for (let T = 0, P = C.length; T < P; T++) {
          const I = C[T];
          Yi(I) ? Yu(I) || x.push(I[2].toLowerCase() + I.slice(3)) : _.push(I);
        }
        _.length && j(
          `Extraneous non-props attributes (${_.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
        ), x.length && j(
          `Extraneous non-emits event listeners (${x.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return t.dirs && (process.env.NODE_ENV !== "production" && !Dg(g) && j(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), g = yr(g, null, !1, !0), g.dirs = g.dirs ? g.dirs.concat(t.dirs) : t.dirs), t.transition && (process.env.NODE_ENV !== "production" && !Dg(g) && j(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), g.transition = t.transition), process.env.NODE_ENV !== "production" && b ? b(g) : S = g, so(y), S;
}
const Wv = (r) => {
  const e = r.children, t = r.dynamicChildren, s = hc(e, !1);
  if (s) {
    if (process.env.NODE_ENV !== "production" && s.patchFlag > 0 && s.patchFlag & 2048)
      return Wv(s);
  } else return [r, void 0];
  const i = e.indexOf(s), n = t ? t.indexOf(s) : -1, a = (o) => {
    e[i] = o, t && (n > -1 ? t[n] = o : o.patchFlag > 0 && (r.dynamicChildren = [...t, o]));
  };
  return [qt(s), a];
};
function hc(r, e = !0) {
  let t;
  for (let s = 0; s < r.length; s++) {
    const i = r[s];
    if (ws(i)) {
      if (i.type !== Je || i.children === "v-if") {
        if (t)
          return;
        if (t = i, process.env.NODE_ENV !== "production" && e && t.patchFlag > 0 && t.patchFlag & 2048)
          return hc(t.children);
      }
    } else
      return;
  }
  return t;
}
const W3 = (r) => {
  let e;
  for (const t in r)
    (t === "class" || t === "style" || Yi(t)) && ((e || (e = {}))[t] = r[t]);
  return e;
}, z3 = (r, e) => {
  const t = {};
  for (const s in r)
    (!Yu(s) || !(s.slice(9) in e)) && (t[s] = r[s]);
  return t;
}, Dg = (r) => r.shapeFlag & 7 || r.type === Je;
function G3(r, e, t) {
  const { props: s, children: i, component: n } = r, { props: a, children: o, patchFlag: u } = e, l = n.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (i || o) && ei || e.dirs || e.transition)
    return !0;
  if (t && u >= 0) {
    if (u & 1024)
      return !0;
    if (u & 16)
      return s ? Lg(s, a, l) : !!a;
    if (u & 8) {
      const c = e.dynamicProps;
      for (let f = 0; f < c.length; f++) {
        const p = c[f];
        if (a[p] !== s[p] && !pc(l, p))
          return !0;
      }
    }
  } else
    return (i || o) && (!o || !o.$stable) ? !0 : s === a ? !1 : s ? a ? Lg(s, a, l) : !0 : !!a;
  return !1;
}
function Lg(r, e, t) {
  const s = Object.keys(e);
  if (s.length !== Object.keys(r).length)
    return !0;
  for (let i = 0; i < s.length; i++) {
    const n = s[i];
    if (e[n] !== r[n] && !pc(t, n))
      return !0;
  }
  return !1;
}
function Id({ vnode: r, parent: e }, t) {
  for (; e; ) {
    const s = e.subTree;
    if (s.suspense && s.suspense.activeBranch === r && (s.el = r.el), s === r)
      (r = e.vnode).el = t, e = e.parent;
    else
      break;
  }
}
const Ep = (r) => r.__isSuspense;
let Sp = 0;
const K3 = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: !0,
  process(r, e, t, s, i, n, a, o, u, l) {
    if (r == null)
      J3(
        e,
        t,
        s,
        i,
        n,
        a,
        o,
        u,
        l
      );
    else {
      if (n && n.deps > 0 && !r.suspense.isInFallback) {
        e.suspense = r.suspense, e.suspense.vnode = e, e.el = r.el;
        return;
      }
      Y3(
        r,
        e,
        t,
        s,
        i,
        a,
        o,
        u,
        l
      );
    }
  },
  hydrate: Q3,
  normalize: Z3
}, X3 = K3;
function no(r, e) {
  const t = r.props && r.props[e];
  fe(t) && t();
}
function J3(r, e, t, s, i, n, a, o, u) {
  const {
    p: l,
    o: { createElement: c }
  } = u, f = c("div"), p = r.suspense = zv(
    r,
    i,
    s,
    e,
    f,
    t,
    n,
    a,
    o,
    u
  );
  l(
    null,
    p.pendingBranch = r.ssContent,
    f,
    null,
    s,
    p,
    n,
    a
  ), p.deps > 0 ? (no(r, "onPending"), no(r, "onFallback"), l(
    null,
    r.ssFallback,
    e,
    t,
    s,
    null,
    // fallback tree will not have suspense context
    n,
    a
  ), En(p, r.ssFallback)) : p.resolve(!1, !0);
}
function Y3(r, e, t, s, i, n, a, o, { p: u, um: l, o: { createElement: c } }) {
  const f = e.suspense = r.suspense;
  f.vnode = e, e.el = r.el;
  const p = e.ssContent, h = e.ssFallback, { activeBranch: m, pendingBranch: d, isInFallback: y, isHydrating: S } = f;
  if (d)
    f.pendingBranch = p, Pr(p, d) ? (u(
      d,
      p,
      f.hiddenContainer,
      null,
      i,
      f,
      n,
      a,
      o
    ), f.deps <= 0 ? f.resolve() : y && (S || (u(
      m,
      h,
      t,
      s,
      i,
      null,
      // fallback tree will not have suspense context
      n,
      a,
      o
    ), En(f, h)))) : (f.pendingId = Sp++, S ? (f.isHydrating = !1, f.activeBranch = d) : l(d, i, f), f.deps = 0, f.effects.length = 0, f.hiddenContainer = c("div"), y ? (u(
      null,
      p,
      f.hiddenContainer,
      null,
      i,
      f,
      n,
      a,
      o
    ), f.deps <= 0 ? f.resolve() : (u(
      m,
      h,
      t,
      s,
      i,
      null,
      // fallback tree will not have suspense context
      n,
      a,
      o
    ), En(f, h))) : m && Pr(p, m) ? (u(
      m,
      p,
      t,
      s,
      i,
      f,
      n,
      a,
      o
    ), f.resolve(!0)) : (u(
      null,
      p,
      f.hiddenContainer,
      null,
      i,
      f,
      n,
      a,
      o
    ), f.deps <= 0 && f.resolve()));
  else if (m && Pr(p, m))
    u(
      m,
      p,
      t,
      s,
      i,
      f,
      n,
      a,
      o
    ), En(f, p);
  else if (no(e, "onPending"), f.pendingBranch = p, p.shapeFlag & 512 ? f.pendingId = p.component.suspenseId : f.pendingId = Sp++, u(
    null,
    p,
    f.hiddenContainer,
    null,
    i,
    f,
    n,
    a,
    o
  ), f.deps <= 0)
    f.resolve();
  else {
    const { timeout: E, pendingId: g } = f;
    E > 0 ? setTimeout(() => {
      f.pendingId === g && f.fallback(h);
    }, E) : E === 0 && f.fallback(h);
  }
}
let Mg = !1;
function zv(r, e, t, s, i, n, a, o, u, l, c = !1) {
  process.env.NODE_ENV !== "production" && !Mg && (Mg = !0, console[console.info ? "info" : "log"](
    "<Suspense> is an experimental feature and its API will likely change."
  ));
  const {
    p: f,
    m: p,
    um: h,
    n: m,
    o: { parentNode: d, remove: y }
  } = l;
  let S;
  const E = eA(r);
  E && e && e.pendingBranch && (S = e.pendingId, e.deps++);
  const g = r.props ? Zu(r.props.timeout) : void 0;
  process.env.NODE_ENV !== "production" && md(g, "Suspense timeout");
  const b = n, v = {
    vnode: r,
    parent: e,
    parentComponent: t,
    namespace: a,
    container: s,
    hiddenContainer: i,
    deps: 0,
    pendingId: Sp++,
    timeout: typeof g == "number" ? g : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !c,
    isHydrating: c,
    isUnmounted: !1,
    effects: [],
    resolve(A = !1, C = !1) {
      if (process.env.NODE_ENV !== "production") {
        if (!A && !v.pendingBranch)
          throw new Error(
            "suspense.resolve() is called without a pending branch."
          );
        if (v.isUnmounted)
          throw new Error(
            "suspense.resolve() is called on an already unmounted suspense boundary."
          );
      }
      const {
        vnode: x,
        activeBranch: _,
        pendingBranch: T,
        pendingId: P,
        effects: I,
        parentComponent: $,
        container: Y
      } = v;
      let W = !1;
      v.isHydrating ? v.isHydrating = !1 : A || (W = _ && T.transition && T.transition.mode === "out-in", W && (_.transition.afterLeave = () => {
        P === v.pendingId && (p(
          T,
          Y,
          n === b ? m(_) : n,
          0
        ), to(I));
      }), _ && (d(_.el) !== v.hiddenContainer && (n = m(_)), h(_, $, v, !0)), W || p(T, Y, n, 0)), En(v, T), v.pendingBranch = null, v.isInFallback = !1;
      let F = v.parent, K = !1;
      for (; F; ) {
        if (F.pendingBranch) {
          F.effects.push(...I), K = !0;
          break;
        }
        F = F.parent;
      }
      !K && !W && to(I), v.effects = [], E && e && e.pendingBranch && S === e.pendingId && (e.deps--, e.deps === 0 && !C && e.resolve()), no(x, "onResolve");
    },
    fallback(A) {
      if (!v.pendingBranch)
        return;
      const { vnode: C, activeBranch: x, parentComponent: _, container: T, namespace: P } = v;
      no(C, "onFallback");
      const I = m(x), $ = () => {
        v.isInFallback && (f(
          null,
          A,
          T,
          I,
          _,
          null,
          // fallback tree will not have suspense context
          P,
          o,
          u
        ), En(v, A));
      }, Y = A.transition && A.transition.mode === "out-in";
      Y && (x.transition.afterLeave = $), v.isInFallback = !0, h(
        x,
        _,
        null,
        // no suspense so unmount hooks fire now
        !0
        // shouldRemove
      ), Y || $();
    },
    move(A, C, x) {
      v.activeBranch && p(v.activeBranch, A, C, x), v.container = A;
    },
    next() {
      return v.activeBranch && m(v.activeBranch);
    },
    registerDep(A, C, x) {
      const _ = !!v.pendingBranch;
      _ && v.deps++;
      const T = A.vnode.el;
      A.asyncDep.catch((P) => {
        ci(P, A, 0);
      }).then((P) => {
        if (A.isUnmounted || v.isUnmounted || v.pendingId !== A.suspenseId)
          return;
        A.asyncResolved = !0;
        const { vnode: I } = A;
        process.env.NODE_ENV !== "production" && Da(I), Ap(A, P, !1), T && (I.el = T);
        const $ = !T && A.subTree.el;
        C(
          A,
          I,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          d(T || A.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          T ? null : m(A.subTree),
          v,
          a,
          x
        ), $ && y($), Id(A, I.el), process.env.NODE_ENV !== "production" && La(), _ && --v.deps === 0 && v.resolve();
      });
    },
    unmount(A, C) {
      v.isUnmounted = !0, v.activeBranch && h(
        v.activeBranch,
        t,
        A,
        C
      ), v.pendingBranch && h(
        v.pendingBranch,
        t,
        A,
        C
      );
    }
  };
  return v;
}
function Q3(r, e, t, s, i, n, a, o, u) {
  const l = e.suspense = zv(
    e,
    s,
    t,
    r.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    i,
    n,
    a,
    o,
    !0
  ), c = u(
    r,
    l.pendingBranch = e.ssContent,
    t,
    l,
    n,
    a
  );
  return l.deps === 0 && l.resolve(!1, !0), c;
}
function Z3(r) {
  const { shapeFlag: e, children: t } = r, s = e & 32;
  r.ssContent = Rg(
    s ? t.default : t
  ), r.ssFallback = s ? Rg(t.fallback) : He(Je);
}
function Rg(r) {
  let e;
  if (fe(r)) {
    const t = Wi && r._c;
    t && (r._d = !1, dc()), r = r(), t && (r._d = !0, e = Lt, Kv());
  }
  if (se(r)) {
    const t = hc(r);
    process.env.NODE_ENV !== "production" && !t && r.filter((s) => s !== Td).length > 0 && j("<Suspense> slots expect a single root node."), r = t;
  }
  return r = qt(r), e && !r.dynamicChildren && (r.dynamicChildren = e.filter((t) => t !== r)), r;
}
function Gv(r, e) {
  e && e.pendingBranch ? se(r) ? e.effects.push(...r) : e.effects.push(r) : to(r);
}
function En(r, e) {
  r.activeBranch = e;
  const { vnode: t, parentComponent: s } = r;
  let i = e.el;
  for (; !i && e.component; )
    e = e.component.subTree, i = e.el;
  t.el = i, s && s.subTree === t && (s.vnode.el = i, Id(s, i));
}
function eA(r) {
  const e = r.props && r.props.suspensible;
  return e != null && e !== !1;
}
const ct = Symbol.for("v-fgt"), Xr = Symbol.for("v-txt"), Je = Symbol.for("v-cmt"), Es = Symbol.for("v-stc"), Ba = [];
let Lt = null;
function dc(r = !1) {
  Ba.push(Lt = r ? null : []);
}
function Kv() {
  Ba.pop(), Lt = Ba[Ba.length - 1] || null;
}
let Wi = 1;
function _p(r) {
  Wi += r, r < 0 && Lt && (Lt.hasOnce = !0);
}
function Xv(r) {
  return r.dynamicChildren = Wi > 0 ? Lt || gn : null, Kv(), Wi > 0 && Lt && Lt.push(r), r;
}
function tA(r, e, t, s, i, n) {
  return Xv(
    Dd(
      r,
      e,
      t,
      s,
      i,
      n,
      !0
    )
  );
}
function kd(r, e, t, s, i) {
  return Xv(
    He(
      r,
      e,
      t,
      s,
      i,
      !0
    )
  );
}
function ws(r) {
  return r ? r.__v_isVNode === !0 : !1;
}
function Pr(r, e) {
  if (process.env.NODE_ENV !== "production" && e.shapeFlag & 6 && r.component) {
    const t = Cu.get(e.type);
    if (t && t.has(r.component))
      return r.shapeFlag &= -257, e.shapeFlag &= -513, !1;
  }
  return r.type === e.type && r.key === e.key;
}
let xp;
function rA(r) {
  xp = r;
}
const sA = (...r) => Yv(
  ...xp ? xp(r, st) : r
), Jv = ({ key: r }) => r ?? null, Ou = ({
  ref: r,
  ref_key: e,
  ref_for: t
}) => (typeof r == "number" && (r = "" + r), r != null ? _e(r) || pt(r) || fe(r) ? { i: st, r, k: e, f: !!t } : r : null);
function Dd(r, e = null, t = null, s = 0, i = null, n = r === ct ? 0 : 1, a = !1, o = !1) {
  const u = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r,
    props: e,
    key: e && Jv(e),
    ref: e && Ou(e),
    scopeId: ac,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: n,
    patchFlag: s,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: st
  };
  return o ? (Md(u, t), n & 128 && r.normalize(u)) : t && (u.shapeFlag |= _e(t) ? 8 : 16), process.env.NODE_ENV !== "production" && u.key !== u.key && j("VNode created with invalid key (NaN). VNode type:", u.type), Wi > 0 && // avoid a block node from tracking itself
  !a && // has current parent block
  Lt && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (u.patchFlag > 0 || n & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  u.patchFlag !== 32 && Lt.push(u), u;
}
const He = process.env.NODE_ENV !== "production" ? sA : Yv;
function Yv(r, e = null, t = null, s = 0, i = null, n = !1) {
  if ((!r || r === Td) && (process.env.NODE_ENV !== "production" && !r && j(`Invalid vnode type when creating vnode: ${r}.`), r = Je), ws(r)) {
    const o = yr(
      r,
      e,
      !0
      /* mergeRef: true */
    );
    return t && Md(o, t), Wi > 0 && !n && Lt && (o.shapeFlag & 6 ? Lt[Lt.indexOf(r)] = o : Lt.push(o)), o.patchFlag = -2, o;
  }
  if (nE(r) && (r = r.__vccOpts), e) {
    e = Qv(e);
    let { class: o, style: u } = e;
    o && !_e(o) && (e.class = en(o)), Ae(u) && (Qa(u) && !se(u) && (u = Be({}, u)), e.style = Zi(u));
  }
  const a = _e(r) ? 1 : Ep(r) ? 128 : N3(r) ? 64 : Ae(r) ? 4 : fe(r) ? 2 : 0;
  return process.env.NODE_ENV !== "production" && a & 4 && Qa(r) && (r = Ee(r), j(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    r
  )), Dd(
    r,
    e,
    t,
    s,
    i,
    a,
    n,
    !0
  );
}
function Qv(r) {
  return r ? Qa(r) || xv(r) ? Be({}, r) : r : null;
}
function yr(r, e, t = !1, s = !1) {
  const { props: i, ref: n, patchFlag: a, children: o, transition: u } = r, l = e ? Rd(i || {}, e) : i, c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r.type,
    props: l,
    key: l && Jv(l),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      t && n ? se(n) ? n.concat(Ou(e)) : [n, Ou(e)] : Ou(e)
    ) : n,
    scopeId: r.scopeId,
    slotScopeIds: r.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && a === -1 && se(o) ? o.map(Zv) : o,
    target: r.target,
    targetStart: r.targetStart,
    targetAnchor: r.targetAnchor,
    staticCount: r.staticCount,
    shapeFlag: r.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && r.type !== ct ? a === -1 ? 16 : a | 16 : a,
    dynamicProps: r.dynamicProps,
    dynamicChildren: r.dynamicChildren,
    appContext: r.appContext,
    dirs: r.dirs,
    transition: u,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: r.component,
    suspense: r.suspense,
    ssContent: r.ssContent && yr(r.ssContent),
    ssFallback: r.ssFallback && yr(r.ssFallback),
    el: r.el,
    anchor: r.anchor,
    ctx: r.ctx,
    ce: r.ce
  };
  return u && s && ni(
    c,
    u.clone(c)
  ), c;
}
function Zv(r) {
  const e = yr(r);
  return se(r.children) && (e.children = r.children.map(Zv)), e;
}
function Ld(r = " ", e = 0) {
  return He(Xr, null, r, e);
}
function iA(r, e) {
  const t = He(Es, null, r);
  return t.staticCount = e, t;
}
function nA(r = "", e = !1) {
  return e ? (dc(), kd(Je, null, r)) : He(Je, null, r);
}
function qt(r) {
  return r == null || typeof r == "boolean" ? He(Je) : se(r) ? He(
    ct,
    null,
    // #3666, avoid reference pollution when reusing vnode
    r.slice()
  ) : typeof r == "object" ? Ws(r) : He(Xr, null, String(r));
}
function Ws(r) {
  return r.el === null && r.patchFlag !== -1 || r.memo ? r : yr(r);
}
function Md(r, e) {
  let t = 0;
  const { shapeFlag: s } = r;
  if (e == null)
    e = null;
  else if (se(e))
    t = 16;
  else if (typeof e == "object")
    if (s & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), Md(r, i()), i._c && (i._d = !0));
      return;
    } else {
      t = 32;
      const i = e._;
      !i && !xv(e) ? e._ctx = st : i === 3 && st && (st.slots._ === 1 ? e._ = 1 : (e._ = 2, r.patchFlag |= 1024));
    }
  else fe(e) ? (e = { default: e, _ctx: st }, t = 32) : (e = String(e), s & 64 ? (t = 16, e = [Ld(e)]) : t = 8);
  r.children = e, r.shapeFlag |= t;
}
function Rd(...r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const s = r[t];
    for (const i in s)
      if (i === "class")
        e.class !== s.class && (e.class = en([e.class, s.class]));
      else if (i === "style")
        e.style = Zi([e.style, s.style]);
      else if (Yi(i)) {
        const n = e[i], a = s[i];
        a && n !== a && !(se(n) && n.includes(a)) && (e[i] = n ? [].concat(n, a) : a);
      } else i !== "" && (e[i] = s[i]);
  }
  return e;
}
function Kt(r, e, t, s = null) {
  ar(r, e, 7, [
    t,
    s
  ]);
}
const aA = vv();
let oA = 0;
function eE(r, e, t) {
  const s = r.type, i = (e ? e.appContext : r.appContext) || aA, n = {
    uid: oA++,
    vnode: r,
    type: s,
    parent: e,
    appContext: i,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new ad(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Tv(s, i),
    emitsOptions: Hv(s, i),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Oe,
    // inheritAttrs
    inheritAttrs: s.inheritAttrs,
    // state
    ctx: Oe,
    data: Oe,
    props: Oe,
    attrs: Oe,
    slots: Oe,
    refs: Oe,
    setupState: Oe,
    setupContext: null,
    // suspense related
    suspense: t,
    suspenseId: t ? t.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return process.env.NODE_ENV !== "production" ? n.ctx = WP(n) : n.ctx = { _: n }, n.root = e ? e.root : n, n.emit = H3.bind(null, n), r.ce && r.ce(n), n;
}
let nt = null;
const is = () => nt || st;
let ll, wp;
{
  const r = Zl(), e = (t, s) => {
    let i;
    return (i = r[t]) || (i = r[t] = []), i.push(s), (n) => {
      i.length > 1 ? i.forEach((a) => a(n)) : i[0](n);
    };
  };
  ll = e(
    "__VUE_INSTANCE_SETTERS__",
    (t) => nt = t
  ), wp = e(
    "__VUE_SSR_SETTERS__",
    (t) => Lo = t
  );
}
const zi = (r) => {
  const e = nt;
  return ll(r), r.scope.on(), () => {
    r.scope.off(), ll(e);
  };
}, Tp = () => {
  nt && nt.scope.off(), ll(null);
}, uA = /* @__PURE__ */ zt("slot,component");
function Pp(r, { isNativeTag: e }) {
  (uA(r) || e(r)) && j(
    "Do not use built-in or reserved HTML elements as component id: " + r
  );
}
function tE(r) {
  return r.vnode.shapeFlag & 4;
}
let Lo = !1;
function rE(r, e = !1, t = !1) {
  e && wp(e);
  const { props: s, children: i } = r.vnode, n = tE(r);
  g3(r, s, n, e), A3(r, i, t);
  const a = n ? lA(r, e) : void 0;
  return e && wp(!1), a;
}
function lA(r, e) {
  var t;
  const s = r.type;
  if (process.env.NODE_ENV !== "production") {
    if (s.name && Pp(s.name, r.appContext.config), s.components) {
      const n = Object.keys(s.components);
      for (let a = 0; a < n.length; a++)
        Pp(n[a], r.appContext.config);
    }
    if (s.directives) {
      const n = Object.keys(s.directives);
      for (let a = 0; a < n.length; a++)
        nv(n[a]);
    }
    s.compilerOptions && $d() && j(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  r.accessCache = /* @__PURE__ */ Object.create(null), r.proxy = new Proxy(r.ctx, Ma), process.env.NODE_ENV !== "production" && zP(r);
  const { setup: i } = s;
  if (i) {
    const n = r.setupContext = i.length > 1 ? iE(r) : null, a = zi(r);
    Os();
    const o = Kr(
      i,
      r,
      0,
      [
        process.env.NODE_ENV !== "production" ? Ar(r.props) : r.props,
        n
      ]
    );
    if (Is(), a(), es(o)) {
      if (o.then(Tp, Tp), e)
        return o.then((u) => {
          Ap(r, u, e);
        }).catch((u) => {
          ci(u, r, 0);
        });
      if (r.asyncDep = o, process.env.NODE_ENV !== "production" && !r.suspense) {
        const u = (t = s.name) != null ? t : "Anonymous";
        j(
          `Component <${u}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      Ap(r, o, e);
  } else
    sE(r, e);
}
function Ap(r, e, t) {
  fe(e) ? r.type.__ssrInlineRender ? r.ssrRender = e : r.render = e : Ae(e) ? (process.env.NODE_ENV !== "production" && ws(e) && j(
    "setup() should not return VNodes directly - return a render function instead."
  ), process.env.NODE_ENV !== "production" && (r.devtoolsRawSetupState = e), r.setupState = dd(e), process.env.NODE_ENV !== "production" && GP(r)) : process.env.NODE_ENV !== "production" && e !== void 0 && j(
    `setup() should return an object. Received: ${e === null ? "null" : typeof e}`
  ), sE(r, t);
}
let Va, Cp;
function cA(r) {
  Va = r, Cp = (e) => {
    e.render._rc && (e.withProxy = new Proxy(e.ctx, HP));
  };
}
const $d = () => !Va;
function sE(r, e, t) {
  const s = r.type;
  if (!r.render) {
    if (!e && Va && !s.render) {
      const i = s.template || Nd(r).template;
      if (i) {
        process.env.NODE_ENV !== "production" && as(r, "compile");
        const { isCustomElement: n, compilerOptions: a } = r.appContext.config, { delimiters: o, compilerOptions: u } = s, l = Be(
          Be(
            {
              isCustomElement: n,
              delimiters: o
            },
            a
          ),
          u
        );
        s.render = Va(i, l), process.env.NODE_ENV !== "production" && os(r, "compile");
      }
    }
    r.render = s.render || Ge, Cp && Cp(r);
  }
  {
    const i = zi(r);
    Os();
    try {
      u3(r);
    } finally {
      Is(), i();
    }
  }
  process.env.NODE_ENV !== "production" && !s.render && r.render === Ge && !e && (!Va && s.template ? j(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  ) : j("Component is missing template or render function: ", s));
}
const $g = process.env.NODE_ENV !== "production" ? {
  get(r, e) {
    return ul(), Ct(r, "get", ""), r[e];
  },
  set() {
    return j("setupContext.attrs is readonly."), !1;
  },
  deleteProperty() {
    return j("setupContext.attrs is readonly."), !1;
  }
} : {
  get(r, e) {
    return Ct(r, "get", ""), r[e];
  }
};
function fA(r) {
  return new Proxy(r.slots, {
    get(e, t) {
      return Ct(r, "get", "$slots"), e[t];
    }
  });
}
function iE(r) {
  const e = (t) => {
    if (process.env.NODE_ENV !== "production" && (r.exposed && j("expose() should be called only once per setup()."), t != null)) {
      let s = typeof t;
      s === "object" && (se(t) ? s = "array" : pt(t) && (s = "ref")), s !== "object" && j(
        `expose() should be passed a plain object, received ${s}.`
      );
    }
    r.exposed = t || {};
  };
  if (process.env.NODE_ENV !== "production") {
    let t, s;
    return Object.freeze({
      get attrs() {
        return t || (t = new Proxy(r.attrs, $g));
      },
      get slots() {
        return s || (s = fA(r));
      },
      get emit() {
        return (i, ...n) => r.emit(i, ...n);
      },
      expose: e
    });
  } else
    return {
      attrs: new Proxy(r.attrs, $g),
      slots: r.slots,
      emit: r.emit,
      expose: e
    };
}
function Mo(r) {
  return r.exposed ? r.exposeProxy || (r.exposeProxy = new Proxy(dd(Gb(r.exposed)), {
    get(e, t) {
      if (t in e)
        return e[t];
      if (t in Li)
        return Li[t](r);
    },
    has(e, t) {
      return t in e || t in Li;
    }
  })) : r.proxy;
}
const pA = /(?:^|[-_])(\w)/g, hA = (r) => r.replace(pA, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function ao(r, e = !0) {
  return fe(r) ? r.displayName || r.name : r.name || e && r.__name;
}
function mc(r, e, t = !1) {
  let s = ao(e);
  if (!s && e.__file) {
    const i = e.__file.match(/([^/\\]+)\.\w+$/);
    i && (s = i[1]);
  }
  if (!s && r && r.parent) {
    const i = (n) => {
      for (const a in n)
        if (n[a] === e)
          return a;
    };
    s = i(
      r.components || r.parent.type.components
    ) || i(r.appContext.components);
  }
  return s ? hA(s) : t ? "App" : "Anonymous";
}
function nE(r) {
  return fe(r) && "__vccOpts" in r;
}
const aE = (r, e) => {
  const t = GT(r, e, Lo);
  if (process.env.NODE_ENV !== "production") {
    const s = is();
    s && s.appContext.config.warnRecursiveComputed && (t._warnRecursive = !0);
  }
  return t;
};
function oE(r, e, t) {
  const s = arguments.length;
  return s === 2 ? Ae(e) && !se(e) ? ws(e) ? He(r, null, [e]) : He(r, e) : He(r, null, e) : (s > 3 ? t = Array.prototype.slice.call(arguments, 2) : s === 3 && ws(t) && (t = [t]), He(r, e, t));
}
function uE() {
  if (process.env.NODE_ENV === "production" || typeof window > "u")
    return;
  const r = { style: "color:#3ba776" }, e = { style: "color:#1677ff" }, t = { style: "color:#f5222d" }, s = { style: "color:#eb2f96" }, i = {
    __vue_custom_formatter: !0,
    header(f) {
      return Ae(f) ? f.__isVue ? ["div", r, "VueInstance"] : pt(f) ? [
        "div",
        {},
        ["span", r, c(f)],
        "<",
        o(f.value),
        ">"
      ] : Zs(f) ? [
        "div",
        {},
        ["span", r, Gr(f) ? "ShallowReactive" : "Reactive"],
        "<",
        o(f),
        `>${rs(f) ? " (readonly)" : ""}`
      ] : rs(f) ? [
        "div",
        {},
        ["span", r, Gr(f) ? "ShallowReadonly" : "Readonly"],
        "<",
        o(f),
        ">"
      ] : null : null;
    },
    hasBody(f) {
      return f && f.__isVue;
    },
    body(f) {
      if (f && f.__isVue)
        return [
          "div",
          {},
          ...n(f.$)
        ];
    }
  };
  function n(f) {
    const p = [];
    f.type.props && f.props && p.push(a("props", Ee(f.props))), f.setupState !== Oe && p.push(a("setup", f.setupState)), f.data !== Oe && p.push(a("data", Ee(f.data)));
    const h = u(f, "computed");
    h && p.push(a("computed", h));
    const m = u(f, "inject");
    return m && p.push(a("injected", m)), p.push([
      "div",
      {},
      [
        "span",
        {
          style: s.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: f }]
    ]), p;
  }
  function a(f, p) {
    return p = Be({}, p), Object.keys(p).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        f
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(p).map((h) => [
          "div",
          {},
          ["span", s, h + ": "],
          o(p[h], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function o(f, p = !0) {
    return typeof f == "number" ? ["span", e, f] : typeof f == "string" ? ["span", t, JSON.stringify(f)] : typeof f == "boolean" ? ["span", s, f] : Ae(f) ? ["object", { object: p ? Ee(f) : f }] : ["span", t, String(f)];
  }
  function u(f, p) {
    const h = f.type;
    if (fe(h))
      return;
    const m = {};
    for (const d in f.ctx)
      l(h, d, p) && (m[d] = f.ctx[d]);
    return m;
  }
  function l(f, p, h) {
    const m = f[h];
    if (se(m) && m.includes(p) || Ae(m) && p in m || f.extends && l(f.extends, p, h) || f.mixins && f.mixins.some((d) => l(d, p, h)))
      return !0;
  }
  function c(f) {
    return Gr(f) ? "ShallowRef" : f.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i];
}
function dA(r, e, t, s) {
  const i = t[s];
  if (i && lE(i, r))
    return i;
  const n = e();
  return n.memo = r.slice(), n.cacheIndex = s, t[s] = n;
}
function lE(r, e) {
  const t = r.memo;
  if (t.length != e.length)
    return !1;
  for (let s = 0; s < t.length; s++)
    if (jt(t[s], e[s]))
      return !1;
  return Wi > 0 && Lt && Lt.push(r), !0;
}
const Np = "3.4.37", ot = process.env.NODE_ENV !== "production" ? j : Ge, mA = ic, gA = (process.env.NODE_ENV, Tr), yA = (process.env.NODE_ENV, bd), bA = {
  createComponentInstance: eE,
  setupComponent: rE,
  renderComponentRoot: Nu,
  setCurrentRenderingInstance: so,
  isVNode: ws,
  normalizeVNode: qt,
  getComponentPublicInstance: Mo,
  ensureValidVNode: Ad
}, Kn = bA, vA = null, EA = null, SA = null;
/**
* @vue/runtime-dom v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const _A = "http://www.w3.org/2000/svg", xA = "http://www.w3.org/1998/Math/MathML", fs = typeof document < "u" ? document : null, Fg = fs && /* @__PURE__ */ fs.createElement("template"), wA = {
  insert: (r, e, t) => {
    e.insertBefore(r, t || null);
  },
  remove: (r) => {
    const e = r.parentNode;
    e && e.removeChild(r);
  },
  createElement: (r, e, t, s) => {
    const i = e === "svg" ? fs.createElementNS(_A, r) : e === "mathml" ? fs.createElementNS(xA, r) : t ? fs.createElement(r, { is: t }) : fs.createElement(r);
    return r === "select" && s && s.multiple != null && i.setAttribute("multiple", s.multiple), i;
  },
  createText: (r) => fs.createTextNode(r),
  createComment: (r) => fs.createComment(r),
  setText: (r, e) => {
    r.nodeValue = e;
  },
  setElementText: (r, e) => {
    r.textContent = e;
  },
  parentNode: (r) => r.parentNode,
  nextSibling: (r) => r.nextSibling,
  querySelector: (r) => fs.querySelector(r),
  setScopeId(r, e) {
    r.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(r, e, t, s, i, n) {
    const a = t ? t.previousSibling : e.lastChild;
    if (i && (i === n || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), t), !(i === n || !(i = i.nextSibling)); )
        ;
    else {
      Fg.innerHTML = s === "svg" ? `<svg>${r}</svg>` : s === "mathml" ? `<math>${r}</math>` : r;
      const o = Fg.content;
      if (s === "svg" || s === "mathml") {
        const u = o.firstChild;
        for (; u.firstChild; )
          o.appendChild(u.firstChild);
        o.removeChild(u);
      }
      e.insertBefore(o, t);
    }
    return [
      // first
      a ? a.nextSibling : e.firstChild,
      // last
      t ? t.previousSibling : e.lastChild
    ];
  }
}, Ms = "transition", ha = "animation", On = Symbol("_vtc"), Fd = (r, { slots: e }) => oE(ov, fE(r), e);
Fd.displayName = "Transition";
const cE = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, TA = Fd.props = /* @__PURE__ */ Be(
  {},
  _d,
  cE
), yi = (r, e = []) => {
  se(r) ? r.forEach((t) => t(...e)) : r && r(...e);
}, Bg = (r) => r ? se(r) ? r.some((e) => e.length > 1) : r.length > 1 : !1;
function fE(r) {
  const e = {};
  for (const I in r)
    I in cE || (e[I] = r[I]);
  if (r.css === !1)
    return e;
  const {
    name: t = "v",
    type: s,
    duration: i,
    enterFromClass: n = `${t}-enter-from`,
    enterActiveClass: a = `${t}-enter-active`,
    enterToClass: o = `${t}-enter-to`,
    appearFromClass: u = n,
    appearActiveClass: l = a,
    appearToClass: c = o,
    leaveFromClass: f = `${t}-leave-from`,
    leaveActiveClass: p = `${t}-leave-active`,
    leaveToClass: h = `${t}-leave-to`
  } = r, m = PA(i), d = m && m[0], y = m && m[1], {
    onBeforeEnter: S,
    onEnter: E,
    onEnterCancelled: g,
    onLeave: b,
    onLeaveCancelled: v,
    onBeforeAppear: A = S,
    onAppear: C = E,
    onAppearCancelled: x = g
  } = e, _ = (I, $, Y) => {
    Bs(I, $ ? c : o), Bs(I, $ ? l : a), Y && Y();
  }, T = (I, $) => {
    I._isLeaving = !1, Bs(I, f), Bs(I, h), Bs(I, p), $ && $();
  }, P = (I) => ($, Y) => {
    const W = I ? C : E, F = () => _($, I, Y);
    yi(W, [$, F]), Vg(() => {
      Bs($, I ? u : n), us($, I ? c : o), Bg(W) || Ug($, s, d, F);
    });
  };
  return Be(e, {
    onBeforeEnter(I) {
      yi(S, [I]), us(I, n), us(I, a);
    },
    onBeforeAppear(I) {
      yi(A, [I]), us(I, u), us(I, l);
    },
    onEnter: P(!1),
    onAppear: P(!0),
    onLeave(I, $) {
      I._isLeaving = !0;
      const Y = () => T(I, $);
      us(I, f), us(I, p), hE(), Vg(() => {
        I._isLeaving && (Bs(I, f), us(I, h), Bg(b) || Ug(I, s, y, Y));
      }), yi(b, [I, Y]);
    },
    onEnterCancelled(I) {
      _(I, !1), yi(g, [I]);
    },
    onAppearCancelled(I) {
      _(I, !0), yi(x, [I]);
    },
    onLeaveCancelled(I) {
      T(I), yi(v, [I]);
    }
  });
}
function PA(r) {
  if (r == null)
    return null;
  if (Ae(r))
    return [Pf(r.enter), Pf(r.leave)];
  {
    const e = Pf(r);
    return [e, e];
  }
}
function Pf(r) {
  const e = Zu(r);
  return process.env.NODE_ENV !== "production" && md(e, "<transition> explicit duration"), e;
}
function us(r, e) {
  e.split(/\s+/).forEach((t) => t && r.classList.add(t)), (r[On] || (r[On] = /* @__PURE__ */ new Set())).add(e);
}
function Bs(r, e) {
  e.split(/\s+/).forEach((s) => s && r.classList.remove(s));
  const t = r[On];
  t && (t.delete(e), t.size || (r[On] = void 0));
}
function Vg(r) {
  requestAnimationFrame(() => {
    requestAnimationFrame(r);
  });
}
let AA = 0;
function Ug(r, e, t, s) {
  const i = r._endId = ++AA, n = () => {
    i === r._endId && s();
  };
  if (t)
    return setTimeout(n, t);
  const { type: a, timeout: o, propCount: u } = pE(r, e);
  if (!a)
    return s();
  const l = a + "end";
  let c = 0;
  const f = () => {
    r.removeEventListener(l, p), n();
  }, p = (h) => {
    h.target === r && ++c >= u && f();
  };
  setTimeout(() => {
    c < u && f();
  }, o + 1), r.addEventListener(l, p);
}
function pE(r, e) {
  const t = window.getComputedStyle(r), s = (m) => (t[m] || "").split(", "), i = s(`${Ms}Delay`), n = s(`${Ms}Duration`), a = jg(i, n), o = s(`${ha}Delay`), u = s(`${ha}Duration`), l = jg(o, u);
  let c = null, f = 0, p = 0;
  e === Ms ? a > 0 && (c = Ms, f = a, p = n.length) : e === ha ? l > 0 && (c = ha, f = l, p = u.length) : (f = Math.max(a, l), c = f > 0 ? a > l ? Ms : ha : null, p = c ? c === Ms ? n.length : u.length : 0);
  const h = c === Ms && /\b(transform|all)(,|$)/.test(
    s(`${Ms}Property`).toString()
  );
  return {
    type: c,
    timeout: f,
    propCount: p,
    hasTransform: h
  };
}
function jg(r, e) {
  for (; r.length < e.length; )
    r = r.concat(r);
  return Math.max(...e.map((t, s) => qg(t) + qg(r[s])));
}
function qg(r) {
  return r === "auto" ? 0 : Number(r.slice(0, -1).replace(",", ".")) * 1e3;
}
function hE() {
  return document.body.offsetHeight;
}
function CA(r, e, t) {
  const s = r[On];
  s && (e = (e ? [e, ...s] : [...s]).join(" ")), e == null ? r.removeAttribute("class") : t ? r.setAttribute("class", e) : r.className = e;
}
const cl = Symbol("_vod"), dE = Symbol("_vsh"), Bd = {
  beforeMount(r, { value: e }, { transition: t }) {
    r[cl] = r.style.display === "none" ? "" : r.style.display, t && e ? t.beforeEnter(r) : da(r, e);
  },
  mounted(r, { value: e }, { transition: t }) {
    t && e && t.enter(r);
  },
  updated(r, { value: e, oldValue: t }, { transition: s }) {
    !e != !t && (s ? e ? (s.beforeEnter(r), da(r, !0), s.enter(r)) : s.leave(r, () => {
      da(r, !1);
    }) : da(r, e));
  },
  beforeUnmount(r, { value: e }) {
    da(r, e);
  }
};
process.env.NODE_ENV !== "production" && (Bd.name = "show");
function da(r, e) {
  r.style.display = e ? r[cl] : "none", r[dE] = !e;
}
function NA() {
  Bd.getSSRProps = ({ value: r }) => {
    if (!r)
      return { style: { display: "none" } };
  };
}
const mE = Symbol(process.env.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : "");
function OA(r) {
  const e = is();
  if (!e) {
    process.env.NODE_ENV !== "production" && ot("useCssVars is called without current active component instance.");
    return;
  }
  const t = e.ut = (i = r(e.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${e.uid}"]`)
    ).forEach((n) => Ip(n, i));
  };
  process.env.NODE_ENV !== "production" && (e.getCssVars = () => r(e.proxy));
  const s = () => {
    const i = r(e.proxy);
    Op(e.subTree, i), t(i);
  };
  wd(() => {
    Vv(s);
  }), Io(() => {
    const i = new MutationObserver(s);
    i.observe(e.subTree.el.parentNode, { childList: !0 }), fc(() => i.disconnect());
  });
}
function Op(r, e) {
  if (r.shapeFlag & 128) {
    const t = r.suspense;
    r = t.activeBranch, t.pendingBranch && !t.isHydrating && t.effects.push(() => {
      Op(t.activeBranch, e);
    });
  }
  for (; r.component; )
    r = r.component.subTree;
  if (r.shapeFlag & 1 && r.el)
    Ip(r.el, e);
  else if (r.type === ct)
    r.children.forEach((t) => Op(t, e));
  else if (r.type === Es) {
    let { el: t, anchor: s } = r;
    for (; t && (Ip(t, e), t !== s); )
      t = t.nextSibling;
  }
}
function Ip(r, e) {
  if (r.nodeType === 1) {
    const t = r.style;
    let s = "";
    for (const i in e)
      t.setProperty(`--${i}`, e[i]), s += `--${i}: ${e[i]};`;
    t[mE] = s;
  }
}
const IA = /(^|;)\s*display\s*:/;
function kA(r, e, t) {
  const s = r.style, i = _e(t);
  let n = !1;
  if (t && !i) {
    if (e)
      if (_e(e))
        for (const a of e.split(";")) {
          const o = a.slice(0, a.indexOf(":")).trim();
          t[o] == null && Iu(s, o, "");
        }
      else
        for (const a in e)
          t[a] == null && Iu(s, a, "");
    for (const a in t)
      a === "display" && (n = !0), Iu(s, a, t[a]);
  } else if (i) {
    if (e !== t) {
      const a = s[mE];
      a && (t += ";" + a), s.cssText = t, n = IA.test(t);
    }
  } else e && r.removeAttribute("style");
  cl in r && (r[cl] = n ? s.display : "", r[dE] && (s.display = "none"));
}
const DA = /[^\\];\s*$/, Hg = /\s*!important$/;
function Iu(r, e, t) {
  if (se(t))
    t.forEach((s) => Iu(r, e, s));
  else if (t == null && (t = ""), process.env.NODE_ENV !== "production" && DA.test(t) && ot(
    `Unexpected semicolon at the end of '${e}' style value: '${t}'`
  ), e.startsWith("--"))
    r.setProperty(e, t);
  else {
    const s = LA(r, e);
    Hg.test(t) ? r.setProperty(
      Tt(s),
      t.replace(Hg, ""),
      "important"
    ) : r[s] = t;
  }
}
const Wg = ["Webkit", "Moz", "ms"], Af = {};
function LA(r, e) {
  const t = Af[e];
  if (t)
    return t;
  let s = Et(e);
  if (s !== "filter" && s in r)
    return Af[e] = s;
  s = ii(s);
  for (let i = 0; i < Wg.length; i++) {
    const n = Wg[i] + s;
    if (n in r)
      return Af[e] = n;
  }
  return e;
}
const zg = "http://www.w3.org/1999/xlink";
function Gg(r, e, t, s, i, n = pT(e)) {
  s && e.startsWith("xlink:") ? t == null ? r.removeAttributeNS(zg, e.slice(6, e.length)) : r.setAttributeNS(zg, e, t) : t == null || n && !Ao(t) ? r.removeAttribute(e) : r.setAttribute(
    e,
    n ? "" : Zr(t) ? String(t) : t
  );
}
function MA(r, e, t, s) {
  if (e === "innerHTML" || e === "textContent") {
    if (t == null) return;
    r[e] = t;
    return;
  }
  const i = r.tagName;
  if (e === "value" && i !== "PROGRESS" && // custom elements may use _value internally
  !i.includes("-")) {
    const a = i === "OPTION" ? r.getAttribute("value") || "" : r.value, o = t == null ? "" : String(t);
    (a !== o || !("_value" in r)) && (r.value = o), t == null && r.removeAttribute(e), r._value = t;
    return;
  }
  let n = !1;
  if (t === "" || t == null) {
    const a = typeof r[e];
    a === "boolean" ? t = Ao(t) : t == null && a === "string" ? (t = "", n = !0) : a === "number" && (t = 0, n = !0);
  }
  try {
    r[e] = t;
  } catch (a) {
    process.env.NODE_ENV !== "production" && !n && ot(
      `Failed setting prop "${e}" on <${i.toLowerCase()}>: value ${t} is invalid.`,
      a
    );
  }
  n && r.removeAttribute(e);
}
function ds(r, e, t, s) {
  r.addEventListener(e, t, s);
}
function RA(r, e, t, s) {
  r.removeEventListener(e, t, s);
}
const Kg = Symbol("_vei");
function $A(r, e, t, s, i = null) {
  const n = r[Kg] || (r[Kg] = {}), a = n[e];
  if (s && a)
    a.value = process.env.NODE_ENV !== "production" ? Jg(s, e) : s;
  else {
    const [o, u] = FA(e);
    if (s) {
      const l = n[e] = UA(
        process.env.NODE_ENV !== "production" ? Jg(s, e) : s,
        i
      );
      ds(r, o, l, u);
    } else a && (RA(r, o, a, u), n[e] = void 0);
  }
}
const Xg = /(?:Once|Passive|Capture)$/;
function FA(r) {
  let e;
  if (Xg.test(r)) {
    e = {};
    let s;
    for (; s = r.match(Xg); )
      r = r.slice(0, r.length - s[0].length), e[s[0].toLowerCase()] = !0;
  }
  return [r[2] === ":" ? r.slice(3) : Tt(r.slice(2)), e];
}
let Cf = 0;
const BA = /* @__PURE__ */ Promise.resolve(), VA = () => Cf || (BA.then(() => Cf = 0), Cf = Date.now());
function UA(r, e) {
  const t = (s) => {
    if (!s._vts)
      s._vts = Date.now();
    else if (s._vts <= t.attached)
      return;
    ar(
      jA(s, t.value),
      e,
      5,
      [s]
    );
  };
  return t.value = r, t.attached = VA(), t;
}
function Jg(r, e) {
  return fe(r) || se(r) ? r : (ot(
    `Wrong type passed as event handler to ${e} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof r}.`
  ), Ge);
}
function jA(r, e) {
  if (se(e)) {
    const t = r.stopImmediatePropagation;
    return r.stopImmediatePropagation = () => {
      t.call(r), r._stopped = !0;
    }, e.map(
      (s) => (i) => !i._stopped && s && s(i)
    );
  } else
    return e;
}
const Yg = (r) => r.charCodeAt(0) === 111 && r.charCodeAt(1) === 110 && // lowercase letter
r.charCodeAt(2) > 96 && r.charCodeAt(2) < 123, qA = (r, e, t, s, i, n) => {
  const a = i === "svg";
  e === "class" ? CA(r, s, a) : e === "style" ? kA(r, t, s) : Yi(e) ? Yu(e) || $A(r, e, t, s, n) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : HA(r, e, s, a)) ? (MA(r, e, s), !r.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && Gg(r, e, s, a, n, e !== "value")) : (e === "true-value" ? r._trueValue = s : e === "false-value" && (r._falseValue = s), Gg(r, e, s, a));
};
function HA(r, e, t, s) {
  if (s)
    return !!(e === "innerHTML" || e === "textContent" || e in r && Yg(e) && fe(t));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && r.tagName === "INPUT" || e === "type" && r.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const i = r.tagName;
    if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
      return !1;
  }
  return Yg(e) && _e(t) ? !1 : e in r;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function gE(r, e, t) {
  const s = /* @__PURE__ */ xd(r, e);
  class i extends gc {
    constructor(a) {
      super(s, a, t);
    }
  }
  return i.def = s, i;
}
/*! #__NO_SIDE_EFFECTS__ */
const WA = /* @__NO_SIDE_EFFECTS__ */ (r, e) => /* @__PURE__ */ gE(r, e, AE), zA = typeof HTMLElement < "u" ? HTMLElement : class {
};
class gc extends zA {
  constructor(e, t = {}, s) {
    super(), this._def = e, this._props = t, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this._ob = null, this.shadowRoot && s ? s(this._createVNode(), this.shadowRoot) : (process.env.NODE_ENV !== "production" && this.shadowRoot && ot(
      "Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`."
    ), this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def));
  }
  connectedCallback() {
    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());
  }
  disconnectedCallback() {
    this._connected = !1, nc(() => {
      this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), kp(null, this.shadowRoot), this._instance = null);
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = !0;
    for (let s = 0; s < this.attributes.length; s++)
      this._setAttr(this.attributes[s].name);
    this._ob = new MutationObserver((s) => {
      for (const i of s)
        this._setAttr(i.attributeName);
    }), this._ob.observe(this, { attributes: !0 });
    const e = (s, i = !1) => {
      const { props: n, styles: a } = s;
      let o;
      if (n && !se(n))
        for (const u in n) {
          const l = n[u];
          (l === Number || l && l.type === Number) && (u in this._props && (this._props[u] = Zu(this._props[u])), (o || (o = /* @__PURE__ */ Object.create(null)))[Et(u)] = !0);
        }
      this._numberProps = o, i && this._resolveProps(s), this._applyStyles(a), this._update();
    }, t = this._def.__asyncLoader;
    t ? t().then((s) => e(s, !0)) : e(this._def);
  }
  _resolveProps(e) {
    const { props: t } = e, s = se(t) ? t : Object.keys(t || {});
    for (const i of Object.keys(this))
      i[0] !== "_" && s.includes(i) && this._setProp(i, this[i], !0, !1);
    for (const i of s.map(Et))
      Object.defineProperty(this, i, {
        get() {
          return this._getProp(i);
        },
        set(n) {
          this._setProp(i, n);
        }
      });
  }
  _setAttr(e) {
    let t = this.hasAttribute(e) ? this.getAttribute(e) : void 0;
    const s = Et(e);
    this._numberProps && this._numberProps[s] && (t = Zu(t)), this._setProp(s, t, !1);
  }
  /**
   * @internal
   */
  _getProp(e) {
    return this._props[e];
  }
  /**
   * @internal
   */
  _setProp(e, t, s = !0, i = !0) {
    t !== this._props[e] && (this._props[e] = t, i && this._instance && this._update(), s && (t === !0 ? this.setAttribute(Tt(e), "") : typeof t == "string" || typeof t == "number" ? this.setAttribute(Tt(e), t + "") : t || this.removeAttribute(Tt(e))));
  }
  _update() {
    kp(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const e = He(this._def, Be({}, this._props));
    return this._instance || (e.ce = (t) => {
      this._instance = t, t.isCE = !0, process.env.NODE_ENV !== "production" && (t.ceReload = (n) => {
        this._styles && (this._styles.forEach((a) => this.shadowRoot.removeChild(a)), this._styles.length = 0), this._applyStyles(n), this._instance = null, this._update();
      });
      const s = (n, a) => {
        this.dispatchEvent(
          new CustomEvent(n, {
            detail: a
          })
        );
      };
      t.emit = (n, ...a) => {
        s(n, a), Tt(n) !== n && s(Tt(n), a);
      };
      let i = this;
      for (; i = i && (i.parentNode || i.host); )
        if (i instanceof gc) {
          t.parent = i._instance, t.provides = i._instance.provides;
          break;
        }
    }), e;
  }
  _applyStyles(e) {
    e && e.forEach((t) => {
      const s = document.createElement("style");
      s.textContent = t, this.shadowRoot.appendChild(s), process.env.NODE_ENV !== "production" && (this._styles || (this._styles = [])).push(s);
    });
  }
}
function GA(r = "$style") {
  {
    const e = is();
    if (!e)
      return process.env.NODE_ENV !== "production" && ot("useCssModule must be called inside setup()"), Oe;
    const t = e.type.__cssModules;
    if (!t)
      return process.env.NODE_ENV !== "production" && ot("Current instance does not have CSS modules injected."), Oe;
    const s = t[r];
    return s || (process.env.NODE_ENV !== "production" && ot(`Current instance does not have CSS module named "${r}".`), Oe);
  }
}
const yE = /* @__PURE__ */ new WeakMap(), bE = /* @__PURE__ */ new WeakMap(), fl = Symbol("_moveCb"), Qg = Symbol("_enterCb"), vE = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ Be({}, TA, {
    tag: String,
    moveClass: String
  }),
  setup(r, { slots: e }) {
    const t = is(), s = Sd();
    let i, n;
    return lc(() => {
      if (!i.length)
        return;
      const a = r.moveClass || `${r.name || "v"}-move`;
      if (!ZA(
        i[0].el,
        t.vnode.el,
        a
      ))
        return;
      i.forEach(JA), i.forEach(YA);
      const o = i.filter(QA);
      hE(), o.forEach((u) => {
        const l = u.el, c = l.style;
        us(l, a), c.transform = c.webkitTransform = c.transitionDuration = "";
        const f = l[fl] = (p) => {
          p && p.target !== l || (!p || /transform$/.test(p.propertyName)) && (l.removeEventListener("transitionend", f), l[fl] = null, Bs(l, a));
        };
        l.addEventListener("transitionend", f);
      });
    }), () => {
      const a = Ee(r), o = fE(a);
      let u = a.tag || ct;
      if (i = [], n)
        for (let l = 0; l < n.length; l++) {
          const c = n[l];
          c.el && c.el instanceof Element && (i.push(c), ni(
            c,
            Nn(
              c,
              o,
              s,
              t
            )
          ), yE.set(
            c,
            c.el.getBoundingClientRect()
          ));
        }
      n = e.default ? oc(e.default()) : [];
      for (let l = 0; l < n.length; l++) {
        const c = n[l];
        c.key != null ? ni(
          c,
          Nn(c, o, s, t)
        ) : process.env.NODE_ENV !== "production" && ot("<TransitionGroup> children must be keyed.");
      }
      return He(u, null, n);
    };
  }
}, KA = (r) => delete r.mode;
vE.props;
const XA = vE;
function JA(r) {
  const e = r.el;
  e[fl] && e[fl](), e[Qg] && e[Qg]();
}
function YA(r) {
  bE.set(r, r.el.getBoundingClientRect());
}
function QA(r) {
  const e = yE.get(r), t = bE.get(r), s = e.left - t.left, i = e.top - t.top;
  if (s || i) {
    const n = r.el.style;
    return n.transform = n.webkitTransform = `translate(${s}px,${i}px)`, n.transitionDuration = "0s", r;
  }
}
function ZA(r, e, t) {
  const s = r.cloneNode(), i = r[On];
  i && i.forEach((o) => {
    o.split(/\s+/).forEach((u) => u && s.classList.remove(u));
  }), t.split(/\s+/).forEach((o) => o && s.classList.add(o)), s.style.display = "none";
  const n = e.nodeType === 1 ? e : e.parentNode;
  n.appendChild(s);
  const { hasTransform: a } = pE(s);
  return n.removeChild(s), a;
}
const ai = (r) => {
  const e = r.props["onUpdate:modelValue"] || !1;
  return se(e) ? (t) => Gs(e, t) : e;
};
function eC(r) {
  r.target.composing = !0;
}
function Zg(r) {
  const e = r.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const gr = Symbol("_assign"), pl = {
  created(r, { modifiers: { lazy: e, trim: t, number: s } }, i) {
    r[gr] = ai(i);
    const n = s || i.props && i.props.type === "number";
    ds(r, e ? "change" : "input", (a) => {
      if (a.target.composing) return;
      let o = r.value;
      t && (o = o.trim()), n && (o = Qu(o)), r[gr](o);
    }), t && ds(r, "change", () => {
      r.value = r.value.trim();
    }), e || (ds(r, "compositionstart", eC), ds(r, "compositionend", Zg), ds(r, "change", Zg));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(r, { value: e }) {
    r.value = e ?? "";
  },
  beforeUpdate(r, { value: e, oldValue: t, modifiers: { lazy: s, trim: i, number: n } }, a) {
    if (r[gr] = ai(a), r.composing) return;
    const o = (n || r.type === "number") && !/^0\d/.test(r.value) ? Qu(r.value) : r.value, u = e ?? "";
    o !== u && (document.activeElement === r && r.type !== "range" && (s && e === t || i && r.value.trim() === u) || (r.value = u));
  }
}, Vd = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(r, e, t) {
    r[gr] = ai(t), ds(r, "change", () => {
      const s = r._modelValue, i = In(r), n = r.checked, a = r[gr];
      if (se(s)) {
        const o = Co(s, i), u = o !== -1;
        if (n && !u)
          a(s.concat(i));
        else if (!n && u) {
          const l = [...s];
          l.splice(o, 1), a(l);
        }
      } else if (Qi(s)) {
        const o = new Set(s);
        n ? o.add(i) : o.delete(i), a(o);
      } else
        a(SE(r, n));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: ey,
  beforeUpdate(r, e, t) {
    r[gr] = ai(t), ey(r, e, t);
  }
};
function ey(r, { value: e, oldValue: t }, s) {
  r._modelValue = e, se(e) ? r.checked = Co(e, s.props.value) > -1 : Qi(e) ? r.checked = e.has(s.props.value) : e !== t && (r.checked = Or(e, SE(r, !0)));
}
const Ud = {
  created(r, { value: e }, t) {
    r.checked = Or(e, t.props.value), r[gr] = ai(t), ds(r, "change", () => {
      r[gr](In(r));
    });
  },
  beforeUpdate(r, { value: e, oldValue: t }, s) {
    r[gr] = ai(s), e !== t && (r.checked = Or(e, s.props.value));
  }
}, EE = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(r, { value: e, modifiers: { number: t } }, s) {
    const i = Qi(e);
    ds(r, "change", () => {
      const n = Array.prototype.filter.call(r.options, (a) => a.selected).map(
        (a) => t ? Qu(In(a)) : In(a)
      );
      r[gr](
        r.multiple ? i ? new Set(n) : n : n[0]
      ), r._assigning = !0, nc(() => {
        r._assigning = !1;
      });
    }), r[gr] = ai(s);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(r, { value: e, modifiers: { number: t } }) {
    ty(r, e);
  },
  beforeUpdate(r, e, t) {
    r[gr] = ai(t);
  },
  updated(r, { value: e, modifiers: { number: t } }) {
    r._assigning || ty(r, e);
  }
};
function ty(r, e, t) {
  const s = r.multiple, i = se(e);
  if (s && !i && !Qi(e)) {
    process.env.NODE_ENV !== "production" && ot(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8, -1)}.`
    );
    return;
  }
  for (let n = 0, a = r.options.length; n < a; n++) {
    const o = r.options[n], u = In(o);
    if (s)
      if (i) {
        const l = typeof u;
        l === "string" || l === "number" ? o.selected = e.some((c) => String(c) === String(u)) : o.selected = Co(e, u) > -1;
      } else
        o.selected = e.has(u);
    else if (Or(In(o), e)) {
      r.selectedIndex !== n && (r.selectedIndex = n);
      return;
    }
  }
  !s && r.selectedIndex !== -1 && (r.selectedIndex = -1);
}
function In(r) {
  return "_value" in r ? r._value : r.value;
}
function SE(r, e) {
  const t = e ? "_trueValue" : "_falseValue";
  return t in r ? r[t] : e;
}
const _E = {
  created(r, e, t) {
    au(r, e, t, null, "created");
  },
  mounted(r, e, t) {
    au(r, e, t, null, "mounted");
  },
  beforeUpdate(r, e, t, s) {
    au(r, e, t, s, "beforeUpdate");
  },
  updated(r, e, t, s) {
    au(r, e, t, s, "updated");
  }
};
function xE(r, e) {
  switch (r) {
    case "SELECT":
      return EE;
    case "TEXTAREA":
      return pl;
    default:
      switch (e) {
        case "checkbox":
          return Vd;
        case "radio":
          return Ud;
        default:
          return pl;
      }
  }
}
function au(r, e, t, s, i) {
  const a = xE(
    r.tagName,
    t.props && t.props.type
  )[i];
  a && a(r, e, t, s);
}
function tC() {
  pl.getSSRProps = ({ value: r }) => ({ value: r }), Ud.getSSRProps = ({ value: r }, e) => {
    if (e.props && Or(e.props.value, r))
      return { checked: !0 };
  }, Vd.getSSRProps = ({ value: r }, e) => {
    if (se(r)) {
      if (e.props && Co(r, e.props.value) > -1)
        return { checked: !0 };
    } else if (Qi(r)) {
      if (e.props && r.has(e.props.value))
        return { checked: !0 };
    } else if (r)
      return { checked: !0 };
  }, _E.getSSRProps = (r, e) => {
    if (typeof e.type != "string")
      return;
    const t = xE(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      e.type.toUpperCase(),
      e.props && e.props.type
    );
    if (t.getSSRProps)
      return t.getSSRProps(r, e);
  };
}
const rC = ["ctrl", "shift", "alt", "meta"], sC = {
  stop: (r) => r.stopPropagation(),
  prevent: (r) => r.preventDefault(),
  self: (r) => r.target !== r.currentTarget,
  ctrl: (r) => !r.ctrlKey,
  shift: (r) => !r.shiftKey,
  alt: (r) => !r.altKey,
  meta: (r) => !r.metaKey,
  left: (r) => "button" in r && r.button !== 0,
  middle: (r) => "button" in r && r.button !== 1,
  right: (r) => "button" in r && r.button !== 2,
  exact: (r, e) => rC.some((t) => r[`${t}Key`] && !e.includes(t))
}, iC = (r, e) => {
  const t = r._withMods || (r._withMods = {}), s = e.join(".");
  return t[s] || (t[s] = (i, ...n) => {
    for (let a = 0; a < e.length; a++) {
      const o = sC[e[a]];
      if (o && o(i, e)) return;
    }
    return r(i, ...n);
  });
}, nC = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, aC = (r, e) => {
  const t = r._withKeys || (r._withKeys = {}), s = e.join(".");
  return t[s] || (t[s] = (i) => {
    if (!("key" in i))
      return;
    const n = Tt(i.key);
    if (e.some((a) => a === n || nC[a] === n))
      return r(i);
  });
}, wE = /* @__PURE__ */ Be({ patchProp: qA }, wA);
let Ua, ry = !1;
function TE() {
  return Ua || (Ua = Lv(wE));
}
function PE() {
  return Ua = ry ? Ua : Mv(wE), ry = !0, Ua;
}
const kp = (...r) => {
  TE().render(...r);
}, AE = (...r) => {
  PE().hydrate(...r);
}, jd = (...r) => {
  const e = TE().createApp(...r);
  process.env.NODE_ENV !== "production" && (NE(e), OE(e));
  const { mount: t } = e;
  return e.mount = (s) => {
    const i = IE(s);
    if (!i) return;
    const n = e._component;
    !fe(n) && !n.render && !n.template && (n.template = i.innerHTML), i.innerHTML = "";
    const a = t(i, !1, CE(i));
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), a;
  }, e;
}, oC = (...r) => {
  const e = PE().createApp(...r);
  process.env.NODE_ENV !== "production" && (NE(e), OE(e));
  const { mount: t } = e;
  return e.mount = (s) => {
    const i = IE(s);
    if (i)
      return t(i, !0, CE(i));
  }, e;
};
function CE(r) {
  if (r instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && r instanceof MathMLElement)
    return "mathml";
}
function NE(r) {
  Object.defineProperty(r.config, "isNativeTag", {
    value: (e) => lT(e) || Pb(e) || cT(e),
    writable: !1
  });
}
function OE(r) {
  if ($d()) {
    const e = r.config.isCustomElement;
    Object.defineProperty(r.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        ot(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const t = r.config.compilerOptions, s = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(r.config, "compilerOptions", {
      get() {
        return ot(s), t;
      },
      set() {
        ot(s);
      }
    });
  }
}
function IE(r) {
  if (_e(r)) {
    const e = document.querySelector(r);
    return process.env.NODE_ENV !== "production" && !e && ot(
      `Failed to mount app: mount target selector "${r}" returned null.`
    ), e;
  }
  return process.env.NODE_ENV !== "production" && window.ShadowRoot && r instanceof window.ShadowRoot && r.mode === "closed" && ot(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), r;
}
let sy = !1;
const kE = () => {
  sy || (sy = !0, tC(), NA());
};
/**
* vue v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function uC() {
  uE();
}
process.env.NODE_ENV !== "production" && uC();
const lC = () => {
  process.env.NODE_ENV !== "production" && ot(
    'Runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  );
}, F7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition: ov,
  BaseTransitionPropsValidators: _d,
  Comment: Je,
  DeprecationTypes: SA,
  EffectScope: ad,
  ErrorCodes: cP,
  ErrorTypeStrings: mA,
  Fragment: ct,
  KeepAlive: LP,
  ReactiveEffect: Cn,
  Static: Es,
  Suspense: X3,
  Teleport: k3,
  Text: Xr,
  TrackOpTypes: iP,
  Transition: Fd,
  TransitionGroup: XA,
  TriggerOpTypes: nP,
  VueElement: gc,
  assertNumber: md,
  callWithAsyncErrorHandling: ar,
  callWithErrorHandling: Kr,
  camelize: Et,
  capitalize: ii,
  cloneVNode: yr,
  compatUtils: EA,
  compile: lC,
  computed: aE,
  createApp: jd,
  createBlock: kd,
  createCommentVNode: nA,
  createElementBlock: tA,
  createElementVNode: Dd,
  createHydrationRenderer: Mv,
  createPropsRestProxy: n3,
  createRenderer: Lv,
  createSSRApp: oC,
  createSlots: UP,
  createStaticVNode: iA,
  createTextVNode: Ld,
  createVNode: He,
  customRef: Jb,
  defineAsyncComponent: kP,
  defineComponent: xd,
  defineCustomElement: gE,
  defineEmits: XP,
  defineExpose: JP,
  defineModel: ZP,
  defineOptions: YP,
  defineProps: KP,
  defineSSRCustomElement: WA,
  defineSlots: QP,
  devtools: gA,
  effect: TT,
  effectScope: _T,
  getCurrentInstance: is,
  getCurrentScope: Ib,
  getTransitionRawChildren: oc,
  guardReactiveProps: Qv,
  h: oE,
  handleError: ci,
  hasInjectionContext: m3,
  hydrate: AE,
  initCustomFormatter: uE,
  initDirectivesForSSR: kE,
  inject: Ra,
  isMemoSame: lE,
  isProxy: Qa,
  isReactive: Zs,
  isReadonly: rs,
  isRef: pt,
  isRuntimeOnly: $d,
  isShallow: Gr,
  isVNode: ws,
  markRaw: Gb,
  mergeDefaults: s3,
  mergeModels: i3,
  mergeProps: Rd,
  nextTick: nc,
  normalizeClass: en,
  normalizeProps: iT,
  normalizeStyle: Zi,
  onActivated: lv,
  onBeforeMount: wd,
  onBeforeUnmount: cc,
  onBeforeUpdate: pv,
  onDeactivated: cv,
  onErrorCaptured: gv,
  onMounted: Io,
  onRenderTracked: mv,
  onRenderTriggered: dv,
  onScopeDispose: xT,
  onServerPrefetch: hv,
  onUnmounted: fc,
  onUpdated: lc,
  openBlock: dc,
  popScopeId: CP,
  provide: Ev,
  proxyRefs: dd,
  pushScopeId: AP,
  queuePostFlushCb: to,
  reactive: rc,
  readonly: cd,
  ref: Ii,
  registerRuntimeCompiler: cA,
  render: kp,
  renderList: VP,
  renderSlot: jP,
  resolveComponent: $P,
  resolveDirective: BP,
  resolveDynamicComponent: FP,
  resolveFilter: vA,
  resolveTransitionHooks: Nn,
  setBlockTracking: _p,
  setDevtoolsHook: yA,
  setTransitionHooks: ni,
  shallowReactive: zb,
  shallowReadonly: Ar,
  shallowRef: KT,
  ssrContextKey: ko,
  ssrUtils: Kn,
  stop: PT,
  toDisplayString: nd,
  toHandlerKey: ps,
  toHandlers: qP,
  toRaw: Ee,
  toRef: sP,
  toRefs: eP,
  toValue: YT,
  transformVNodeArgs: rA,
  triggerRef: JT,
  unref: hd,
  useAttrs: r3,
  useCssModule: GA,
  useCssVars: OA,
  useModel: q3,
  useSSRContext: Bv,
  useSlots: t3,
  useTransitionState: Sd,
  vModelCheckbox: Vd,
  vModelDynamic: _E,
  vModelRadio: Ud,
  vModelSelect: EE,
  vModelText: pl,
  vShow: Bd,
  version: Np,
  warn: ot,
  watch: Fa,
  watchEffect: U3,
  watchPostEffect: Vv,
  watchSyncEffect: Uv,
  withAsyncContext: a3,
  withCtx: Ed,
  withDefaults: e3,
  withDirectives: OP,
  withKeys: aC,
  withMemo: dA,
  withModifiers: iC,
  withScopeId: NP
}, Symbol.toStringTag, { value: "Module" }));
/**
* @vue/compiler-sfc v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Rt(r, e) {
  const t = new Set(r.split(","));
  return e ? (s) => t.has(s.toLowerCase()) : (s) => t.has(s);
}
const cC = Object.freeze({}), Nf = () => {
}, ku = () => !1, DE = (r) => r.charCodeAt(0) === 111 && r.charCodeAt(1) === 110 && // uppercase letter
(r.charCodeAt(2) > 122 || r.charCodeAt(2) < 97), Jr = Object.assign, fC = Object.prototype.hasOwnProperty, qd = (r, e) => fC.call(r, e), er = Array.isArray, pC = (r) => Hd(r) === "[object Map]", hC = (r) => Hd(r) === "[object Set]", LE = (r) => typeof r == "function", Ie = (r) => typeof r == "string", fi = (r) => typeof r == "symbol", pi = (r) => r !== null && typeof r == "object", ME = Object.prototype.toString, Hd = (r) => ME.call(r), RE = (r) => Hd(r) === "[object Object]", iy = /* @__PURE__ */ Rt(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Wd = /* @__PURE__ */ Rt(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), yc = (r) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = r(t));
}, dC = /-(\w)/g, or = yc((r) => r.replace(dC, (e, t) => t ? t.toUpperCase() : "")), mC = /\B([A-Z])/g, gC = yc(
  (r) => r.replace(mC, "-$1").toLowerCase()
), oi = yc((r) => r.charAt(0).toUpperCase() + r.slice(1)), yC = yc((r) => r ? `on${oi(r)}` : ""), bC = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function hl(r) {
  return bC.test(r) ? `__props.${r}` : `__props[${JSON.stringify(r)}]`;
}
const ti = {
  1: "TEXT",
  2: "CLASS",
  4: "STYLE",
  8: "PROPS",
  16: "FULL_PROPS",
  32: "NEED_HYDRATION",
  64: "STABLE_FRAGMENT",
  128: "KEYED_FRAGMENT",
  256: "UNKEYED_FRAGMENT",
  512: "NEED_PATCH",
  1024: "DYNAMIC_SLOTS",
  2048: "DEV_ROOT_FRAGMENT",
  [-1]: "HOISTED",
  [-2]: "BAIL"
}, vC = {
  1: "STABLE",
  2: "DYNAMIC",
  3: "FORWARDED"
}, EC = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error", $E = /* @__PURE__ */ Rt(EC), ny = 2;
function kn(r, e = 0, t = r.length) {
  if (e = Math.max(0, Math.min(e, r.length)), t = Math.max(0, Math.min(t, r.length)), e > t) return "";
  let s = r.split(/(\r?\n)/);
  const i = s.filter((o, u) => u % 2 === 1);
  s = s.filter((o, u) => u % 2 === 0);
  let n = 0;
  const a = [];
  for (let o = 0; o < s.length; o++)
    if (n += s[o].length + (i[o] && i[o].length || 0), n >= e) {
      for (let u = o - ny; u <= o + ny || t > n; u++) {
        if (u < 0 || u >= s.length) continue;
        const l = u + 1;
        a.push(
          `${l}${" ".repeat(Math.max(3 - String(l).length, 0))}|  ${s[u]}`
        );
        const c = s[u].length, f = i[u] && i[u].length || 0;
        if (u === o) {
          const p = e - (n - (c + f)), h = Math.max(
            1,
            t > n ? c - p : t - e
          );
          a.push("   |  " + " ".repeat(p) + "^".repeat(h));
        } else if (u > o) {
          if (t > n) {
            const p = Math.max(Math.min(t - n, c), 1);
            a.push("   |  " + "^".repeat(p));
          }
          n += c + f;
        }
      }
      break;
    }
  return a.join(`
`);
}
function FE(r) {
  if (er(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
      const s = r[t], i = Ie(s) ? BE(s) : FE(s);
      if (i)
        for (const n in i)
          e[n] = i[n];
    }
    return e;
  } else if (Ie(r) || pi(r))
    return r;
}
const SC = /;(?![^(]*\))/g, _C = /:([^]+)/, xC = /\/\*[^]*?\*\//g;
function BE(r) {
  const e = {};
  return r.replace(xC, "").split(SC).forEach((t) => {
    if (t) {
      const s = t.split(_C);
      s.length > 1 && (e[s[0].trim()] = s[1].trim());
    }
  }), e;
}
function wC(r) {
  let e = "";
  if (!r || Ie(r))
    return e;
  for (const t in r) {
    const s = r[t];
    if (Ie(s) || typeof s == "number") {
      const i = t.startsWith("--") ? t : gC(t);
      e += `${i}:${s};`;
    }
  }
  return e;
}
function VE(r) {
  let e = "";
  if (Ie(r))
    e = r;
  else if (er(r))
    for (let t = 0; t < r.length; t++) {
      const s = VE(r[t]);
      s && (e += s + " ");
    }
  else if (pi(r))
    for (const t in r)
      r[t] && (e += t + " ");
  return e.trim();
}
const TC = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", PC = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", AC = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", CC = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr", NC = /* @__PURE__ */ Rt(TC), OC = /* @__PURE__ */ Rt(PC), IC = /* @__PURE__ */ Rt(AC), UE = /* @__PURE__ */ Rt(CC), kC = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", jE = /* @__PURE__ */ Rt(
  kC + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"
), DC = /[>/="'\u0009\u000a\u000c\u0020]/, Of = {};
function LC(r) {
  if (Of.hasOwnProperty(r))
    return Of[r];
  const e = DC.test(r);
  return e && console.error(`unsafe attribute name: ${r}`), Of[r] = !e;
}
const MC = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
}, RC = /* @__PURE__ */ Rt(
  "accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"
), $C = /* @__PURE__ */ Rt(
  "xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"
), FC = /["'&<>]/;
function Ur(r) {
  const e = "" + r, t = FC.exec(e);
  if (!t)
    return e;
  let s = "", i, n, a = 0;
  for (n = t.index; n < e.length; n++) {
    switch (e.charCodeAt(n)) {
      case 34:
        i = "&quot;";
        break;
      case 38:
        i = "&amp;";
        break;
      case 39:
        i = "&#39;";
        break;
      case 60:
        i = "&lt;";
        break;
      case 62:
        i = "&gt;";
        break;
      default:
        continue;
    }
    a !== n && (s += e.slice(a, n)), a = n + 1, s += i;
  }
  return a !== n ? s + e.slice(a, n) : s;
}
const qE = (r) => !!(r && r.__v_isRef === !0), bc = (r) => Ie(r) ? r : r == null ? "" : er(r) || pi(r) && (r.toString === ME || !LE(r.toString)) ? qE(r) ? bc(r.value) : JSON.stringify(r, HE, 2) : String(r), HE = (r, e) => qE(e) ? HE(r, e.value) : pC(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (t, [s, i], n) => (t[If(s, n) + " =>"] = i, t),
    {}
  )
} : hC(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((t) => If(t))
} : fi(e) ? If(e) : pi(e) && !er(e) && !RE(e) ? String(e) : e, If = (r, e = "") => {
  var t;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    fi(r) ? `Symbol(${(t = r.description) != null ? t : e})` : r
  );
}, Dn = Symbol("Fragment"), $i = Symbol("Teleport"), Xn = Symbol("Suspense"), oo = Symbol("KeepAlive"), zd = Symbol("BaseTransition"), ui = Symbol("openBlock"), Gd = Symbol("createBlock"), Kd = Symbol("createElementBlock"), Ro = Symbol("createVNode"), vc = Symbol("createElementVNode"), Jn = Symbol("createCommentVNode"), Ec = Symbol("createTextVNode"), Sc = Symbol("createStaticVNode"), uo = Symbol("resolveComponent"), $o = Symbol(
  "resolveDynamicComponent"
), _c = Symbol("resolveDirective"), WE = Symbol("resolveFilter"), xc = Symbol("withDirectives"), wc = Symbol("renderList"), Xd = Symbol("renderSlot"), Jd = Symbol("createSlots"), Fo = Symbol("toDisplayString"), Gi = Symbol("mergeProps"), Tc = Symbol("normalizeClass"), Pc = Symbol("normalizeStyle"), Ln = Symbol("normalizeProps"), Yn = Symbol("guardReactiveProps"), Ac = Symbol("toHandlers"), dl = Symbol("camelize"), zE = Symbol("capitalize"), ml = Symbol("toHandlerKey"), lo = Symbol("setBlockTracking"), Cc = Symbol("pushScopeId"), Nc = Symbol("popScopeId"), Oc = Symbol("withCtx"), Mn = Symbol("unref"), co = Symbol("isRef"), Ic = Symbol("withMemo"), Yd = Symbol("isMemoSame"), Jt = {
  [Dn]: "Fragment",
  [$i]: "Teleport",
  [Xn]: "Suspense",
  [oo]: "KeepAlive",
  [zd]: "BaseTransition",
  [ui]: "openBlock",
  [Gd]: "createBlock",
  [Kd]: "createElementBlock",
  [Ro]: "createVNode",
  [vc]: "createElementVNode",
  [Jn]: "createCommentVNode",
  [Ec]: "createTextVNode",
  [Sc]: "createStaticVNode",
  [uo]: "resolveComponent",
  [$o]: "resolveDynamicComponent",
  [_c]: "resolveDirective",
  [WE]: "resolveFilter",
  [xc]: "withDirectives",
  [wc]: "renderList",
  [Xd]: "renderSlot",
  [Jd]: "createSlots",
  [Fo]: "toDisplayString",
  [Gi]: "mergeProps",
  [Tc]: "normalizeClass",
  [Pc]: "normalizeStyle",
  [Ln]: "normalizeProps",
  [Yn]: "guardReactiveProps",
  [Ac]: "toHandlers",
  [dl]: "camelize",
  [zE]: "capitalize",
  [ml]: "toHandlerKey",
  [lo]: "setBlockTracking",
  [Cc]: "pushScopeId",
  [Nc]: "popScopeId",
  [Oc]: "withCtx",
  [Mn]: "unref",
  [co]: "isRef",
  [Ic]: "withMemo",
  [Yd]: "isMemoSame"
};
function Qd(r) {
  Object.getOwnPropertySymbols(r).forEach((e) => {
    Jt[e] = r[e];
  });
}
const BC = {
  HTML: 0,
  0: "HTML",
  SVG: 1,
  1: "SVG",
  MATH_ML: 2,
  2: "MATH_ML"
}, VC = {
  ROOT: 0,
  0: "ROOT",
  ELEMENT: 1,
  1: "ELEMENT",
  TEXT: 2,
  2: "TEXT",
  COMMENT: 3,
  3: "COMMENT",
  SIMPLE_EXPRESSION: 4,
  4: "SIMPLE_EXPRESSION",
  INTERPOLATION: 5,
  5: "INTERPOLATION",
  ATTRIBUTE: 6,
  6: "ATTRIBUTE",
  DIRECTIVE: 7,
  7: "DIRECTIVE",
  COMPOUND_EXPRESSION: 8,
  8: "COMPOUND_EXPRESSION",
  IF: 9,
  9: "IF",
  IF_BRANCH: 10,
  10: "IF_BRANCH",
  FOR: 11,
  11: "FOR",
  TEXT_CALL: 12,
  12: "TEXT_CALL",
  VNODE_CALL: 13,
  13: "VNODE_CALL",
  JS_CALL_EXPRESSION: 14,
  14: "JS_CALL_EXPRESSION",
  JS_OBJECT_EXPRESSION: 15,
  15: "JS_OBJECT_EXPRESSION",
  JS_PROPERTY: 16,
  16: "JS_PROPERTY",
  JS_ARRAY_EXPRESSION: 17,
  17: "JS_ARRAY_EXPRESSION",
  JS_FUNCTION_EXPRESSION: 18,
  18: "JS_FUNCTION_EXPRESSION",
  JS_CONDITIONAL_EXPRESSION: 19,
  19: "JS_CONDITIONAL_EXPRESSION",
  JS_CACHE_EXPRESSION: 20,
  20: "JS_CACHE_EXPRESSION",
  JS_BLOCK_STATEMENT: 21,
  21: "JS_BLOCK_STATEMENT",
  JS_TEMPLATE_LITERAL: 22,
  22: "JS_TEMPLATE_LITERAL",
  JS_IF_STATEMENT: 23,
  23: "JS_IF_STATEMENT",
  JS_ASSIGNMENT_EXPRESSION: 24,
  24: "JS_ASSIGNMENT_EXPRESSION",
  JS_SEQUENCE_EXPRESSION: 25,
  25: "JS_SEQUENCE_EXPRESSION",
  JS_RETURN_STATEMENT: 26,
  26: "JS_RETURN_STATEMENT"
}, UC = {
  ELEMENT: 0,
  0: "ELEMENT",
  COMPONENT: 1,
  1: "COMPONENT",
  SLOT: 2,
  2: "SLOT",
  TEMPLATE: 3,
  3: "TEMPLATE"
}, jC = {
  NOT_CONSTANT: 0,
  0: "NOT_CONSTANT",
  CAN_SKIP_PATCH: 1,
  1: "CAN_SKIP_PATCH",
  CAN_HOIST: 2,
  2: "CAN_HOIST",
  CAN_STRINGIFY: 3,
  3: "CAN_STRINGIFY"
}, rt = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 },
  source: ""
};
function rn(r, e = "") {
  return {
    type: 0,
    source: e,
    children: r,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc: rt
  };
}
function Rn(r, e, t, s, i, n, a, o = !1, u = !1, l = !1, c = rt) {
  return r && (o ? (r.helper(ui), r.helper(Xi(r.inSSR, l))) : r.helper(Ki(r.inSSR, l)), a && r.helper(xc)), {
    type: 13,
    tag: e,
    props: t,
    children: s,
    patchFlag: i,
    dynamicProps: n,
    directives: a,
    isBlock: o,
    disableTracking: u,
    isComponent: l,
    loc: c
  };
}
function sn(r, e = rt) {
  return {
    type: 17,
    loc: e,
    elements: r
  };
}
function Yt(r, e = rt) {
  return {
    type: 15,
    loc: e,
    properties: r
  };
}
function Fe(r, e) {
  return {
    type: 16,
    loc: rt,
    key: Ie(r) ? Q(r, !0) : r,
    value: e
  };
}
function Q(r, e = !1, t = rt, s = 0) {
  return {
    type: 4,
    loc: t,
    content: r,
    isStatic: e,
    constType: e ? 3 : s
  };
}
function gl(r, e) {
  return {
    type: 5,
    loc: e,
    content: Ie(r) ? Q(r, !1, e) : r
  };
}
function yt(r, e = rt) {
  return {
    type: 8,
    loc: e,
    children: r
  };
}
function ge(r, e = [], t = rt) {
  return {
    type: 14,
    loc: t,
    callee: r,
    arguments: e
  };
}
function fr(r, e = void 0, t = !1, s = !1, i = rt) {
  return {
    type: 18,
    params: r,
    returns: e,
    newline: t,
    isSlot: s,
    loc: i
  };
}
function Nr(r, e, t, s = !0) {
  return {
    type: 19,
    test: r,
    consequent: e,
    alternate: t,
    newline: s,
    loc: rt
  };
}
function GE(r, e, t = !1) {
  return {
    type: 20,
    index: r,
    value: e,
    isVOnce: t,
    loc: rt
  };
}
function Bo(r) {
  return {
    type: 21,
    body: r,
    loc: rt
  };
}
function Zd(r) {
  return {
    type: 22,
    elements: r,
    loc: rt
  };
}
function yl(r, e, t) {
  return {
    type: 23,
    test: r,
    consequent: e,
    alternate: t,
    loc: rt
  };
}
function Du(r, e) {
  return {
    type: 24,
    left: r,
    right: e,
    loc: rt
  };
}
function KE(r) {
  return {
    type: 25,
    expressions: r,
    loc: rt
  };
}
function XE(r) {
  return {
    type: 26,
    returns: r,
    loc: rt
  };
}
function Ki(r, e) {
  return r || e ? Ro : vc;
}
function Xi(r, e) {
  return r || e ? Gd : Kd;
}
function kc(r, { helper: e, removeHelper: t, inSSR: s }) {
  r.isBlock || (r.isBlock = !0, t(Ki(s, r.isComponent)), e(ui), e(Xi(s, r.isComponent)));
}
var JE = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((r) => r.charCodeAt(0))
), qC = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((r) => r.charCodeAt(0))
), kf;
const HC = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), Dp = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
  (kf = String.fromCodePoint) !== null && kf !== void 0 ? kf : function(r) {
    let e = "";
    return r > 65535 && (r -= 65536, e += String.fromCharCode(r >>> 10 & 1023 | 55296), r = 56320 | r & 1023), e += String.fromCharCode(r), e;
  }
);
function WC(r) {
  var e;
  return r >= 55296 && r <= 57343 || r > 1114111 ? 65533 : (e = HC.get(r)) !== null && e !== void 0 ? e : r;
}
var bt;
(function(r) {
  r[r.NUM = 35] = "NUM", r[r.SEMI = 59] = "SEMI", r[r.EQUALS = 61] = "EQUALS", r[r.ZERO = 48] = "ZERO", r[r.NINE = 57] = "NINE", r[r.LOWER_A = 97] = "LOWER_A", r[r.LOWER_F = 102] = "LOWER_F", r[r.LOWER_X = 120] = "LOWER_X", r[r.LOWER_Z = 122] = "LOWER_Z", r[r.UPPER_A = 65] = "UPPER_A", r[r.UPPER_F = 70] = "UPPER_F", r[r.UPPER_Z = 90] = "UPPER_Z";
})(bt || (bt = {}));
const zC = 32;
var Js;
(function(r) {
  r[r.VALUE_LENGTH = 49152] = "VALUE_LENGTH", r[r.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", r[r.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Js || (Js = {}));
function Lp(r) {
  return r >= bt.ZERO && r <= bt.NINE;
}
function GC(r) {
  return r >= bt.UPPER_A && r <= bt.UPPER_F || r >= bt.LOWER_A && r <= bt.LOWER_F;
}
function KC(r) {
  return r >= bt.UPPER_A && r <= bt.UPPER_Z || r >= bt.LOWER_A && r <= bt.LOWER_Z || Lp(r);
}
function XC(r) {
  return r === bt.EQUALS || KC(r);
}
var dt;
(function(r) {
  r[r.EntityStart = 0] = "EntityStart", r[r.NumericStart = 1] = "NumericStart", r[r.NumericDecimal = 2] = "NumericDecimal", r[r.NumericHex = 3] = "NumericHex", r[r.NamedEntity = 4] = "NamedEntity";
})(dt || (dt = {}));
var Br;
(function(r) {
  r[r.Legacy = 0] = "Legacy", r[r.Strict = 1] = "Strict", r[r.Attribute = 2] = "Attribute";
})(Br || (Br = {}));
class YE {
  constructor(e, t, s) {
    this.decodeTree = e, this.emitCodePoint = t, this.errors = s, this.state = dt.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Br.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = dt.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, t) {
    switch (this.state) {
      case dt.EntityStart:
        return e.charCodeAt(t) === bt.NUM ? (this.state = dt.NumericStart, this.consumed += 1, this.stateNumericStart(e, t + 1)) : (this.state = dt.NamedEntity, this.stateNamedEntity(e, t));
      case dt.NumericStart:
        return this.stateNumericStart(e, t);
      case dt.NumericDecimal:
        return this.stateNumericDecimal(e, t);
      case dt.NumericHex:
        return this.stateNumericHex(e, t);
      case dt.NamedEntity:
        return this.stateNamedEntity(e, t);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, t) {
    return t >= e.length ? -1 : (e.charCodeAt(t) | zC) === bt.LOWER_X ? (this.state = dt.NumericHex, this.consumed += 1, this.stateNumericHex(e, t + 1)) : (this.state = dt.NumericDecimal, this.stateNumericDecimal(e, t));
  }
  addToNumericResult(e, t, s, i) {
    if (t !== s) {
      const n = s - t;
      this.result = this.result * Math.pow(i, n) + Number.parseInt(e.substr(t, n), i), this.consumed += n;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, t) {
    const s = t;
    for (; t < e.length; ) {
      const i = e.charCodeAt(t);
      if (Lp(i) || GC(i))
        t += 1;
      else
        return this.addToNumericResult(e, s, t, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(e, s, t, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, t) {
    const s = t;
    for (; t < e.length; ) {
      const i = e.charCodeAt(t);
      if (Lp(i))
        t += 1;
      else
        return this.addToNumericResult(e, s, t, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(e, s, t, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, t) {
    var s;
    if (this.consumed <= t)
      return (s = this.errors) === null || s === void 0 || s.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === bt.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Br.Strict)
      return 0;
    return this.emitCodePoint(WC(this.result), this.consumed), this.errors && (e !== bt.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, t) {
    const { decodeTree: s } = this;
    let i = s[this.treeIndex], n = (i & Js.VALUE_LENGTH) >> 14;
    for (; t < e.length; t++, this.excess++) {
      const a = e.charCodeAt(t);
      if (this.treeIndex = JC(s, i, this.treeIndex + Math.max(1, n), a), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Br.Attribute && // We shouldn't have consumed any characters after the entity,
        (n === 0 || // And there should be no invalid characters.
        XC(a)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = s[this.treeIndex], n = (i & Js.VALUE_LENGTH) >> 14, n !== 0) {
        if (a === bt.SEMI)
          return this.emitNamedEntityData(this.treeIndex, n, this.consumed + this.excess);
        this.decodeMode !== Br.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: t, decodeTree: s } = this, i = (s[t] & Js.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(t, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, t, s) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(t === 1 ? i[e] & ~Js.VALUE_LENGTH : i[e + 1], s), t === 3 && this.emitCodePoint(i[e + 2], s), s;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case dt.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Br.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case dt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case dt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case dt.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case dt.EntityStart:
        return 0;
    }
  }
}
function QE(r) {
  let e = "";
  const t = new YE(r, (s) => e += Dp(s));
  return function(i, n) {
    let a = 0, o = 0;
    for (; (o = i.indexOf("&", o)) >= 0; ) {
      e += i.slice(a, o), t.startEntity(n);
      const l = t.write(
        i,
        // Skip the "&"
        o + 1
      );
      if (l < 0) {
        a = o + t.end();
        break;
      }
      a = o + l, o = l === 0 ? a + 1 : a;
    }
    const u = e + i.slice(a);
    return e = "", u;
  };
}
function JC(r, e, t, s) {
  const i = (e & Js.BRANCH_LENGTH) >> 7, n = e & Js.JUMP_TABLE;
  if (i === 0)
    return n !== 0 && s === n ? t : -1;
  if (n) {
    const u = s - n;
    return u < 0 || u >= i ? -1 : r[t + u] - 1;
  }
  let a = t, o = a + i - 1;
  for (; a <= o; ) {
    const u = a + o >>> 1, l = r[u];
    if (l < s)
      a = u + 1;
    else if (l > s)
      o = u - 1;
    else
      return r[u + i];
  }
  return -1;
}
const YC = QE(JE);
QE(qC);
function QC(r, e = Br.Legacy) {
  return YC(r, e);
}
const ay = new Uint8Array([123, 123]), oy = new Uint8Array([125, 125]);
function uy(r) {
  return r >= 97 && r <= 122 || r >= 65 && r <= 90;
}
function sr(r) {
  return r === 32 || r === 10 || r === 9 || r === 12 || r === 13;
}
function Rs(r) {
  return r === 47 || r === 62 || sr(r);
}
function bl(r) {
  const e = new Uint8Array(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
}
const _t = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea
};
let ZC = class {
  constructor(e, t) {
    this.stack = e, this.cbs = t, this.state = 1, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = 1, this.inRCDATA = !1, this.inXML = !1, this.inVPre = !1, this.newlines = [], this.mode = 0, this.delimiterOpen = ay, this.delimiterClose = oy, this.delimiterIndex = -1, this.currentSequence = void 0, this.sequenceIndex = 0, this.entityDecoder = new YE(
      JE,
      (s, i) => this.emitCodePoint(s, i)
    );
  }
  get inSFCRoot() {
    return this.mode === 2 && this.stack.length === 0;
  }
  reset() {
    this.state = 1, this.mode = 0, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = 1, this.inRCDATA = !1, this.currentSequence = void 0, this.newlines.length = 0, this.delimiterOpen = ay, this.delimiterClose = oy;
  }
  /**
   * Generate Position object with line / column information using recorded
   * newline positions. We know the index is always going to be an already
   * processed index, so all the newlines up to this index should have been
   * recorded.
   */
  getPos(e) {
    let t = 1, s = e + 1;
    for (let i = this.newlines.length - 1; i >= 0; i--) {
      const n = this.newlines[i];
      if (e > n) {
        t = i + 2, s = e - n;
        break;
      }
    }
    return {
      column: s,
      line: t,
      offset: e
    };
  }
  peek() {
    return this.buffer.charCodeAt(this.index + 1);
  }
  stateText(e) {
    e === 60 ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = 5, this.sectionStart = this.index) : e === 38 ? this.startEntity() : !this.inVPre && e === this.delimiterOpen[0] && (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e));
  }
  stateInterpolationOpen(e) {
    if (e === this.delimiterOpen[this.delimiterIndex])
      if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const t = this.index + 1 - this.delimiterOpen.length;
        t > this.sectionStart && this.cbs.ontext(this.sectionStart, t), this.state = 3, this.sectionStart = t;
      } else
        this.delimiterIndex++;
    else this.inRCDATA ? (this.state = 32, this.stateInRCDATA(e)) : (this.state = 1, this.stateText(e));
  }
  stateInterpolation(e) {
    e === this.delimiterClose[0] && (this.state = 4, this.delimiterIndex = 0, this.stateInterpolationClose(e));
  }
  stateInterpolationClose(e) {
    e === this.delimiterClose[this.delimiterIndex] ? this.delimiterIndex === this.delimiterClose.length - 1 ? (this.cbs.oninterpolation(this.sectionStart, this.index + 1), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : this.delimiterIndex++ : (this.state = 3, this.stateInterpolation(e));
  }
  stateSpecialStartSequence(e) {
    const t = this.sequenceIndex === this.currentSequence.length;
    if (!(t ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      Rs(e)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (e | 32) === this.currentSequence[this.sequenceIndex]
    )))
      this.inRCDATA = !1;
    else if (!t) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0, this.state = 6, this.stateInTagName(e);
  }
  /** Look for an end tag. For <title> and <textarea>, also decode entities. */
  stateInRCDATA(e) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (e === 62 || sr(e)) {
        const t = this.index - this.currentSequence.length;
        if (this.sectionStart < t) {
          const s = this.index;
          this.index = t, this.cbs.ontext(this.sectionStart, t), this.index = s;
        }
        this.sectionStart = t + 2, this.stateInClosingTagName(e), this.inRCDATA = !1;
        return;
      }
      this.sequenceIndex = 0;
    }
    (e | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === _t.TitleEnd || this.currentSequence === _t.TextareaEnd && !this.inSFCRoot ? e === 38 ? this.startEntity() : e === this.delimiterOpen[0] && (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e)) : this.fastForwardTo(60) && (this.sequenceIndex = 1) : this.sequenceIndex = +(e === 60);
  }
  stateCDATASequence(e) {
    e === _t.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === _t.Cdata.length && (this.state = 28, this.currentSequence = _t.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = 23, this.stateInDeclaration(e));
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(e) {
    for (; ++this.index < this.buffer.length; ) {
      const t = this.buffer.charCodeAt(this.index);
      if (t === 10 && this.newlines.push(this.index), t === e)
        return !0;
    }
    return this.index = this.buffer.length - 1, !1;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(e) {
    e === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === _t.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index - 2) : this.cbs.oncomment(this.sectionStart, this.index - 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = 1) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  startSpecial(e, t) {
    this.enterRCDATA(e, t), this.state = 31;
  }
  enterRCDATA(e, t) {
    this.inRCDATA = !0, this.currentSequence = e, this.sequenceIndex = t;
  }
  stateBeforeTagName(e) {
    e === 33 ? (this.state = 22, this.sectionStart = this.index + 1) : e === 63 ? (this.state = 24, this.sectionStart = this.index + 1) : uy(e) ? (this.sectionStart = this.index, this.mode === 0 ? this.state = 6 : this.inSFCRoot ? this.state = 34 : this.inXML ? this.state = 6 : e === 116 ? this.state = 30 : this.state = e === 115 ? 29 : 6) : e === 47 ? this.state = 8 : (this.state = 1, this.stateText(e));
  }
  stateInTagName(e) {
    Rs(e) && this.handleTagName(e);
  }
  stateInSFCRootTagName(e) {
    if (Rs(e)) {
      const t = this.buffer.slice(this.sectionStart, this.index);
      t !== "template" && this.enterRCDATA(bl("</" + t), 0), this.handleTagName(e);
    }
  }
  handleTagName(e) {
    this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e);
  }
  stateBeforeClosingTagName(e) {
    sr(e) || (e === 62 ? (this.cbs.onerr(14, this.index), this.state = 1, this.sectionStart = this.index + 1) : (this.state = uy(e) ? 9 : 27, this.sectionStart = this.index));
  }
  stateInClosingTagName(e) {
    (e === 62 || sr(e)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = 10, this.stateAfterClosingTagName(e));
  }
  stateAfterClosingTagName(e) {
    e === 62 && (this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeAttrName(e) {
    e === 62 ? (this.cbs.onopentagend(this.index), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : e === 47 ? (this.state = 7, this.peek() !== 62 && this.cbs.onerr(22, this.index)) : e === 60 && this.peek() === 47 ? (this.cbs.onopentagend(this.index), this.state = 5, this.sectionStart = this.index) : sr(e) || (e === 61 && this.cbs.onerr(
      19,
      this.index
    ), this.handleAttrStart(e));
  }
  handleAttrStart(e) {
    e === 118 && this.peek() === 45 ? (this.state = 13, this.sectionStart = this.index) : e === 46 || e === 58 || e === 64 || e === 35 ? (this.cbs.ondirname(this.index, this.index + 1), this.state = 14, this.sectionStart = this.index + 1) : (this.state = 12, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(e) {
    e === 62 ? (this.cbs.onselfclosingtag(this.index), this.state = 1, this.sectionStart = this.index + 1, this.inRCDATA = !1) : sr(e) || (this.state = 11, this.stateBeforeAttrName(e));
  }
  stateInAttrName(e) {
    e === 61 || Rs(e) ? (this.cbs.onattribname(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : (e === 34 || e === 39 || e === 60) && this.cbs.onerr(
      17,
      this.index
    );
  }
  stateInDirName(e) {
    e === 61 || Rs(e) ? (this.cbs.ondirname(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 58 ? (this.cbs.ondirname(this.sectionStart, this.index), this.state = 14, this.sectionStart = this.index + 1) : e === 46 && (this.cbs.ondirname(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
  }
  stateInDirArg(e) {
    e === 61 || Rs(e) ? (this.cbs.ondirarg(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 91 ? this.state = 15 : e === 46 && (this.cbs.ondirarg(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
  }
  stateInDynamicDirArg(e) {
    e === 93 ? this.state = 14 : (e === 61 || Rs(e)) && (this.cbs.ondirarg(this.sectionStart, this.index + 1), this.handleAttrNameEnd(e), this.cbs.onerr(
      27,
      this.index
    ));
  }
  stateInDirModifier(e) {
    e === 61 || Rs(e) ? (this.cbs.ondirmodifier(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 46 && (this.cbs.ondirmodifier(this.sectionStart, this.index), this.sectionStart = this.index + 1);
  }
  handleAttrNameEnd(e) {
    this.sectionStart = this.index, this.state = 17, this.cbs.onattribnameend(this.index), this.stateAfterAttrName(e);
  }
  stateAfterAttrName(e) {
    e === 61 ? this.state = 18 : e === 47 || e === 62 ? (this.cbs.onattribend(0, this.sectionStart), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e)) : sr(e) || (this.cbs.onattribend(0, this.sectionStart), this.handleAttrStart(e));
  }
  stateBeforeAttrValue(e) {
    e === 34 ? (this.state = 19, this.sectionStart = this.index + 1) : e === 39 ? (this.state = 20, this.sectionStart = this.index + 1) : sr(e) || (this.sectionStart = this.index, this.state = 21, this.stateInAttrValueNoQuotes(e));
  }
  handleInAttrValue(e, t) {
    e === t ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(
      t === 34 ? 3 : 2,
      this.index + 1
    ), this.state = 11) : e === 38 && this.startEntity();
  }
  stateInAttrValueDoubleQuotes(e) {
    this.handleInAttrValue(e, 34);
  }
  stateInAttrValueSingleQuotes(e) {
    this.handleInAttrValue(e, 39);
  }
  stateInAttrValueNoQuotes(e) {
    sr(e) || e === 62 ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(1, this.index), this.state = 11, this.stateBeforeAttrName(e)) : e === 34 || e === 39 || e === 60 || e === 61 || e === 96 ? this.cbs.onerr(
      18,
      this.index
    ) : e === 38 && this.startEntity();
  }
  stateBeforeDeclaration(e) {
    e === 91 ? (this.state = 26, this.sequenceIndex = 0) : this.state = e === 45 ? 25 : 23;
  }
  stateInDeclaration(e) {
    (e === 62 || this.fastForwardTo(62)) && (this.state = 1, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(e) {
    (e === 62 || this.fastForwardTo(62)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(e) {
    e === 45 ? (this.state = 28, this.currentSequence = _t.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = 23;
  }
  stateInSpecialComment(e) {
    (e === 62 || this.fastForwardTo(62)) && (this.cbs.oncomment(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(e) {
    e === _t.ScriptEnd[3] ? this.startSpecial(_t.ScriptEnd, 4) : e === _t.StyleEnd[3] ? this.startSpecial(_t.StyleEnd, 4) : (this.state = 6, this.stateInTagName(e));
  }
  stateBeforeSpecialT(e) {
    e === _t.TitleEnd[3] ? this.startSpecial(_t.TitleEnd, 4) : e === _t.TextareaEnd[3] ? this.startSpecial(_t.TextareaEnd, 4) : (this.state = 6, this.stateInTagName(e));
  }
  startEntity() {
    this.baseState = this.state, this.state = 33, this.entityStart = this.index, this.entityDecoder.startEntity(
      this.baseState === 1 || this.baseState === 32 ? Br.Legacy : Br.Attribute
    );
  }
  stateInEntity() {
    {
      const e = this.entityDecoder.write(this.buffer, this.index);
      e >= 0 ? (this.state = this.baseState, e === 0 && (this.index = this.entityStart)) : this.index = this.buffer.length - 1;
    }
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse(e) {
    for (this.buffer = e; this.index < this.buffer.length; ) {
      const t = this.buffer.charCodeAt(this.index);
      switch (t === 10 && this.newlines.push(this.index), this.state) {
        case 1: {
          this.stateText(t);
          break;
        }
        case 2: {
          this.stateInterpolationOpen(t);
          break;
        }
        case 3: {
          this.stateInterpolation(t);
          break;
        }
        case 4: {
          this.stateInterpolationClose(t);
          break;
        }
        case 31: {
          this.stateSpecialStartSequence(t);
          break;
        }
        case 32: {
          this.stateInRCDATA(t);
          break;
        }
        case 26: {
          this.stateCDATASequence(t);
          break;
        }
        case 19: {
          this.stateInAttrValueDoubleQuotes(t);
          break;
        }
        case 12: {
          this.stateInAttrName(t);
          break;
        }
        case 13: {
          this.stateInDirName(t);
          break;
        }
        case 14: {
          this.stateInDirArg(t);
          break;
        }
        case 15: {
          this.stateInDynamicDirArg(t);
          break;
        }
        case 16: {
          this.stateInDirModifier(t);
          break;
        }
        case 28: {
          this.stateInCommentLike(t);
          break;
        }
        case 27: {
          this.stateInSpecialComment(t);
          break;
        }
        case 11: {
          this.stateBeforeAttrName(t);
          break;
        }
        case 6: {
          this.stateInTagName(t);
          break;
        }
        case 34: {
          this.stateInSFCRootTagName(t);
          break;
        }
        case 9: {
          this.stateInClosingTagName(t);
          break;
        }
        case 5: {
          this.stateBeforeTagName(t);
          break;
        }
        case 17: {
          this.stateAfterAttrName(t);
          break;
        }
        case 20: {
          this.stateInAttrValueSingleQuotes(t);
          break;
        }
        case 18: {
          this.stateBeforeAttrValue(t);
          break;
        }
        case 8: {
          this.stateBeforeClosingTagName(t);
          break;
        }
        case 10: {
          this.stateAfterClosingTagName(t);
          break;
        }
        case 29: {
          this.stateBeforeSpecialS(t);
          break;
        }
        case 30: {
          this.stateBeforeSpecialT(t);
          break;
        }
        case 21: {
          this.stateInAttrValueNoQuotes(t);
          break;
        }
        case 7: {
          this.stateInSelfClosingTag(t);
          break;
        }
        case 23: {
          this.stateInDeclaration(t);
          break;
        }
        case 22: {
          this.stateBeforeDeclaration(t);
          break;
        }
        case 25: {
          this.stateBeforeComment(t);
          break;
        }
        case 24: {
          this.stateInProcessingInstruction(t);
          break;
        }
        case 33: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup(), this.finish();
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    this.sectionStart !== this.index && (this.state === 1 || this.state === 32 && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === 19 || this.state === 20 || this.state === 21) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  finish() {
    this.state === 33 && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const e = this.buffer.length;
    this.sectionStart >= e || (this.state === 28 ? this.currentSequence === _t.CdataEnd ? this.cbs.oncdata(this.sectionStart, e) : this.cbs.oncomment(this.sectionStart, e) : this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9 || this.cbs.ontext(this.sectionStart, e));
  }
  emitCodePoint(e, t) {
    this.baseState !== 1 && this.baseState !== 32 ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + t, this.index = this.sectionStart - 1, this.cbs.onattribentity(
      Dp(e),
      this.entityStart,
      this.sectionStart
    )) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + t, this.index = this.sectionStart - 1, this.cbs.ontextentity(
      Dp(e),
      this.entityStart,
      this.sectionStart
    ));
  }
};
const eN = {
  COMPILER_IS_ON_ELEMENT: "COMPILER_IS_ON_ELEMENT",
  COMPILER_V_BIND_SYNC: "COMPILER_V_BIND_SYNC",
  COMPILER_V_BIND_OBJECT_ORDER: "COMPILER_V_BIND_OBJECT_ORDER",
  COMPILER_V_ON_NATIVE: "COMPILER_V_ON_NATIVE",
  COMPILER_V_IF_V_FOR_PRECEDENCE: "COMPILER_V_IF_V_FOR_PRECEDENCE",
  COMPILER_NATIVE_TEMPLATE: "COMPILER_NATIVE_TEMPLATE",
  COMPILER_INLINE_TEMPLATE: "COMPILER_INLINE_TEMPLATE",
  COMPILER_FILTERS: "COMPILER_FILTERS"
}, tN = {
  COMPILER_IS_ON_ELEMENT: {
    message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
    link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"
  },
  COMPILER_V_BIND_SYNC: {
    message: (r) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${r}.sync\` should be changed to \`v-model:${r}\`.`,
    link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html"
  },
  COMPILER_V_BIND_OBJECT_ORDER: {
    message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
    link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html"
  },
  COMPILER_V_ON_NATIVE: {
    message: ".native modifier for v-on has been removed as is no longer necessary.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"
  },
  COMPILER_V_IF_V_FOR_PRECEDENCE: {
    message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"
  },
  COMPILER_NATIVE_TEMPLATE: {
    message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3."
  },
  COMPILER_INLINE_TEMPLATE: {
    message: '"inline-template" has been removed in Vue 3.',
    link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"
  },
  COMPILER_FILTERS: {
    message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
    link: "https://v3-migration.vuejs.org/breaking-changes/filters.html"
  }
};
function Mp(r, { compatConfig: e }) {
  const t = e && e[r];
  return r === "MODE" ? t || 3 : t;
}
function rN(r, e) {
  const t = Mp("MODE", e), s = Mp(r, e);
  return t === 3 ? s === !0 : s !== !1;
}
function sN(r, e, t, ...s) {
  const i = rN(r, e);
  return i && ZE(r, e, t, ...s), i;
}
function ZE(r, e, t, ...s) {
  if (Mp(r, e) === "suppress-warning")
    return;
  const { message: n, link: a } = tN[r], o = `(deprecation ${r}) ${typeof n == "function" ? n(...s) : n}${a ? `
  Details: ${a}` : ""}`, u = new SyntaxError(o);
  u.code = r, t && (u.loc = t), e.onWarn(u);
}
function em(r) {
  throw r;
}
function eS(r) {
  console.warn(`[Vue warn] ${r.message}`);
}
function Me(r, e, t, s) {
  const i = (t || tm)[r] + (s || ""), n = new SyntaxError(String(i));
  return n.code = r, n.loc = e, n;
}
const iN = {
  ABRUPT_CLOSING_OF_EMPTY_COMMENT: 0,
  0: "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
  CDATA_IN_HTML_CONTENT: 1,
  1: "CDATA_IN_HTML_CONTENT",
  DUPLICATE_ATTRIBUTE: 2,
  2: "DUPLICATE_ATTRIBUTE",
  END_TAG_WITH_ATTRIBUTES: 3,
  3: "END_TAG_WITH_ATTRIBUTES",
  END_TAG_WITH_TRAILING_SOLIDUS: 4,
  4: "END_TAG_WITH_TRAILING_SOLIDUS",
  EOF_BEFORE_TAG_NAME: 5,
  5: "EOF_BEFORE_TAG_NAME",
  EOF_IN_CDATA: 6,
  6: "EOF_IN_CDATA",
  EOF_IN_COMMENT: 7,
  7: "EOF_IN_COMMENT",
  EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT: 8,
  8: "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
  EOF_IN_TAG: 9,
  9: "EOF_IN_TAG",
  INCORRECTLY_CLOSED_COMMENT: 10,
  10: "INCORRECTLY_CLOSED_COMMENT",
  INCORRECTLY_OPENED_COMMENT: 11,
  11: "INCORRECTLY_OPENED_COMMENT",
  INVALID_FIRST_CHARACTER_OF_TAG_NAME: 12,
  12: "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
  MISSING_ATTRIBUTE_VALUE: 13,
  13: "MISSING_ATTRIBUTE_VALUE",
  MISSING_END_TAG_NAME: 14,
  14: "MISSING_END_TAG_NAME",
  MISSING_WHITESPACE_BETWEEN_ATTRIBUTES: 15,
  15: "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
  NESTED_COMMENT: 16,
  16: "NESTED_COMMENT",
  UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME: 17,
  17: "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
  UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE: 18,
  18: "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
  UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME: 19,
  19: "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
  UNEXPECTED_NULL_CHARACTER: 20,
  20: "UNEXPECTED_NULL_CHARACTER",
  UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME: 21,
  21: "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
  UNEXPECTED_SOLIDUS_IN_TAG: 22,
  22: "UNEXPECTED_SOLIDUS_IN_TAG",
  X_INVALID_END_TAG: 23,
  23: "X_INVALID_END_TAG",
  X_MISSING_END_TAG: 24,
  24: "X_MISSING_END_TAG",
  X_MISSING_INTERPOLATION_END: 25,
  25: "X_MISSING_INTERPOLATION_END",
  X_MISSING_DIRECTIVE_NAME: 26,
  26: "X_MISSING_DIRECTIVE_NAME",
  X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END: 27,
  27: "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
  X_V_IF_NO_EXPRESSION: 28,
  28: "X_V_IF_NO_EXPRESSION",
  X_V_IF_SAME_KEY: 29,
  29: "X_V_IF_SAME_KEY",
  X_V_ELSE_NO_ADJACENT_IF: 30,
  30: "X_V_ELSE_NO_ADJACENT_IF",
  X_V_FOR_NO_EXPRESSION: 31,
  31: "X_V_FOR_NO_EXPRESSION",
  X_V_FOR_MALFORMED_EXPRESSION: 32,
  32: "X_V_FOR_MALFORMED_EXPRESSION",
  X_V_FOR_TEMPLATE_KEY_PLACEMENT: 33,
  33: "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
  X_V_BIND_NO_EXPRESSION: 34,
  34: "X_V_BIND_NO_EXPRESSION",
  X_V_ON_NO_EXPRESSION: 35,
  35: "X_V_ON_NO_EXPRESSION",
  X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET: 36,
  36: "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
  X_V_SLOT_MIXED_SLOT_USAGE: 37,
  37: "X_V_SLOT_MIXED_SLOT_USAGE",
  X_V_SLOT_DUPLICATE_SLOT_NAMES: 38,
  38: "X_V_SLOT_DUPLICATE_SLOT_NAMES",
  X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN: 39,
  39: "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
  X_V_SLOT_MISPLACED: 40,
  40: "X_V_SLOT_MISPLACED",
  X_V_MODEL_NO_EXPRESSION: 41,
  41: "X_V_MODEL_NO_EXPRESSION",
  X_V_MODEL_MALFORMED_EXPRESSION: 42,
  42: "X_V_MODEL_MALFORMED_EXPRESSION",
  X_V_MODEL_ON_SCOPE_VARIABLE: 43,
  43: "X_V_MODEL_ON_SCOPE_VARIABLE",
  X_V_MODEL_ON_PROPS: 44,
  44: "X_V_MODEL_ON_PROPS",
  X_INVALID_EXPRESSION: 45,
  45: "X_INVALID_EXPRESSION",
  X_KEEP_ALIVE_INVALID_CHILDREN: 46,
  46: "X_KEEP_ALIVE_INVALID_CHILDREN",
  X_PREFIX_ID_NOT_SUPPORTED: 47,
  47: "X_PREFIX_ID_NOT_SUPPORTED",
  X_MODULE_MODE_NOT_SUPPORTED: 48,
  48: "X_MODULE_MODE_NOT_SUPPORTED",
  X_CACHE_HANDLER_NOT_SUPPORTED: 49,
  49: "X_CACHE_HANDLER_NOT_SUPPORTED",
  X_SCOPE_ID_NOT_SUPPORTED: 50,
  50: "X_SCOPE_ID_NOT_SUPPORTED",
  X_VNODE_HOOKS: 51,
  51: "X_VNODE_HOOKS",
  X_V_BIND_INVALID_SAME_NAME_ARGUMENT: 52,
  52: "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
  __EXTEND_POINT__: 53,
  53: "__EXTEND_POINT__"
}, tm = {
  // parse errors
  0: "Illegal comment.",
  1: "CDATA section is allowed only in XML context.",
  2: "Duplicate attribute.",
  3: "End tag cannot have attributes.",
  4: "Illegal '/' in tags.",
  5: "Unexpected EOF in tag.",
  6: "Unexpected EOF in CDATA section.",
  7: "Unexpected EOF in comment.",
  8: "Unexpected EOF in script.",
  9: "Unexpected EOF in tag.",
  10: "Incorrectly closed comment.",
  11: "Incorrectly opened comment.",
  12: "Illegal tag name. Use '&lt;' to print '<'.",
  13: "Attribute value was expected.",
  14: "End tag name was expected.",
  15: "Whitespace was expected.",
  16: "Unexpected '<!--' in comment.",
  17: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  19: "Attribute name cannot start with '='.",
  21: "'<?' is allowed only in XML context.",
  20: "Unexpected null character.",
  22: "Illegal '/' in tags.",
  // Vue-specific parse errors
  23: "Invalid end tag.",
  24: "Element is missing end tag.",
  25: "Interpolation end sign was not found.",
  27: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  26: "Legal directive name was expected.",
  // transform errors
  28: "v-if/v-else-if is missing expression.",
  29: "v-if/else branches must use unique keys.",
  30: "v-else/v-else-if has no adjacent v-if or v-else-if.",
  31: "v-for is missing expression.",
  32: "v-for has invalid expression.",
  33: "<template v-for> key should be placed on the <template> tag.",
  34: "v-bind is missing expression.",
  52: "v-bind with same-name shorthand only allows static argument.",
  35: "v-on is missing expression.",
  36: "Unexpected custom directive on <slot> outlet.",
  37: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",
  38: "Duplicate slot names found. ",
  39: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.",
  40: "v-slot can only be used on components or <template> tags.",
  41: "v-model is missing expression.",
  42: "v-model value must be a valid JavaScript member expression.",
  43: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.",
  44: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  45: "Error parsing JavaScript expression: ",
  46: "<KeepAlive> expects exactly one child component.",
  51: "@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.",
  // generic errors
  47: '"prefixIdentifiers" option is not supported in this build of compiler.',
  48: "ES module mode is not supported in this build of compiler.",
  49: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',
  50: '"scopeId" option is only supported in module mode.',
  // just to fulfill types
  53: ""
};
function Dc(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function Vo(r) {
  if (r.__esModule) return r;
  var e = r.default;
  if (typeof e == "function") {
    var t = function s() {
      return this instanceof s ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(r).forEach(function(s) {
    var i = Object.getOwnPropertyDescriptor(r, s);
    Object.defineProperty(t, s, i.get ? i : {
      enumerable: !0,
      get: function() {
        return r[s];
      }
    });
  }), t;
}
var Lc = {};
Object.defineProperty(Lc, "__esModule", {
  value: !0
});
function tS(r, e) {
  if (r == null) return {};
  var t = {}, s = Object.keys(r), i, n;
  for (n = 0; n < s.length; n++)
    i = s[n], !(e.indexOf(i) >= 0) && (t[i] = r[i]);
  return t;
}
class ri {
  constructor(e, t, s) {
    this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = t, this.index = s;
  }
}
class vl {
  constructor(e, t) {
    this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = t;
  }
}
function Ht(r, e) {
  const {
    line: t,
    column: s,
    index: i
  } = r;
  return new ri(t, s + e, i + e);
}
const ly = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
var nN = {
  ImportMetaOutsideModule: {
    message: `import.meta may appear only with 'sourceType: "module"'`,
    code: ly
  },
  ImportOutsideModule: {
    message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
    code: ly
  }
};
const cy = {
  ArrayPattern: "array destructuring pattern",
  AssignmentExpression: "assignment expression",
  AssignmentPattern: "assignment expression",
  ArrowFunctionExpression: "arrow function expression",
  ConditionalExpression: "conditional expression",
  CatchClause: "catch clause",
  ForOfStatement: "for-of statement",
  ForInStatement: "for-in statement",
  ForStatement: "for-loop",
  FormalParameters: "function parameter list",
  Identifier: "identifier",
  ImportSpecifier: "import specifier",
  ImportDefaultSpecifier: "import default specifier",
  ImportNamespaceSpecifier: "import namespace specifier",
  ObjectPattern: "object destructuring pattern",
  ParenthesizedExpression: "parenthesized expression",
  RestElement: "rest element",
  UpdateExpression: {
    true: "prefix operation",
    false: "postfix operation"
  },
  VariableDeclarator: "variable declaration",
  YieldExpression: "yield expression"
}, Lu = (r) => r.type === "UpdateExpression" ? cy.UpdateExpression[`${r.prefix}`] : cy[r.type];
var aN = {
  AccessorIsGenerator: ({
    kind: r
  }) => `A ${r}ter cannot be a generator.`,
  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
  AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
  BadGetterArity: "A 'get' accessor must not have any formal parameters.",
  BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
  BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
  ConstructorClassField: "Classes may not have a field named 'constructor'.",
  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
  ConstructorIsAccessor: "Class constructor may not be an accessor.",
  ConstructorIsAsync: "Constructor can't be an async function.",
  ConstructorIsGenerator: "Constructor can't be a generator.",
  DeclarationMissingInitializer: ({
    kind: r
  }) => `Missing initializer in ${r} declaration.`,
  DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
  DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
  DecoratorStaticBlock: "Decorators can't be used with a static block.",
  DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
  DeletePrivateField: "Deleting a private field is not allowed.",
  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
  DuplicateConstructor: "Duplicate constructor in the same class.",
  DuplicateDefaultExport: "Only one default export allowed per module.",
  DuplicateExport: ({
    exportName: r
  }) => `\`${r}\` has already been exported. Exported identifiers must be unique.`,
  DuplicateProto: "Redefinition of __proto__ property.",
  DuplicateRegExpFlags: "Duplicate regular expression flag.",
  DynamicImportPhaseRequiresImportExpressions: ({
    phase: r
  }) => `'import.${r}(...)' can only be parsed when using the 'createImportExpressions' option.`,
  ElementAfterRest: "Rest element must be last element.",
  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
  ExportBindingIsString: ({
    localName: r,
    exportName: e
  }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${r}' as '${e}' } from 'some-module'\`?`,
  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
  ForInOfLoopInitializer: ({
    type: r
  }) => `'${r === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
  ForInUsing: "For-in loop may not start with 'using' declaration.",
  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
  IllegalBreakContinue: ({
    type: r
  }) => `Unsyntactic ${r === "BreakStatement" ? "break" : "continue"}.`,
  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
  IllegalReturn: "'return' outside of function.",
  ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
  ImportBindingIsString: ({
    importName: r
  }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${r}" as foo }\`?`,
  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
  ImportCallArity: ({
    maxArgumentCount: r
  }) => `\`import()\` requires exactly ${r === 1 ? "one argument" : "one or two arguments"}.`,
  ImportCallNotNewExpression: "Cannot use new with import(...).",
  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
  ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
  ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
  ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
  IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
  InvalidCodePoint: "Code point out of bounds.",
  InvalidCoverInitializedName: "Invalid shorthand property initializer.",
  InvalidDecimal: "Invalid decimal.",
  InvalidDigit: ({
    radix: r
  }) => `Expected number in radix ${r}.`,
  InvalidEscapeSequence: "Bad character escape sequence.",
  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
  InvalidEscapedReservedWord: ({
    reservedWord: r
  }) => `Escape sequence in keyword ${r}.`,
  InvalidIdentifier: ({
    identifierName: r
  }) => `Invalid identifier ${r}.`,
  InvalidLhs: ({
    ancestor: r
  }) => `Invalid left-hand side in ${Lu(r)}.`,
  InvalidLhsBinding: ({
    ancestor: r
  }) => `Binding invalid left-hand side in ${Lu(r)}.`,
  InvalidLhsOptionalChaining: ({
    ancestor: r
  }) => `Invalid optional chaining in the left-hand side of ${Lu(r)}.`,
  InvalidNumber: "Invalid number.",
  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
  InvalidOrUnexpectedToken: ({
    unexpected: r
  }) => `Unexpected character '${r}'.`,
  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
  InvalidPrivateFieldResolution: ({
    identifierName: r
  }) => `Private name #${r} is not defined.`,
  InvalidPropertyBindingPattern: "Binding member expression.",
  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
  LabelRedeclaration: ({
    labelName: r
  }) => `Label '${r}' is already declared.`,
  LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
  MalformedRegExpFlags: "Invalid regular expression flag.",
  MissingClassName: "A class name is required.",
  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
  MissingSemicolon: "Missing semicolon.",
  MissingPlugin: ({
    missingPlugin: r
  }) => `This experimental syntax requires enabling the parser plugin: ${r.map((e) => JSON.stringify(e)).join(", ")}.`,
  MissingOneOfPlugins: ({
    missingPlugin: r
  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${r.map((e) => JSON.stringify(e)).join(", ")}.`,
  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
  ModuleAttributesWithDuplicateKeys: ({
    key: r
  }) => `Duplicate key "${r}" is not allowed in module attributes.`,
  ModuleExportNameHasLoneSurrogate: ({
    surrogateCharCode: r
  }) => `An export name cannot include a lone surrogate, found '\\u${r.toString(16)}'.`,
  ModuleExportUndefined: ({
    localName: r
  }) => `Export '${r}' is not defined.`,
  MultipleDefaultsInSwitch: "Multiple default clauses.",
  NewlineAfterThrow: "Illegal newline after throw.",
  NoCatchOrFinally: "Missing catch or finally clause.",
  NumberIdentifier: "Identifier directly after number.",
  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
  ParamDupe: "Argument name clash.",
  PatternHasAccessor: "Object pattern can't contain getter or setter.",
  PatternHasMethod: "Object pattern can't contain methods.",
  PrivateInExpectedIn: ({
    identifierName: r
  }) => `Private names are only allowed in property accesses (\`obj.#${r}\`) or in \`in\` expressions (\`#${r} in obj\`).`,
  PrivateNameRedeclaration: ({
    identifierName: r
  }) => `Duplicate private name #${r}.`,
  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
  RestTrailingComma: "Unexpected trailing comma after rest element.",
  SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
  SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
  SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
  StaticPrototype: "Classes may not have static property named prototype.",
  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
  SuperPrivateField: "Private fields can't be accessed on super.",
  TrailingDecorator: "Decorators must be attached to a class element.",
  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
  UnexpectedKeyword: ({
    keyword: r
  }) => `Unexpected keyword '${r}'.`,
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
  UnexpectedPrivateField: "Unexpected private name.",
  UnexpectedReservedWord: ({
    reservedWord: r
  }) => `Unexpected reserved word '${r}'.`,
  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
  UnexpectedToken: ({
    expected: r,
    unexpected: e
  }) => `Unexpected token${e ? ` '${e}'.` : ""}${r ? `, expected "${r}"` : ""}`,
  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
  UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
  UnsupportedBind: "Binding should be performed on object property.",
  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
  UnsupportedMetaProperty: ({
    target: r,
    onlyValidPropertyName: e
  }) => `The only valid meta property for ${r} is ${r}.${e}.`,
  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
  UnterminatedComment: "Unterminated comment.",
  UnterminatedRegExp: "Unterminated regular expression.",
  UnterminatedString: "Unterminated string constant.",
  UnterminatedTemplate: "Unterminated template.",
  UsingDeclarationExport: "Using declaration cannot be exported.",
  UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
  VarRedeclaration: ({
    identifierName: r
  }) => `Identifier '${r}' has already been declared.`,
  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
  YieldInParameter: "Yield expression is not allowed in formal parameters.",
  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
}, oN = {
  StrictDelete: "Deleting local variable in strict mode.",
  StrictEvalArguments: ({
    referenceName: r
  }) => `Assigning to '${r}' in strict mode.`,
  StrictEvalArgumentsBinding: ({
    bindingName: r
  }) => `Binding '${r}' in strict mode.`,
  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
  StrictWith: "'with' in strict mode."
};
const uN = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
var lN = {
  PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
  PipeTopicUnconfiguredToken: ({
    token: r
  }) => `Invalid topic token ${r}. In order to use ${r} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${r}" }.`,
  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
  PipeUnparenthesizedBody: ({
    type: r
  }) => `Hack-style pipe body cannot be an unparenthesized ${Lu({
    type: r
  })}; please wrap it in parentheses.`,
  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
};
const cN = ["toMessage"], fN = ["message"];
function fy(r, e, t) {
  Object.defineProperty(r, e, {
    enumerable: !1,
    configurable: !0,
    value: t
  });
}
function pN(r) {
  let {
    toMessage: e
  } = r, t = tS(r, cN);
  return function s(i, n) {
    const a = new SyntaxError();
    return Object.assign(a, t, {
      loc: i,
      pos: i.index
    }), "missingPlugin" in n && Object.assign(a, {
      missingPlugin: n.missingPlugin
    }), fy(a, "clone", function(u = {}) {
      var l;
      const {
        line: c,
        column: f,
        index: p
      } = (l = u.loc) != null ? l : i;
      return s(new ri(c, f, p), Object.assign({}, n, u.details));
    }), fy(a, "details", n), Object.defineProperty(a, "message", {
      configurable: !0,
      get() {
        const o = `${e(n)} (${i.line}:${i.column})`;
        return this.message = o, o;
      },
      set(o) {
        Object.defineProperty(this, "message", {
          value: o,
          writable: !0
        });
      }
    }), a;
  };
}
function gs(r, e) {
  if (Array.isArray(r))
    return (s) => gs(s, r[0]);
  const t = {};
  for (const s of Object.keys(r)) {
    const i = r[s], n = typeof i == "string" ? {
      message: () => i
    } : typeof i == "function" ? {
      message: i
    } : i, {
      message: a
    } = n, o = tS(n, fN), u = typeof a == "string" ? () => a : a;
    t[s] = pN(Object.assign({
      code: "BABEL_PARSER_SYNTAX_ERROR",
      reasonCode: s,
      toMessage: u
    }, e ? {
      syntaxPlugin: e
    } : {}, o));
  }
  return t;
}
const O = Object.assign({}, gs(nN), gs(aN), gs(oN), gs`pipelineOperator`(lN)), {
  defineProperty: hN
} = Object, py = (r, e) => hN(r, e, {
  enumerable: !1,
  value: r[e]
});
function ma(r) {
  return r.loc.start && py(r.loc.start, "index"), r.loc.end && py(r.loc.end, "index"), r;
}
var dN = (r) => class extends r {
  parse() {
    const t = ma(super.parse());
    return this.options.tokens && (t.tokens = t.tokens.map(ma)), t;
  }
  parseRegExpLiteral({
    pattern: t,
    flags: s
  }) {
    let i = null;
    try {
      i = new RegExp(t, s);
    } catch {
    }
    const n = this.estreeParseLiteral(i);
    return n.regex = {
      pattern: t,
      flags: s
    }, n;
  }
  parseBigIntLiteral(t) {
    let s;
    try {
      s = BigInt(t);
    } catch {
      s = null;
    }
    const i = this.estreeParseLiteral(s);
    return i.bigint = String(i.value || t), i;
  }
  parseDecimalLiteral(t) {
    const i = this.estreeParseLiteral(null);
    return i.decimal = String(i.value || t), i;
  }
  estreeParseLiteral(t) {
    return this.parseLiteral(t, "Literal");
  }
  parseStringLiteral(t) {
    return this.estreeParseLiteral(t);
  }
  parseNumericLiteral(t) {
    return this.estreeParseLiteral(t);
  }
  parseNullLiteral() {
    return this.estreeParseLiteral(null);
  }
  parseBooleanLiteral(t) {
    return this.estreeParseLiteral(t);
  }
  directiveToStmt(t) {
    const s = t.value;
    delete t.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
    const i = t;
    return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
  }
  initFunction(t, s) {
    super.initFunction(t, s), t.expression = !1;
  }
  checkDeclaration(t) {
    t != null && this.isObjectProperty(t) ? this.checkDeclaration(t.value) : super.checkDeclaration(t);
  }
  getObjectOrClassMethodParams(t) {
    return t.value.params;
  }
  isValidDirective(t) {
    var s;
    return t.type === "ExpressionStatement" && t.expression.type === "Literal" && typeof t.expression.value == "string" && !((s = t.expression.extra) != null && s.parenthesized);
  }
  parseBlockBody(t, s, i, n, a) {
    super.parseBlockBody(t, s, i, n, a);
    const o = t.directives.map((u) => this.directiveToStmt(u));
    t.body = o.concat(t.body), delete t.directives;
  }
  pushClassMethod(t, s, i, n, a, o) {
    this.parseMethod(s, i, n, a, o, "ClassMethod", !0), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters), t.body.push(s);
  }
  parsePrivateName() {
    const t = super.parsePrivateName();
    return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(t) : t;
  }
  convertPrivateNameToPrivateIdentifier(t) {
    const s = super.getPrivateNameSV(t);
    return t = t, delete t.id, t.name = s, t.type = "PrivateIdentifier", t;
  }
  isPrivateName(t) {
    return this.getPluginOption("estree", "classFeatures") ? t.type === "PrivateIdentifier" : super.isPrivateName(t);
  }
  getPrivateNameSV(t) {
    return this.getPluginOption("estree", "classFeatures") ? t.name : super.getPrivateNameSV(t);
  }
  parseLiteral(t, s) {
    const i = super.parseLiteral(t, s);
    return i.raw = i.extra.raw, delete i.extra, i;
  }
  parseFunctionBody(t, s, i = !1) {
    super.parseFunctionBody(t, s, i), t.expression = t.body.type !== "BlockStatement";
  }
  parseMethod(t, s, i, n, a, o, u = !1) {
    let l = this.startNode();
    return l.kind = t.kind, l = super.parseMethod(l, s, i, n, a, o, u), l.type = "FunctionExpression", delete l.kind, t.value = l, o === "ClassPrivateMethod" && (t.computed = !1), this.finishNode(t, "MethodDefinition");
  }
  nameIsConstructor(t) {
    return t.type === "Literal" ? t.value === "constructor" : super.nameIsConstructor(t);
  }
  parseClassProperty(...t) {
    const s = super.parseClassProperty(...t);
    return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition"), s;
  }
  parseClassPrivateProperty(...t) {
    const s = super.parseClassPrivateProperty(...t);
    return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition", s.computed = !1), s;
  }
  parseObjectMethod(t, s, i, n, a) {
    const o = super.parseObjectMethod(t, s, i, n, a);
    return o && (o.type = "Property", o.kind === "method" && (o.kind = "init"), o.shorthand = !1), o;
  }
  parseObjectProperty(t, s, i, n) {
    const a = super.parseObjectProperty(t, s, i, n);
    return a && (a.kind = "init", a.type = "Property"), a;
  }
  isValidLVal(t, s, i) {
    return t === "Property" ? "value" : super.isValidLVal(t, s, i);
  }
  isAssignable(t, s) {
    return t != null && this.isObjectProperty(t) ? this.isAssignable(t.value, s) : super.isAssignable(t, s);
  }
  toAssignable(t, s = !1) {
    if (t != null && this.isObjectProperty(t)) {
      const {
        key: i,
        value: n
      } = t;
      this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(n, s);
    } else
      super.toAssignable(t, s);
  }
  toAssignableObjectExpressionProp(t, s, i) {
    t.type === "Property" && (t.kind === "get" || t.kind === "set") ? this.raise(O.PatternHasAccessor, t.key) : t.type === "Property" && t.method ? this.raise(O.PatternHasMethod, t.key) : super.toAssignableObjectExpressionProp(t, s, i);
  }
  finishCallExpression(t, s) {
    const i = super.finishCallExpression(t, s);
    if (i.callee.type === "Import") {
      if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
        var n, a;
        i.options = (n = i.arguments[1]) != null ? n : null, i.attributes = (a = i.arguments[1]) != null ? a : null;
      }
      delete i.arguments, delete i.callee;
    }
    return i;
  }
  toReferencedArguments(t) {
    t.type !== "ImportExpression" && super.toReferencedArguments(t);
  }
  parseExport(t, s) {
    const i = this.state.lastTokStartLoc, n = super.parseExport(t, s);
    switch (n.type) {
      case "ExportAllDeclaration":
        n.exported = null;
        break;
      case "ExportNamedDeclaration":
        n.specifiers.length === 1 && n.specifiers[0].type === "ExportNamespaceSpecifier" && (n.type = "ExportAllDeclaration", n.exported = n.specifiers[0].exported, delete n.specifiers);
      case "ExportDefaultDeclaration":
        {
          var a;
          const {
            declaration: o
          } = n;
          (o == null ? void 0 : o.type) === "ClassDeclaration" && ((a = o.decorators) == null ? void 0 : a.length) > 0 && o.start === n.start && this.resetStartLocation(n, i);
        }
        break;
    }
    return n;
  }
  parseSubscript(t, s, i, n) {
    const a = super.parseSubscript(t, s, i, n);
    if (n.optionalChainMember) {
      if ((a.type === "OptionalMemberExpression" || a.type === "OptionalCallExpression") && (a.type = a.type.substring(8)), n.stop) {
        const o = this.startNodeAtNode(a);
        return o.expression = a, this.finishNode(o, "ChainExpression");
      }
    } else (a.type === "MemberExpression" || a.type === "CallExpression") && (a.optional = !1);
    return a;
  }
  isOptionalMemberExpression(t) {
    return t.type === "ChainExpression" ? t.expression.type === "MemberExpression" : super.isOptionalMemberExpression(t);
  }
  hasPropertyAsPrivateName(t) {
    return t.type === "ChainExpression" && (t = t.expression), super.hasPropertyAsPrivateName(t);
  }
  isObjectProperty(t) {
    return t.type === "Property" && t.kind === "init" && !t.method;
  }
  isObjectMethod(t) {
    return t.type === "Property" && (t.method || t.kind === "get" || t.kind === "set");
  }
  finishNodeAt(t, s, i) {
    return ma(super.finishNodeAt(t, s, i));
  }
  resetStartLocation(t, s) {
    super.resetStartLocation(t, s), ma(t);
  }
  resetEndLocation(t, s = this.state.lastTokEndLoc) {
    super.resetEndLocation(t, s), ma(t);
  }
};
class Oa {
  constructor(e, t) {
    this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!t;
  }
}
const Ue = {
  brace: new Oa("{"),
  j_oTag: new Oa("<tag"),
  j_cTag: new Oa("</tag"),
  j_expr: new Oa("<tag>...</tag>", !0)
};
Ue.template = new Oa("`", !0);
const Te = !0, te = !0, Df = !0, ga = !0, $s = !0, mN = !0;
class rS {
  constructor(e, t = {}) {
    this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = t.keyword, this.beforeExpr = !!t.beforeExpr, this.startsExpr = !!t.startsExpr, this.rightAssociative = !!t.rightAssociative, this.isLoop = !!t.isLoop, this.isAssign = !!t.isAssign, this.prefix = !!t.prefix, this.postfix = !!t.postfix, this.binop = t.binop != null ? t.binop : null, this.updateContext = null;
  }
}
const rm = /* @__PURE__ */ new Map();
function Ne(r, e = {}) {
  e.keyword = r;
  const t = he(r, e);
  return rm.set(r, t), t;
}
function Ft(r, e) {
  return he(r, {
    beforeExpr: Te,
    binop: e
  });
}
let ja = -1;
const hs = [], sm = [], im = [], nm = [], am = [], om = [];
function he(r, e = {}) {
  var t, s, i, n;
  return ++ja, sm.push(r), im.push((t = e.binop) != null ? t : -1), nm.push((s = e.beforeExpr) != null ? s : !1), am.push((i = e.startsExpr) != null ? i : !1), om.push((n = e.prefix) != null ? n : !1), hs.push(new rS(r, e)), ja;
}
function we(r, e = {}) {
  var t, s, i, n;
  return ++ja, rm.set(r, ja), sm.push(r), im.push((t = e.binop) != null ? t : -1), nm.push((s = e.beforeExpr) != null ? s : !1), am.push((i = e.startsExpr) != null ? i : !1), om.push((n = e.prefix) != null ? n : !1), hs.push(new rS("name", e)), ja;
}
const gN = {
  bracketL: he("[", {
    beforeExpr: Te,
    startsExpr: te
  }),
  bracketHashL: he("#[", {
    beforeExpr: Te,
    startsExpr: te
  }),
  bracketBarL: he("[|", {
    beforeExpr: Te,
    startsExpr: te
  }),
  bracketR: he("]"),
  bracketBarR: he("|]"),
  braceL: he("{", {
    beforeExpr: Te,
    startsExpr: te
  }),
  braceBarL: he("{|", {
    beforeExpr: Te,
    startsExpr: te
  }),
  braceHashL: he("#{", {
    beforeExpr: Te,
    startsExpr: te
  }),
  braceR: he("}"),
  braceBarR: he("|}"),
  parenL: he("(", {
    beforeExpr: Te,
    startsExpr: te
  }),
  parenR: he(")"),
  comma: he(",", {
    beforeExpr: Te
  }),
  semi: he(";", {
    beforeExpr: Te
  }),
  colon: he(":", {
    beforeExpr: Te
  }),
  doubleColon: he("::", {
    beforeExpr: Te
  }),
  dot: he("."),
  question: he("?", {
    beforeExpr: Te
  }),
  questionDot: he("?."),
  arrow: he("=>", {
    beforeExpr: Te
  }),
  template: he("template"),
  ellipsis: he("...", {
    beforeExpr: Te
  }),
  backQuote: he("`", {
    startsExpr: te
  }),
  dollarBraceL: he("${", {
    beforeExpr: Te,
    startsExpr: te
  }),
  templateTail: he("...`", {
    startsExpr: te
  }),
  templateNonTail: he("...${", {
    beforeExpr: Te,
    startsExpr: te
  }),
  at: he("@"),
  hash: he("#", {
    startsExpr: te
  }),
  interpreterDirective: he("#!..."),
  eq: he("=", {
    beforeExpr: Te,
    isAssign: ga
  }),
  assign: he("_=", {
    beforeExpr: Te,
    isAssign: ga
  }),
  slashAssign: he("_=", {
    beforeExpr: Te,
    isAssign: ga
  }),
  xorAssign: he("_=", {
    beforeExpr: Te,
    isAssign: ga
  }),
  moduloAssign: he("_=", {
    beforeExpr: Te,
    isAssign: ga
  }),
  incDec: he("++/--", {
    prefix: $s,
    postfix: mN,
    startsExpr: te
  }),
  bang: he("!", {
    beforeExpr: Te,
    prefix: $s,
    startsExpr: te
  }),
  tilde: he("~", {
    beforeExpr: Te,
    prefix: $s,
    startsExpr: te
  }),
  doubleCaret: he("^^", {
    startsExpr: te
  }),
  doubleAt: he("@@", {
    startsExpr: te
  }),
  pipeline: Ft("|>", 0),
  nullishCoalescing: Ft("??", 1),
  logicalOR: Ft("||", 1),
  logicalAND: Ft("&&", 2),
  bitwiseOR: Ft("|", 3),
  bitwiseXOR: Ft("^", 4),
  bitwiseAND: Ft("&", 5),
  equality: Ft("==/!=/===/!==", 6),
  lt: Ft("</>/<=/>=", 7),
  gt: Ft("</>/<=/>=", 7),
  relational: Ft("</>/<=/>=", 7),
  bitShift: Ft("<</>>/>>>", 8),
  bitShiftL: Ft("<</>>/>>>", 8),
  bitShiftR: Ft("<</>>/>>>", 8),
  plusMin: he("+/-", {
    beforeExpr: Te,
    binop: 9,
    prefix: $s,
    startsExpr: te
  }),
  modulo: he("%", {
    binop: 10,
    startsExpr: te
  }),
  star: he("*", {
    binop: 10
  }),
  slash: Ft("/", 10),
  exponent: he("**", {
    beforeExpr: Te,
    binop: 11,
    rightAssociative: !0
  }),
  _in: Ne("in", {
    beforeExpr: Te,
    binop: 7
  }),
  _instanceof: Ne("instanceof", {
    beforeExpr: Te,
    binop: 7
  }),
  _break: Ne("break"),
  _case: Ne("case", {
    beforeExpr: Te
  }),
  _catch: Ne("catch"),
  _continue: Ne("continue"),
  _debugger: Ne("debugger"),
  _default: Ne("default", {
    beforeExpr: Te
  }),
  _else: Ne("else", {
    beforeExpr: Te
  }),
  _finally: Ne("finally"),
  _function: Ne("function", {
    startsExpr: te
  }),
  _if: Ne("if"),
  _return: Ne("return", {
    beforeExpr: Te
  }),
  _switch: Ne("switch"),
  _throw: Ne("throw", {
    beforeExpr: Te,
    prefix: $s,
    startsExpr: te
  }),
  _try: Ne("try"),
  _var: Ne("var"),
  _const: Ne("const"),
  _with: Ne("with"),
  _new: Ne("new", {
    beforeExpr: Te,
    startsExpr: te
  }),
  _this: Ne("this", {
    startsExpr: te
  }),
  _super: Ne("super", {
    startsExpr: te
  }),
  _class: Ne("class", {
    startsExpr: te
  }),
  _extends: Ne("extends", {
    beforeExpr: Te
  }),
  _export: Ne("export"),
  _import: Ne("import", {
    startsExpr: te
  }),
  _null: Ne("null", {
    startsExpr: te
  }),
  _true: Ne("true", {
    startsExpr: te
  }),
  _false: Ne("false", {
    startsExpr: te
  }),
  _typeof: Ne("typeof", {
    beforeExpr: Te,
    prefix: $s,
    startsExpr: te
  }),
  _void: Ne("void", {
    beforeExpr: Te,
    prefix: $s,
    startsExpr: te
  }),
  _delete: Ne("delete", {
    beforeExpr: Te,
    prefix: $s,
    startsExpr: te
  }),
  _do: Ne("do", {
    isLoop: Df,
    beforeExpr: Te
  }),
  _for: Ne("for", {
    isLoop: Df
  }),
  _while: Ne("while", {
    isLoop: Df
  }),
  _as: we("as", {
    startsExpr: te
  }),
  _assert: we("assert", {
    startsExpr: te
  }),
  _async: we("async", {
    startsExpr: te
  }),
  _await: we("await", {
    startsExpr: te
  }),
  _defer: we("defer", {
    startsExpr: te
  }),
  _from: we("from", {
    startsExpr: te
  }),
  _get: we("get", {
    startsExpr: te
  }),
  _let: we("let", {
    startsExpr: te
  }),
  _meta: we("meta", {
    startsExpr: te
  }),
  _of: we("of", {
    startsExpr: te
  }),
  _sent: we("sent", {
    startsExpr: te
  }),
  _set: we("set", {
    startsExpr: te
  }),
  _source: we("source", {
    startsExpr: te
  }),
  _static: we("static", {
    startsExpr: te
  }),
  _using: we("using", {
    startsExpr: te
  }),
  _yield: we("yield", {
    startsExpr: te
  }),
  _asserts: we("asserts", {
    startsExpr: te
  }),
  _checks: we("checks", {
    startsExpr: te
  }),
  _exports: we("exports", {
    startsExpr: te
  }),
  _global: we("global", {
    startsExpr: te
  }),
  _implements: we("implements", {
    startsExpr: te
  }),
  _intrinsic: we("intrinsic", {
    startsExpr: te
  }),
  _infer: we("infer", {
    startsExpr: te
  }),
  _is: we("is", {
    startsExpr: te
  }),
  _mixins: we("mixins", {
    startsExpr: te
  }),
  _proto: we("proto", {
    startsExpr: te
  }),
  _require: we("require", {
    startsExpr: te
  }),
  _satisfies: we("satisfies", {
    startsExpr: te
  }),
  _keyof: we("keyof", {
    startsExpr: te
  }),
  _readonly: we("readonly", {
    startsExpr: te
  }),
  _unique: we("unique", {
    startsExpr: te
  }),
  _abstract: we("abstract", {
    startsExpr: te
  }),
  _declare: we("declare", {
    startsExpr: te
  }),
  _enum: we("enum", {
    startsExpr: te
  }),
  _module: we("module", {
    startsExpr: te
  }),
  _namespace: we("namespace", {
    startsExpr: te
  }),
  _interface: we("interface", {
    startsExpr: te
  }),
  _type: we("type", {
    startsExpr: te
  }),
  _opaque: we("opaque", {
    startsExpr: te
  }),
  name: he("name", {
    startsExpr: te
  }),
  string: he("string", {
    startsExpr: te
  }),
  num: he("num", {
    startsExpr: te
  }),
  bigint: he("bigint", {
    startsExpr: te
  }),
  decimal: he("decimal", {
    startsExpr: te
  }),
  regexp: he("regexp", {
    startsExpr: te
  }),
  privateName: he("#name", {
    startsExpr: te
  }),
  eof: he("eof"),
  jsxName: he("jsxName"),
  jsxText: he("jsxText", {
    beforeExpr: !0
  }),
  jsxTagStart: he("jsxTagStart", {
    startsExpr: !0
  }),
  jsxTagEnd: he("jsxTagEnd"),
  placeholder: he("%%", {
    startsExpr: !0
  })
};
function Le(r) {
  return r >= 93 && r <= 132;
}
function yN(r) {
  return r <= 92;
}
function Cr(r) {
  return r >= 58 && r <= 132;
}
function sS(r) {
  return r >= 58 && r <= 136;
}
function bN(r) {
  return nm[r];
}
function Rp(r) {
  return am[r];
}
function vN(r) {
  return r >= 29 && r <= 33;
}
function hy(r) {
  return r >= 129 && r <= 131;
}
function EN(r) {
  return r >= 90 && r <= 92;
}
function um(r) {
  return r >= 58 && r <= 92;
}
function SN(r) {
  return r >= 39 && r <= 59;
}
function _N(r) {
  return r === 34;
}
function xN(r) {
  return om[r];
}
function wN(r) {
  return r >= 121 && r <= 123;
}
function TN(r) {
  return r >= 124 && r <= 130;
}
function si(r) {
  return sm[r];
}
function Mu(r) {
  return im[r];
}
function PN(r) {
  return r === 57;
}
function El(r) {
  return r >= 24 && r <= 25;
}
function ls(r) {
  return hs[r];
}
hs[8].updateContext = (r) => {
  r.pop();
}, hs[5].updateContext = hs[7].updateContext = hs[23].updateContext = (r) => {
  r.push(Ue.brace);
}, hs[22].updateContext = (r) => {
  r[r.length - 1] === Ue.template ? r.pop() : r.push(Ue.template);
}, hs[142].updateContext = (r) => {
  r.push(Ue.j_expr, Ue.j_oTag);
};
let lm = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", iS = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
const AN = new RegExp("[" + lm + "]"), CN = new RegExp("[" + lm + iS + "]");
lm = iS = null;
const nS = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], NN = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function $p(r, e) {
  let t = 65536;
  for (let s = 0, i = e.length; s < i; s += 2) {
    if (t += e[s], t > r) return !1;
    if (t += e[s + 1], t >= r) return !0;
  }
  return !1;
}
function ms(r) {
  return r < 65 ? r === 36 : r <= 90 ? !0 : r < 97 ? r === 95 : r <= 122 ? !0 : r <= 65535 ? r >= 170 && AN.test(String.fromCharCode(r)) : $p(r, nS);
}
function Sn(r) {
  return r < 48 ? r === 36 : r < 58 ? !0 : r < 65 ? !1 : r <= 90 ? !0 : r < 97 ? r === 95 : r <= 122 ? !0 : r <= 65535 ? r >= 170 && CN.test(String.fromCharCode(r)) : $p(r, nS) || $p(r, NN);
}
const cm = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
}, ON = new Set(cm.keyword), IN = new Set(cm.strict), kN = new Set(cm.strictBind);
function aS(r, e) {
  return e && r === "await" || r === "enum";
}
function oS(r, e) {
  return aS(r, e) || IN.has(r);
}
function uS(r) {
  return kN.has(r);
}
function lS(r, e) {
  return oS(r, e) || uS(r);
}
function DN(r) {
  return ON.has(r);
}
function LN(r, e, t) {
  return r === 64 && e === 64 && ms(t);
}
const MN = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
function RN(r) {
  return MN.has(r);
}
class fm {
  constructor(e) {
    this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
  }
}
class pm {
  constructor(e, t) {
    this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e, this.inModule = t;
  }
  get inTopLevel() {
    return (this.currentScope().flags & 1) > 0;
  }
  get inFunction() {
    return (this.currentVarScopeFlags() & 2) > 0;
  }
  get allowSuper() {
    return (this.currentThisScopeFlags() & 16) > 0;
  }
  get allowDirectSuper() {
    return (this.currentThisScopeFlags() & 32) > 0;
  }
  get inClass() {
    return (this.currentThisScopeFlags() & 64) > 0;
  }
  get inClassAndNotInNonArrowFunction() {
    const e = this.currentThisScopeFlags();
    return (e & 64) > 0 && (e & 2) === 0;
  }
  get inStaticBlock() {
    for (let e = this.scopeStack.length - 1; ; e--) {
      const {
        flags: t
      } = this.scopeStack[e];
      if (t & 128)
        return !0;
      if (t & 451)
        return !1;
    }
  }
  get inNonArrowFunction() {
    return (this.currentThisScopeFlags() & 2) > 0;
  }
  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }
  createScope(e) {
    return new fm(e);
  }
  enter(e) {
    this.scopeStack.push(this.createScope(e));
  }
  exit() {
    return this.scopeStack.pop().flags;
  }
  treatFunctionsAsVarInScope(e) {
    return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
  }
  declareName(e, t, s) {
    let i = this.currentScope();
    if (t & 8 || t & 16) {
      this.checkRedeclarationInScope(i, e, t, s);
      let n = i.names.get(e) || 0;
      t & 16 ? n = n | 4 : (i.firstLexicalName || (i.firstLexicalName = e), n = n | 2), i.names.set(e, n), t & 8 && this.maybeExportDefined(i, e);
    } else if (t & 4)
      for (let n = this.scopeStack.length - 1; n >= 0 && (i = this.scopeStack[n], this.checkRedeclarationInScope(i, e, t, s), i.names.set(e, (i.names.get(e) || 0) | 1), this.maybeExportDefined(i, e), !(i.flags & 387)); --n)
        ;
    this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(e);
  }
  maybeExportDefined(e, t) {
    this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(t);
  }
  checkRedeclarationInScope(e, t, s, i) {
    this.isRedeclaredInScope(e, t, s) && this.parser.raise(O.VarRedeclaration, i, {
      identifierName: t
    });
  }
  isRedeclaredInScope(e, t, s) {
    if (!(s & 1)) return !1;
    if (s & 8)
      return e.names.has(t);
    const i = e.names.get(t);
    return s & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (i & 1) > 0 : (i & 2) > 0 && !(e.flags & 8 && e.firstLexicalName === t) || !this.treatFunctionsAsVarInScope(e) && (i & 4) > 0;
  }
  checkLocalExport(e) {
    const {
      name: t
    } = e;
    this.scopeStack[0].names.has(t) || this.undefinedExports.set(t, e.loc.start);
  }
  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1];
  }
  currentVarScopeFlags() {
    for (let e = this.scopeStack.length - 1; ; e--) {
      const {
        flags: t
      } = this.scopeStack[e];
      if (t & 387)
        return t;
    }
  }
  currentThisScopeFlags() {
    for (let e = this.scopeStack.length - 1; ; e--) {
      const {
        flags: t
      } = this.scopeStack[e];
      if (t & 451 && !(t & 4))
        return t;
    }
  }
}
class $N extends fm {
  constructor(...e) {
    super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
  }
}
class FN extends pm {
  createScope(e) {
    return new $N(e);
  }
  declareName(e, t, s) {
    const i = this.currentScope();
    if (t & 2048) {
      this.checkRedeclarationInScope(i, e, t, s), this.maybeExportDefined(i, e), i.declareFunctions.add(e);
      return;
    }
    super.declareName(e, t, s);
  }
  isRedeclaredInScope(e, t, s) {
    if (super.isRedeclaredInScope(e, t, s)) return !0;
    if (s & 2048 && !e.declareFunctions.has(t)) {
      const i = e.names.get(t);
      return (i & 4) > 0 || (i & 2) > 0;
    }
    return !1;
  }
  checkLocalExport(e) {
    this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
  }
}
class BN {
  constructor() {
    this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
  }
  hasPlugin(e) {
    if (typeof e == "string")
      return this.plugins.has(e);
    {
      const [t, s] = e;
      if (!this.hasPlugin(t))
        return !1;
      const i = this.plugins.get(t);
      for (const n of Object.keys(s))
        if ((i == null ? void 0 : i[n]) !== s[n])
          return !1;
      return !0;
    }
  }
  getPluginOption(e, t) {
    var s;
    return (s = this.plugins.get(e)) == null ? void 0 : s[t];
  }
}
function cS(r, e) {
  r.trailingComments === void 0 ? r.trailingComments = e : r.trailingComments.unshift(...e);
}
function VN(r, e) {
  r.leadingComments === void 0 ? r.leadingComments = e : r.leadingComments.unshift(...e);
}
function fo(r, e) {
  r.innerComments === void 0 ? r.innerComments = e : r.innerComments.unshift(...e);
}
function ya(r, e, t) {
  let s = null, i = e.length;
  for (; s === null && i > 0; )
    s = e[--i];
  s === null || s.start > t.start ? fo(r, t.comments) : cS(s, t.comments);
}
class UN extends BN {
  addComment(e) {
    this.filename && (e.loc.filename = this.filename);
    const {
      commentsLen: t
    } = this.state;
    this.comments.length !== t && (this.comments.length = t), this.comments.push(e), this.state.commentsLen++;
  }
  processComment(e) {
    const {
      commentStack: t
    } = this.state, s = t.length;
    if (s === 0) return;
    let i = s - 1;
    const n = t[i];
    n.start === e.end && (n.leadingNode = e, i--);
    const {
      start: a
    } = e;
    for (; i >= 0; i--) {
      const o = t[i], u = o.end;
      if (u > a)
        o.containingNode = e, this.finalizeComment(o), t.splice(i, 1);
      else {
        u === a && (o.trailingNode = e);
        break;
      }
    }
  }
  finalizeComment(e) {
    const {
      comments: t
    } = e;
    if (e.leadingNode !== null || e.trailingNode !== null)
      e.leadingNode !== null && cS(e.leadingNode, t), e.trailingNode !== null && VN(e.trailingNode, t);
    else {
      const {
        containingNode: s,
        start: i
      } = e;
      if (this.input.charCodeAt(i - 1) === 44)
        switch (s.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            ya(s, s.properties, e);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            ya(s, s.arguments, e);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            ya(s, s.params, e);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            ya(s, s.elements, e);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            ya(s, s.specifiers, e);
            break;
          default:
            fo(s, t);
        }
      else
        fo(s, t);
    }
  }
  finalizeRemainingComments() {
    const {
      commentStack: e
    } = this.state;
    for (let t = e.length - 1; t >= 0; t--)
      this.finalizeComment(e[t]);
    this.state.commentStack = [];
  }
  resetPreviousNodeTrailingComments(e) {
    const {
      commentStack: t
    } = this.state, {
      length: s
    } = t;
    if (s === 0) return;
    const i = t[s - 1];
    i.leadingNode === e && (i.leadingNode = null);
  }
  resetPreviousIdentifierLeadingComments(e) {
    const {
      commentStack: t
    } = this.state, {
      length: s
    } = t;
    s !== 0 && (t[s - 1].trailingNode === e ? t[s - 1].trailingNode = null : s >= 2 && t[s - 2].trailingNode === e && (t[s - 2].trailingNode = null));
  }
  takeSurroundingComments(e, t, s) {
    const {
      commentStack: i
    } = this.state, n = i.length;
    if (n === 0) return;
    let a = n - 1;
    for (; a >= 0; a--) {
      const o = i[a], u = o.end;
      if (o.start === s)
        o.leadingNode = e;
      else if (u === t)
        o.trailingNode = e;
      else if (u < t)
        break;
    }
  }
}
const fS = /\r\n?|[\n\u2028\u2029]/, ou = new RegExp(fS.source, "g");
function qa(r) {
  switch (r) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return !0;
    default:
      return !1;
  }
}
const Lf = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ru = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, dy = new RegExp("(?=(" + Ru.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
function jN(r) {
  switch (r) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return !0;
    default:
      return !1;
  }
}
class hm {
  constructor() {
    this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [Ue.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
  }
  get strict() {
    return (this.flags & 1) > 0;
  }
  set strict(e) {
    e ? this.flags |= 1 : this.flags &= -2;
  }
  init({
    strictMode: e,
    sourceType: t,
    startLine: s,
    startColumn: i
  }) {
    this.strict = e === !1 ? !1 : e === !0 ? !0 : t === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new ri(s, i, 0);
  }
  get maybeInArrowParameters() {
    return (this.flags & 2) > 0;
  }
  set maybeInArrowParameters(e) {
    e ? this.flags |= 2 : this.flags &= -3;
  }
  get inType() {
    return (this.flags & 4) > 0;
  }
  set inType(e) {
    e ? this.flags |= 4 : this.flags &= -5;
  }
  get noAnonFunctionType() {
    return (this.flags & 8) > 0;
  }
  set noAnonFunctionType(e) {
    e ? this.flags |= 8 : this.flags &= -9;
  }
  get hasFlowComment() {
    return (this.flags & 16) > 0;
  }
  set hasFlowComment(e) {
    e ? this.flags |= 16 : this.flags &= -17;
  }
  get isAmbientContext() {
    return (this.flags & 32) > 0;
  }
  set isAmbientContext(e) {
    e ? this.flags |= 32 : this.flags &= -33;
  }
  get inAbstractClass() {
    return (this.flags & 64) > 0;
  }
  set inAbstractClass(e) {
    e ? this.flags |= 64 : this.flags &= -65;
  }
  get inDisallowConditionalTypesContext() {
    return (this.flags & 128) > 0;
  }
  set inDisallowConditionalTypesContext(e) {
    e ? this.flags |= 128 : this.flags &= -129;
  }
  get soloAwait() {
    return (this.flags & 256) > 0;
  }
  set soloAwait(e) {
    e ? this.flags |= 256 : this.flags &= -257;
  }
  get inFSharpPipelineDirectBody() {
    return (this.flags & 512) > 0;
  }
  set inFSharpPipelineDirectBody(e) {
    e ? this.flags |= 512 : this.flags &= -513;
  }
  get canStartJSXElement() {
    return (this.flags & 1024) > 0;
  }
  set canStartJSXElement(e) {
    e ? this.flags |= 1024 : this.flags &= -1025;
  }
  get containsEsc() {
    return (this.flags & 2048) > 0;
  }
  set containsEsc(e) {
    e ? this.flags |= 2048 : this.flags &= -2049;
  }
  curPosition() {
    return new ri(this.curLine, this.pos - this.lineStart, this.pos);
  }
  clone() {
    const e = new hm();
    return e.flags = this.flags, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.startLoc, e.endLoc = this.endLoc, e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.slice(), e.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.slice(), e.commentsLen = this.commentsLen, e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value = this.value, e.start = this.start, e.end = this.end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.context = this.context.slice(), e.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors, e.tokensLength = this.tokensLength, e;
  }
}
var qN = function(e) {
  return e >= 48 && e <= 57;
};
const my = {
  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
}, uu = {
  bin: (r) => r === 48 || r === 49,
  oct: (r) => r >= 48 && r <= 55,
  dec: (r) => r >= 48 && r <= 57,
  hex: (r) => r >= 48 && r <= 57 || r >= 65 && r <= 70 || r >= 97 && r <= 102
};
function gy(r, e, t, s, i, n) {
  const a = t, o = s, u = i;
  let l = "", c = null, f = t;
  const {
    length: p
  } = e;
  for (; ; ) {
    if (t >= p) {
      n.unterminated(a, o, u), l += e.slice(f, t);
      break;
    }
    const h = e.charCodeAt(t);
    if (HN(r, h, e, t)) {
      l += e.slice(f, t);
      break;
    }
    if (h === 92) {
      l += e.slice(f, t);
      const m = WN(e, t, s, i, r === "template", n);
      m.ch === null && !c ? c = {
        pos: t,
        lineStart: s,
        curLine: i
      } : l += m.ch, {
        pos: t,
        lineStart: s,
        curLine: i
      } = m, f = t;
    } else h === 8232 || h === 8233 ? (++t, ++i, s = t) : h === 10 || h === 13 ? r === "template" ? (l += e.slice(f, t) + `
`, ++t, h === 13 && e.charCodeAt(t) === 10 && ++t, ++i, f = s = t) : n.unterminated(a, o, u) : ++t;
  }
  return {
    pos: t,
    str: l,
    firstInvalidLoc: c,
    lineStart: s,
    curLine: i,
    containsInvalid: !!c
  };
}
function HN(r, e, t, s) {
  return r === "template" ? e === 96 || e === 36 && t.charCodeAt(s + 1) === 123 : e === (r === "double" ? 34 : 39);
}
function WN(r, e, t, s, i, n) {
  const a = !i;
  e++;
  const o = (l) => ({
    pos: e,
    ch: l,
    lineStart: t,
    curLine: s
  }), u = r.charCodeAt(e++);
  switch (u) {
    case 110:
      return o(`
`);
    case 114:
      return o("\r");
    case 120: {
      let l;
      return {
        code: l,
        pos: e
      } = Fp(r, e, t, s, 2, !1, a, n), o(l === null ? null : String.fromCharCode(l));
    }
    case 117: {
      let l;
      return {
        code: l,
        pos: e
      } = hS(r, e, t, s, a, n), o(l === null ? null : String.fromCodePoint(l));
    }
    case 116:
      return o("	");
    case 98:
      return o("\b");
    case 118:
      return o("\v");
    case 102:
      return o("\f");
    case 13:
      r.charCodeAt(e) === 10 && ++e;
    case 10:
      t = e, ++s;
    case 8232:
    case 8233:
      return o("");
    case 56:
    case 57:
      if (i)
        return o(null);
      n.strictNumericEscape(e - 1, t, s);
    default:
      if (u >= 48 && u <= 55) {
        const l = e - 1;
        let f = r.slice(l, e + 2).match(/^[0-7]+/)[0], p = parseInt(f, 8);
        p > 255 && (f = f.slice(0, -1), p = parseInt(f, 8)), e += f.length - 1;
        const h = r.charCodeAt(e);
        if (f !== "0" || h === 56 || h === 57) {
          if (i)
            return o(null);
          n.strictNumericEscape(l, t, s);
        }
        return o(String.fromCharCode(p));
      }
      return o(String.fromCharCode(u));
  }
}
function Fp(r, e, t, s, i, n, a, o) {
  const u = e;
  let l;
  return {
    n: l,
    pos: e
  } = pS(r, e, t, s, 16, i, n, !1, o, !a), l === null && (a ? o.invalidEscapeSequence(u, t, s) : e = u - 1), {
    code: l,
    pos: e
  };
}
function pS(r, e, t, s, i, n, a, o, u, l) {
  const c = e, f = i === 16 ? my.hex : my.decBinOct, p = i === 16 ? uu.hex : i === 10 ? uu.dec : i === 8 ? uu.oct : uu.bin;
  let h = !1, m = 0;
  for (let d = 0, y = n ?? 1 / 0; d < y; ++d) {
    const S = r.charCodeAt(e);
    let E;
    if (S === 95 && o !== "bail") {
      const g = r.charCodeAt(e - 1), b = r.charCodeAt(e + 1);
      if (o) {
        if (Number.isNaN(b) || !p(b) || f.has(g) || f.has(b)) {
          if (l) return {
            n: null,
            pos: e
          };
          u.unexpectedNumericSeparator(e, t, s);
        }
      } else {
        if (l) return {
          n: null,
          pos: e
        };
        u.numericSeparatorInEscapeSequence(e, t, s);
      }
      ++e;
      continue;
    }
    if (S >= 97 ? E = S - 97 + 10 : S >= 65 ? E = S - 65 + 10 : qN(S) ? E = S - 48 : E = 1 / 0, E >= i) {
      if (E <= 9 && l)
        return {
          n: null,
          pos: e
        };
      if (E <= 9 && u.invalidDigit(e, t, s, i))
        E = 0;
      else if (a)
        E = 0, h = !0;
      else
        break;
    }
    ++e, m = m * i + E;
  }
  return e === c || n != null && e - c !== n || h ? {
    n: null,
    pos: e
  } : {
    n: m,
    pos: e
  };
}
function hS(r, e, t, s, i, n) {
  const a = r.charCodeAt(e);
  let o;
  if (a === 123) {
    if (++e, {
      code: o,
      pos: e
    } = Fp(r, e, t, s, r.indexOf("}", e) - e, !0, i, n), ++e, o !== null && o > 1114111)
      if (i)
        n.invalidCodePoint(e, t, s);
      else
        return {
          code: null,
          pos: e
        };
  } else
    ({
      code: o,
      pos: e
    } = Fp(r, e, t, s, 4, !1, i, n));
  return {
    code: o,
    pos: e
  };
}
function ba(r, e, t) {
  return new ri(t, r - e, r);
}
const zN = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
class Vs {
  constructor(e) {
    this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, this.loc = new vl(e.startLoc, e.endLoc);
  }
}
class GN extends UN {
  constructor(e, t) {
    super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
      invalidDigit: (s, i, n, a) => this.options.errorRecovery ? (this.raise(O.InvalidDigit, ba(s, i, n), {
        radix: a
      }), !0) : !1,
      numericSeparatorInEscapeSequence: this.errorBuilder(O.NumericSeparatorInEscapeSequence),
      unexpectedNumericSeparator: this.errorBuilder(O.UnexpectedNumericSeparator)
    }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
      invalidEscapeSequence: this.errorBuilder(O.InvalidEscapeSequence),
      invalidCodePoint: this.errorBuilder(O.InvalidCodePoint)
    }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: (s, i, n) => {
        this.recordStrictModeErrors(O.StrictNumericEscape, ba(s, i, n));
      },
      unterminated: (s, i, n) => {
        throw this.raise(O.UnterminatedString, ba(s - 1, i, n));
      }
    }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: this.errorBuilder(O.StrictNumericEscape),
      unterminated: (s, i, n) => {
        throw this.raise(O.UnterminatedTemplate, ba(s, i, n));
      }
    }), this.state = new hm(), this.state.init(e), this.input = t, this.length = t.length, this.comments = [], this.isLookahead = !1;
  }
  pushToken(e) {
    this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
  }
  next() {
    this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Vs(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
  }
  eat(e) {
    return this.match(e) ? (this.next(), !0) : !1;
  }
  match(e) {
    return this.state.type === e;
  }
  createLookaheadState(e) {
    return {
      pos: e.pos,
      value: null,
      type: e.type,
      start: e.start,
      end: e.end,
      context: [this.curContext()],
      inType: e.inType,
      startLoc: e.startLoc,
      lastTokEndLoc: e.lastTokEndLoc,
      curLine: e.curLine,
      lineStart: e.lineStart,
      curPosition: e.curPosition
    };
  }
  lookahead() {
    const e = this.state;
    this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
    const t = this.state;
    return this.state = e, t;
  }
  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos);
  }
  nextTokenStartSince(e) {
    return Lf.lastIndex = e, Lf.test(this.input) ? Lf.lastIndex : e;
  }
  lookaheadCharCode() {
    return this.input.charCodeAt(this.nextTokenStart());
  }
  nextTokenInLineStart() {
    return this.nextTokenInLineStartSince(this.state.pos);
  }
  nextTokenInLineStartSince(e) {
    return Ru.lastIndex = e, Ru.test(this.input) ? Ru.lastIndex : e;
  }
  lookaheadInLineCharCode() {
    return this.input.charCodeAt(this.nextTokenInLineStart());
  }
  codePointAtPos(e) {
    let t = this.input.charCodeAt(e);
    if ((t & 64512) === 55296 && ++e < this.input.length) {
      const s = this.input.charCodeAt(e);
      (s & 64512) === 56320 && (t = 65536 + ((t & 1023) << 10) + (s & 1023));
    }
    return t;
  }
  setStrict(e) {
    this.state.strict = e, e && (this.state.strictErrors.forEach(([t, s]) => this.raise(t, s)), this.state.strictErrors.clear());
  }
  curContext() {
    return this.state.context[this.state.context.length - 1];
  }
  nextToken() {
    if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
      this.finishToken(139);
      return;
    }
    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
  }
  skipBlockComment(e) {
    let t;
    this.isLookahead || (t = this.state.curPosition());
    const s = this.state.pos, i = this.input.indexOf(e, s + 2);
    if (i === -1)
      throw this.raise(O.UnterminatedComment, this.state.curPosition());
    for (this.state.pos = i + e.length, ou.lastIndex = s + 2; ou.test(this.input) && ou.lastIndex <= i; )
      ++this.state.curLine, this.state.lineStart = ou.lastIndex;
    if (this.isLookahead) return;
    const n = {
      type: "CommentBlock",
      value: this.input.slice(s + 2, i),
      start: s,
      end: i + e.length,
      loc: new vl(t, this.state.curPosition())
    };
    return this.options.tokens && this.pushToken(n), n;
  }
  skipLineComment(e) {
    const t = this.state.pos;
    let s;
    this.isLookahead || (s = this.state.curPosition());
    let i = this.input.charCodeAt(this.state.pos += e);
    if (this.state.pos < this.length)
      for (; !qa(i) && ++this.state.pos < this.length; )
        i = this.input.charCodeAt(this.state.pos);
    if (this.isLookahead) return;
    const n = this.state.pos, o = {
      type: "CommentLine",
      value: this.input.slice(t + e, n),
      start: t,
      end: n,
      loc: new vl(s, this.state.curPosition())
    };
    return this.options.tokens && this.pushToken(o), o;
  }
  skipSpace() {
    const e = this.state.pos, t = [];
    e: for (; this.state.pos < this.length; ) {
      const s = this.input.charCodeAt(this.state.pos);
      switch (s) {
        case 32:
        case 160:
        case 9:
          ++this.state.pos;
          break;
        case 13:
          this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
          break;
        case 47:
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42: {
              const i = this.skipBlockComment("*/");
              i !== void 0 && (this.addComment(i), this.options.attachComment && t.push(i));
              break;
            }
            case 47: {
              const i = this.skipLineComment(2);
              i !== void 0 && (this.addComment(i), this.options.attachComment && t.push(i));
              break;
            }
            default:
              break e;
          }
          break;
        default:
          if (jN(s))
            ++this.state.pos;
          else if (s === 45 && !this.inModule && this.options.annexB) {
            const i = this.state.pos;
            if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
              const n = this.skipLineComment(3);
              n !== void 0 && (this.addComment(n), this.options.attachComment && t.push(n));
            } else
              break e;
          } else if (s === 60 && !this.inModule && this.options.annexB) {
            const i = this.state.pos;
            if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
              const n = this.skipLineComment(4);
              n !== void 0 && (this.addComment(n), this.options.attachComment && t.push(n));
            } else
              break e;
          } else
            break e;
      }
    }
    if (t.length > 0) {
      const s = this.state.pos, i = {
        start: e,
        end: s,
        comments: t,
        leadingNode: null,
        trailingNode: null,
        containingNode: null
      };
      this.state.commentStack.push(i);
    }
  }
  finishToken(e, t) {
    this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
    const s = this.state.type;
    this.state.type = e, this.state.value = t, this.isLookahead || this.updateContext(s);
  }
  replaceToken(e) {
    this.state.type = e, this.updateContext();
  }
  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter())
      return;
    const e = this.state.pos + 1, t = this.codePointAtPos(e);
    if (t >= 48 && t <= 57)
      throw this.raise(O.UnexpectedDigitAfterHash, this.state.curPosition());
    if (t === 123 || t === 91 && this.hasPlugin("recordAndTuple")) {
      if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
        throw this.raise(t === 123 ? O.RecordExpressionHashIncorrectStartSyntaxType : O.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
      this.state.pos += 2, t === 123 ? this.finishToken(7) : this.finishToken(1);
    } else ms(t) ? (++this.state.pos, this.finishToken(138, this.readWord1(t))) : t === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
  }
  readToken_dot() {
    const e = this.input.charCodeAt(this.state.pos + 1);
    if (e >= 48 && e <= 57) {
      this.readNumber(!0);
      return;
    }
    e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
  }
  readToken_slash() {
    this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
  }
  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2) return !1;
    let e = this.input.charCodeAt(this.state.pos + 1);
    if (e !== 33) return !1;
    const t = this.state.pos;
    for (this.state.pos += 1; !qa(e) && ++this.state.pos < this.length; )
      e = this.input.charCodeAt(this.state.pos);
    const s = this.input.slice(t + 2, this.state.pos);
    return this.finishToken(28, s), !0;
  }
  readToken_mult_modulo(e) {
    let t = e === 42 ? 55 : 54, s = 1, i = this.input.charCodeAt(this.state.pos + 1);
    e === 42 && i === 42 && (s++, i = this.input.charCodeAt(this.state.pos + 2), t = 57), i === 61 && !this.state.inType && (s++, t = e === 37 ? 33 : 30), this.finishOp(t, s);
  }
  readToken_pipe_amp(e) {
    const t = this.input.charCodeAt(this.state.pos + 1);
    if (t === e) {
      this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
      return;
    }
    if (e === 124) {
      if (t === 62) {
        this.finishOp(39, 2);
        return;
      }
      if (this.hasPlugin("recordAndTuple") && t === 125) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
          throw this.raise(O.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
        this.state.pos += 2, this.finishToken(9);
        return;
      }
      if (this.hasPlugin("recordAndTuple") && t === 93) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
          throw this.raise(O.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
        this.state.pos += 2, this.finishToken(4);
        return;
      }
    }
    if (t === 61) {
      this.finishOp(30, 2);
      return;
    }
    this.finishOp(e === 124 ? 43 : 45, 1);
  }
  readToken_caret() {
    const e = this.input.charCodeAt(this.state.pos + 1);
    e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
      proposal: "hack",
      topicToken: "^^"
    }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
  }
  readToken_atSign() {
    this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
      proposal: "hack",
      topicToken: "@@"
    }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
  }
  readToken_plus_min(e) {
    const t = this.input.charCodeAt(this.state.pos + 1);
    if (t === e) {
      this.finishOp(34, 2);
      return;
    }
    t === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
  }
  readToken_lt() {
    const {
      pos: e
    } = this.state, t = this.input.charCodeAt(e + 1);
    if (t === 60) {
      if (this.input.charCodeAt(e + 2) === 61) {
        this.finishOp(30, 3);
        return;
      }
      this.finishOp(51, 2);
      return;
    }
    if (t === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(47, 1);
  }
  readToken_gt() {
    const {
      pos: e
    } = this.state, t = this.input.charCodeAt(e + 1);
    if (t === 62) {
      const s = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(e + s) === 61) {
        this.finishOp(30, s + 1);
        return;
      }
      this.finishOp(52, s);
      return;
    }
    if (t === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(48, 1);
  }
  readToken_eq_excl(e) {
    const t = this.input.charCodeAt(this.state.pos + 1);
    if (t === 61) {
      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
      return;
    }
    if (e === 61 && t === 62) {
      this.state.pos += 2, this.finishToken(19);
      return;
    }
    this.finishOp(e === 61 ? 29 : 35, 1);
  }
  readToken_question() {
    const e = this.input.charCodeAt(this.state.pos + 1), t = this.input.charCodeAt(this.state.pos + 2);
    e === 63 ? t === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(t >= 48 && t <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
  }
  getTokenFromCode(e) {
    switch (e) {
      case 46:
        this.readToken_dot();
        return;
      case 40:
        ++this.state.pos, this.finishToken(10);
        return;
      case 41:
        ++this.state.pos, this.finishToken(11);
        return;
      case 59:
        ++this.state.pos, this.finishToken(13);
        return;
      case 44:
        ++this.state.pos, this.finishToken(12);
        return;
      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(O.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(2);
        } else
          ++this.state.pos, this.finishToken(0);
        return;
      case 93:
        ++this.state.pos, this.finishToken(3);
        return;
      case 123:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(O.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(6);
        } else
          ++this.state.pos, this.finishToken(5);
        return;
      case 125:
        ++this.state.pos, this.finishToken(8);
        return;
      case 58:
        this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
        return;
      case 63:
        this.readToken_question();
        return;
      case 96:
        this.readTemplateToken();
        return;
      case 48: {
        const t = this.input.charCodeAt(this.state.pos + 1);
        if (t === 120 || t === 88) {
          this.readRadixNumber(16);
          return;
        }
        if (t === 111 || t === 79) {
          this.readRadixNumber(8);
          return;
        }
        if (t === 98 || t === 66) {
          this.readRadixNumber(2);
          return;
        }
      }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        this.readNumber(!1);
        return;
      case 34:
      case 39:
        this.readString(e);
        return;
      case 47:
        this.readToken_slash();
        return;
      case 37:
      case 42:
        this.readToken_mult_modulo(e);
        return;
      case 124:
      case 38:
        this.readToken_pipe_amp(e);
        return;
      case 94:
        this.readToken_caret();
        return;
      case 43:
      case 45:
        this.readToken_plus_min(e);
        return;
      case 60:
        this.readToken_lt();
        return;
      case 62:
        this.readToken_gt();
        return;
      case 61:
      case 33:
        this.readToken_eq_excl(e);
        return;
      case 126:
        this.finishOp(36, 1);
        return;
      case 64:
        this.readToken_atSign();
        return;
      case 35:
        this.readToken_numberSign();
        return;
      case 92:
        this.readWord();
        return;
      default:
        if (ms(e)) {
          this.readWord(e);
          return;
        }
    }
    throw this.raise(O.InvalidOrUnexpectedToken, this.state.curPosition(), {
      unexpected: String.fromCodePoint(e)
    });
  }
  finishOp(e, t) {
    const s = this.input.slice(this.state.pos, this.state.pos + t);
    this.state.pos += t, this.finishToken(e, s);
  }
  readRegexp() {
    const e = this.state.startLoc, t = this.state.start + 1;
    let s, i, {
      pos: n
    } = this.state;
    for (; ; ++n) {
      if (n >= this.length)
        throw this.raise(O.UnterminatedRegExp, Ht(e, 1));
      const l = this.input.charCodeAt(n);
      if (qa(l))
        throw this.raise(O.UnterminatedRegExp, Ht(e, 1));
      if (s)
        s = !1;
      else {
        if (l === 91)
          i = !0;
        else if (l === 93 && i)
          i = !1;
        else if (l === 47 && !i)
          break;
        s = l === 92;
      }
    }
    const a = this.input.slice(t, n);
    ++n;
    let o = "";
    const u = () => Ht(e, n + 2 - t);
    for (; n < this.length; ) {
      const l = this.codePointAtPos(n), c = String.fromCharCode(l);
      if (zN.has(l))
        l === 118 ? o.includes("u") && this.raise(O.IncompatibleRegExpUVFlags, u()) : l === 117 && o.includes("v") && this.raise(O.IncompatibleRegExpUVFlags, u()), o.includes(c) && this.raise(O.DuplicateRegExpFlags, u());
      else if (Sn(l) || l === 92)
        this.raise(O.MalformedRegExpFlags, u());
      else
        break;
      ++n, o += c;
    }
    this.state.pos = n, this.finishToken(137, {
      pattern: a,
      flags: o
    });
  }
  readInt(e, t, s = !1, i = !0) {
    const {
      n,
      pos: a
    } = pS(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, t, s, i, this.errorHandlers_readInt, !1);
    return this.state.pos = a, n;
  }
  readRadixNumber(e) {
    const t = this.state.curPosition();
    let s = !1;
    this.state.pos += 2;
    const i = this.readInt(e);
    i == null && this.raise(O.InvalidDigit, Ht(t, 2), {
      radix: e
    });
    const n = this.input.charCodeAt(this.state.pos);
    if (n === 110)
      ++this.state.pos, s = !0;
    else if (n === 109)
      throw this.raise(O.InvalidDecimal, t);
    if (ms(this.codePointAtPos(this.state.pos)))
      throw this.raise(O.NumberIdentifier, this.state.curPosition());
    if (s) {
      const a = this.input.slice(t.index, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(135, a);
      return;
    }
    this.finishToken(134, i);
  }
  readNumber(e) {
    const t = this.state.pos, s = this.state.curPosition();
    let i = !1, n = !1, a = !1, o = !1, u = !1;
    !e && this.readInt(10) === null && this.raise(O.InvalidNumber, this.state.curPosition());
    const l = this.state.pos - t >= 2 && this.input.charCodeAt(t) === 48;
    if (l) {
      const h = this.input.slice(t, this.state.pos);
      if (this.recordStrictModeErrors(O.StrictOctalLiteral, s), !this.state.strict) {
        const m = h.indexOf("_");
        m > 0 && this.raise(O.ZeroDigitNumericSeparator, Ht(s, m));
      }
      u = l && !/[89]/.test(h);
    }
    let c = this.input.charCodeAt(this.state.pos);
    if (c === 46 && !u && (++this.state.pos, this.readInt(10), i = !0, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) && !u && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(O.InvalidOrMissingExponent, s), i = !0, o = !0, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((i || l) && this.raise(O.InvalidBigIntLiteral, s), ++this.state.pos, n = !0), c === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (o || l) && this.raise(O.InvalidDecimal, s), ++this.state.pos, a = !0), ms(this.codePointAtPos(this.state.pos)))
      throw this.raise(O.NumberIdentifier, this.state.curPosition());
    const f = this.input.slice(t, this.state.pos).replace(/[_mn]/g, "");
    if (n) {
      this.finishToken(135, f);
      return;
    }
    if (a) {
      this.finishToken(136, f);
      return;
    }
    const p = u ? parseInt(f, 8) : parseFloat(f);
    this.finishToken(134, p);
  }
  readCodePoint(e) {
    const {
      code: t,
      pos: s
    } = hS(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
    return this.state.pos = s, t;
  }
  readString(e) {
    const {
      str: t,
      pos: s,
      curLine: i,
      lineStart: n
    } = gy(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
    this.state.pos = s + 1, this.state.lineStart = n, this.state.curLine = i, this.finishToken(133, t);
  }
  readTemplateContinuation() {
    this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
  }
  readTemplateToken() {
    const e = this.input[this.state.pos], {
      str: t,
      firstInvalidLoc: s,
      pos: i,
      curLine: n,
      lineStart: a
    } = gy("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
    this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = n, s && (this.state.firstInvalidTemplateEscapePos = new ri(s.curLine, s.pos - s.lineStart, s.pos)), this.input.codePointAt(i) === 96 ? this.finishToken(24, s ? null : e + t + "`") : (this.state.pos++, this.finishToken(25, s ? null : e + t + "${"));
  }
  recordStrictModeErrors(e, t) {
    const s = t.index;
    this.state.strict && !this.state.strictErrors.has(s) ? this.raise(e, t) : this.state.strictErrors.set(s, [e, t]);
  }
  readWord1(e) {
    this.state.containsEsc = !1;
    let t = "";
    const s = this.state.pos;
    let i = this.state.pos;
    for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
      const n = this.codePointAtPos(this.state.pos);
      if (Sn(n))
        this.state.pos += n <= 65535 ? 1 : 2;
      else if (n === 92) {
        this.state.containsEsc = !0, t += this.input.slice(i, this.state.pos);
        const a = this.state.curPosition(), o = this.state.pos === s ? ms : Sn;
        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          this.raise(O.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
          continue;
        }
        ++this.state.pos;
        const u = this.readCodePoint(!0);
        u !== null && (o(u) || this.raise(O.EscapedCharNotAnIdentifier, a), t += String.fromCodePoint(u)), i = this.state.pos;
      } else
        break;
    }
    return t + this.input.slice(i, this.state.pos);
  }
  readWord(e) {
    const t = this.readWord1(e), s = rm.get(t);
    s !== void 0 ? this.finishToken(s, si(s)) : this.finishToken(132, t);
  }
  checkKeywordEscapes() {
    const {
      type: e
    } = this.state;
    um(e) && this.state.containsEsc && this.raise(O.InvalidEscapedReservedWord, this.state.startLoc, {
      reservedWord: si(e)
    });
  }
  raise(e, t, s = {}) {
    const i = t instanceof ri ? t : t.loc.start, n = e(i, s);
    if (!this.options.errorRecovery) throw n;
    return this.isLookahead || this.state.errors.push(n), n;
  }
  raiseOverwrite(e, t, s = {}) {
    const i = t instanceof ri ? t : t.loc.start, n = i.index, a = this.state.errors;
    for (let o = a.length - 1; o >= 0; o--) {
      const u = a[o];
      if (u.loc.index === n)
        return a[o] = e(i, s);
      if (u.loc.index < n) break;
    }
    return this.raise(e, t, s);
  }
  updateContext(e) {
  }
  unexpected(e, t) {
    throw this.raise(O.UnexpectedToken, e ?? this.state.startLoc, {
      expected: t ? si(t) : null
    });
  }
  expectPlugin(e, t) {
    if (this.hasPlugin(e))
      return !0;
    throw this.raise(O.MissingPlugin, t ?? this.state.startLoc, {
      missingPlugin: [e]
    });
  }
  expectOnePlugin(e) {
    if (!e.some((t) => this.hasPlugin(t)))
      throw this.raise(O.MissingOneOfPlugins, this.state.startLoc, {
        missingPlugin: e
      });
  }
  errorBuilder(e) {
    return (t, s, i) => {
      this.raise(e, ba(t, s, i));
    };
  }
}
class KN {
  constructor() {
    this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
  }
}
class XN {
  constructor(e) {
    this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  enter() {
    this.stack.push(new KN());
  }
  exit() {
    const e = this.stack.pop(), t = this.current();
    for (const [s, i] of Array.from(e.undefinedPrivateNames))
      t ? t.undefinedPrivateNames.has(s) || t.undefinedPrivateNames.set(s, i) : this.parser.raise(O.InvalidPrivateFieldResolution, i, {
        identifierName: s
      });
  }
  declarePrivateName(e, t, s) {
    const {
      privateNames: i,
      loneAccessors: n,
      undefinedPrivateNames: a
    } = this.current();
    let o = i.has(e);
    if (t & 3) {
      const u = o && n.get(e);
      if (u) {
        const l = u & 4, c = t & 4, f = u & 3, p = t & 3;
        o = f === p || l !== c, o || n.delete(e);
      } else o || n.set(e, t);
    }
    o && this.parser.raise(O.PrivateNameRedeclaration, s, {
      identifierName: e
    }), i.add(e), a.delete(e);
  }
  usePrivateName(e, t) {
    let s;
    for (s of this.stack)
      if (s.privateNames.has(e)) return;
    s ? s.undefinedPrivateNames.set(e, t) : this.parser.raise(O.InvalidPrivateFieldResolution, t, {
      identifierName: e
    });
  }
}
class Mc {
  constructor(e = 0) {
    this.type = e;
  }
  canBeArrowParameterDeclaration() {
    return this.type === 2 || this.type === 1;
  }
  isCertainlyParameterDeclaration() {
    return this.type === 3;
  }
}
class dS extends Mc {
  constructor(e) {
    super(e), this.declarationErrors = /* @__PURE__ */ new Map();
  }
  recordDeclarationError(e, t) {
    const s = t.index;
    this.declarationErrors.set(s, [e, t]);
  }
  clearDeclarationError(e) {
    this.declarationErrors.delete(e);
  }
  iterateErrors(e) {
    this.declarationErrors.forEach(e);
  }
}
class JN {
  constructor(e) {
    this.parser = void 0, this.stack = [new Mc()], this.parser = e;
  }
  enter(e) {
    this.stack.push(e);
  }
  exit() {
    this.stack.pop();
  }
  recordParameterInitializerError(e, t) {
    const s = t.loc.start, {
      stack: i
    } = this;
    let n = i.length - 1, a = i[n];
    for (; !a.isCertainlyParameterDeclaration(); ) {
      if (a.canBeArrowParameterDeclaration())
        a.recordDeclarationError(e, s);
      else
        return;
      a = i[--n];
    }
    this.parser.raise(e, s);
  }
  recordArrowParameterBindingError(e, t) {
    const {
      stack: s
    } = this, i = s[s.length - 1], n = t.loc.start;
    if (i.isCertainlyParameterDeclaration())
      this.parser.raise(e, n);
    else if (i.canBeArrowParameterDeclaration())
      i.recordDeclarationError(e, n);
    else
      return;
  }
  recordAsyncArrowParametersError(e) {
    const {
      stack: t
    } = this;
    let s = t.length - 1, i = t[s];
    for (; i.canBeArrowParameterDeclaration(); )
      i.type === 2 && i.recordDeclarationError(O.AwaitBindingIdentifier, e), i = t[--s];
  }
  validateAsPattern() {
    const {
      stack: e
    } = this, t = e[e.length - 1];
    t.canBeArrowParameterDeclaration() && t.iterateErrors(([s, i]) => {
      this.parser.raise(s, i);
      let n = e.length - 2, a = e[n];
      for (; a.canBeArrowParameterDeclaration(); )
        a.clearDeclarationError(i.index), a = e[--n];
    });
  }
}
function YN() {
  return new Mc(3);
}
function QN() {
  return new dS(1);
}
function ZN() {
  return new dS(2);
}
function mS() {
  return new Mc();
}
class eO {
  constructor() {
    this.stacks = [];
  }
  enter(e) {
    this.stacks.push(e);
  }
  exit() {
    this.stacks.pop();
  }
  currentFlags() {
    return this.stacks[this.stacks.length - 1];
  }
  get hasAwait() {
    return (this.currentFlags() & 2) > 0;
  }
  get hasYield() {
    return (this.currentFlags() & 1) > 0;
  }
  get hasReturn() {
    return (this.currentFlags() & 4) > 0;
  }
  get hasIn() {
    return (this.currentFlags() & 8) > 0;
  }
}
function $u(r, e) {
  return (r ? 2 : 0) | (e ? 1 : 0);
}
class tO extends GN {
  addExtra(e, t, s, i = !0) {
    if (!e) return;
    const n = e.extra = e.extra || {};
    i ? n[t] = s : Object.defineProperty(n, t, {
      enumerable: i,
      value: s
    });
  }
  isContextual(e) {
    return this.state.type === e && !this.state.containsEsc;
  }
  isUnparsedContextual(e, t) {
    const s = e + t.length;
    if (this.input.slice(e, s) === t) {
      const i = this.input.charCodeAt(s);
      return !(Sn(i) || (i & 64512) === 55296);
    }
    return !1;
  }
  isLookaheadContextual(e) {
    const t = this.nextTokenStart();
    return this.isUnparsedContextual(t, e);
  }
  eatContextual(e) {
    return this.isContextual(e) ? (this.next(), !0) : !1;
  }
  expectContextual(e, t) {
    if (!this.eatContextual(e)) {
      if (t != null)
        throw this.raise(t, this.state.startLoc);
      this.unexpected(null, e);
    }
  }
  canInsertSemicolon() {
    return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
  }
  hasPrecedingLineBreak() {
    return fS.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
  }
  hasFollowingLineBreak() {
    return dy.lastIndex = this.state.end, dy.test(this.input);
  }
  isLineTerminator() {
    return this.eat(13) || this.canInsertSemicolon();
  }
  semicolon(e = !0) {
    (e ? this.isLineTerminator() : this.eat(13)) || this.raise(O.MissingSemicolon, this.state.lastTokEndLoc);
  }
  expect(e, t) {
    this.eat(e) || this.unexpected(t, e);
  }
  tryParse(e, t = this.state.clone()) {
    const s = {
      node: null
    };
    try {
      const i = e((n = null) => {
        throw s.node = n, s;
      });
      if (this.state.errors.length > t.errors.length) {
        const n = this.state;
        return this.state = t, this.state.tokensLength = n.tokensLength, {
          node: i,
          error: n.errors[t.errors.length],
          thrown: !1,
          aborted: !1,
          failState: n
        };
      }
      return {
        node: i,
        error: null,
        thrown: !1,
        aborted: !1,
        failState: null
      };
    } catch (i) {
      const n = this.state;
      if (this.state = t, i instanceof SyntaxError)
        return {
          node: null,
          error: i,
          thrown: !0,
          aborted: !1,
          failState: n
        };
      if (i === s)
        return {
          node: s.node,
          error: null,
          thrown: !1,
          aborted: !0,
          failState: n
        };
      throw i;
    }
  }
  checkExpressionErrors(e, t) {
    if (!e) return !1;
    const {
      shorthandAssignLoc: s,
      doubleProtoLoc: i,
      privateKeyLoc: n,
      optionalParametersLoc: a
    } = e, o = !!s || !!i || !!a || !!n;
    if (!t)
      return o;
    s != null && this.raise(O.InvalidCoverInitializedName, s), i != null && this.raise(O.DuplicateProto, i), n != null && this.raise(O.UnexpectedPrivateField, n), a != null && this.unexpected(a);
  }
  isLiteralPropertyName() {
    return sS(this.state.type);
  }
  isPrivateName(e) {
    return e.type === "PrivateName";
  }
  getPrivateNameSV(e) {
    return e.id.name;
  }
  hasPropertyAsPrivateName(e) {
    return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
  }
  isObjectProperty(e) {
    return e.type === "ObjectProperty";
  }
  isObjectMethod(e) {
    return e.type === "ObjectMethod";
  }
  initializeScopes(e = this.options.sourceType === "module") {
    const t = this.state.labels;
    this.state.labels = [];
    const s = this.exportedIdentifiers;
    this.exportedIdentifiers = /* @__PURE__ */ new Set();
    const i = this.inModule;
    this.inModule = e;
    const n = this.scope, a = this.getScopeHandler();
    this.scope = new a(this, e);
    const o = this.prodParam;
    this.prodParam = new eO();
    const u = this.classScope;
    this.classScope = new XN(this);
    const l = this.expressionScope;
    return this.expressionScope = new JN(this), () => {
      this.state.labels = t, this.exportedIdentifiers = s, this.inModule = i, this.scope = n, this.prodParam = o, this.classScope = u, this.expressionScope = l;
    };
  }
  enterInitialScopes() {
    let e = 0;
    this.inModule && (e |= 2), this.scope.enter(1), this.prodParam.enter(e);
  }
  checkDestructuringPrivate(e) {
    const {
      privateKeyLoc: t
    } = e;
    t !== null && this.expectPlugin("destructuringPrivate", t);
  }
}
class Fu {
  constructor() {
    this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
  }
}
let Sl = class {
  constructor(e, t, s) {
    this.type = "", this.start = t, this.end = 0, this.loc = new vl(s), e != null && e.options.ranges && (this.range = [t, 0]), e != null && e.filename && (this.loc.filename = e.filename);
  }
};
const dm = Sl.prototype;
dm.__clone = function() {
  const r = new Sl(void 0, this.start, this.loc.start), e = Object.keys(this);
  for (let t = 0, s = e.length; t < s; t++) {
    const i = e[t];
    i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (r[i] = this[i]);
  }
  return r;
};
function rO(r) {
  return Ss(r);
}
function Ss(r) {
  const {
    type: e,
    start: t,
    end: s,
    loc: i,
    range: n,
    extra: a,
    name: o
  } = r, u = Object.create(dm);
  return u.type = e, u.start = t, u.end = s, u.loc = i, u.range = n, u.extra = a, u.name = o, e === "Placeholder" && (u.expectedNode = r.expectedNode), u;
}
function sO(r) {
  const {
    type: e,
    start: t,
    end: s,
    loc: i,
    range: n,
    extra: a
  } = r;
  if (e === "Placeholder")
    return rO(r);
  const o = Object.create(dm);
  return o.type = e, o.start = t, o.end = s, o.loc = i, o.range = n, r.raw !== void 0 ? o.raw = r.raw : o.extra = a, o.value = r.value, o;
}
class iO extends tO {
  startNode() {
    const e = this.state.startLoc;
    return new Sl(this, e.index, e);
  }
  startNodeAt(e) {
    return new Sl(this, e.index, e);
  }
  startNodeAtNode(e) {
    return this.startNodeAt(e.loc.start);
  }
  finishNode(e, t) {
    return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
  }
  finishNodeAt(e, t, s) {
    return e.type = t, e.end = s.index, e.loc.end = s, this.options.ranges && (e.range[1] = s.index), this.options.attachComment && this.processComment(e), e;
  }
  resetStartLocation(e, t) {
    e.start = t.index, e.loc.start = t, this.options.ranges && (e.range[0] = t.index);
  }
  resetEndLocation(e, t = this.state.lastTokEndLoc) {
    e.end = t.index, e.loc.end = t, this.options.ranges && (e.range[1] = t.index);
  }
  resetStartLocationFromNode(e, t) {
    this.resetStartLocation(e, t.loc.start);
  }
}
const nO = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), de = gs`flow`({
  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
  AssignReservedType: ({
    reservedType: r
  }) => `Cannot overwrite reserved type ${r}.`,
  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
  EnumBooleanMemberNotInitialized: ({
    memberName: r,
    enumName: e
  }) => `Boolean enum members need to be initialized. Use either \`${r} = true,\` or \`${r} = false,\` in enum \`${e}\`.`,
  EnumDuplicateMemberName: ({
    memberName: r,
    enumName: e
  }) => `Enum member names need to be unique, but the name \`${r}\` has already been used before in enum \`${e}\`.`,
  EnumInconsistentMemberValues: ({
    enumName: r
  }) => `Enum \`${r}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
  EnumInvalidExplicitType: ({
    invalidEnumType: r,
    enumName: e
  }) => `Enum type \`${r}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`,
  EnumInvalidExplicitTypeUnknownSupplied: ({
    enumName: r
  }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${r}\`.`,
  EnumInvalidMemberInitializerPrimaryType: ({
    enumName: r,
    memberName: e,
    explicitType: t
  }) => `Enum \`${r}\` has type \`${t}\`, so the initializer of \`${e}\` needs to be a ${t} literal.`,
  EnumInvalidMemberInitializerSymbolType: ({
    enumName: r,
    memberName: e
  }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${r}\`.`,
  EnumInvalidMemberInitializerUnknownType: ({
    enumName: r,
    memberName: e
  }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${r}\`.`,
  EnumInvalidMemberName: ({
    enumName: r,
    memberName: e,
    suggestion: t
  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${t}\`, in enum \`${r}\`.`,
  EnumNumberMemberNotInitialized: ({
    enumName: r,
    memberName: e
  }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${r}\`.`,
  EnumStringMemberInconsistentlyInitialized: ({
    enumName: r
  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${r}\`.`,
  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
  ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
  InexactVariance: "Explicit inexact syntax cannot have variance.",
  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
  PatternIsOptional: Object.assign({
    message: "A binding pattern parameter cannot be optional in an implementation signature."
  }, {
    reasonCode: "OptionalBindingPattern"
  }),
  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
  SpreadVariance: "Spread properties cannot have variance.",
  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
  ThisParamNoDefault: "The `this` parameter may not have a default value.",
  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
  UnexpectedReservedType: ({
    reservedType: r
  }) => `Unexpected reserved type ${r}.`,
  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
  UnsupportedDeclareExportKind: ({
    unsupportedExportKind: r,
    suggestion: e
  }) => `\`declare export ${r}\` is not supported. Use \`${e}\` instead.`,
  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
  UnterminatedFlowComment: "Unterminated flow-comment."
});
function aO(r) {
  return r.type === "DeclareExportAllDeclaration" || r.type === "DeclareExportDeclaration" && (!r.declaration || r.declaration.type !== "TypeAlias" && r.declaration.type !== "InterfaceDeclaration");
}
function yy(r) {
  return r.importKind === "type" || r.importKind === "typeof";
}
const oO = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface"
};
function uO(r, e) {
  const t = [], s = [];
  for (let i = 0; i < r.length; i++)
    (e(r[i], i, r) ? t : s).push(r[i]);
  return [t, s];
}
const lO = /\*?\s*@((?:no)?flow)\b/;
var cO = (r) => class extends r {
  constructor(...t) {
    super(...t), this.flowPragma = void 0;
  }
  getScopeHandler() {
    return FN;
  }
  shouldParseTypes() {
    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
  }
  shouldParseEnums() {
    return !!this.getPluginOption("flow", "enums");
  }
  finishToken(t, s) {
    t !== 133 && t !== 13 && t !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(t, s);
  }
  addComment(t) {
    if (this.flowPragma === void 0) {
      const s = lO.exec(t.value);
      if (s) if (s[1] === "flow")
        this.flowPragma = "flow";
      else if (s[1] === "noflow")
        this.flowPragma = "noflow";
      else
        throw new Error("Unexpected flow pragma");
    }
    super.addComment(t);
  }
  flowParseTypeInitialiser(t) {
    const s = this.state.inType;
    this.state.inType = !0, this.expect(t || 14);
    const i = this.flowParseType();
    return this.state.inType = s, i;
  }
  flowParsePredicate() {
    const t = this.startNode(), s = this.state.startLoc;
    return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(de.UnexpectedSpaceBetweenModuloChecks, s), this.eat(10) ? (t.value = super.parseExpression(), this.expect(11), this.finishNode(t, "DeclaredPredicate")) : this.finishNode(t, "InferredPredicate");
  }
  flowParseTypeAndPredicateInitialiser() {
    const t = this.state.inType;
    this.state.inType = !0, this.expect(14);
    let s = null, i = null;
    return this.match(54) ? (this.state.inType = t, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = t, this.match(54) && (i = this.flowParsePredicate())), [s, i];
  }
  flowParseDeclareClass(t) {
    return this.next(), this.flowParseInterfaceish(t, !0), this.finishNode(t, "DeclareClass");
  }
  flowParseDeclareFunction(t) {
    this.next();
    const s = t.id = this.parseIdentifier(), i = this.startNode(), n = this.startNode();
    this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
    const a = this.flowParseFunctionTypeParams();
    return i.params = a.params, i.rest = a.rest, i.this = a._this, this.expect(11), [i.returnType, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), n.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(n, "TypeAnnotation"), this.resetEndLocation(s), this.semicolon(), this.scope.declareName(t.id.name, 2048, t.id.loc.start), this.finishNode(t, "DeclareFunction");
  }
  flowParseDeclare(t, s) {
    if (this.match(80))
      return this.flowParseDeclareClass(t);
    if (this.match(68))
      return this.flowParseDeclareFunction(t);
    if (this.match(74))
      return this.flowParseDeclareVariable(t);
    if (this.eatContextual(127))
      return this.match(16) ? this.flowParseDeclareModuleExports(t) : (s && this.raise(de.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(t));
    if (this.isContextual(130))
      return this.flowParseDeclareTypeAlias(t);
    if (this.isContextual(131))
      return this.flowParseDeclareOpaqueType(t);
    if (this.isContextual(129))
      return this.flowParseDeclareInterface(t);
    if (this.match(82))
      return this.flowParseDeclareExportDeclaration(t, s);
    this.unexpected();
  }
  flowParseDeclareVariable(t) {
    return this.next(), t.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(t.id.name, 5, t.id.loc.start), this.semicolon(), this.finishNode(t, "DeclareVariable");
  }
  flowParseDeclareModule(t) {
    this.scope.enter(0), this.match(133) ? t.id = super.parseExprAtom() : t.id = this.parseIdentifier();
    const s = t.body = this.startNode(), i = s.body = [];
    for (this.expect(5); !this.match(8); ) {
      let o = this.startNode();
      this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(de.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(o)) : (this.expectContextual(125, de.UnsupportedStatementInDeclareModule), o = this.flowParseDeclare(o, !0)), i.push(o);
    }
    this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
    let n = null, a = !1;
    return i.forEach((o) => {
      aO(o) ? (n === "CommonJS" && this.raise(de.AmbiguousDeclareModuleKind, o), n = "ES") : o.type === "DeclareModuleExports" && (a && this.raise(de.DuplicateDeclareModuleExports, o), n === "ES" && this.raise(de.AmbiguousDeclareModuleKind, o), n = "CommonJS", a = !0);
    }), t.kind = n || "CommonJS", this.finishNode(t, "DeclareModule");
  }
  flowParseDeclareExportDeclaration(t, s) {
    if (this.expect(82), this.eat(65))
      return this.match(68) || this.match(80) ? t.declaration = this.flowParseDeclare(this.startNode()) : (t.declaration = this.flowParseType(), this.semicolon()), t.default = !0, this.finishNode(t, "DeclareExportDeclaration");
    if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
      const i = this.state.value;
      throw this.raise(de.UnsupportedDeclareExportKind, this.state.startLoc, {
        unsupportedExportKind: i,
        suggestion: oO[i]
      });
    }
    if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
      return t.declaration = this.flowParseDeclare(this.startNode()), t.default = !1, this.finishNode(t, "DeclareExportDeclaration");
    if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
      return t = this.parseExport(t, null), t.type === "ExportNamedDeclaration" && (t.type = "ExportDeclaration", t.default = !1, delete t.exportKind), t.type = "Declare" + t.type, t;
    this.unexpected();
  }
  flowParseDeclareModuleExports(t) {
    return this.next(), this.expectContextual(111), t.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(t, "DeclareModuleExports");
  }
  flowParseDeclareTypeAlias(t) {
    this.next();
    const s = this.flowParseTypeAlias(t);
    return s.type = "DeclareTypeAlias", s;
  }
  flowParseDeclareOpaqueType(t) {
    this.next();
    const s = this.flowParseOpaqueType(t, !0);
    return s.type = "DeclareOpaqueType", s;
  }
  flowParseDeclareInterface(t) {
    return this.next(), this.flowParseInterfaceish(t, !1), this.finishNode(t, "DeclareInterface");
  }
  flowParseInterfaceish(t, s) {
    if (t.id = this.flowParseRestrictedIdentifier(!s, !0), this.scope.declareName(t.id.name, s ? 17 : 8201, t.id.loc.start), this.match(47) ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.extends = [], this.eat(81))
      do
        t.extends.push(this.flowParseInterfaceExtends());
      while (!s && this.eat(12));
    if (s) {
      if (t.implements = [], t.mixins = [], this.eatContextual(117))
        do
          t.mixins.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      if (this.eatContextual(113))
        do
          t.implements.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
    }
    t.body = this.flowParseObjectType({
      allowStatic: s,
      allowExact: !1,
      allowSpread: !1,
      allowProto: s,
      allowInexact: !1
    });
  }
  flowParseInterfaceExtends() {
    const t = this.startNode();
    return t.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? t.typeParameters = this.flowParseTypeParameterInstantiation() : t.typeParameters = null, this.finishNode(t, "InterfaceExtends");
  }
  flowParseInterface(t) {
    return this.flowParseInterfaceish(t, !1), this.finishNode(t, "InterfaceDeclaration");
  }
  checkNotUnderscore(t) {
    t === "_" && this.raise(de.UnexpectedReservedUnderscore, this.state.startLoc);
  }
  checkReservedType(t, s, i) {
    nO.has(t) && this.raise(i ? de.AssignReservedType : de.UnexpectedReservedType, s, {
      reservedType: t
    });
  }
  flowParseRestrictedIdentifier(t, s) {
    return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(t);
  }
  flowParseTypeAlias(t) {
    return t.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(t.id.name, 8201, t.id.loc.start), this.match(47) ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(t, "TypeAlias");
  }
  flowParseOpaqueType(t, s) {
    return this.expectContextual(130), t.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(t.id.name, 8201, t.id.loc.start), this.match(47) ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.supertype = null, this.match(14) && (t.supertype = this.flowParseTypeInitialiser(14)), t.impltype = null, s || (t.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(t, "OpaqueType");
  }
  flowParseTypeParameter(t = !1) {
    const s = this.state.startLoc, i = this.startNode(), n = this.flowParseVariance(), a = this.flowParseTypeAnnotatableIdentifier();
    return i.name = a.name, i.variance = n, i.bound = a.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) : t && this.raise(de.MissingTypeParamDefault, s), this.finishNode(i, "TypeParameter");
  }
  flowParseTypeParameterDeclaration() {
    const t = this.state.inType, s = this.startNode();
    s.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
    let i = !1;
    do {
      const n = this.flowParseTypeParameter(i);
      s.params.push(n), n.default && (i = !0), this.match(48) || this.expect(12);
    } while (!this.match(48));
    return this.expect(48), this.state.inType = t, this.finishNode(s, "TypeParameterDeclaration");
  }
  flowParseTypeParameterInstantiation() {
    const t = this.startNode(), s = this.state.inType;
    t.params = [], this.state.inType = !0, this.expect(47);
    const i = this.state.noAnonFunctionType;
    for (this.state.noAnonFunctionType = !1; !this.match(48); )
      t.params.push(this.flowParseType()), this.match(48) || this.expect(12);
    return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(t, "TypeParameterInstantiation");
  }
  flowParseTypeParameterInstantiationCallOrNew() {
    const t = this.startNode(), s = this.state.inType;
    for (t.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
      t.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
    return this.expect(48), this.state.inType = s, this.finishNode(t, "TypeParameterInstantiation");
  }
  flowParseInterfaceType() {
    const t = this.startNode();
    if (this.expectContextual(129), t.extends = [], this.eat(81))
      do
        t.extends.push(this.flowParseInterfaceExtends());
      while (this.eat(12));
    return t.body = this.flowParseObjectType({
      allowStatic: !1,
      allowExact: !1,
      allowSpread: !1,
      allowProto: !1,
      allowInexact: !1
    }), this.finishNode(t, "InterfaceTypeAnnotation");
  }
  flowParseObjectPropertyKey() {
    return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
  }
  flowParseObjectTypeIndexer(t, s, i) {
    return t.static = s, this.lookahead().type === 14 ? (t.id = this.flowParseObjectPropertyKey(), t.key = this.flowParseTypeInitialiser()) : (t.id = null, t.key = this.flowParseType()), this.expect(3), t.value = this.flowParseTypeInitialiser(), t.variance = i, this.finishNode(t, "ObjectTypeIndexer");
  }
  flowParseObjectTypeInternalSlot(t, s) {
    return t.static = s, t.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (t.method = !0, t.optional = !1, t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.loc.start))) : (t.method = !1, this.eat(17) && (t.optional = !0), t.value = this.flowParseTypeInitialiser()), this.finishNode(t, "ObjectTypeInternalSlot");
  }
  flowParseObjectTypeMethodish(t) {
    for (t.params = [], t.rest = null, t.typeParameters = null, t.this = null, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (t.this = this.flowParseFunctionTypeParam(!0), t.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
      t.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
    return this.eat(21) && (t.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), t.returnType = this.flowParseTypeInitialiser(), this.finishNode(t, "FunctionTypeAnnotation");
  }
  flowParseObjectTypeCallProperty(t, s) {
    const i = this.startNode();
    return t.static = s, t.value = this.flowParseObjectTypeMethodish(i), this.finishNode(t, "ObjectTypeCallProperty");
  }
  flowParseObjectType({
    allowStatic: t,
    allowExact: s,
    allowSpread: i,
    allowProto: n,
    allowInexact: a
  }) {
    const o = this.state.inType;
    this.state.inType = !0;
    const u = this.startNode();
    u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
    let l, c, f = !1;
    for (s && this.match(6) ? (this.expect(6), l = 9, c = !0) : (this.expect(5), l = 8, c = !1), u.exact = c; !this.match(l); ) {
      let h = !1, m = null, d = null;
      const y = this.startNode();
      if (n && this.isContextual(118)) {
        const E = this.lookahead();
        E.type !== 14 && E.type !== 17 && (this.next(), m = this.state.startLoc, t = !1);
      }
      if (t && this.isContextual(106)) {
        const E = this.lookahead();
        E.type !== 14 && E.type !== 17 && (this.next(), h = !0);
      }
      const S = this.flowParseVariance();
      if (this.eat(0))
        m != null && this.unexpected(m), this.eat(0) ? (S && this.unexpected(S.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(y, h))) : u.indexers.push(this.flowParseObjectTypeIndexer(y, h, S));
      else if (this.match(10) || this.match(47))
        m != null && this.unexpected(m), S && this.unexpected(S.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(y, h));
      else {
        let E = "init";
        if (this.isContextual(99) || this.isContextual(104)) {
          const b = this.lookahead();
          sS(b.type) && (E = this.state.value, this.next());
        }
        const g = this.flowParseObjectTypeProperty(y, h, m, S, E, i, a ?? !c);
        g === null ? (f = !0, d = this.state.lastTokStartLoc) : u.properties.push(g);
      }
      this.flowObjectTypeSemicolon(), d && !this.match(8) && !this.match(9) && this.raise(de.UnexpectedExplicitInexactInObject, d);
    }
    this.expect(l), i && (u.inexact = f);
    const p = this.finishNode(u, "ObjectTypeAnnotation");
    return this.state.inType = o, p;
  }
  flowParseObjectTypeProperty(t, s, i, n, a, o, u) {
    if (this.eat(21))
      return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? u || this.raise(de.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(de.InexactInsideNonObject, this.state.lastTokStartLoc), n && this.raise(de.InexactVariance, n), null) : (o || this.raise(de.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), n && this.raise(de.SpreadVariance, n), t.argument = this.flowParseType(), this.finishNode(t, "ObjectTypeSpreadProperty"));
    {
      t.key = this.flowParseObjectPropertyKey(), t.static = s, t.proto = i != null, t.kind = a;
      let l = !1;
      return this.match(47) || this.match(10) ? (t.method = !0, i != null && this.unexpected(i), n && this.unexpected(n.loc.start), t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.loc.start)), (a === "get" || a === "set") && this.flowCheckGetterSetterParams(t), !o && t.key.name === "constructor" && t.value.this && this.raise(de.ThisParamBannedInConstructor, t.value.this)) : (a !== "init" && this.unexpected(), t.method = !1, this.eat(17) && (l = !0), t.value = this.flowParseTypeInitialiser(), t.variance = n), t.optional = l, this.finishNode(t, "ObjectTypeProperty");
    }
  }
  flowCheckGetterSetterParams(t) {
    const s = t.kind === "get" ? 0 : 1, i = t.value.params.length + (t.value.rest ? 1 : 0);
    t.value.this && this.raise(t.kind === "get" ? de.GetterMayNotHaveThisParam : de.SetterMayNotHaveThisParam, t.value.this), i !== s && this.raise(t.kind === "get" ? O.BadGetterArity : O.BadSetterArity, t), t.kind === "set" && t.value.rest && this.raise(O.BadSetterRestParameter, t);
  }
  flowObjectTypeSemicolon() {
    !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
  }
  flowParseQualifiedTypeIdentifier(t, s) {
    var i;
    (i = t) != null || (t = this.state.startLoc);
    let n = s || this.flowParseRestrictedIdentifier(!0);
    for (; this.eat(16); ) {
      const a = this.startNodeAt(t);
      a.qualification = n, a.id = this.flowParseRestrictedIdentifier(!0), n = this.finishNode(a, "QualifiedTypeIdentifier");
    }
    return n;
  }
  flowParseGenericType(t, s) {
    const i = this.startNodeAt(t);
    return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(t, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
  }
  flowParseTypeofType() {
    const t = this.startNode();
    return this.expect(87), t.argument = this.flowParsePrimaryType(), this.finishNode(t, "TypeofTypeAnnotation");
  }
  flowParseTupleType() {
    const t = this.startNode();
    for (t.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (t.types.push(this.flowParseType()), !this.match(3)); )
      this.expect(12);
    return this.expect(3), this.finishNode(t, "TupleTypeAnnotation");
  }
  flowParseFunctionTypeParam(t) {
    let s = null, i = !1, n = null;
    const a = this.startNode(), o = this.lookahead(), u = this.state.type === 78;
    return o.type === 14 || o.type === 17 ? (u && !t && this.raise(de.ThisParamMustBeFirst, a), s = this.parseIdentifier(u), this.eat(17) && (i = !0, u && this.raise(de.ThisParamMayNotBeOptional, a)), n = this.flowParseTypeInitialiser()) : n = this.flowParseType(), a.name = s, a.optional = i, a.typeAnnotation = n, this.finishNode(a, "FunctionTypeParam");
  }
  reinterpretTypeAsFunctionTypeParam(t) {
    const s = this.startNodeAt(t.loc.start);
    return s.name = null, s.optional = !1, s.typeAnnotation = t, this.finishNode(s, "FunctionTypeParam");
  }
  flowParseFunctionTypeParams(t = []) {
    let s = null, i = null;
    for (this.match(78) && (i = this.flowParseFunctionTypeParam(!0), i.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
      t.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
    return this.eat(21) && (s = this.flowParseFunctionTypeParam(!1)), {
      params: t,
      rest: s,
      _this: i
    };
  }
  flowIdentToTypeAnnotation(t, s, i) {
    switch (i.name) {
      case "any":
        return this.finishNode(s, "AnyTypeAnnotation");
      case "bool":
      case "boolean":
        return this.finishNode(s, "BooleanTypeAnnotation");
      case "mixed":
        return this.finishNode(s, "MixedTypeAnnotation");
      case "empty":
        return this.finishNode(s, "EmptyTypeAnnotation");
      case "number":
        return this.finishNode(s, "NumberTypeAnnotation");
      case "string":
        return this.finishNode(s, "StringTypeAnnotation");
      case "symbol":
        return this.finishNode(s, "SymbolTypeAnnotation");
      default:
        return this.checkNotUnderscore(i.name), this.flowParseGenericType(t, i);
    }
  }
  flowParsePrimaryType() {
    const t = this.state.startLoc, s = this.startNode();
    let i, n, a = !1;
    const o = this.state.noAnonFunctionType;
    switch (this.state.type) {
      case 5:
        return this.flowParseObjectType({
          allowStatic: !1,
          allowExact: !1,
          allowSpread: !0,
          allowProto: !1,
          allowInexact: !0
        });
      case 6:
        return this.flowParseObjectType({
          allowStatic: !1,
          allowExact: !0,
          allowSpread: !0,
          allowProto: !1,
          allowInexact: !1
        });
      case 0:
        return this.state.noAnonFunctionType = !1, n = this.flowParseTupleType(), this.state.noAnonFunctionType = o, n;
      case 47: {
        const u = this.startNode();
        return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), u.params = i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(u, "FunctionTypeAnnotation");
      }
      case 10: {
        const u = this.startNode();
        if (this.next(), !this.match(11) && !this.match(21))
          if (Le(this.state.type) || this.match(78)) {
            const l = this.lookahead().type;
            a = l !== 17 && l !== 14;
          } else
            a = !0;
        if (a) {
          if (this.state.noAnonFunctionType = !1, n = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
            return this.expect(11), n;
          this.eat(12);
        }
        return n ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(n)]) : i = this.flowParseFunctionTypeParams(), u.params = i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters = null, this.finishNode(u, "FunctionTypeAnnotation");
      }
      case 133:
        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
      case 85:
      case 86:
        return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
      case 53:
        if (this.state.value === "-") {
          if (this.next(), this.match(134))
            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
          if (this.match(135))
            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
          throw this.raise(de.UnexpectedSubtractionOperand, this.state.startLoc);
        }
        this.unexpected();
        return;
      case 134:
        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
      case 135:
        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
      case 88:
        return this.next(), this.finishNode(s, "VoidTypeAnnotation");
      case 84:
        return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
      case 78:
        return this.next(), this.finishNode(s, "ThisTypeAnnotation");
      case 55:
        return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
      case 87:
        return this.flowParseTypeofType();
      default:
        if (um(this.state.type)) {
          const u = si(this.state.type);
          return this.next(), super.createIdentifier(s, u);
        } else if (Le(this.state.type))
          return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(t, s, this.parseIdentifier());
    }
    this.unexpected();
  }
  flowParsePostfixType() {
    const t = this.state.startLoc;
    let s = this.flowParsePrimaryType(), i = !1;
    for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
      const n = this.startNodeAt(t), a = this.eat(18);
      i = i || a, this.expect(0), !a && this.match(3) ? (n.elementType = s, this.next(), s = this.finishNode(n, "ArrayTypeAnnotation")) : (n.objectType = s, n.indexType = this.flowParseType(), this.expect(3), i ? (n.optional = a, s = this.finishNode(n, "OptionalIndexedAccessType")) : s = this.finishNode(n, "IndexedAccessType"));
    }
    return s;
  }
  flowParsePrefixType() {
    const t = this.startNode();
    return this.eat(17) ? (t.typeAnnotation = this.flowParsePrefixType(), this.finishNode(t, "NullableTypeAnnotation")) : this.flowParsePostfixType();
  }
  flowParseAnonFunctionWithoutParens() {
    const t = this.flowParsePrefixType();
    if (!this.state.noAnonFunctionType && this.eat(19)) {
      const s = this.startNodeAt(t.loc.start);
      return s.params = [this.reinterpretTypeAsFunctionTypeParam(t)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
    }
    return t;
  }
  flowParseIntersectionType() {
    const t = this.startNode();
    this.eat(45);
    const s = this.flowParseAnonFunctionWithoutParens();
    for (t.types = [s]; this.eat(45); )
      t.types.push(this.flowParseAnonFunctionWithoutParens());
    return t.types.length === 1 ? s : this.finishNode(t, "IntersectionTypeAnnotation");
  }
  flowParseUnionType() {
    const t = this.startNode();
    this.eat(43);
    const s = this.flowParseIntersectionType();
    for (t.types = [s]; this.eat(43); )
      t.types.push(this.flowParseIntersectionType());
    return t.types.length === 1 ? s : this.finishNode(t, "UnionTypeAnnotation");
  }
  flowParseType() {
    const t = this.state.inType;
    this.state.inType = !0;
    const s = this.flowParseUnionType();
    return this.state.inType = t, s;
  }
  flowParseTypeOrImplicitInstantiation() {
    if (this.state.type === 132 && this.state.value === "_") {
      const t = this.state.startLoc, s = this.parseIdentifier();
      return this.flowParseGenericType(t, s);
    } else
      return this.flowParseType();
  }
  flowParseTypeAnnotation() {
    const t = this.startNode();
    return t.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(t, "TypeAnnotation");
  }
  flowParseTypeAnnotatableIdentifier(t) {
    const s = t ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
    return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
  }
  typeCastToParameter(t) {
    return t.expression.typeAnnotation = t.typeAnnotation, this.resetEndLocation(t.expression, t.typeAnnotation.loc.end), t.expression;
  }
  flowParseVariance() {
    let t = null;
    return this.match(53) ? (t = this.startNode(), this.state.value === "+" ? t.kind = "plus" : t.kind = "minus", this.next(), this.finishNode(t, "Variance")) : t;
  }
  parseFunctionBody(t, s, i = !1) {
    if (s) {
      this.forwardNoArrowParamsConversionAt(t, () => super.parseFunctionBody(t, !0, i));
      return;
    }
    super.parseFunctionBody(t, !1, i);
  }
  parseFunctionBodyAndFinish(t, s, i = !1) {
    if (this.match(14)) {
      const n = this.startNode();
      [n.typeAnnotation, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), t.returnType = n.typeAnnotation ? this.finishNode(n, "TypeAnnotation") : null;
    }
    return super.parseFunctionBodyAndFinish(t, s, i);
  }
  parseStatementLike(t) {
    if (this.state.strict && this.isContextual(129)) {
      const i = this.lookahead();
      if (Cr(i.type)) {
        const n = this.startNode();
        return this.next(), this.flowParseInterface(n);
      }
    } else if (this.shouldParseEnums() && this.isContextual(126)) {
      const i = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(i);
    }
    const s = super.parseStatementLike(t);
    return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
  }
  parseExpressionStatement(t, s, i) {
    if (s.type === "Identifier") {
      if (s.name === "declare") {
        if (this.match(80) || Le(this.state.type) || this.match(68) || this.match(74) || this.match(82))
          return this.flowParseDeclare(t);
      } else if (Le(this.state.type)) {
        if (s.name === "interface")
          return this.flowParseInterface(t);
        if (s.name === "type")
          return this.flowParseTypeAlias(t);
        if (s.name === "opaque")
          return this.flowParseOpaqueType(t, !1);
      }
    }
    return super.parseExpressionStatement(t, s, i);
  }
  shouldParseExportDeclaration() {
    const {
      type: t
    } = this.state;
    return hy(t) || this.shouldParseEnums() && t === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
  }
  isExportDefaultSpecifier() {
    const {
      type: t
    } = this.state;
    return hy(t) || this.shouldParseEnums() && t === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
  }
  parseExportDefaultExpression() {
    if (this.shouldParseEnums() && this.isContextual(126)) {
      const t = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(t);
    }
    return super.parseExportDefaultExpression();
  }
  parseConditional(t, s, i) {
    if (!this.match(17)) return t;
    if (this.state.maybeInArrowParameters) {
      const p = this.lookaheadCharCode();
      if (p === 44 || p === 61 || p === 58 || p === 41)
        return this.setOptionalParametersError(i), t;
    }
    this.expect(17);
    const n = this.state.clone(), a = this.state.noArrowAt, o = this.startNodeAt(s);
    let {
      consequent: u,
      failed: l
    } = this.tryParseConditionalConsequent(), [c, f] = this.getArrowLikeExpressions(u);
    if (l || f.length > 0) {
      const p = [...a];
      if (f.length > 0) {
        this.state = n, this.state.noArrowAt = p;
        for (let h = 0; h < f.length; h++)
          p.push(f[h].start);
        ({
          consequent: u,
          failed: l
        } = this.tryParseConditionalConsequent()), [c, f] = this.getArrowLikeExpressions(u);
      }
      l && c.length > 1 && this.raise(de.AmbiguousConditionalArrow, n.startLoc), l && c.length === 1 && (this.state = n, p.push(c[0].start), this.state.noArrowAt = p, {
        consequent: u,
        failed: l
      } = this.tryParseConditionalConsequent());
    }
    return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = a, this.expect(14), o.test = t, o.consequent = u, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
  }
  tryParseConditionalConsequent() {
    this.state.noArrowParamsConversionAt.push(this.state.start);
    const t = this.parseMaybeAssignAllowIn(), s = !this.match(14);
    return this.state.noArrowParamsConversionAt.pop(), {
      consequent: t,
      failed: s
    };
  }
  getArrowLikeExpressions(t, s) {
    const i = [t], n = [];
    for (; i.length !== 0; ) {
      const a = i.pop();
      a.type === "ArrowFunctionExpression" && a.body.type !== "BlockStatement" ? (a.typeParameters || !a.returnType ? this.finishArrowValidation(a) : n.push(a), i.push(a.body)) : a.type === "ConditionalExpression" && (i.push(a.consequent), i.push(a.alternate));
    }
    return s ? (n.forEach((a) => this.finishArrowValidation(a)), [n, []]) : uO(n, (a) => a.params.every((o) => this.isAssignable(o, !0)));
  }
  finishArrowValidation(t) {
    var s;
    this.toAssignableList(t.params, (s = t.extra) == null ? void 0 : s.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(t, !1, !0), this.scope.exit();
  }
  forwardNoArrowParamsConversionAt(t, s) {
    let i;
    return this.state.noArrowParamsConversionAt.indexOf(t.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i = s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
  }
  parseParenItem(t, s) {
    const i = super.parseParenItem(t, s);
    if (this.eat(17) && (i.optional = !0, this.resetEndLocation(t)), this.match(14)) {
      const n = this.startNodeAt(s);
      return n.expression = i, n.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(n, "TypeCastExpression");
    }
    return i;
  }
  assertModuleNodeAllowed(t) {
    t.type === "ImportDeclaration" && (t.importKind === "type" || t.importKind === "typeof") || t.type === "ExportNamedDeclaration" && t.exportKind === "type" || t.type === "ExportAllDeclaration" && t.exportKind === "type" || super.assertModuleNodeAllowed(t);
  }
  parseExportDeclaration(t) {
    if (this.isContextual(130)) {
      t.exportKind = "type";
      const s = this.startNode();
      return this.next(), this.match(5) ? (t.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(t), null) : this.flowParseTypeAlias(s);
    } else if (this.isContextual(131)) {
      t.exportKind = "type";
      const s = this.startNode();
      return this.next(), this.flowParseOpaqueType(s, !1);
    } else if (this.isContextual(129)) {
      t.exportKind = "type";
      const s = this.startNode();
      return this.next(), this.flowParseInterface(s);
    } else if (this.shouldParseEnums() && this.isContextual(126)) {
      t.exportKind = "value";
      const s = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(s);
    } else
      return super.parseExportDeclaration(t);
  }
  eatExportStar(t) {
    return super.eatExportStar(t) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (t.exportKind = "type", this.next(), this.next(), !0) : !1;
  }
  maybeParseExportNamespaceSpecifier(t) {
    const {
      startLoc: s
    } = this.state, i = super.maybeParseExportNamespaceSpecifier(t);
    return i && t.exportKind === "type" && this.unexpected(s), i;
  }
  parseClassId(t, s, i) {
    super.parseClassId(t, s, i), this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration());
  }
  parseClassMember(t, s, i) {
    const {
      startLoc: n
    } = this.state;
    if (this.isContextual(125)) {
      if (super.parseClassMemberFromModifier(t, s))
        return;
      s.declare = !0;
    }
    super.parseClassMember(t, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "PropertyDefinition" ? this.raise(de.DeclareClassElement, n) : s.value && this.raise(de.DeclareClassFieldInitializer, s.value));
  }
  isIterator(t) {
    return t === "iterator" || t === "asyncIterator";
  }
  readIterator() {
    const t = super.readWord1(), s = "@@" + t;
    (!this.isIterator(t) || !this.state.inType) && this.raise(O.InvalidIdentifier, this.state.curPosition(), {
      identifierName: s
    }), this.finishToken(132, s);
  }
  getTokenFromCode(t) {
    const s = this.input.charCodeAt(this.state.pos + 1);
    t === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (t === 62 || t === 60) ? this.finishOp(t === 62 ? 48 : 47, 1) : this.state.inType && t === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : LN(t, s, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(t);
  }
  isAssignable(t, s) {
    return t.type === "TypeCastExpression" ? this.isAssignable(t.expression, s) : super.isAssignable(t, s);
  }
  toAssignable(t, s = !1) {
    !s && t.type === "AssignmentExpression" && t.left.type === "TypeCastExpression" && (t.left = this.typeCastToParameter(t.left)), super.toAssignable(t, s);
  }
  toAssignableList(t, s, i) {
    for (let n = 0; n < t.length; n++) {
      const a = t[n];
      (a == null ? void 0 : a.type) === "TypeCastExpression" && (t[n] = this.typeCastToParameter(a));
    }
    super.toAssignableList(t, s, i);
  }
  toReferencedList(t, s) {
    for (let n = 0; n < t.length; n++) {
      var i;
      const a = t[n];
      a && a.type === "TypeCastExpression" && !((i = a.extra) != null && i.parenthesized) && (t.length > 1 || !s) && this.raise(de.TypeCastInPattern, a.typeAnnotation);
    }
    return t;
  }
  parseArrayLike(t, s, i, n) {
    const a = super.parseArrayLike(t, s, i, n);
    return s && !this.state.maybeInArrowParameters && this.toReferencedList(a.elements), a;
  }
  isValidLVal(t, s, i) {
    return t === "TypeCastExpression" || super.isValidLVal(t, s, i);
  }
  parseClassProperty(t) {
    return this.match(14) && (t.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(t);
  }
  parseClassPrivateProperty(t) {
    return this.match(14) && (t.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(t);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(14) || super.isClassProperty();
  }
  isNonstaticConstructor(t) {
    return !this.match(14) && super.isNonstaticConstructor(t);
  }
  pushClassMethod(t, s, i, n, a, o) {
    if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(t, s, i, n, a, o), s.params && a) {
      const u = s.params;
      u.length > 0 && this.isThisParam(u[0]) && this.raise(de.ThisParamBannedInConstructor, s);
    } else if (s.type === "MethodDefinition" && a && s.value.params) {
      const u = s.value.params;
      u.length > 0 && this.isThisParam(u[0]) && this.raise(de.ThisParamBannedInConstructor, s);
    }
  }
  pushClassPrivateMethod(t, s, i, n) {
    s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(t, s, i, n);
  }
  parseClassSuper(t) {
    if (super.parseClassSuper(t), t.superClass && this.match(47) && (t.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
      this.next();
      const s = t.implements = [];
      do {
        const i = this.startNode();
        i.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
      } while (this.eat(12));
    }
  }
  checkGetterSetterParams(t) {
    super.checkGetterSetterParams(t);
    const s = this.getObjectOrClassMethodParams(t);
    if (s.length > 0) {
      const i = s[0];
      this.isThisParam(i) && t.kind === "get" ? this.raise(de.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(de.SetterMayNotHaveThisParam, i);
    }
  }
  parsePropertyNamePrefixOperator(t) {
    t.variance = this.flowParseVariance();
  }
  parseObjPropValue(t, s, i, n, a, o, u) {
    t.variance && this.unexpected(t.variance.loc.start), delete t.variance;
    let l;
    this.match(47) && !o && (l = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
    const c = super.parseObjPropValue(t, s, i, n, a, o, u);
    return l && ((c.value || c).typeParameters = l), c;
  }
  parseAssignableListItemTypes(t) {
    return this.eat(17) && (t.type !== "Identifier" && this.raise(de.PatternIsOptional, t), this.isThisParam(t) && this.raise(de.ThisParamMayNotBeOptional, t), t.optional = !0), this.match(14) ? t.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(t) && this.raise(de.ThisParamAnnotationRequired, t), this.match(29) && this.isThisParam(t) && this.raise(de.ThisParamNoDefault, t), this.resetEndLocation(t), t;
  }
  parseMaybeDefault(t, s) {
    const i = super.parseMaybeDefault(t, s);
    return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(de.TypeBeforeInitializer, i.typeAnnotation), i;
  }
  checkImportReflection(t) {
    super.checkImportReflection(t), t.module && t.importKind !== "value" && this.raise(de.ImportReflectionHasImportType, t.specifiers[0].loc.start);
  }
  parseImportSpecifierLocal(t, s, i) {
    s.local = yy(t) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(s, i));
  }
  isPotentialImportPhase(t) {
    if (super.isPotentialImportPhase(t)) return !0;
    if (this.isContextual(130)) {
      if (!t) return !0;
      const s = this.lookaheadCharCode();
      return s === 123 || s === 42;
    }
    return !t && this.isContextual(87);
  }
  applyImportPhase(t, s, i, n) {
    if (super.applyImportPhase(t, s, i, n), s) {
      if (!i && this.match(65))
        return;
      t.exportKind = i === "type" ? i : "value";
    } else
      i === "type" && this.match(55) && this.unexpected(), t.importKind = i === "type" || i === "typeof" ? i : "value";
  }
  parseImportSpecifier(t, s, i, n, a) {
    const o = t.imported;
    let u = null;
    o.type === "Identifier" && (o.name === "type" ? u = "type" : o.name === "typeof" && (u = "typeof"));
    let l = !1;
    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
      const f = this.parseIdentifier(!0);
      u !== null && !Cr(this.state.type) ? (t.imported = f, t.importKind = u, t.local = Ss(f)) : (t.imported = o, t.importKind = null, t.local = this.parseIdentifier());
    } else {
      if (u !== null && Cr(this.state.type))
        t.imported = this.parseIdentifier(!0), t.importKind = u;
      else {
        if (s)
          throw this.raise(O.ImportBindingIsString, t, {
            importName: o.value
          });
        t.imported = o, t.importKind = null;
      }
      this.eatContextual(93) ? t.local = this.parseIdentifier() : (l = !0, t.local = Ss(t.imported));
    }
    const c = yy(t);
    return i && c && this.raise(de.ImportTypeShorthandOnlyInPureImport, t), (i || c) && this.checkReservedType(t.local.name, t.local.loc.start, !0), l && !i && !c && this.checkReservedWord(t.local.name, t.loc.start, !0, !0), this.finishImportSpecifier(t, "ImportSpecifier");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 78:
        return this.parseIdentifier(!0);
      default:
        return super.parseBindingAtom();
    }
  }
  parseFunctionParams(t, s) {
    const i = t.kind;
    i !== "get" && i !== "set" && this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(t, s);
  }
  parseVarId(t, s) {
    super.parseVarId(t, s), this.match(14) && (t.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t.id));
  }
  parseAsyncArrowFromCallExpression(t, s) {
    if (this.match(14)) {
      const i = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = !0, t.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
    }
    return super.parseAsyncArrowFromCallExpression(t, s);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  parseMaybeAssign(t, s) {
    var i;
    let n = null, a;
    if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
      if (n = this.state.clone(), a = this.tryParse(() => super.parseMaybeAssign(t, s), n), !a.error) return a.node;
      const {
        context: l
      } = this.state, c = l[l.length - 1];
      (c === Ue.j_oTag || c === Ue.j_expr) && l.pop();
    }
    if ((i = a) != null && i.error || this.match(47)) {
      var o, u;
      n = n || this.state.clone();
      let l;
      const c = this.tryParse((p) => {
        var h;
        l = this.flowParseTypeParameterDeclaration();
        const m = this.forwardNoArrowParamsConversionAt(l, () => {
          const y = super.parseMaybeAssign(t, s);
          return this.resetStartLocationFromNode(y, l), y;
        });
        (h = m.extra) != null && h.parenthesized && p();
        const d = this.maybeUnwrapTypeCastExpression(m);
        return d.type !== "ArrowFunctionExpression" && p(), d.typeParameters = l, this.resetStartLocationFromNode(d, l), m;
      }, n);
      let f = null;
      if (c.node && this.maybeUnwrapTypeCastExpression(c.node).type === "ArrowFunctionExpression") {
        if (!c.error && !c.aborted)
          return c.node.async && this.raise(de.UnexpectedTypeParameterBeforeAsyncArrowFunction, l), c.node;
        f = c.node;
      }
      if ((o = a) != null && o.node)
        return this.state = a.failState, a.node;
      if (f)
        return this.state = c.failState, f;
      throw (u = a) != null && u.thrown ? a.error : c.thrown ? c.error : this.raise(de.UnexpectedTokenAfterTypeParameter, l);
    }
    return super.parseMaybeAssign(t, s);
  }
  parseArrow(t) {
    if (this.match(14)) {
      const s = this.tryParse(() => {
        const i = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0;
        const n = this.startNode();
        return [n.typeAnnotation, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), n;
      });
      if (s.thrown) return null;
      s.error && (this.state = s.failState), t.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
    }
    return super.parseArrow(t);
  }
  shouldParseArrow(t) {
    return this.match(14) || super.shouldParseArrow(t);
  }
  setArrowFunctionParameters(t, s) {
    this.state.noArrowParamsConversionAt.indexOf(t.start) !== -1 ? t.params = s : super.setArrowFunctionParameters(t, s);
  }
  checkParams(t, s, i, n = !0) {
    if (!(i && this.state.noArrowParamsConversionAt.indexOf(t.start) !== -1)) {
      for (let a = 0; a < t.params.length; a++)
        this.isThisParam(t.params[a]) && a > 0 && this.raise(de.ThisParamMustBeFirst, t.params[a]);
      super.checkParams(t, s, i, n);
    }
  }
  parseParenAndDistinguishExpression(t) {
    return super.parseParenAndDistinguishExpression(t && this.state.noArrowAt.indexOf(this.state.start) === -1);
  }
  parseSubscripts(t, s, i) {
    if (t.type === "Identifier" && t.name === "async" && this.state.noArrowAt.indexOf(s.index) !== -1) {
      this.next();
      const n = this.startNodeAt(s);
      n.callee = t, n.arguments = super.parseCallExpressionArguments(11, !1), t = this.finishNode(n, "CallExpression");
    } else if (t.type === "Identifier" && t.name === "async" && this.match(47)) {
      const n = this.state.clone(), a = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s) || u(), n);
      if (!a.error && !a.aborted) return a.node;
      const o = this.tryParse(() => super.parseSubscripts(t, s, i), n);
      if (o.node && !o.error) return o.node;
      if (a.node)
        return this.state = a.failState, a.node;
      if (o.node)
        return this.state = o.failState, o.node;
      throw a.error || o.error;
    }
    return super.parseSubscripts(t, s, i);
  }
  parseSubscript(t, s, i, n) {
    if (this.match(18) && this.isLookaheadToken_lt()) {
      if (n.optionalChainMember = !0, i)
        return n.stop = !0, t;
      this.next();
      const a = this.startNodeAt(s);
      return a.callee = t, a.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), a.arguments = this.parseCallExpressionArguments(11, !1), a.optional = !0, this.finishCallExpression(a, !0);
    } else if (!i && this.shouldParseTypes() && this.match(47)) {
      const a = this.startNodeAt(s);
      a.callee = t;
      const o = this.tryParse(() => (a.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), a.arguments = super.parseCallExpressionArguments(11, !1), n.optionalChainMember && (a.optional = !1), this.finishCallExpression(a, n.optionalChainMember)));
      if (o.node)
        return o.error && (this.state = o.failState), o.node;
    }
    return super.parseSubscript(t, s, i, n);
  }
  parseNewCallee(t) {
    super.parseNewCallee(t);
    let s = null;
    this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), t.typeArguments = s;
  }
  parseAsyncArrowWithTypeParameters(t) {
    const s = this.startNodeAt(t);
    if (this.parseFunctionParams(s, !1), !!this.parseArrow(s))
      return super.parseArrowExpression(s, void 0, !0);
  }
  readToken_mult_modulo(t) {
    const s = this.input.charCodeAt(this.state.pos + 1);
    if (t === 42 && s === 47 && this.state.hasFlowComment) {
      this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
      return;
    }
    super.readToken_mult_modulo(t);
  }
  readToken_pipe_amp(t) {
    const s = this.input.charCodeAt(this.state.pos + 1);
    if (t === 124 && s === 125) {
      this.finishOp(9, 2);
      return;
    }
    super.readToken_pipe_amp(t);
  }
  parseTopLevel(t, s) {
    const i = super.parseTopLevel(t, s);
    return this.state.hasFlowComment && this.raise(de.UnterminatedFlowComment, this.state.curPosition()), i;
  }
  skipBlockComment() {
    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
      if (this.state.hasFlowComment)
        throw this.raise(de.NestedFlowComment, this.state.startLoc);
      this.hasFlowCommentCompletion();
      const t = this.skipFlowComment();
      t && (this.state.pos += t, this.state.hasFlowComment = !0);
      return;
    }
    return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
  }
  skipFlowComment() {
    const {
      pos: t
    } = this.state;
    let s = 2;
    for (; [32, 9].includes(this.input.charCodeAt(t + s)); )
      s++;
    const i = this.input.charCodeAt(s + t), n = this.input.charCodeAt(s + t + 1);
    return i === 58 && n === 58 ? s + 2 : this.input.slice(s + t, s + t + 12) === "flow-include" ? s + 12 : i === 58 && n !== 58 ? s : !1;
  }
  hasFlowCommentCompletion() {
    if (this.input.indexOf("*/", this.state.pos) === -1)
      throw this.raise(O.UnterminatedComment, this.state.curPosition());
  }
  flowEnumErrorBooleanMemberNotInitialized(t, {
    enumName: s,
    memberName: i
  }) {
    this.raise(de.EnumBooleanMemberNotInitialized, t, {
      memberName: i,
      enumName: s
    });
  }
  flowEnumErrorInvalidMemberInitializer(t, s) {
    return this.raise(s.explicitType ? s.explicitType === "symbol" ? de.EnumInvalidMemberInitializerSymbolType : de.EnumInvalidMemberInitializerPrimaryType : de.EnumInvalidMemberInitializerUnknownType, t, s);
  }
  flowEnumErrorNumberMemberNotInitialized(t, s) {
    this.raise(de.EnumNumberMemberNotInitialized, t, s);
  }
  flowEnumErrorStringMemberInconsistentlyInitialized(t, s) {
    this.raise(de.EnumStringMemberInconsistentlyInitialized, t, s);
  }
  flowEnumMemberInit() {
    const t = this.state.startLoc, s = () => this.match(12) || this.match(8);
    switch (this.state.type) {
      case 134: {
        const i = this.parseNumericLiteral(this.state.value);
        return s() ? {
          type: "number",
          loc: i.loc.start,
          value: i
        } : {
          type: "invalid",
          loc: t
        };
      }
      case 133: {
        const i = this.parseStringLiteral(this.state.value);
        return s() ? {
          type: "string",
          loc: i.loc.start,
          value: i
        } : {
          type: "invalid",
          loc: t
        };
      }
      case 85:
      case 86: {
        const i = this.parseBooleanLiteral(this.match(85));
        return s() ? {
          type: "boolean",
          loc: i.loc.start,
          value: i
        } : {
          type: "invalid",
          loc: t
        };
      }
      default:
        return {
          type: "invalid",
          loc: t
        };
    }
  }
  flowEnumMemberRaw() {
    const t = this.state.startLoc, s = this.parseIdentifier(!0), i = this.eat(29) ? this.flowEnumMemberInit() : {
      type: "none",
      loc: t
    };
    return {
      id: s,
      init: i
    };
  }
  flowEnumCheckExplicitTypeMismatch(t, s, i) {
    const {
      explicitType: n
    } = s;
    n !== null && n !== i && this.flowEnumErrorInvalidMemberInitializer(t, s);
  }
  flowEnumMembers({
    enumName: t,
    explicitType: s
  }) {
    const i = /* @__PURE__ */ new Set(), n = {
      booleanMembers: [],
      numberMembers: [],
      stringMembers: [],
      defaultedMembers: []
    };
    let a = !1;
    for (; !this.match(8); ) {
      if (this.eat(21)) {
        a = !0;
        break;
      }
      const o = this.startNode(), {
        id: u,
        init: l
      } = this.flowEnumMemberRaw(), c = u.name;
      if (c === "")
        continue;
      /^[a-z]/.test(c) && this.raise(de.EnumInvalidMemberName, u, {
        memberName: c,
        suggestion: c[0].toUpperCase() + c.slice(1),
        enumName: t
      }), i.has(c) && this.raise(de.EnumDuplicateMemberName, u, {
        memberName: c,
        enumName: t
      }), i.add(c);
      const f = {
        enumName: t,
        explicitType: s,
        memberName: c
      };
      switch (o.id = u, l.type) {
        case "boolean": {
          this.flowEnumCheckExplicitTypeMismatch(l.loc, f, "boolean"), o.init = l.value, n.booleanMembers.push(this.finishNode(o, "EnumBooleanMember"));
          break;
        }
        case "number": {
          this.flowEnumCheckExplicitTypeMismatch(l.loc, f, "number"), o.init = l.value, n.numberMembers.push(this.finishNode(o, "EnumNumberMember"));
          break;
        }
        case "string": {
          this.flowEnumCheckExplicitTypeMismatch(l.loc, f, "string"), o.init = l.value, n.stringMembers.push(this.finishNode(o, "EnumStringMember"));
          break;
        }
        case "invalid":
          throw this.flowEnumErrorInvalidMemberInitializer(l.loc, f);
        case "none":
          switch (s) {
            case "boolean":
              this.flowEnumErrorBooleanMemberNotInitialized(l.loc, f);
              break;
            case "number":
              this.flowEnumErrorNumberMemberNotInitialized(l.loc, f);
              break;
            default:
              n.defaultedMembers.push(this.finishNode(o, "EnumDefaultedMember"));
          }
      }
      this.match(8) || this.expect(12);
    }
    return {
      members: n,
      hasUnknownMembers: a
    };
  }
  flowEnumStringMembers(t, s, {
    enumName: i
  }) {
    if (t.length === 0)
      return s;
    if (s.length === 0)
      return t;
    if (s.length > t.length) {
      for (const n of t)
        this.flowEnumErrorStringMemberInconsistentlyInitialized(n, {
          enumName: i
        });
      return s;
    } else {
      for (const n of s)
        this.flowEnumErrorStringMemberInconsistentlyInitialized(n, {
          enumName: i
        });
      return t;
    }
  }
  flowEnumParseExplicitType({
    enumName: t
  }) {
    if (!this.eatContextual(102)) return null;
    if (!Le(this.state.type))
      throw this.raise(de.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
        enumName: t
      });
    const {
      value: s
    } = this.state;
    return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(de.EnumInvalidExplicitType, this.state.startLoc, {
      enumName: t,
      invalidEnumType: s
    }), s;
  }
  flowEnumBody(t, s) {
    const i = s.name, n = s.loc.start, a = this.flowEnumParseExplicitType({
      enumName: i
    });
    this.expect(5);
    const {
      members: o,
      hasUnknownMembers: u
    } = this.flowEnumMembers({
      enumName: i,
      explicitType: a
    });
    switch (t.hasUnknownMembers = u, a) {
      case "boolean":
        return t.explicitType = !0, t.members = o.booleanMembers, this.expect(8), this.finishNode(t, "EnumBooleanBody");
      case "number":
        return t.explicitType = !0, t.members = o.numberMembers, this.expect(8), this.finishNode(t, "EnumNumberBody");
      case "string":
        return t.explicitType = !0, t.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, {
          enumName: i
        }), this.expect(8), this.finishNode(t, "EnumStringBody");
      case "symbol":
        return t.members = o.defaultedMembers, this.expect(8), this.finishNode(t, "EnumSymbolBody");
      default: {
        const l = () => (t.members = [], this.expect(8), this.finishNode(t, "EnumStringBody"));
        t.explicitType = !1;
        const c = o.booleanMembers.length, f = o.numberMembers.length, p = o.stringMembers.length, h = o.defaultedMembers.length;
        if (!c && !f && !p && !h)
          return l();
        if (!c && !f)
          return t.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, {
            enumName: i
          }), this.expect(8), this.finishNode(t, "EnumStringBody");
        if (!f && !p && c >= h) {
          for (const m of o.defaultedMembers)
            this.flowEnumErrorBooleanMemberNotInitialized(m.loc.start, {
              enumName: i,
              memberName: m.id.name
            });
          return t.members = o.booleanMembers, this.expect(8), this.finishNode(t, "EnumBooleanBody");
        } else if (!c && !p && f >= h) {
          for (const m of o.defaultedMembers)
            this.flowEnumErrorNumberMemberNotInitialized(m.loc.start, {
              enumName: i,
              memberName: m.id.name
            });
          return t.members = o.numberMembers, this.expect(8), this.finishNode(t, "EnumNumberBody");
        } else
          return this.raise(de.EnumInconsistentMemberValues, n, {
            enumName: i
          }), l();
      }
    }
  }
  flowParseEnumDeclaration(t) {
    const s = this.parseIdentifier();
    return t.id = s, t.body = this.flowEnumBody(this.startNode(), s), this.finishNode(t, "EnumDeclaration");
  }
  isLookaheadToken_lt() {
    const t = this.nextTokenStart();
    if (this.input.charCodeAt(t) === 60) {
      const s = this.input.charCodeAt(t + 1);
      return s !== 60 && s !== 61;
    }
    return !1;
  }
  maybeUnwrapTypeCastExpression(t) {
    return t.type === "TypeCastExpression" ? t.expression : t;
  }
};
const fO = {
  __proto__: null,
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  fnof: "",
  circ: "",
  tilde: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  bull: "",
  hellip: "",
  permil: "",
  prime: "",
  Prime: "",
  lsaquo: "",
  rsaquo: "",
  oline: "",
  frasl: "",
  euro: "",
  image: "",
  weierp: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: ""
}, bi = gs`jsx`({
  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
  MissingClosingTagElement: ({
    openingTagName: r
  }) => `Expected corresponding JSX closing tag for <${r}>.`,
  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
  UnexpectedToken: ({
    unexpected: r,
    HTMLEntity: e
  }) => `Unexpected token \`${r}\`. Did you mean \`${e}\` or \`{'${r}'}\`?`,
  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
  UnterminatedJsxContent: "Unterminated JSX contents.",
  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
});
function Fs(r) {
  return r ? r.type === "JSXOpeningFragment" || r.type === "JSXClosingFragment" : !1;
}
function hn(r) {
  if (r.type === "JSXIdentifier")
    return r.name;
  if (r.type === "JSXNamespacedName")
    return r.namespace.name + ":" + r.name.name;
  if (r.type === "JSXMemberExpression")
    return hn(r.object) + "." + hn(r.property);
  throw new Error("Node had unexpected type: " + r.type);
}
var pO = (r) => class extends r {
  jsxReadToken() {
    let t = "", s = this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(bi.UnterminatedJsxContent, this.state.startLoc);
      const i = this.input.charCodeAt(this.state.pos);
      switch (i) {
        case 60:
        case 123:
          if (this.state.pos === this.state.start) {
            i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i);
            return;
          }
          t += this.input.slice(s, this.state.pos), this.finishToken(141, t);
          return;
        case 38:
          t += this.input.slice(s, this.state.pos), t += this.jsxReadEntity(), s = this.state.pos;
          break;
        case 62:
        case 125:
        default:
          qa(i) ? (t += this.input.slice(s, this.state.pos), t += this.jsxReadNewLine(!0), s = this.state.pos) : ++this.state.pos;
      }
    }
  }
  jsxReadNewLine(t) {
    const s = this.input.charCodeAt(this.state.pos);
    let i;
    return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = t ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
  }
  jsxReadString(t) {
    let s = "", i = ++this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(O.UnterminatedString, this.state.startLoc);
      const n = this.input.charCodeAt(this.state.pos);
      if (n === t) break;
      n === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : qa(n) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(!1), i = this.state.pos) : ++this.state.pos;
    }
    s += this.input.slice(i, this.state.pos++), this.finishToken(133, s);
  }
  jsxReadEntity() {
    const t = ++this.state.pos;
    if (this.codePointAtPos(this.state.pos) === 35) {
      ++this.state.pos;
      let s = 10;
      this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
      const i = this.readInt(s, void 0, !1, "bail");
      if (i !== null && this.codePointAtPos(this.state.pos) === 59)
        return ++this.state.pos, String.fromCodePoint(i);
    } else {
      let s = 0, i = !1;
      for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) === 59); )
        ++this.state.pos;
      if (i) {
        const n = this.input.slice(t, this.state.pos), a = fO[n];
        if (++this.state.pos, a)
          return a;
      }
    }
    return this.state.pos = t, "&";
  }
  jsxReadWord() {
    let t;
    const s = this.state.pos;
    do
      t = this.input.charCodeAt(++this.state.pos);
    while (Sn(t) || t === 45);
    this.finishToken(140, this.input.slice(s, this.state.pos));
  }
  jsxParseIdentifier() {
    const t = this.startNode();
    return this.match(140) ? t.name = this.state.value : um(this.state.type) ? t.name = si(this.state.type) : this.unexpected(), this.next(), this.finishNode(t, "JSXIdentifier");
  }
  jsxParseNamespacedName() {
    const t = this.state.startLoc, s = this.jsxParseIdentifier();
    if (!this.eat(14)) return s;
    const i = this.startNodeAt(t);
    return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
  }
  jsxParseElementName() {
    const t = this.state.startLoc;
    let s = this.jsxParseNamespacedName();
    if (s.type === "JSXNamespacedName")
      return s;
    for (; this.eat(16); ) {
      const i = this.startNodeAt(t);
      i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
    }
    return s;
  }
  jsxParseAttributeValue() {
    let t;
    switch (this.state.type) {
      case 5:
        return t = this.startNode(), this.setContext(Ue.brace), this.next(), t = this.jsxParseExpressionContainer(t, Ue.j_oTag), t.expression.type === "JSXEmptyExpression" && this.raise(bi.AttributeIsEmpty, t), t;
      case 142:
      case 133:
        return this.parseExprAtom();
      default:
        throw this.raise(bi.UnsupportedJsxValue, this.state.startLoc);
    }
  }
  jsxParseEmptyExpression() {
    const t = this.startNodeAt(this.state.lastTokEndLoc);
    return this.finishNodeAt(t, "JSXEmptyExpression", this.state.startLoc);
  }
  jsxParseSpreadChild(t) {
    return this.next(), t.expression = this.parseExpression(), this.setContext(Ue.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(t, "JSXSpreadChild");
  }
  jsxParseExpressionContainer(t, s) {
    if (this.match(8))
      t.expression = this.jsxParseEmptyExpression();
    else {
      const i = this.parseExpression();
      t.expression = i;
    }
    return this.setContext(s), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(t, "JSXExpressionContainer");
  }
  jsxParseAttribute() {
    const t = this.startNode();
    return this.match(5) ? (this.setContext(Ue.brace), this.next(), this.expect(21), t.argument = this.parseMaybeAssignAllowIn(), this.setContext(Ue.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(t, "JSXSpreadAttribute")) : (t.name = this.jsxParseNamespacedName(), t.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(t, "JSXAttribute"));
  }
  jsxParseOpeningElementAt(t) {
    const s = this.startNodeAt(t);
    return this.eat(143) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s));
  }
  jsxParseOpeningElementAfterName(t) {
    const s = [];
    for (; !this.match(56) && !this.match(143); )
      s.push(this.jsxParseAttribute());
    return t.attributes = s, t.selfClosing = this.eat(56), this.expect(143), this.finishNode(t, "JSXOpeningElement");
  }
  jsxParseClosingElementAt(t) {
    const s = this.startNodeAt(t);
    return this.eat(143) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(143), this.finishNode(s, "JSXClosingElement"));
  }
  jsxParseElementAt(t) {
    const s = this.startNodeAt(t), i = [], n = this.jsxParseOpeningElementAt(t);
    let a = null;
    if (!n.selfClosing) {
      e: for (; ; )
        switch (this.state.type) {
          case 142:
            if (t = this.state.startLoc, this.next(), this.eat(56)) {
              a = this.jsxParseClosingElementAt(t);
              break e;
            }
            i.push(this.jsxParseElementAt(t));
            break;
          case 141:
            i.push(this.parseLiteral(this.state.value, "JSXText"));
            break;
          case 5: {
            const o = this.startNode();
            this.setContext(Ue.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(o)) : i.push(this.jsxParseExpressionContainer(o, Ue.j_expr));
            break;
          }
          default:
            this.unexpected();
        }
      Fs(n) && !Fs(a) && a !== null ? this.raise(bi.MissingClosingTagFragment, a) : !Fs(n) && Fs(a) ? this.raise(bi.MissingClosingTagElement, a, {
        openingTagName: hn(n.name)
      }) : !Fs(n) && !Fs(a) && hn(a.name) !== hn(n.name) && this.raise(bi.MissingClosingTagElement, a, {
        openingTagName: hn(n.name)
      });
    }
    if (Fs(n) ? (s.openingFragment = n, s.closingFragment = a) : (s.openingElement = n, s.closingElement = a), s.children = i, this.match(47))
      throw this.raise(bi.UnwrappedAdjacentJSXElements, this.state.startLoc);
    return Fs(n) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
  }
  jsxParseElement() {
    const t = this.state.startLoc;
    return this.next(), this.jsxParseElementAt(t);
  }
  setContext(t) {
    const {
      context: s
    } = this.state;
    s[s.length - 1] = t;
  }
  parseExprAtom(t) {
    return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(t);
  }
  skipSpace() {
    this.curContext().preserveSpace || super.skipSpace();
  }
  getTokenFromCode(t) {
    const s = this.curContext();
    if (s === Ue.j_expr) {
      this.jsxReadToken();
      return;
    }
    if (s === Ue.j_oTag || s === Ue.j_cTag) {
      if (ms(t)) {
        this.jsxReadWord();
        return;
      }
      if (t === 62) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      if ((t === 34 || t === 39) && s === Ue.j_oTag) {
        this.jsxReadString(t);
        return;
      }
    }
    if (t === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
      ++this.state.pos, this.finishToken(142);
      return;
    }
    super.getTokenFromCode(t);
  }
  updateContext(t) {
    const {
      context: s,
      type: i
    } = this.state;
    if (i === 56 && t === 142)
      s.splice(-2, 2, Ue.j_cTag), this.state.canStartJSXElement = !1;
    else if (i === 142)
      s.push(Ue.j_oTag);
    else if (i === 143) {
      const n = s[s.length - 1];
      n === Ue.j_oTag && t === 56 || n === Ue.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === Ue.j_expr) : (this.setContext(Ue.j_expr), this.state.canStartJSXElement = !0);
    } else
      this.state.canStartJSXElement = bN(i);
  }
};
class hO extends fm {
  constructor(...e) {
    super(...e), this.tsNames = /* @__PURE__ */ new Map();
  }
}
class dO extends pm {
  constructor(...e) {
    super(...e), this.importsStack = [];
  }
  createScope(e) {
    return this.importsStack.push(/* @__PURE__ */ new Set()), new hO(e);
  }
  enter(e) {
    e === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
  }
  exit() {
    const e = super.exit();
    return e === 256 && this.importsStack.pop(), e;
  }
  hasImport(e, t) {
    const s = this.importsStack.length;
    if (this.importsStack[s - 1].has(e))
      return !0;
    if (!t && s > 1) {
      for (let i = 0; i < s - 1; i++)
        if (this.importsStack[i].has(e)) return !0;
    }
    return !1;
  }
  declareName(e, t, s) {
    if (t & 4096) {
      this.hasImport(e, !0) && this.parser.raise(O.VarRedeclaration, s, {
        identifierName: e
      }), this.importsStack[this.importsStack.length - 1].add(e);
      return;
    }
    const i = this.currentScope();
    let n = i.tsNames.get(e) || 0;
    if (t & 1024) {
      this.maybeExportDefined(i, e), i.tsNames.set(e, n | 16);
      return;
    }
    super.declareName(e, t, s), t & 2 && (t & 1 || (this.checkRedeclarationInScope(i, e, t, s), this.maybeExportDefined(i, e)), n = n | 1), t & 256 && (n = n | 2), t & 512 && (n = n | 4), t & 128 && (n = n | 8), n && i.tsNames.set(e, n);
  }
  isRedeclaredInScope(e, t, s) {
    const i = e.tsNames.get(t);
    if ((i & 2) > 0) {
      if (s & 256) {
        const n = !!(s & 512), a = (i & 4) > 0;
        return n !== a;
      }
      return !0;
    }
    return s & 128 && (i & 8) > 0 ? e.names.get(t) & 2 ? !!(s & 1) : !1 : s & 2 && (i & 1) > 0 ? !0 : super.isRedeclaredInScope(e, t, s);
  }
  checkLocalExport(e) {
    const {
      name: t
    } = e;
    if (this.hasImport(t)) return;
    const s = this.scopeStack.length;
    for (let i = s - 1; i >= 0; i--) {
      const a = this.scopeStack[i].tsNames.get(t);
      if ((a & 1) > 0 || (a & 16) > 0)
        return;
    }
    super.checkLocalExport(e);
  }
}
const mO = (r, e) => hasOwnProperty.call(r, e) && r[e], gS = (r) => r.type === "ParenthesizedExpression" ? gS(r.expression) : r;
class gO extends iO {
  toAssignable(e, t = !1) {
    var s, i;
    let n;
    switch ((e.type === "ParenthesizedExpression" || (s = e.extra) != null && s.parenthesized) && (n = gS(e), t ? n.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(O.InvalidParenthesizedAssignment, e) : n.type !== "MemberExpression" && !this.isOptionalMemberExpression(n) && this.raise(O.InvalidParenthesizedAssignment, e) : this.raise(O.InvalidParenthesizedAssignment, e)), e.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e.type = "ObjectPattern";
        for (let o = 0, u = e.properties.length, l = u - 1; o < u; o++) {
          var a;
          const c = e.properties[o], f = o === l;
          this.toAssignableObjectExpressionProp(c, f, t), f && c.type === "RestElement" && (a = e.extra) != null && a.trailingCommaLoc && this.raise(O.RestTrailingComma, e.extra.trailingCommaLoc);
        }
        break;
      case "ObjectProperty": {
        const {
          key: o,
          value: u
        } = e;
        this.isPrivateName(o) && this.classScope.usePrivateName(this.getPrivateNameSV(o), o.loc.start), this.toAssignable(u, t);
        break;
      }
      case "SpreadElement":
        throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
      case "ArrayExpression":
        e.type = "ArrayPattern", this.toAssignableList(e.elements, (i = e.extra) == null ? void 0 : i.trailingCommaLoc, t);
        break;
      case "AssignmentExpression":
        e.operator !== "=" && this.raise(O.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(n, t);
        break;
    }
  }
  toAssignableObjectExpressionProp(e, t, s) {
    if (e.type === "ObjectMethod")
      this.raise(e.kind === "get" || e.kind === "set" ? O.PatternHasAccessor : O.PatternHasMethod, e.key);
    else if (e.type === "SpreadElement") {
      e.type = "RestElement";
      const i = e.argument;
      this.checkToRestConversion(i, !1), this.toAssignable(i, s), t || this.raise(O.RestTrailingComma, e);
    } else
      this.toAssignable(e, s);
  }
  toAssignableList(e, t, s) {
    const i = e.length - 1;
    for (let n = 0; n <= i; n++) {
      const a = e[n];
      if (a) {
        if (a.type === "SpreadElement") {
          a.type = "RestElement";
          const o = a.argument;
          this.checkToRestConversion(o, !0), this.toAssignable(o, s);
        } else
          this.toAssignable(a, s);
        a.type === "RestElement" && (n < i ? this.raise(O.RestTrailingComma, a) : t && this.raise(O.RestTrailingComma, t));
      }
    }
  }
  isAssignable(e, t) {
    switch (e.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        return !0;
      case "ObjectExpression": {
        const s = e.properties.length - 1;
        return e.properties.every((i, n) => i.type !== "ObjectMethod" && (n === s || i.type !== "SpreadElement") && this.isAssignable(i));
      }
      case "ObjectProperty":
        return this.isAssignable(e.value);
      case "SpreadElement":
        return this.isAssignable(e.argument);
      case "ArrayExpression":
        return e.elements.every((s) => s === null || this.isAssignable(s));
      case "AssignmentExpression":
        return e.operator === "=";
      case "ParenthesizedExpression":
        return this.isAssignable(e.expression);
      case "MemberExpression":
      case "OptionalMemberExpression":
        return !t;
      default:
        return !1;
    }
  }
  toReferencedList(e, t) {
    return e;
  }
  toReferencedListDeep(e, t) {
    this.toReferencedList(e, t);
    for (const s of e)
      (s == null ? void 0 : s.type) === "ArrayExpression" && this.toReferencedListDeep(s.elements);
  }
  parseSpread(e) {
    const t = this.startNode();
    return this.next(), t.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(t, "SpreadElement");
  }
  parseRestBinding() {
    const e = this.startNode();
    return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 0: {
        const e = this.startNode();
        return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
      }
      case 5:
        return this.parseObjectLike(8, !0);
    }
    return this.parseIdentifier();
  }
  parseBindingList(e, t, s) {
    const i = s & 1, n = [];
    let a = !0;
    for (; !this.eat(e); )
      if (a ? a = !1 : this.expect(12), i && this.match(12))
        n.push(null);
      else {
        if (this.eat(e))
          break;
        if (this.match(21)) {
          if (n.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s)), !this.checkCommaAfterRest(t)) {
            this.expect(e);
            break;
          }
        } else {
          const o = [];
          for (this.match(26) && this.hasPlugin("decorators") && this.raise(O.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
            o.push(this.parseDecorator());
          n.push(this.parseAssignableListItem(s, o));
        }
      }
    return n;
  }
  parseBindingRestProperty(e) {
    return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
  }
  parseBindingProperty() {
    const {
      type: e,
      startLoc: t
    } = this.state;
    if (e === 21)
      return this.parseBindingRestProperty(this.startNode());
    const s = this.startNode();
    return e === 138 ? (this.expectPlugin("destructuringPrivate", t), this.classScope.usePrivateName(this.state.value, t), s.key = this.parsePrivateName()) : this.parsePropertyName(s), s.method = !1, this.parseObjPropValue(s, t, !1, !1, !0, !1);
  }
  parseAssignableListItem(e, t) {
    const s = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(s, e);
    const i = this.parseMaybeDefault(s.loc.start, s);
    return t.length && (s.decorators = t), i;
  }
  parseAssignableListItemTypes(e, t) {
    return e;
  }
  parseMaybeDefault(e, t) {
    var s, i;
    if ((s = e) != null || (e = this.state.startLoc), t = (i = t) != null ? i : this.parseBindingAtom(), !this.eat(29)) return t;
    const n = this.startNodeAt(e);
    return n.left = t, n.right = this.parseMaybeAssignAllowIn(), this.finishNode(n, "AssignmentPattern");
  }
  isValidLVal(e, t, s) {
    return mO({
      AssignmentPattern: "left",
      RestElement: "argument",
      ObjectProperty: "value",
      ParenthesizedExpression: "expression",
      ArrayPattern: "elements",
      ObjectPattern: "properties"
    }, e);
  }
  isOptionalMemberExpression(e) {
    return e.type === "OptionalMemberExpression";
  }
  checkLVal(e, {
    in: t,
    binding: s = 64,
    checkClashes: i = !1,
    strictModeChanged: n = !1,
    hasParenthesizedAncestor: a = !1
  }) {
    var o;
    const u = e.type;
    if (this.isObjectMethod(e)) return;
    const l = this.isOptionalMemberExpression(e);
    if (l || u === "MemberExpression") {
      l && (this.expectPlugin("optionalChainingAssign", e.loc.start), t.type !== "AssignmentExpression" && this.raise(O.InvalidLhsOptionalChaining, e, {
        ancestor: t
      })), s !== 64 && this.raise(O.InvalidPropertyBindingPattern, e);
      return;
    }
    if (u === "Identifier") {
      this.checkIdentifier(e, s, n);
      const {
        name: m
      } = e;
      i && (i.has(m) ? this.raise(O.ParamDupe, e) : i.add(m));
      return;
    }
    const c = this.isValidLVal(u, !(a || (o = e.extra) != null && o.parenthesized) && t.type === "AssignmentExpression", s);
    if (c === !0) return;
    if (c === !1) {
      const m = s === 64 ? O.InvalidLhs : O.InvalidLhsBinding;
      this.raise(m, e, {
        ancestor: t
      });
      return;
    }
    const [f, p] = Array.isArray(c) ? c : [c, u === "ParenthesizedExpression"], h = u === "ArrayPattern" || u === "ObjectPattern" ? {
      type: u
    } : t;
    for (const m of [].concat(e[f]))
      m && this.checkLVal(m, {
        in: h,
        binding: s,
        checkClashes: i,
        strictModeChanged: n,
        hasParenthesizedAncestor: p
      });
  }
  checkIdentifier(e, t, s = !1) {
    this.state.strict && (s ? lS(e.name, this.inModule) : uS(e.name)) && (t === 64 ? this.raise(O.StrictEvalArguments, e, {
      referenceName: e.name
    }) : this.raise(O.StrictEvalArgumentsBinding, e, {
      bindingName: e.name
    })), t & 8192 && e.name === "let" && this.raise(O.LetInLexicalBinding, e), t & 64 || this.declareNameFromIdentifier(e, t);
  }
  declareNameFromIdentifier(e, t) {
    this.scope.declareName(e.name, t, e.loc.start);
  }
  checkToRestConversion(e, t) {
    switch (e.type) {
      case "ParenthesizedExpression":
        this.checkToRestConversion(e.expression, t);
        break;
      case "Identifier":
      case "MemberExpression":
        break;
      case "ArrayExpression":
      case "ObjectExpression":
        if (t) break;
      default:
        this.raise(O.InvalidRestAssignmentPattern, e);
    }
  }
  checkCommaAfterRest(e) {
    return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? O.RestTrailingComma : O.ElementAfterRest, this.state.startLoc), !0) : !1;
  }
}
const yO = (r, e) => hasOwnProperty.call(r, e) && r[e];
function bO(r) {
  if (r == null)
    throw new Error(`Unexpected ${r} value.`);
  return r;
}
function by(r) {
  if (!r)
    throw new Error("Assert fail");
}
const oe = gs`typescript`({
  AbstractMethodHasImplementation: ({
    methodName: r
  }) => `Method '${r}' cannot have an implementation because it is marked abstract.`,
  AbstractPropertyHasInitializer: ({
    propertyName: r
  }) => `Property '${r}' cannot have an initializer because it is marked abstract.`,
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: ({
    kind: r
  }) => `'declare' is not allowed in ${r}ters.`,
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: ({
    modifier: r
  }) => "Accessibility modifier already seen.",
  DuplicateModifier: ({
    modifier: r
  }) => `Duplicate modifier: '${r}'.`,
  EmptyHeritageClauseType: ({
    token: r
  }) => `'${r}' list cannot be empty.`,
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
  IncompatibleModifiers: ({
    modifiers: r
  }) => `'${r[0]}' modifier cannot be used with '${r[1]}' modifier.`,
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: ({
    modifier: r
  }) => `Index signatures cannot have an accessibility modifier ('${r}').`,
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
  InvalidModifierOnTypeMember: ({
    modifier: r
  }) => `'${r}' modifier cannot appear on a type member.`,
  InvalidModifierOnTypeParameter: ({
    modifier: r
  }) => `'${r}' modifier cannot appear on a type parameter.`,
  InvalidModifierOnTypeParameterPositions: ({
    modifier: r
  }) => `'${r}' modifier can only appear on a type parameter of a class, interface or type alias.`,
  InvalidModifiersOrder: ({
    orderedModifiers: r
  }) => `'${r[0]}' modifier must precede '${r[1]}' modifier.`,
  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: ({
    modifier: r
  }) => `Private elements cannot have an accessibility modifier ('${r}').`,
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  SingleTypeParameterWithoutTrailingComma: ({
    typeParameterName: r
  }) => `Single type parameter ${r} should have a trailing comma. Example usage: <${r},>.`,
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: ({
    type: r
  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${r}.`
});
function vO(r) {
  switch (r) {
    case "any":
      return "TSAnyKeyword";
    case "boolean":
      return "TSBooleanKeyword";
    case "bigint":
      return "TSBigIntKeyword";
    case "never":
      return "TSNeverKeyword";
    case "number":
      return "TSNumberKeyword";
    case "object":
      return "TSObjectKeyword";
    case "string":
      return "TSStringKeyword";
    case "symbol":
      return "TSSymbolKeyword";
    case "undefined":
      return "TSUndefinedKeyword";
    case "unknown":
      return "TSUnknownKeyword";
    default:
      return;
  }
}
function vy(r) {
  return r === "private" || r === "public" || r === "protected";
}
function EO(r) {
  return r === "in" || r === "out";
}
var SO = (r) => class extends r {
  constructor(...t) {
    super(...t), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["in", "out"],
      disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
      errorTemplate: oe.InvalidModifierOnTypeParameter
    }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["const"],
      disallowedModifiers: ["in", "out"],
      errorTemplate: oe.InvalidModifierOnTypeParameterPositions
    }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["in", "out", "const"],
      disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
      errorTemplate: oe.InvalidModifierOnTypeParameter
    });
  }
  getScopeHandler() {
    return dO;
  }
  tsIsIdentifier() {
    return Le(this.state.type);
  }
  tsTokenCanFollowModifier() {
    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
  }
  tsNextTokenCanFollowModifier() {
    return this.next(), this.tsTokenCanFollowModifier();
  }
  tsParseModifier(t, s) {
    if (!Le(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
      return;
    const i = this.state.value;
    if (t.indexOf(i) !== -1) {
      if (s && this.tsIsStartOfStaticBlocks())
        return;
      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
        return i;
    }
  }
  tsParseModifiers({
    allowedModifiers: t,
    disallowedModifiers: s,
    stopOnStartOfClassStaticBlock: i,
    errorTemplate: n = oe.InvalidModifierOnTypeMember
  }, a) {
    const o = (l, c, f, p) => {
      c === f && a[p] && this.raise(oe.InvalidModifiersOrder, l, {
        orderedModifiers: [f, p]
      });
    }, u = (l, c, f, p) => {
      (a[f] && c === p || a[p] && c === f) && this.raise(oe.IncompatibleModifiers, l, {
        modifiers: [f, p]
      });
    };
    for (; ; ) {
      const {
        startLoc: l
      } = this.state, c = this.tsParseModifier(t.concat(s ?? []), i);
      if (!c) break;
      vy(c) ? a.accessibility ? this.raise(oe.DuplicateAccessibilityModifier, l, {
        modifier: c
      }) : (o(l, c, c, "override"), o(l, c, c, "static"), o(l, c, c, "readonly"), a.accessibility = c) : EO(c) ? (a[c] && this.raise(oe.DuplicateModifier, l, {
        modifier: c
      }), a[c] = !0, o(l, c, "in", "out")) : (hasOwnProperty.call(a, c) ? this.raise(oe.DuplicateModifier, l, {
        modifier: c
      }) : (o(l, c, "static", "readonly"), o(l, c, "static", "override"), o(l, c, "override", "readonly"), o(l, c, "abstract", "override"), u(l, c, "declare", "override"), u(l, c, "static", "abstract")), a[c] = !0), s != null && s.includes(c) && this.raise(n, l, {
        modifier: c
      });
    }
  }
  tsIsListTerminator(t) {
    switch (t) {
      case "EnumMembers":
      case "TypeMembers":
        return this.match(8);
      case "HeritageClauseElement":
        return this.match(5);
      case "TupleElementTypes":
        return this.match(3);
      case "TypeParametersOrArguments":
        return this.match(48);
    }
  }
  tsParseList(t, s) {
    const i = [];
    for (; !this.tsIsListTerminator(t); )
      i.push(s());
    return i;
  }
  tsParseDelimitedList(t, s, i) {
    return bO(this.tsParseDelimitedListWorker(t, s, !0, i));
  }
  tsParseDelimitedListWorker(t, s, i, n) {
    const a = [];
    let o = -1;
    for (; !this.tsIsListTerminator(t); ) {
      o = -1;
      const u = s();
      if (u == null)
        return;
      if (a.push(u), this.eat(12)) {
        o = this.state.lastTokStartLoc.index;
        continue;
      }
      if (this.tsIsListTerminator(t))
        break;
      i && this.expect(12);
      return;
    }
    return n && (n.value = o), a;
  }
  tsParseBracketedList(t, s, i, n, a) {
    n || (i ? this.expect(0) : this.expect(47));
    const o = this.tsParseDelimitedList(t, s, a);
    return i ? this.expect(3) : this.expect(48), o;
  }
  tsParseImportType() {
    const t = this.startNode();
    return this.expect(83), this.expect(10), this.match(133) || this.raise(oe.UnsupportedImportTypeArgument, this.state.startLoc), t.argument = super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (t.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.eat(16) && (t.qualifier = this.tsParseEntityName()), this.match(47) && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, "TSImportType");
  }
  tsParseEntityName(t = !0) {
    let s = this.parseIdentifier(t);
    for (; this.eat(16); ) {
      const i = this.startNodeAtNode(s);
      i.left = s, i.right = this.parseIdentifier(t), s = this.finishNode(i, "TSQualifiedName");
    }
    return s;
  }
  tsParseTypeReference() {
    const t = this.startNode();
    return t.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, "TSTypeReference");
  }
  tsParseThisTypePredicate(t) {
    this.next();
    const s = this.startNodeAtNode(t);
    return s.parameterName = t, s.typeAnnotation = this.tsParseTypeAnnotation(!1), s.asserts = !1, this.finishNode(s, "TSTypePredicate");
  }
  tsParseThisTypeNode() {
    const t = this.startNode();
    return this.next(), this.finishNode(t, "TSThisType");
  }
  tsParseTypeQuery() {
    const t = this.startNode();
    return this.expect(87), this.match(83) ? t.exprName = this.tsParseImportType() : t.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, "TSTypeQuery");
  }
  tsParseTypeParameter(t) {
    const s = this.startNode();
    return t(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(29), this.finishNode(s, "TSTypeParameter");
  }
  tsTryParseTypeParameters(t) {
    if (this.match(47))
      return this.tsParseTypeParameters(t);
  }
  tsParseTypeParameters(t) {
    const s = this.startNode();
    this.match(47) || this.match(142) ? this.next() : this.unexpected();
    const i = {
      value: -1
    };
    return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, t), !1, !0, i), s.params.length === 0 && this.raise(oe.EmptyTypeParameters, s), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s, "TSTypeParameterDeclaration");
  }
  tsFillSignature(t, s) {
    const i = t === 19, n = "parameters", a = "typeAnnotation";
    s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[n] = this.tsParseBindingListForSignature(), i ? s[a] = this.tsParseTypeOrTypePredicateAnnotation(t) : this.match(t) && (s[a] = this.tsParseTypeOrTypePredicateAnnotation(t));
  }
  tsParseBindingListForSignature() {
    const t = super.parseBindingList(11, 41, 2);
    for (const s of t) {
      const {
        type: i
      } = s;
      (i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(oe.UnsupportedSignatureParameterKind, s, {
        type: i
      });
    }
    return t;
  }
  tsParseTypeMemberSemicolon() {
    !this.eat(12) && !this.isLineTerminator() && this.expect(13);
  }
  tsParseSignatureMember(t, s) {
    return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, t);
  }
  tsIsUnambiguouslyIndexSignature() {
    return this.next(), Le(this.state.type) ? (this.next(), this.match(14)) : !1;
  }
  tsTryParseIndexSignature(t) {
    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
      return;
    this.expect(0);
    const s = this.parseIdentifier();
    s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), t.parameters = [s];
    const i = this.tsTryParseTypeAnnotation();
    return i && (t.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(t, "TSIndexSignature");
  }
  tsParsePropertyOrMethodSignature(t, s) {
    this.eat(17) && (t.optional = !0);
    const i = t;
    if (this.match(10) || this.match(47)) {
      s && this.raise(oe.ReadonlyForMethodSignature, t);
      const n = i;
      n.kind && this.match(47) && this.raise(oe.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, n), this.tsParseTypeMemberSemicolon();
      const a = "parameters", o = "typeAnnotation";
      if (n.kind === "get")
        n[a].length > 0 && (this.raise(O.BadGetterArity, this.state.curPosition()), this.isThisParam(n[a][0]) && this.raise(oe.AccesorCannotDeclareThisParameter, this.state.curPosition()));
      else if (n.kind === "set") {
        if (n[a].length !== 1)
          this.raise(O.BadSetterArity, this.state.curPosition());
        else {
          const u = n[a][0];
          this.isThisParam(u) && this.raise(oe.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.optional && this.raise(oe.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(oe.SetAccesorCannotHaveRestParameter, this.state.curPosition());
        }
        n[o] && this.raise(oe.SetAccesorCannotHaveReturnType, n[o]);
      } else
        n.kind = "method";
      return this.finishNode(n, "TSMethodSignature");
    } else {
      const n = i;
      s && (n.readonly = !0);
      const a = this.tsTryParseTypeAnnotation();
      return a && (n.typeAnnotation = a), this.tsParseTypeMemberSemicolon(), this.finishNode(n, "TSPropertySignature");
    }
  }
  tsParseTypeMember() {
    const t = this.startNode();
    if (this.match(10) || this.match(47))
      return this.tsParseSignatureMember("TSCallSignatureDeclaration", t);
    if (this.match(77)) {
      const i = this.startNode();
      return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", t) : (t.key = this.createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(t, !1));
    }
    this.tsParseModifiers({
      allowedModifiers: ["readonly"],
      disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
    }, t);
    const s = this.tsTryParseIndexSignature(t);
    return s || (super.parsePropertyName(t), !t.computed && t.key.type === "Identifier" && (t.key.name === "get" || t.key.name === "set") && this.tsTokenCanFollowModifier() && (t.kind = t.key.name, super.parsePropertyName(t)), this.tsParsePropertyOrMethodSignature(t, !!t.readonly));
  }
  tsParseTypeLiteral() {
    const t = this.startNode();
    return t.members = this.tsParseObjectTypeMembers(), this.finishNode(t, "TSTypeLiteral");
  }
  tsParseObjectTypeMembers() {
    this.expect(5);
    const t = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
    return this.expect(8), t;
  }
  tsIsStartOfMappedType() {
    return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
  }
  tsParseMappedTypeParameter() {
    const t = this.startNode();
    return t.name = this.tsParseTypeParameterName(), t.constraint = this.tsExpectThenParseType(58), this.finishNode(t, "TSTypeParameter");
  }
  tsParseMappedType() {
    const t = this.startNode();
    return this.expect(5), this.match(53) ? (t.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (t.readonly = !0), this.expect(0), t.typeParameter = this.tsParseMappedTypeParameter(), t.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (t.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (t.optional = !0), t.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(t, "TSMappedType");
  }
  tsParseTupleType() {
    const t = this.startNode();
    t.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
    let s = !1;
    return t.elementTypes.forEach((i) => {
      const {
        type: n
      } = i;
      s && n !== "TSRestType" && n !== "TSOptionalType" && !(n === "TSNamedTupleMember" && i.optional) && this.raise(oe.OptionalTypeBeforeRequired, i), s || (s = n === "TSNamedTupleMember" && i.optional || n === "TSOptionalType");
    }), this.finishNode(t, "TSTupleType");
  }
  tsParseTupleElementType() {
    const {
      startLoc: t
    } = this.state, s = this.eat(21);
    let i, n, a, o;
    const l = Cr(this.state.type) ? this.lookaheadCharCode() : null;
    if (l === 58)
      i = !0, a = !1, n = this.parseIdentifier(!0), this.expect(14), o = this.tsParseType();
    else if (l === 63) {
      a = !0;
      const c = this.state.startLoc, f = this.state.value, p = this.tsParseNonArrayType();
      this.lookaheadCharCode() === 58 ? (i = !0, n = this.createIdentifier(this.startNodeAt(c), f), this.expect(17), this.expect(14), o = this.tsParseType()) : (i = !1, o = p, this.expect(17));
    } else
      o = this.tsParseType(), a = this.eat(17), i = this.eat(14);
    if (i) {
      let c;
      n ? (c = this.startNodeAtNode(n), c.optional = a, c.label = n, c.elementType = o, this.eat(17) && (c.optional = !0, this.raise(oe.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (c = this.startNodeAtNode(o), c.optional = a, this.raise(oe.InvalidTupleMemberLabel, o), c.label = o, c.elementType = this.tsParseType()), o = this.finishNode(c, "TSNamedTupleMember");
    } else if (a) {
      const c = this.startNodeAtNode(o);
      c.typeAnnotation = o, o = this.finishNode(c, "TSOptionalType");
    }
    if (s) {
      const c = this.startNodeAt(t);
      c.typeAnnotation = o, o = this.finishNode(c, "TSRestType");
    }
    return o;
  }
  tsParseParenthesizedType() {
    const t = this.startNode();
    return this.expect(10), t.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(t, "TSParenthesizedType");
  }
  tsParseFunctionOrConstructorType(t, s) {
    const i = this.startNode();
    return t === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i)), this.finishNode(i, t);
  }
  tsParseLiteralTypeNode() {
    const t = this.startNode();
    switch (this.state.type) {
      case 134:
      case 135:
      case 133:
      case 85:
      case 86:
        t.literal = super.parseExprAtom();
        break;
      default:
        this.unexpected();
    }
    return this.finishNode(t, "TSLiteralType");
  }
  tsParseTemplateLiteralType() {
    const t = this.startNode();
    return t.literal = super.parseTemplate(!1), this.finishNode(t, "TSLiteralType");
  }
  parseTemplateSubstitution() {
    return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
  }
  tsParseThisTypeOrThisTypePredicate() {
    const t = this.tsParseThisTypeNode();
    return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(t) : t;
  }
  tsParseNonArrayType() {
    switch (this.state.type) {
      case 133:
      case 134:
      case 135:
      case 85:
      case 86:
        return this.tsParseLiteralTypeNode();
      case 53:
        if (this.state.value === "-") {
          const t = this.startNode(), s = this.lookahead();
          return s.type !== 134 && s.type !== 135 && this.unexpected(), t.literal = this.parseMaybeUnary(), this.finishNode(t, "TSLiteralType");
        }
        break;
      case 78:
        return this.tsParseThisTypeOrThisTypePredicate();
      case 87:
        return this.tsParseTypeQuery();
      case 83:
        return this.tsParseImportType();
      case 5:
        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
      case 0:
        return this.tsParseTupleType();
      case 10:
        return this.tsParseParenthesizedType();
      case 25:
      case 24:
        return this.tsParseTemplateLiteralType();
      default: {
        const {
          type: t
        } = this.state;
        if (Le(t) || t === 88 || t === 84) {
          const s = t === 88 ? "TSVoidKeyword" : t === 84 ? "TSNullKeyword" : vO(this.state.value);
          if (s !== void 0 && this.lookaheadCharCode() !== 46) {
            const i = this.startNode();
            return this.next(), this.finishNode(i, s);
          }
          return this.tsParseTypeReference();
        }
      }
    }
    this.unexpected();
  }
  tsParseArrayTypeOrHigher() {
    let t = this.tsParseNonArrayType();
    for (; !this.hasPrecedingLineBreak() && this.eat(0); )
      if (this.match(3)) {
        const s = this.startNodeAtNode(t);
        s.elementType = t, this.expect(3), t = this.finishNode(s, "TSArrayType");
      } else {
        const s = this.startNodeAtNode(t);
        s.objectType = t, s.indexType = this.tsParseType(), this.expect(3), t = this.finishNode(s, "TSIndexedAccessType");
      }
    return t;
  }
  tsParseTypeOperator() {
    const t = this.startNode(), s = this.state.value;
    return this.next(), t.operator = s, t.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(t), this.finishNode(t, "TSTypeOperator");
  }
  tsCheckTypeAnnotationForReadOnly(t) {
    switch (t.typeAnnotation.type) {
      case "TSTupleType":
      case "TSArrayType":
        return;
      default:
        this.raise(oe.UnexpectedReadonly, t);
    }
  }
  tsParseInferType() {
    const t = this.startNode();
    this.expectContextual(115);
    const s = this.startNode();
    return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), t.typeParameter = this.finishNode(s, "TSTypeParameter"), this.finishNode(t, "TSInferType");
  }
  tsParseConstraintForInferType() {
    if (this.eat(81)) {
      const t = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
      if (this.state.inDisallowConditionalTypesContext || !this.match(17))
        return t;
    }
  }
  tsParseTypeOperatorOrHigher() {
    return wN(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
  }
  tsParseUnionOrIntersectionType(t, s, i) {
    const n = this.startNode(), a = this.eat(i), o = [];
    do
      o.push(s());
    while (this.eat(i));
    return o.length === 1 && !a ? o[0] : (n.types = o, this.finishNode(n, t));
  }
  tsParseIntersectionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
  }
  tsParseUnionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
  }
  tsIsStartOfFunctionType() {
    return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
  }
  tsSkipParameterStart() {
    if (Le(this.state.type) || this.match(78))
      return this.next(), !0;
    if (this.match(5)) {
      const {
        errors: t
      } = this.state, s = t.length;
      try {
        return this.parseObjectLike(8, !0), t.length === s;
      } catch {
        return !1;
      }
    }
    if (this.match(0)) {
      this.next();
      const {
        errors: t
      } = this.state, s = t.length;
      try {
        return super.parseBindingList(3, 93, 1), t.length === s;
      } catch {
        return !1;
      }
    }
    return !1;
  }
  tsIsUnambiguouslyStartOfFunctionType() {
    return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
  }
  tsParseTypeOrTypePredicateAnnotation(t) {
    return this.tsInType(() => {
      const s = this.startNode();
      this.expect(t);
      const i = this.startNode(), n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
      if (n && this.match(78)) {
        let u = this.tsParseThisTypeOrThisTypePredicate();
        return u.type === "TSThisType" ? (i.parameterName = u, i.asserts = !0, i.typeAnnotation = null, u = this.finishNode(i, "TSTypePredicate")) : (this.resetStartLocationFromNode(u, i), u.asserts = !0), s.typeAnnotation = u, this.finishNode(s, "TSTypeAnnotation");
      }
      const a = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
      if (!a)
        return n ? (i.parameterName = this.parseIdentifier(), i.asserts = n, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, s);
      const o = this.tsParseTypeAnnotation(!1);
      return i.parameterName = a, i.typeAnnotation = o, i.asserts = n, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation");
    });
  }
  tsTryParseTypeOrTypePredicateAnnotation() {
    if (this.match(14))
      return this.tsParseTypeOrTypePredicateAnnotation(14);
  }
  tsTryParseTypeAnnotation() {
    if (this.match(14))
      return this.tsParseTypeAnnotation();
  }
  tsTryParseType() {
    return this.tsEatThenParseType(14);
  }
  tsParseTypePredicatePrefix() {
    const t = this.parseIdentifier();
    if (this.isContextual(116) && !this.hasPrecedingLineBreak())
      return this.next(), t;
  }
  tsParseTypePredicateAsserts() {
    if (this.state.type !== 109)
      return !1;
    const t = this.state.containsEsc;
    return this.next(), !Le(this.state.type) && !this.match(78) ? !1 : (t && this.raise(O.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
      reservedWord: "asserts"
    }), !0);
  }
  tsParseTypeAnnotation(t = !0, s = this.startNode()) {
    return this.tsInType(() => {
      t && this.expect(14), s.typeAnnotation = this.tsParseType();
    }), this.finishNode(s, "TSTypeAnnotation");
  }
  tsParseType() {
    by(this.state.inType);
    const t = this.tsParseNonConditionalType();
    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
      return t;
    const s = this.startNodeAtNode(t);
    return s.checkType = t, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s, "TSConditionalType");
  }
  isAbstractConstructorSignature() {
    return this.isContextual(124) && this.lookahead().type === 77;
  }
  tsParseNonConditionalType() {
    return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
  }
  tsParseTypeAssertion() {
    this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(oe.ReservedTypeAssertion, this.state.startLoc);
    const t = this.startNode();
    return t.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), t.expression = this.parseMaybeUnary(), this.finishNode(t, "TSTypeAssertion");
  }
  tsParseHeritageClause(t) {
    const s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
      const n = this.startNode();
      return n.expression = this.tsParseEntityName(), this.match(47) && (n.typeParameters = this.tsParseTypeArguments()), this.finishNode(n, "TSExpressionWithTypeArguments");
    });
    return i.length || this.raise(oe.EmptyHeritageClauseType, s, {
      token: t
    }), i;
  }
  tsParseInterfaceDeclaration(t, s = {}) {
    if (this.hasFollowingLineBreak()) return null;
    this.expectContextual(129), s.declare && (t.declare = !0), Le(this.state.type) ? (t.id = this.parseIdentifier(), this.checkIdentifier(t.id, 130)) : (t.id = null, this.raise(oe.MissingInterfaceName, this.state.startLoc)), t.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (t.extends = this.tsParseHeritageClause("extends"));
    const i = this.startNode();
    return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), t.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(t, "TSInterfaceDeclaration");
  }
  tsParseTypeAliasDeclaration(t) {
    return t.id = this.parseIdentifier(), this.checkIdentifier(t.id, 2), t.typeAnnotation = this.tsInType(() => {
      if (t.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
        const s = this.startNode();
        return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
      }
      return this.tsParseType();
    }), this.semicolon(), this.finishNode(t, "TSTypeAliasDeclaration");
  }
  tsInNoContext(t) {
    const s = this.state.context;
    this.state.context = [s[0]];
    try {
      return t();
    } finally {
      this.state.context = s;
    }
  }
  tsInType(t) {
    const s = this.state.inType;
    this.state.inType = !0;
    try {
      return t();
    } finally {
      this.state.inType = s;
    }
  }
  tsInDisallowConditionalTypesContext(t) {
    const s = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = !0;
    try {
      return t();
    } finally {
      this.state.inDisallowConditionalTypesContext = s;
    }
  }
  tsInAllowConditionalTypesContext(t) {
    const s = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = !1;
    try {
      return t();
    } finally {
      this.state.inDisallowConditionalTypesContext = s;
    }
  }
  tsEatThenParseType(t) {
    if (this.match(t))
      return this.tsNextThenParseType();
  }
  tsExpectThenParseType(t) {
    return this.tsInType(() => (this.expect(t), this.tsParseType()));
  }
  tsNextThenParseType() {
    return this.tsInType(() => (this.next(), this.tsParseType()));
  }
  tsParseEnumMember() {
    const t = this.startNode();
    return t.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (t.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(t, "TSEnumMember");
  }
  tsParseEnumDeclaration(t, s = {}) {
    return s.const && (t.const = !0), s.declare && (t.declare = !0), this.expectContextual(126), t.id = this.parseIdentifier(), this.checkIdentifier(t.id, t.const ? 8971 : 8459), this.expect(5), t.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(t, "TSEnumDeclaration");
  }
  tsParseModuleBlock() {
    const t = this.startNode();
    return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(t.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(t, "TSModuleBlock");
  }
  tsParseModuleOrNamespaceDeclaration(t, s = !1) {
    if (t.id = this.parseIdentifier(), s || this.checkIdentifier(t.id, 1024), this.eat(16)) {
      const i = this.startNode();
      this.tsParseModuleOrNamespaceDeclaration(i, !0), t.body = i;
    } else
      this.scope.enter(256), this.prodParam.enter(0), t.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
    return this.finishNode(t, "TSModuleDeclaration");
  }
  tsParseAmbientExternalModuleDeclaration(t) {
    return this.isContextual(112) ? (t.global = !0, t.id = this.parseIdentifier()) : this.match(133) ? t.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), t.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(t, "TSModuleDeclaration");
  }
  tsParseImportEqualsDeclaration(t, s, i) {
    t.isExport = i || !1, t.id = s || this.parseIdentifier(), this.checkIdentifier(t.id, 4096), this.expect(29);
    const n = this.tsParseModuleReference();
    return t.importKind === "type" && n.type !== "TSExternalModuleReference" && this.raise(oe.ImportAliasHasImportType, n), t.moduleReference = n, this.semicolon(), this.finishNode(t, "TSImportEqualsDeclaration");
  }
  tsIsExternalModuleReference() {
    return this.isContextual(119) && this.lookaheadCharCode() === 40;
  }
  tsParseModuleReference() {
    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
  }
  tsParseExternalModuleReference() {
    const t = this.startNode();
    return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), t.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(t, "TSExternalModuleReference");
  }
  tsLookAhead(t) {
    const s = this.state.clone(), i = t();
    return this.state = s, i;
  }
  tsTryParseAndCatch(t) {
    const s = this.tryParse((i) => t() || i());
    if (!(s.aborted || !s.node))
      return s.error && (this.state = s.failState), s.node;
  }
  tsTryParse(t) {
    const s = this.state.clone(), i = t();
    if (i !== void 0 && i !== !1)
      return i;
    this.state = s;
  }
  tsTryParseDeclare(t) {
    if (this.isLineTerminator())
      return;
    let s = this.state.type, i;
    return this.isContextual(100) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
      switch (s) {
        case 68:
          return t.declare = !0, super.parseFunctionStatement(t, !1, !1);
        case 80:
          return t.declare = !0, this.parseClass(t, !0, !1);
        case 126:
          return this.tsParseEnumDeclaration(t, {
            declare: !0
          });
        case 112:
          return this.tsParseAmbientExternalModuleDeclaration(t);
        case 75:
        case 74:
          return !this.match(75) || !this.isLookaheadContextual("enum") ? (t.declare = !0, this.parseVarStatement(t, i || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(t, {
            const: !0,
            declare: !0
          }));
        case 129: {
          const n = this.tsParseInterfaceDeclaration(t, {
            declare: !0
          });
          if (n) return n;
        }
        default:
          if (Le(s))
            return this.tsParseDeclaration(t, this.state.value, !0, null);
      }
    });
  }
  tsTryParseExportDeclaration() {
    return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
  }
  tsParseExpressionStatement(t, s, i) {
    switch (s.name) {
      case "declare": {
        const n = this.tsTryParseDeclare(t);
        return n && (n.declare = !0), n;
      }
      case "global":
        if (this.match(5)) {
          this.scope.enter(256), this.prodParam.enter(0);
          const n = t;
          return n.global = !0, n.id = s, n.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(n, "TSModuleDeclaration");
        }
        break;
      default:
        return this.tsParseDeclaration(t, s.name, !1, i);
    }
  }
  tsParseDeclaration(t, s, i, n) {
    switch (s) {
      case "abstract":
        if (this.tsCheckLineTerminator(i) && (this.match(80) || Le(this.state.type)))
          return this.tsParseAbstractDeclaration(t, n);
        break;
      case "module":
        if (this.tsCheckLineTerminator(i)) {
          if (this.match(133))
            return this.tsParseAmbientExternalModuleDeclaration(t);
          if (Le(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(t);
        }
        break;
      case "namespace":
        if (this.tsCheckLineTerminator(i) && Le(this.state.type))
          return this.tsParseModuleOrNamespaceDeclaration(t);
        break;
      case "type":
        if (this.tsCheckLineTerminator(i) && Le(this.state.type))
          return this.tsParseTypeAliasDeclaration(t);
        break;
    }
  }
  tsCheckLineTerminator(t) {
    return t ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
  }
  tsTryParseGenericAsyncArrowFunction(t) {
    if (!this.match(47)) return;
    const s = this.state.maybeInArrowParameters;
    this.state.maybeInArrowParameters = !0;
    const i = this.tsTryParseAndCatch(() => {
      const n = this.startNodeAt(t);
      return n.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(n), n.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), n;
    });
    if (this.state.maybeInArrowParameters = s, !!i)
      return super.parseArrowExpression(i, null, !0);
  }
  tsParseTypeArgumentsInExpression() {
    if (this.reScan_lt() === 47)
      return this.tsParseTypeArguments();
  }
  tsParseTypeArguments() {
    const t = this.startNode();
    return t.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), t.params.length === 0 ? this.raise(oe.EmptyTypeArguments, t) : !this.state.inType && this.curContext() === Ue.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(t, "TSTypeParameterInstantiation");
  }
  tsIsDeclarationStart() {
    return TN(this.state.type);
  }
  isExportDefaultSpecifier() {
    return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
  }
  parseAssignableListItem(t, s) {
    const i = this.state.startLoc, n = {};
    this.tsParseModifiers({
      allowedModifiers: ["public", "private", "protected", "override", "readonly"]
    }, n);
    const a = n.accessibility, o = n.override, u = n.readonly;
    !(t & 4) && (a || u || o) && this.raise(oe.UnexpectedParameterModifier, i);
    const l = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(l, t);
    const c = this.parseMaybeDefault(l.loc.start, l);
    if (a || u || o) {
      const f = this.startNodeAt(i);
      return s.length && (f.decorators = s), a && (f.accessibility = a), u && (f.readonly = u), o && (f.override = o), c.type !== "Identifier" && c.type !== "AssignmentPattern" && this.raise(oe.UnsupportedParameterPropertyKind, f), f.parameter = c, this.finishNode(f, "TSParameterProperty");
    }
    return s.length && (l.decorators = s), c;
  }
  isSimpleParameter(t) {
    return t.type === "TSParameterProperty" && super.isSimpleParameter(t.parameter) || super.isSimpleParameter(t);
  }
  tsDisallowOptionalPattern(t) {
    for (const s of t.params)
      s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(oe.PatternIsOptional, s);
  }
  setArrowFunctionParameters(t, s, i) {
    super.setArrowFunctionParameters(t, s, i), this.tsDisallowOptionalPattern(t);
  }
  parseFunctionBodyAndFinish(t, s, i = !1) {
    this.match(14) && (t.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
    const n = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
    return n && !this.match(5) && this.isLineTerminator() ? this.finishNode(t, n) : n === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(oe.DeclareFunctionHasImplementation, t), t.declare) ? super.parseFunctionBodyAndFinish(t, n, i) : (this.tsDisallowOptionalPattern(t), super.parseFunctionBodyAndFinish(t, s, i));
  }
  registerFunctionStatementId(t) {
    !t.body && t.id ? this.checkIdentifier(t.id, 1024) : super.registerFunctionStatementId(t);
  }
  tsCheckForInvalidTypeCasts(t) {
    t.forEach((s) => {
      (s == null ? void 0 : s.type) === "TSTypeCastExpression" && this.raise(oe.UnexpectedTypeAnnotation, s.typeAnnotation);
    });
  }
  toReferencedList(t, s) {
    return this.tsCheckForInvalidTypeCasts(t), t;
  }
  parseArrayLike(t, s, i, n) {
    const a = super.parseArrayLike(t, s, i, n);
    return a.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(a.elements), a;
  }
  parseSubscript(t, s, i, n) {
    if (!this.hasPrecedingLineBreak() && this.match(35)) {
      this.state.canStartJSXElement = !1, this.next();
      const o = this.startNodeAt(s);
      return o.expression = t, this.finishNode(o, "TSNonNullExpression");
    }
    let a = !1;
    if (this.match(18) && this.lookaheadCharCode() === 60) {
      if (i)
        return n.stop = !0, t;
      n.optionalChainMember = a = !0, this.next();
    }
    if (this.match(47) || this.match(51)) {
      let o;
      const u = this.tsTryParseAndCatch(() => {
        if (!i && this.atPossibleAsyncArrow(t)) {
          const p = this.tsTryParseGenericAsyncArrowFunction(s);
          if (p)
            return p;
        }
        const l = this.tsParseTypeArgumentsInExpression();
        if (!l) return;
        if (a && !this.match(10)) {
          o = this.state.curPosition();
          return;
        }
        if (El(this.state.type)) {
          const p = super.parseTaggedTemplateExpression(t, s, n);
          return p.typeParameters = l, p;
        }
        if (!i && this.eat(10)) {
          const p = this.startNodeAt(s);
          return p.callee = t, p.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(p.arguments), p.typeParameters = l, n.optionalChainMember && (p.optional = a), this.finishCallExpression(p, n.optionalChainMember);
        }
        const c = this.state.type;
        if (c === 48 || c === 52 || c !== 10 && Rp(c) && !this.hasPrecedingLineBreak())
          return;
        const f = this.startNodeAt(s);
        return f.expression = t, f.typeParameters = l, this.finishNode(f, "TSInstantiationExpression");
      });
      if (o && this.unexpected(o, 10), u)
        return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(oe.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
    }
    return super.parseSubscript(t, s, i, n);
  }
  parseNewCallee(t) {
    var s;
    super.parseNewCallee(t);
    const {
      callee: i
    } = t;
    i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (t.typeParameters = i.typeParameters, t.callee = i.expression);
  }
  parseExprOp(t, s, i) {
    let n;
    if (Mu(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n = this.isContextual(120)))) {
      const a = this.startNodeAt(s);
      return a.expression = t, a.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (n && this.raise(O.UnexpectedKeyword, this.state.startLoc, {
        keyword: "const"
      }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(a, n ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(a, s, i);
    }
    return super.parseExprOp(t, s, i);
  }
  checkReservedWord(t, s, i, n) {
    this.state.isAmbientContext || super.checkReservedWord(t, s, i, n);
  }
  checkImportReflection(t) {
    super.checkImportReflection(t), t.module && t.importKind !== "value" && this.raise(oe.ImportReflectionHasImportType, t.specifiers[0].loc.start);
  }
  checkDuplicateExports() {
  }
  isPotentialImportPhase(t) {
    if (super.isPotentialImportPhase(t)) return !0;
    if (this.isContextual(130)) {
      const s = this.lookaheadCharCode();
      return t ? s === 123 || s === 42 : s !== 61;
    }
    return !t && this.isContextual(87);
  }
  applyImportPhase(t, s, i, n) {
    super.applyImportPhase(t, s, i, n), s ? t.exportKind = i === "type" ? "type" : "value" : t.importKind = i === "type" || i === "typeof" ? i : "value";
  }
  parseImport(t) {
    if (this.match(133))
      return t.importKind = "value", super.parseImport(t);
    let s;
    if (Le(this.state.type) && this.lookaheadCharCode() === 61)
      return t.importKind = "value", this.tsParseImportEqualsDeclaration(t);
    if (this.isContextual(130)) {
      const i = this.parseMaybeImportPhase(t, !1);
      if (this.lookaheadCharCode() === 61)
        return this.tsParseImportEqualsDeclaration(t, i);
      s = super.parseImportSpecifiersAndAfter(t, i);
    } else
      s = super.parseImport(t);
    return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(oe.TypeImportCannotSpecifyDefaultAndNamed, s), s;
  }
  parseExport(t, s) {
    if (this.match(83)) {
      this.next();
      const i = t;
      let n = null;
      return this.isContextual(130) && this.isPotentialImportPhase(!1) ? n = this.parseMaybeImportPhase(i, !1) : i.importKind = "value", this.tsParseImportEqualsDeclaration(i, n, !0);
    } else if (this.eat(29)) {
      const i = t;
      return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(i, "TSExportAssignment");
    } else if (this.eatContextual(93)) {
      const i = t;
      return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
    } else
      return super.parseExport(t, s);
  }
  isAbstractClass() {
    return this.isContextual(124) && this.lookahead().type === 80;
  }
  parseExportDefaultExpression() {
    if (this.isAbstractClass()) {
      const t = this.startNode();
      return this.next(), t.abstract = !0, this.parseClass(t, !0, !0);
    }
    if (this.match(129)) {
      const t = this.tsParseInterfaceDeclaration(this.startNode());
      if (t) return t;
    }
    return super.parseExportDefaultExpression();
  }
  parseVarStatement(t, s, i = !1) {
    const {
      isAmbientContext: n
    } = this.state, a = super.parseVarStatement(t, s, i || n);
    if (!n) return a;
    for (const {
      id: o,
      init: u
    } of a.declarations)
      u && (s !== "const" || o.typeAnnotation ? this.raise(oe.InitializerNotAllowedInAmbientContext, u) : xO(u, this.hasPlugin("estree")) || this.raise(oe.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
    return a;
  }
  parseStatementContent(t, s) {
    if (this.match(75) && this.isLookaheadContextual("enum")) {
      const i = this.startNode();
      return this.expect(75), this.tsParseEnumDeclaration(i, {
        const: !0
      });
    }
    if (this.isContextual(126))
      return this.tsParseEnumDeclaration(this.startNode());
    if (this.isContextual(129)) {
      const i = this.tsParseInterfaceDeclaration(this.startNode());
      if (i) return i;
    }
    return super.parseStatementContent(t, s);
  }
  parseAccessModifier() {
    return this.tsParseModifier(["public", "protected", "private"]);
  }
  tsHasSomeModifiers(t, s) {
    return s.some((i) => vy(i) ? t.accessibility === i : !!t[i]);
  }
  tsIsStartOfStaticBlocks() {
    return this.isContextual(106) && this.lookaheadCharCode() === 123;
  }
  parseClassMember(t, s, i) {
    const n = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
    this.tsParseModifiers({
      allowedModifiers: n,
      disallowedModifiers: ["in", "out"],
      stopOnStartOfClassStaticBlock: !0,
      errorTemplate: oe.InvalidModifierOnTypeParameterPositions
    }, s);
    const a = () => {
      this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, n) && this.raise(oe.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(t, s)) : this.parseClassMemberWithIsStatic(t, s, i, !!s.static);
    };
    s.declare ? this.tsInAmbientContext(a) : a();
  }
  parseClassMemberWithIsStatic(t, s, i, n) {
    const a = this.tsTryParseIndexSignature(s);
    if (a) {
      t.body.push(a), s.abstract && this.raise(oe.IndexSignatureHasAbstract, s), s.accessibility && this.raise(oe.IndexSignatureHasAccessibility, s, {
        modifier: s.accessibility
      }), s.declare && this.raise(oe.IndexSignatureHasDeclare, s), s.override && this.raise(oe.IndexSignatureHasOverride, s);
      return;
    }
    !this.state.inAbstractClass && s.abstract && this.raise(oe.NonAbstractClassHasAbstractMethod, s), s.override && (i.hadSuperClass || this.raise(oe.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(t, s, i, n);
  }
  parsePostMemberNameModifiers(t) {
    this.eat(17) && (t.optional = !0), t.readonly && this.match(10) && this.raise(oe.ClassMethodHasReadonly, t), t.declare && this.match(10) && this.raise(oe.ClassMethodHasDeclare, t);
  }
  parseExpressionStatement(t, s, i) {
    return (s.type === "Identifier" ? this.tsParseExpressionStatement(t, s, i) : void 0) || super.parseExpressionStatement(t, s, i);
  }
  shouldParseExportDeclaration() {
    return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
  }
  parseConditional(t, s, i) {
    if (!this.state.maybeInArrowParameters || !this.match(17))
      return super.parseConditional(t, s, i);
    const n = this.tryParse(() => super.parseConditional(t, s));
    return n.node ? (n.error && (this.state = n.failState), n.node) : (n.error && super.setOptionalParametersError(i, n.error), t);
  }
  parseParenItem(t, s) {
    const i = super.parseParenItem(t, s);
    if (this.eat(17) && (i.optional = !0, this.resetEndLocation(t)), this.match(14)) {
      const n = this.startNodeAt(s);
      return n.expression = t, n.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(n, "TSTypeCastExpression");
    }
    return t;
  }
  parseExportDeclaration(t) {
    if (!this.state.isAmbientContext && this.isContextual(125))
      return this.tsInAmbientContext(() => this.parseExportDeclaration(t));
    const s = this.state.startLoc, i = this.eatContextual(125);
    if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
      throw this.raise(oe.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
    const a = Le(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(t);
    return a ? ((a.type === "TSInterfaceDeclaration" || a.type === "TSTypeAliasDeclaration" || i) && (t.exportKind = "type"), i && (this.resetStartLocation(a, s), a.declare = !0), a) : null;
  }
  parseClassId(t, s, i, n) {
    if ((!s || i) && this.isContextual(113))
      return;
    super.parseClassId(t, s, i, t.declare ? 1024 : 8331);
    const a = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
    a && (t.typeParameters = a);
  }
  parseClassPropertyAnnotation(t) {
    t.optional || (this.eat(35) ? t.definite = !0 : this.eat(17) && (t.optional = !0));
    const s = this.tsTryParseTypeAnnotation();
    s && (t.typeAnnotation = s);
  }
  parseClassProperty(t) {
    if (this.parseClassPropertyAnnotation(t), this.state.isAmbientContext && !(t.readonly && !t.typeAnnotation) && this.match(29) && this.raise(oe.DeclareClassFieldHasInitializer, this.state.startLoc), t.abstract && this.match(29)) {
      const {
        key: s
      } = t;
      this.raise(oe.AbstractPropertyHasInitializer, this.state.startLoc, {
        propertyName: s.type === "Identifier" && !t.computed ? s.name : `[${this.input.slice(s.start, s.end)}]`
      });
    }
    return super.parseClassProperty(t);
  }
  parseClassPrivateProperty(t) {
    return t.abstract && this.raise(oe.PrivateElementHasAbstract, t), t.accessibility && this.raise(oe.PrivateElementHasAccessibility, t, {
      modifier: t.accessibility
    }), this.parseClassPropertyAnnotation(t), super.parseClassPrivateProperty(t);
  }
  parseClassAccessorProperty(t) {
    return this.parseClassPropertyAnnotation(t), t.optional && this.raise(oe.AccessorCannotBeOptional, t), super.parseClassAccessorProperty(t);
  }
  pushClassMethod(t, s, i, n, a, o) {
    const u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    u && a && this.raise(oe.ConstructorHasTypeParameters, u);
    const {
      declare: l = !1,
      kind: c
    } = s;
    l && (c === "get" || c === "set") && this.raise(oe.DeclareAccessor, s, {
      kind: c
    }), u && (s.typeParameters = u), super.pushClassMethod(t, s, i, n, a, o);
  }
  pushClassPrivateMethod(t, s, i, n) {
    const a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    a && (s.typeParameters = a), super.pushClassPrivateMethod(t, s, i, n);
  }
  declareClassPrivateMethodInScope(t, s) {
    t.type !== "TSDeclareMethod" && (t.type === "MethodDefinition" && !hasOwnProperty.call(t.value, "body") || super.declareClassPrivateMethodInScope(t, s));
  }
  parseClassSuper(t) {
    super.parseClassSuper(t), t.superClass && (this.match(47) || this.match(51)) && (t.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (t.implements = this.tsParseHeritageClause("implements"));
  }
  parseObjPropValue(t, s, i, n, a, o, u) {
    const l = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    return l && (t.typeParameters = l), super.parseObjPropValue(t, s, i, n, a, o, u);
  }
  parseFunctionParams(t, s) {
    const i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    i && (t.typeParameters = i), super.parseFunctionParams(t, s);
  }
  parseVarId(t, s) {
    super.parseVarId(t, s), t.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (t.definite = !0);
    const i = this.tsTryParseTypeAnnotation();
    i && (t.id.typeAnnotation = i, this.resetEndLocation(t.id));
  }
  parseAsyncArrowFromCallExpression(t, s) {
    return this.match(14) && (t.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(t, s);
  }
  parseMaybeAssign(t, s) {
    var i, n, a, o, u;
    let l, c, f;
    if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
      if (l = this.state.clone(), c = this.tryParse(() => super.parseMaybeAssign(t, s), l), !c.error) return c.node;
      const {
        context: m
      } = this.state, d = m[m.length - 1];
      (d === Ue.j_oTag || d === Ue.j_expr) && m.pop();
    }
    if (!((i = c) != null && i.error) && !this.match(47))
      return super.parseMaybeAssign(t, s);
    (!l || l === this.state) && (l = this.state.clone());
    let p;
    const h = this.tryParse((m) => {
      var d, y;
      p = this.tsParseTypeParameters(this.tsParseConstModifier);
      const S = super.parseMaybeAssign(t, s);
      return (S.type !== "ArrowFunctionExpression" || (d = S.extra) != null && d.parenthesized) && m(), ((y = p) == null ? void 0 : y.params.length) !== 0 && this.resetStartLocationFromNode(S, p), S.typeParameters = p, S;
    }, l);
    if (!h.error && !h.aborted)
      return p && this.reportReservedArrowTypeParam(p), h.node;
    if (!c && (by(!this.hasPlugin("jsx")), f = this.tryParse(() => super.parseMaybeAssign(t, s), l), !f.error))
      return f.node;
    if ((n = c) != null && n.node)
      return this.state = c.failState, c.node;
    if (h.node)
      return this.state = h.failState, p && this.reportReservedArrowTypeParam(p), h.node;
    if ((a = f) != null && a.node)
      return this.state = f.failState, f.node;
    throw ((o = c) == null ? void 0 : o.error) || h.error || ((u = f) == null ? void 0 : u.error);
  }
  reportReservedArrowTypeParam(t) {
    var s;
    t.params.length === 1 && !t.params[0].constraint && !((s = t.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(oe.ReservedArrowTypeParam, t);
  }
  parseMaybeUnary(t, s) {
    return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(t, s);
  }
  parseArrow(t) {
    if (this.match(14)) {
      const s = this.tryParse((i) => {
        const n = this.tsParseTypeOrTypePredicateAnnotation(14);
        return (this.canInsertSemicolon() || !this.match(19)) && i(), n;
      });
      if (s.aborted) return;
      s.thrown || (s.error && (this.state = s.failState), t.returnType = s.node);
    }
    return super.parseArrow(t);
  }
  parseAssignableListItemTypes(t, s) {
    if (!(s & 2)) return t;
    this.eat(17) && (t.optional = !0);
    const i = this.tsTryParseTypeAnnotation();
    return i && (t.typeAnnotation = i), this.resetEndLocation(t), t;
  }
  isAssignable(t, s) {
    switch (t.type) {
      case "TSTypeCastExpression":
        return this.isAssignable(t.expression, s);
      case "TSParameterProperty":
        return !0;
      default:
        return super.isAssignable(t, s);
    }
  }
  toAssignable(t, s = !1) {
    switch (t.type) {
      case "ParenthesizedExpression":
        this.toAssignableParenthesizedExpression(t, s);
        break;
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        s ? this.expressionScope.recordArrowParameterBindingError(oe.UnexpectedTypeCastInParameter, t) : this.raise(oe.UnexpectedTypeCastInParameter, t), this.toAssignable(t.expression, s);
        break;
      case "AssignmentExpression":
        !s && t.left.type === "TSTypeCastExpression" && (t.left = this.typeCastToParameter(t.left));
      default:
        super.toAssignable(t, s);
    }
  }
  toAssignableParenthesizedExpression(t, s) {
    switch (t.expression.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
      case "ParenthesizedExpression":
        this.toAssignable(t.expression, s);
        break;
      default:
        super.toAssignable(t, s);
    }
  }
  checkToRestConversion(t, s) {
    switch (t.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        this.checkToRestConversion(t.expression, !1);
        break;
      default:
        super.checkToRestConversion(t, s);
    }
  }
  isValidLVal(t, s, i) {
    return yO({
      TSTypeCastExpression: !0,
      TSParameterProperty: "parameter",
      TSNonNullExpression: "expression",
      TSInstantiationExpression: "expression",
      TSAsExpression: (i !== 64 || !s) && ["expression", !0],
      TSSatisfiesExpression: (i !== 64 || !s) && ["expression", !0],
      TSTypeAssertion: (i !== 64 || !s) && ["expression", !0]
    }, t) || super.isValidLVal(t, s, i);
  }
  parseBindingAtom() {
    return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
  }
  parseMaybeDecoratorArguments(t) {
    if (this.match(47) || this.match(51)) {
      const s = this.tsParseTypeArgumentsInExpression();
      if (this.match(10)) {
        const i = super.parseMaybeDecoratorArguments(t);
        return i.typeParameters = s, i;
      }
      this.unexpected(null, 10);
    }
    return super.parseMaybeDecoratorArguments(t);
  }
  checkCommaAfterRest(t) {
    return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === t ? (this.next(), !1) : super.checkCommaAfterRest(t);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(35) || this.match(14) || super.isClassProperty();
  }
  parseMaybeDefault(t, s) {
    const i = super.parseMaybeDefault(t, s);
    return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(oe.TypeAnnotationAfterAssign, i.typeAnnotation), i;
  }
  getTokenFromCode(t) {
    if (this.state.inType) {
      if (t === 62) {
        this.finishOp(48, 1);
        return;
      }
      if (t === 60) {
        this.finishOp(47, 1);
        return;
      }
    }
    super.getTokenFromCode(t);
  }
  reScan_lt_gt() {
    const {
      type: t
    } = this.state;
    t === 47 ? (this.state.pos -= 1, this.readToken_lt()) : t === 48 && (this.state.pos -= 1, this.readToken_gt());
  }
  reScan_lt() {
    const {
      type: t
    } = this.state;
    return t === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : t;
  }
  toAssignableList(t, s, i) {
    for (let n = 0; n < t.length; n++) {
      const a = t[n];
      (a == null ? void 0 : a.type) === "TSTypeCastExpression" && (t[n] = this.typeCastToParameter(a));
    }
    super.toAssignableList(t, s, i);
  }
  typeCastToParameter(t) {
    return t.expression.typeAnnotation = t.typeAnnotation, this.resetEndLocation(t.expression, t.typeAnnotation.loc.end), t.expression;
  }
  shouldParseArrow(t) {
    return this.match(14) ? t.every((s) => this.isAssignable(s, !0)) : super.shouldParseArrow(t);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  canHaveLeadingDecorator() {
    return super.canHaveLeadingDecorator() || this.isAbstractClass();
  }
  jsxParseOpeningElementAfterName(t) {
    if (this.match(47) || this.match(51)) {
      const s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
      s && (t.typeParameters = s);
    }
    return super.jsxParseOpeningElementAfterName(t);
  }
  getGetterSetterExpectedParamCount(t) {
    const s = super.getGetterSetterExpectedParamCount(t), n = this.getObjectOrClassMethodParams(t)[0];
    return n && this.isThisParam(n) ? s + 1 : s;
  }
  parseCatchClauseParam() {
    const t = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
    return s && (t.typeAnnotation = s, this.resetEndLocation(t)), t;
  }
  tsInAmbientContext(t) {
    const s = this.state.isAmbientContext;
    this.state.isAmbientContext = !0;
    try {
      return t();
    } finally {
      this.state.isAmbientContext = s;
    }
  }
  parseClass(t, s, i) {
    const n = this.state.inAbstractClass;
    this.state.inAbstractClass = !!t.abstract;
    try {
      return super.parseClass(t, s, i);
    } finally {
      this.state.inAbstractClass = n;
    }
  }
  tsParseAbstractDeclaration(t, s) {
    if (this.match(80))
      return t.abstract = !0, this.maybeTakeDecorators(s, this.parseClass(t, !0, !1));
    if (this.isContextual(129)) {
      if (!this.hasFollowingLineBreak())
        return t.abstract = !0, this.raise(oe.NonClassMethodPropertyHasAbstractModifer, t), this.tsParseInterfaceDeclaration(t);
    } else
      this.unexpected(null, 80);
  }
  parseMethod(t, s, i, n, a, o, u) {
    const l = super.parseMethod(t, s, i, n, a, o, u);
    if (l.abstract && (this.hasPlugin("estree") ? !!l.value.body : !!l.body)) {
      const {
        key: f
      } = l;
      this.raise(oe.AbstractMethodHasImplementation, l, {
        methodName: f.type === "Identifier" && !l.computed ? f.name : `[${this.input.slice(f.start, f.end)}]`
      });
    }
    return l;
  }
  tsParseTypeParameterName() {
    return this.parseIdentifier().name;
  }
  shouldParseAsAmbientContext() {
    return !!this.getPluginOption("typescript", "dts");
  }
  parse() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
  }
  getExpression() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
  }
  parseExportSpecifier(t, s, i, n) {
    return !s && n ? (this.parseTypeOnlyImportExportSpecifier(t, !1, i), this.finishNode(t, "ExportSpecifier")) : (t.exportKind = "value", super.parseExportSpecifier(t, s, i, n));
  }
  parseImportSpecifier(t, s, i, n, a) {
    return !s && n ? (this.parseTypeOnlyImportExportSpecifier(t, !0, i), this.finishNode(t, "ImportSpecifier")) : (t.importKind = "value", super.parseImportSpecifier(t, s, i, n, i ? 4098 : 4096));
  }
  parseTypeOnlyImportExportSpecifier(t, s, i) {
    const n = s ? "imported" : "local", a = s ? "local" : "exported";
    let o = t[n], u, l = !1, c = !0;
    const f = o.loc.start;
    if (this.isContextual(93)) {
      const h = this.parseIdentifier();
      if (this.isContextual(93)) {
        const m = this.parseIdentifier();
        Cr(this.state.type) ? (l = !0, o = h, u = s ? this.parseIdentifier() : this.parseModuleExportName(), c = !1) : (u = m, c = !1);
      } else Cr(this.state.type) ? (c = !1, u = s ? this.parseIdentifier() : this.parseModuleExportName()) : (l = !0, o = h);
    } else Cr(this.state.type) && (l = !0, s ? (o = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, !0, !0)) : o = this.parseModuleExportName());
    l && i && this.raise(s ? oe.TypeModifierIsUsedInTypeImports : oe.TypeModifierIsUsedInTypeExports, f), t[n] = o, t[a] = u;
    const p = s ? "importKind" : "exportKind";
    t[p] = l ? "type" : "value", c && this.eatContextual(93) && (t[a] = s ? this.parseIdentifier() : this.parseModuleExportName()), t[a] || (t[a] = Ss(t[n])), s && this.checkIdentifier(t[a], l ? 4098 : 4096);
  }
};
function _O(r) {
  if (r.type !== "MemberExpression") return !1;
  const {
    computed: e,
    property: t
  } = r;
  return e && t.type !== "StringLiteral" && (t.type !== "TemplateLiteral" || t.expressions.length > 0) ? !1 : bS(r.object);
}
function xO(r, e) {
  var t;
  const {
    type: s
  } = r;
  if ((t = r.extra) != null && t.parenthesized)
    return !1;
  if (e) {
    if (s === "Literal") {
      const {
        value: i
      } = r;
      if (typeof i == "string" || typeof i == "boolean")
        return !0;
    }
  } else if (s === "StringLiteral" || s === "BooleanLiteral")
    return !0;
  return !!(yS(r, e) || wO(r, e) || s === "TemplateLiteral" && r.expressions.length === 0 || _O(r));
}
function yS(r, e) {
  return e ? r.type === "Literal" && (typeof r.value == "number" || "bigint" in r) : r.type === "NumericLiteral" || r.type === "BigIntLiteral";
}
function wO(r, e) {
  if (r.type === "UnaryExpression") {
    const {
      operator: t,
      argument: s
    } = r;
    if (t === "-" && yS(s, e))
      return !0;
  }
  return !1;
}
function bS(r) {
  return r.type === "Identifier" ? !0 : r.type !== "MemberExpression" || r.computed ? !1 : bS(r.object);
}
const Ey = gs`placeholders`({
  ClassNameIsRequired: "A class name is required.",
  UnexpectedSpace: "Unexpected space in placeholder."
});
var TO = (r) => class extends r {
  parsePlaceholder(t) {
    if (this.match(144)) {
      const s = this.startNode();
      return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(s, t);
    }
  }
  finishPlaceholder(t, s) {
    let i = t;
    return (!i.expectedNode || !i.type) && (i = this.finishNode(i, "Placeholder")), i.expectedNode = s, i;
  }
  getTokenFromCode(t) {
    t === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(t);
  }
  parseExprAtom(t) {
    return this.parsePlaceholder("Expression") || super.parseExprAtom(t);
  }
  parseIdentifier(t) {
    return this.parsePlaceholder("Identifier") || super.parseIdentifier(t);
  }
  checkReservedWord(t, s, i, n) {
    t !== void 0 && super.checkReservedWord(t, s, i, n);
  }
  parseBindingAtom() {
    return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
  }
  isValidLVal(t, s, i) {
    return t === "Placeholder" || super.isValidLVal(t, s, i);
  }
  toAssignable(t, s) {
    t && t.type === "Placeholder" && t.expectedNode === "Expression" ? t.expectedNode = "Pattern" : super.toAssignable(t, s);
  }
  chStartsBindingIdentifier(t, s) {
    return !!(super.chStartsBindingIdentifier(t, s) || this.lookahead().type === 144);
  }
  verifyBreakContinue(t, s) {
    t.label && t.label.type === "Placeholder" || super.verifyBreakContinue(t, s);
  }
  parseExpressionStatement(t, s) {
    var i;
    if (s.type !== "Placeholder" || (i = s.extra) != null && i.parenthesized)
      return super.parseExpressionStatement(t, s);
    if (this.match(14)) {
      const a = t;
      return a.label = this.finishPlaceholder(s, "Identifier"), this.next(), a.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(a, "LabeledStatement");
    }
    this.semicolon();
    const n = t;
    return n.name = s.name, this.finishPlaceholder(n, "Statement");
  }
  parseBlock(t, s, i) {
    return this.parsePlaceholder("BlockStatement") || super.parseBlock(t, s, i);
  }
  parseFunctionId(t) {
    return this.parsePlaceholder("Identifier") || super.parseFunctionId(t);
  }
  parseClass(t, s, i) {
    const n = s ? "ClassDeclaration" : "ClassExpression";
    this.next();
    const a = this.state.strict, o = this.parsePlaceholder("Identifier");
    if (o)
      if (this.match(81) || this.match(144) || this.match(5))
        t.id = o;
      else {
        if (i || !s)
          return t.id = null, t.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(t, n);
        throw this.raise(Ey.ClassNameIsRequired, this.state.startLoc);
      }
    else
      this.parseClassId(t, s, i);
    return super.parseClassSuper(t), t.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!t.superClass, a), this.finishNode(t, n);
  }
  parseExport(t, s) {
    const i = this.parsePlaceholder("Identifier");
    if (!i) return super.parseExport(t, s);
    const n = t;
    if (!this.isContextual(98) && !this.match(12))
      return n.specifiers = [], n.source = null, n.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(n, "ExportNamedDeclaration");
    this.expectPlugin("exportDefaultFrom");
    const a = this.startNode();
    return a.exported = i, n.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(n, s);
  }
  isExportDefaultSpecifier() {
    if (this.match(65)) {
      const t = this.nextTokenStart();
      if (this.isUnparsedContextual(t, "from") && this.input.startsWith(si(144), this.nextTokenStartSince(t + 4)))
        return !0;
    }
    return super.isExportDefaultSpecifier();
  }
  maybeParseExportDefaultSpecifier(t, s) {
    var i;
    return (i = t.specifiers) != null && i.length ? !0 : super.maybeParseExportDefaultSpecifier(t, s);
  }
  checkExport(t) {
    const {
      specifiers: s
    } = t;
    s != null && s.length && (t.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(t), t.specifiers = s;
  }
  parseImport(t) {
    const s = this.parsePlaceholder("Identifier");
    if (!s) return super.parseImport(t);
    if (t.specifiers = [], !this.isContextual(98) && !this.match(12))
      return t.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(t, "ImportDeclaration");
    const i = this.startNodeAtNode(s);
    return i.local = s, t.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(t) || this.parseNamedImportSpecifiers(t)), this.expectContextual(98), t.source = this.parseImportSource(), this.semicolon(), this.finishNode(t, "ImportDeclaration");
  }
  parseImportSource() {
    return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
  }
  assertNoSpace() {
    this.state.start > this.state.lastTokEndLoc.index && this.raise(Ey.UnexpectedSpace, this.state.lastTokEndLoc);
  }
}, PO = (r) => class extends r {
  parseV8Intrinsic() {
    if (this.match(54)) {
      const t = this.state.startLoc, s = this.startNode();
      if (this.next(), Le(this.state.type)) {
        const i = this.parseIdentifierName(), n = this.createIdentifier(s, i);
        if (n.type = "V8IntrinsicIdentifier", this.match(10))
          return n;
      }
      this.unexpected(t);
    }
  }
  parseExprAtom(t) {
    return this.parseV8Intrinsic() || super.parseExprAtom(t);
  }
};
function lt(r, e) {
  const [t, s] = typeof e == "string" ? [e, {}] : e, i = Object.keys(s), n = i.length === 0;
  return r.some((a) => {
    if (typeof a == "string")
      return n && a === t;
    {
      const [o, u] = a;
      if (o !== t)
        return !1;
      for (const l of i)
        if (u[l] !== s[l])
          return !1;
      return !0;
    }
  });
}
function vi(r, e, t) {
  const s = r.find((i) => Array.isArray(i) ? i[0] === e : i === e);
  return s && Array.isArray(s) && s.length > 1 ? s[1][t] : null;
}
const Sy = ["minimal", "fsharp", "hack", "smart"], _y = ["^^", "@@", "^", "%", "#"];
function AO(r) {
  if (lt(r, "decorators")) {
    if (lt(r, "decorators-legacy"))
      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    const e = vi(r, "decorators", "decoratorsBeforeExport");
    if (e != null && typeof e != "boolean")
      throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
    const t = vi(r, "decorators", "allowCallParenthesized");
    if (t != null && typeof t != "boolean")
      throw new Error("'allowCallParenthesized' must be a boolean.");
  }
  if (lt(r, "flow") && lt(r, "typescript"))
    throw new Error("Cannot combine flow and typescript plugins.");
  if (lt(r, "placeholders") && lt(r, "v8intrinsic"))
    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
  if (lt(r, "pipelineOperator")) {
    const e = vi(r, "pipelineOperator", "proposal");
    if (!Sy.includes(e)) {
      const i = Sy.map((n) => `"${n}"`).join(", ");
      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
    }
    const t = ["recordAndTuple", {
      syntaxType: "hash"
    }], s = lt(r, t);
    if (e === "hack") {
      if (lt(r, "placeholders"))
        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
      if (lt(r, "v8intrinsic"))
        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
      const i = vi(r, "pipelineOperator", "topicToken");
      if (!_y.includes(i)) {
        const n = _y.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${n}.`);
      }
      if (i === "#" && s)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(t)}\`.`);
    } else if (e === "smart" && s)
      throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(t)}\`.`);
  }
  if (lt(r, "moduleAttributes")) {
    if (lt(r, "importAssertions") || lt(r, "importAttributes"))
      throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
    if (vi(r, "moduleAttributes", "version") !== "may-2020")
      throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
  }
  if (lt(r, "importAssertions") && lt(r, "importAttributes"))
    throw new Error("Cannot combine importAssertions and importAttributes plugins.");
  if (lt(r, "recordAndTuple")) {
    const e = vi(r, "recordAndTuple", "syntaxType");
    if (e != null) {
      const t = ["hash", "bar"];
      if (!t.includes(e))
        throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + t.map((s) => `'${s}'`).join(", "));
    }
  }
  if (lt(r, "asyncDoExpressions") && !lt(r, "doExpressions")) {
    const e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
    throw e.missingPlugins = "doExpressions", e;
  }
  if (lt(r, "optionalChainingAssign") && vi(r, "optionalChainingAssign", "version") !== "2023-07")
    throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
}
const vS = {
  estree: dN,
  jsx: pO,
  flow: cO,
  typescript: SO,
  v8intrinsic: PO,
  placeholders: TO
}, CO = Object.keys(vS), Mf = {
  sourceType: "script",
  sourceFilename: void 0,
  startColumn: 0,
  startLine: 1,
  allowAwaitOutsideFunction: !1,
  allowReturnOutsideFunction: !1,
  allowNewTargetOutsideFunction: !1,
  allowImportExportEverywhere: !1,
  allowSuperOutsideMethod: !1,
  allowUndeclaredExports: !1,
  plugins: [],
  strictMode: null,
  ranges: !1,
  tokens: !1,
  createImportExpressions: !1,
  createParenthesizedExpressions: !1,
  errorRecovery: !1,
  attachComment: !0,
  annexB: !0
};
function NO(r) {
  if (r == null)
    return Object.assign({}, Mf);
  if (r.annexB != null && r.annexB !== !1)
    throw new Error("The `annexB` option can only be set to `false`.");
  const e = {};
  for (const s of Object.keys(Mf)) {
    var t;
    e[s] = (t = r[s]) != null ? t : Mf[s];
  }
  return e;
}
class OO extends gO {
  checkProto(e, t, s, i) {
    if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
      return;
    const n = e.key;
    if ((n.type === "Identifier" ? n.name : n.value) === "__proto__") {
      if (t) {
        this.raise(O.RecordNoProto, n);
        return;
      }
      s.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = n.loc.start) : this.raise(O.DuplicateProto, n)), s.used = !0;
    }
  }
  shouldExitDescending(e, t) {
    return e.type === "ArrowFunctionExpression" && e.start === t;
  }
  getExpression() {
    this.enterInitialScopes(), this.nextToken();
    const e = this.parseExpression();
    return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors, this.options.tokens && (e.tokens = this.tokens), e;
  }
  parseExpression(e, t) {
    return e ? this.disallowInAnd(() => this.parseExpressionBase(t)) : this.allowInAnd(() => this.parseExpressionBase(t));
  }
  parseExpressionBase(e) {
    const t = this.state.startLoc, s = this.parseMaybeAssign(e);
    if (this.match(12)) {
      const i = this.startNodeAt(t);
      for (i.expressions = [s]; this.eat(12); )
        i.expressions.push(this.parseMaybeAssign(e));
      return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
    }
    return s;
  }
  parseMaybeAssignDisallowIn(e, t) {
    return this.disallowInAnd(() => this.parseMaybeAssign(e, t));
  }
  parseMaybeAssignAllowIn(e, t) {
    return this.allowInAnd(() => this.parseMaybeAssign(e, t));
  }
  setOptionalParametersError(e, t) {
    var s;
    e.optionalParametersLoc = (s = t == null ? void 0 : t.loc) != null ? s : this.state.startLoc;
  }
  parseMaybeAssign(e, t) {
    const s = this.state.startLoc;
    if (this.isContextual(108) && this.prodParam.hasYield) {
      let o = this.parseYield();
      return t && (o = t.call(this, o, s)), o;
    }
    let i;
    e ? i = !1 : (e = new Fu(), i = !0);
    const {
      type: n
    } = this.state;
    (n === 10 || Le(n)) && (this.state.potentialArrowAt = this.state.start);
    let a = this.parseMaybeConditional(e);
    if (t && (a = t.call(this, a, s)), vN(this.state.type)) {
      const o = this.startNodeAt(s), u = this.state.value;
      if (o.operator = u, this.match(29)) {
        this.toAssignable(a, !0), o.left = a;
        const l = s.index;
        e.doubleProtoLoc != null && e.doubleProtoLoc.index >= l && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.index >= l && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= l && (this.checkDestructuringPrivate(e), e.privateKeyLoc = null);
      } else
        o.left = a;
      return this.next(), o.right = this.parseMaybeAssign(), this.checkLVal(a, {
        in: this.finishNode(o, "AssignmentExpression")
      }), o;
    } else i && this.checkExpressionErrors(e, !0);
    return a;
  }
  parseMaybeConditional(e) {
    const t = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprOps(e);
    return this.shouldExitDescending(i, s) ? i : this.parseConditional(i, t, e);
  }
  parseConditional(e, t, s) {
    if (this.eat(17)) {
      const i = this.startNodeAt(t);
      return i.test = e, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(i, "ConditionalExpression");
    }
    return e;
  }
  parseMaybeUnaryOrPrivate(e) {
    return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(e);
  }
  parseExprOps(e) {
    const t = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(e);
    return this.shouldExitDescending(i, s) ? i : this.parseExprOp(i, t, -1);
  }
  parseExprOp(e, t, s) {
    if (this.isPrivateName(e)) {
      const n = this.getPrivateNameSV(e);
      (s >= Mu(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(O.PrivateInExpectedIn, e, {
        identifierName: n
      }), this.classScope.usePrivateName(n, e.loc.start);
    }
    const i = this.state.type;
    if (SN(i) && (this.prodParam.hasIn || !this.match(58))) {
      let n = Mu(i);
      if (n > s) {
        if (i === 39) {
          if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
            return e;
          this.checkPipelineAtInfixOperator(e, t);
        }
        const a = this.startNodeAt(t);
        a.left = e, a.operator = this.state.value;
        const o = i === 41 || i === 42, u = i === 40;
        if (u && (n = Mu(42)), this.next(), i === 39 && this.hasPlugin(["pipelineOperator", {
          proposal: "minimal"
        }]) && this.state.type === 96 && this.prodParam.hasAwait)
          throw this.raise(O.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
        a.right = this.parseExprOpRightExpr(i, n);
        const l = this.finishNode(a, o || u ? "LogicalExpression" : "BinaryExpression"), c = this.state.type;
        if (u && (c === 41 || c === 42) || o && c === 40)
          throw this.raise(O.MixingCoalesceWithLogical, this.state.startLoc);
        return this.parseExprOp(l, t, s);
      }
    }
    return e;
  }
  parseExprOpRightExpr(e, t) {
    const s = this.state.startLoc;
    switch (e) {
      case 39:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
            return this.withTopicBindingContext(() => this.parseHackPipeBody());
          case "smart":
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(O.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, t), s);
            });
          case "fsharp":
            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t));
        }
      default:
        return this.parseExprOpBaseRightExpr(e, t);
    }
  }
  parseExprOpBaseRightExpr(e, t) {
    const s = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, PN(e) ? t - 1 : t);
  }
  parseHackPipeBody() {
    var e;
    const {
      startLoc: t
    } = this.state, s = this.parseMaybeAssign();
    return uN.has(s.type) && !((e = s.extra) != null && e.parenthesized) && this.raise(O.PipeUnparenthesizedBody, t, {
      type: s.type
    }), this.topicReferenceWasUsedInCurrentContext() || this.raise(O.PipeTopicUnused, t), s;
  }
  checkExponentialAfterUnary(e) {
    this.match(57) && this.raise(O.UnexpectedTokenUnaryExponentiation, e.argument);
  }
  parseMaybeUnary(e, t) {
    const s = this.state.startLoc, i = this.isContextual(96);
    if (i && this.isAwaitAllowed()) {
      this.next();
      const u = this.parseAwait(s);
      return t || this.checkExponentialAfterUnary(u), u;
    }
    const n = this.match(34), a = this.startNode();
    if (xN(this.state.type)) {
      a.operator = this.state.value, a.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
      const u = this.match(89);
      if (this.next(), a.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
        const l = a.argument;
        l.type === "Identifier" ? this.raise(O.StrictDelete, a) : this.hasPropertyAsPrivateName(l) && this.raise(O.DeletePrivateField, a);
      }
      if (!n)
        return t || this.checkExponentialAfterUnary(a), this.finishNode(a, "UnaryExpression");
    }
    const o = this.parseUpdate(a, n, e);
    if (i) {
      const {
        type: u
      } = this.state;
      if ((this.hasPlugin("v8intrinsic") ? Rp(u) : Rp(u) && !this.match(54)) && !this.isAmbiguousAwait())
        return this.raiseOverwrite(O.AwaitNotInAsyncContext, s), this.parseAwait(s);
    }
    return o;
  }
  parseUpdate(e, t, s) {
    if (t) {
      const a = e;
      return this.checkLVal(a.argument, {
        in: this.finishNode(a, "UpdateExpression")
      }), e;
    }
    const i = this.state.startLoc;
    let n = this.parseExprSubscripts(s);
    if (this.checkExpressionErrors(s, !1)) return n;
    for (; _N(this.state.type) && !this.canInsertSemicolon(); ) {
      const a = this.startNodeAt(i);
      a.operator = this.state.value, a.prefix = !1, a.argument = n, this.next(), this.checkLVal(n, {
        in: n = this.finishNode(a, "UpdateExpression")
      });
    }
    return n;
  }
  parseExprSubscripts(e) {
    const t = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprAtom(e);
    return this.shouldExitDescending(i, s) ? i : this.parseSubscripts(i, t);
  }
  parseSubscripts(e, t, s) {
    const i = {
      optionalChainMember: !1,
      maybeAsyncArrow: this.atPossibleAsyncArrow(e),
      stop: !1
    };
    do
      e = this.parseSubscript(e, t, s, i), i.maybeAsyncArrow = !1;
    while (!i.stop);
    return e;
  }
  parseSubscript(e, t, s, i) {
    const {
      type: n
    } = this.state;
    if (!s && n === 15)
      return this.parseBind(e, t, s, i);
    if (El(n))
      return this.parseTaggedTemplateExpression(e, t, i);
    let a = !1;
    if (n === 18) {
      if (s && (this.raise(O.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
        return i.stop = !0, e;
      i.optionalChainMember = a = !0, this.next();
    }
    if (!s && this.match(10))
      return this.parseCoverCallAndAsyncArrowHead(e, t, i, a);
    {
      const o = this.eat(0);
      return o || a || this.eat(16) ? this.parseMember(e, t, i, o, a) : (i.stop = !0, e);
    }
  }
  parseMember(e, t, s, i, n) {
    const a = this.startNodeAt(t);
    return a.object = e, a.computed = i, i ? (a.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (e.type === "Super" && this.raise(O.SuperPrivateField, t), this.classScope.usePrivateName(this.state.value, this.state.startLoc), a.property = this.parsePrivateName()) : a.property = this.parseIdentifier(!0), s.optionalChainMember ? (a.optional = n, this.finishNode(a, "OptionalMemberExpression")) : this.finishNode(a, "MemberExpression");
  }
  parseBind(e, t, s, i) {
    const n = this.startNodeAt(t);
    return n.object = e, this.next(), n.callee = this.parseNoCallExpr(), i.stop = !0, this.parseSubscripts(this.finishNode(n, "BindExpression"), t, s);
  }
  parseCoverCallAndAsyncArrowHead(e, t, s, i) {
    const n = this.state.maybeInArrowParameters;
    let a = null;
    this.state.maybeInArrowParameters = !0, this.next();
    const o = this.startNodeAt(t);
    o.callee = e;
    const {
      maybeAsyncArrow: u,
      optionalChainMember: l
    } = s;
    u && (this.expressionScope.enter(ZN()), a = new Fu()), l && (o.optional = i), i ? o.arguments = this.parseCallExpressionArguments(11) : o.arguments = this.parseCallExpressionArguments(11, e.type === "Import", e.type !== "Super", o, a);
    let c = this.finishCallExpression(o, l);
    return u && this.shouldParseAsyncArrow() && !i ? (s.stop = !0, this.checkDestructuringPrivate(a), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t), c)) : (u && (this.checkExpressionErrors(a, !0), this.expressionScope.exit()), this.toReferencedArguments(c)), this.state.maybeInArrowParameters = n, c;
  }
  toReferencedArguments(e, t) {
    this.toReferencedListDeep(e.arguments, t);
  }
  parseTaggedTemplateExpression(e, t, s) {
    const i = this.startNodeAt(t);
    return i.tag = e, i.quasi = this.parseTemplate(!0), s.optionalChainMember && this.raise(O.OptionalChainingNoTemplate, t), this.finishNode(i, "TaggedTemplateExpression");
  }
  atPossibleAsyncArrow(e) {
    return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end - e.start === 5 && e.start === this.state.potentialArrowAt;
  }
  expectImportAttributesPlugin() {
    this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
  }
  finishCallExpression(e, t) {
    if (e.callee.type === "Import")
      if (e.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), e.arguments.length === 0 || e.arguments.length > 2)
        this.raise(O.ImportCallArity, e, {
          maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
        });
      else
        for (const s of e.arguments)
          s.type === "SpreadElement" && this.raise(O.ImportCallSpreadArgument, s);
    return this.finishNode(e, t ? "OptionalCallExpression" : "CallExpression");
  }
  parseCallExpressionArguments(e, t, s, i, n) {
    const a = [];
    let o = !0;
    const u = this.state.inFSharpPipelineDirectBody;
    for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
      if (o)
        o = !1;
      else if (this.expect(12), this.match(e)) {
        t && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(O.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i && this.addTrailingCommaExtraToNode(i), this.next();
        break;
      }
      a.push(this.parseExprListItem(!1, n, s));
    }
    return this.state.inFSharpPipelineDirectBody = u, a;
  }
  shouldParseAsyncArrow() {
    return this.match(19) && !this.canInsertSemicolon();
  }
  parseAsyncArrowFromCallExpression(e, t) {
    var s;
    return this.resetPreviousNodeTrailingComments(t), this.expect(19), this.parseArrowExpression(e, t.arguments, !0, (s = t.extra) == null ? void 0 : s.trailingCommaLoc), t.innerComments && fo(e, t.innerComments), t.callee.trailingComments && fo(e, t.callee.trailingComments), e;
  }
  parseNoCallExpr() {
    const e = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), e, !0);
  }
  parseExprAtom(e) {
    let t, s = null;
    const {
      type: i
    } = this.state;
    switch (i) {
      case 79:
        return this.parseSuper();
      case 83:
        return t = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(t) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(t) : this.finishNode(t, "Import") : (this.raise(O.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(t, "Import"));
      case 78:
        return t = this.startNode(), this.next(), this.finishNode(t, "ThisExpression");
      case 90:
        return this.parseDo(this.startNode(), !1);
      case 56:
      case 31:
        return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
      case 134:
        return this.parseNumericLiteral(this.state.value);
      case 135:
        return this.parseBigIntLiteral(this.state.value);
      case 136:
        return this.parseDecimalLiteral(this.state.value);
      case 133:
        return this.parseStringLiteral(this.state.value);
      case 84:
        return this.parseNullLiteral();
      case 85:
        return this.parseBooleanLiteral(!0);
      case 86:
        return this.parseBooleanLiteral(!1);
      case 10: {
        const n = this.state.potentialArrowAt === this.state.start;
        return this.parseParenAndDistinguishExpression(n);
      }
      case 2:
      case 1:
        return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
      case 0:
        return this.parseArrayLike(3, !0, !1, e);
      case 6:
      case 7:
        return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
      case 5:
        return this.parseObjectLike(8, !1, !1, e);
      case 68:
        return this.parseFunctionOrFunctionSent();
      case 26:
        s = this.parseDecorators();
      case 80:
        return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), !1);
      case 77:
        return this.parseNewOrNewTarget();
      case 25:
      case 24:
        return this.parseTemplate(!1);
      case 15: {
        t = this.startNode(), this.next(), t.object = null;
        const n = t.callee = this.parseNoCallExpr();
        if (n.type === "MemberExpression")
          return this.finishNode(t, "BindExpression");
        throw this.raise(O.UnsupportedBind, n);
      }
      case 138:
        return this.raise(O.PrivateInExpectedIn, this.state.startLoc, {
          identifierName: this.state.value
        }), this.parsePrivateName();
      case 33:
        return this.parseTopicReferenceThenEqualsSign(54, "%");
      case 32:
        return this.parseTopicReferenceThenEqualsSign(44, "^");
      case 37:
      case 38:
        return this.parseTopicReference("hack");
      case 44:
      case 54:
      case 27: {
        const n = this.getPluginOption("pipelineOperator", "proposal");
        if (n)
          return this.parseTopicReference(n);
        this.unexpected();
        break;
      }
      case 47: {
        const n = this.input.codePointAt(this.nextTokenStart());
        ms(n) || n === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
        break;
      }
      default:
        if (Le(i)) {
          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
            return this.parseModuleExpression();
          const n = this.state.potentialArrowAt === this.state.start, a = this.state.containsEsc, o = this.parseIdentifier();
          if (!a && o.name === "async" && !this.canInsertSemicolon()) {
            const {
              type: u
            } = this.state;
            if (u === 68)
              return this.resetPreviousNodeTrailingComments(o), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(o));
            if (Le(u))
              return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(o)) : o;
            if (u === 90)
              return this.resetPreviousNodeTrailingComments(o), this.parseDo(this.startNodeAtNode(o), !0);
          }
          return n && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(o), [o], !1)) : o;
        } else
          this.unexpected();
    }
  }
  parseTopicReferenceThenEqualsSign(e, t) {
    const s = this.getPluginOption("pipelineOperator", "proposal");
    if (s)
      return this.state.type = e, this.state.value = t, this.state.pos--, this.state.end--, this.state.endLoc = Ht(this.state.endLoc, -1), this.parseTopicReference(s);
    this.unexpected();
  }
  parseTopicReference(e) {
    const t = this.startNode(), s = this.state.startLoc, i = this.state.type;
    return this.next(), this.finishTopicReference(t, s, e, i);
  }
  finishTopicReference(e, t, s, i) {
    if (this.testTopicReferenceConfiguration(s, t, i)) {
      const n = s === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
      return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s === "smart" ? O.PrimaryTopicNotAllowed : O.PipeTopicUnbound, t), this.registerTopicReference(), this.finishNode(e, n);
    } else
      throw this.raise(O.PipeTopicUnconfiguredToken, t, {
        token: si(i)
      });
  }
  testTopicReferenceConfiguration(e, t, s) {
    switch (e) {
      case "hack":
        return this.hasPlugin(["pipelineOperator", {
          topicToken: si(s)
        }]);
      case "smart":
        return s === 27;
      default:
        throw this.raise(O.PipeTopicRequiresHackPipes, t);
    }
  }
  parseAsyncArrowUnaryFunction(e) {
    this.prodParam.enter($u(!0, this.prodParam.hasYield));
    const t = [this.parseIdentifier()];
    return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(O.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(e, t, !0);
  }
  parseDo(e, t) {
    this.expectPlugin("doExpressions"), t && this.expectPlugin("asyncDoExpressions"), e.async = t, this.next();
    const s = this.state.labels;
    return this.state.labels = [], t ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(), this.state.labels = s, this.finishNode(e, "DoExpression");
  }
  parseSuper() {
    const e = this.startNode();
    return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(O.SuperNotAllowed, e) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(O.UnexpectedSuper, e), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(O.UnsupportedSuper, e), this.finishNode(e, "Super");
  }
  parsePrivateName() {
    const e = this.startNode(), t = this.startNodeAt(Ht(this.state.startLoc, 1)), s = this.state.value;
    return this.next(), e.id = this.createIdentifier(t, s), this.finishNode(e, "PrivateName");
  }
  parseFunctionOrFunctionSent() {
    const e = this.startNode();
    if (this.next(), this.prodParam.hasYield && this.match(16)) {
      const t = this.createIdentifier(this.startNodeAtNode(e), "function");
      return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(e, t, "sent");
    }
    return this.parseFunction(e);
  }
  parseMetaProperty(e, t, s) {
    e.meta = t;
    const i = this.state.containsEsc;
    return e.property = this.parseIdentifier(!0), (e.property.name !== s || i) && this.raise(O.UnsupportedMetaProperty, e.property, {
      target: t.name,
      onlyValidPropertyName: s
    }), this.finishNode(e, "MetaProperty");
  }
  parseImportMetaProperty(e) {
    const t = this.createIdentifier(this.startNodeAtNode(e), "import");
    if (this.next(), this.isContextual(101))
      this.inModule || this.raise(O.ImportMetaOutsideModule, t), this.sawUnambiguousESM = !0;
    else if (this.isContextual(105) || this.isContextual(97)) {
      const s = this.isContextual(105);
      if (s || this.unexpected(), this.expectPlugin(s ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
        throw this.raise(O.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
          phase: this.state.value
        });
      return this.next(), e.phase = s ? "source" : "defer", this.parseImportCall(e);
    }
    return this.parseMetaProperty(e, t, "meta");
  }
  parseLiteralAtNode(e, t, s) {
    return this.addExtra(s, "rawValue", e), this.addExtra(s, "raw", this.input.slice(s.start, this.state.end)), s.value = e, this.next(), this.finishNode(s, t);
  }
  parseLiteral(e, t) {
    const s = this.startNode();
    return this.parseLiteralAtNode(e, t, s);
  }
  parseStringLiteral(e) {
    return this.parseLiteral(e, "StringLiteral");
  }
  parseNumericLiteral(e) {
    return this.parseLiteral(e, "NumericLiteral");
  }
  parseBigIntLiteral(e) {
    return this.parseLiteral(e, "BigIntLiteral");
  }
  parseDecimalLiteral(e) {
    return this.parseLiteral(e, "DecimalLiteral");
  }
  parseRegExpLiteral(e) {
    const t = this.parseLiteral(e.value, "RegExpLiteral");
    return t.pattern = e.pattern, t.flags = e.flags, t;
  }
  parseBooleanLiteral(e) {
    const t = this.startNode();
    return t.value = e, this.next(), this.finishNode(t, "BooleanLiteral");
  }
  parseNullLiteral() {
    const e = this.startNode();
    return this.next(), this.finishNode(e, "NullLiteral");
  }
  parseParenAndDistinguishExpression(e) {
    const t = this.state.startLoc;
    let s;
    this.next(), this.expressionScope.enter(QN());
    const i = this.state.maybeInArrowParameters, n = this.state.inFSharpPipelineDirectBody;
    this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
    const a = this.state.startLoc, o = [], u = new Fu();
    let l = !0, c, f;
    for (; !this.match(11); ) {
      if (l)
        l = !1;
      else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
        f = this.state.startLoc;
        break;
      }
      if (this.match(21)) {
        const m = this.state.startLoc;
        if (c = this.state.startLoc, o.push(this.parseParenItem(this.parseRestBinding(), m)), !this.checkCommaAfterRest(41))
          break;
      } else
        o.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
    }
    const p = this.state.lastTokEndLoc;
    this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = n;
    let h = this.startNodeAt(t);
    return e && this.shouldParseArrow(o) && (h = this.parseArrow(h)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(h, o, !1), h) : (this.expressionScope.exit(), o.length || this.unexpected(this.state.lastTokStartLoc), f && this.unexpected(f), c && this.unexpected(c), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(o, !0), o.length > 1 ? (s = this.startNodeAt(a), s.expressions = o, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s, p)) : s = o[0], this.wrapParenthesis(t, s));
  }
  wrapParenthesis(e, t) {
    if (!this.options.createParenthesizedExpressions)
      return this.addExtra(t, "parenthesized", !0), this.addExtra(t, "parenStart", e.index), this.takeSurroundingComments(t, e.index, this.state.lastTokEndLoc.index), t;
    const s = this.startNodeAt(e);
    return s.expression = t, this.finishNode(s, "ParenthesizedExpression");
  }
  shouldParseArrow(e) {
    return !this.canInsertSemicolon();
  }
  parseArrow(e) {
    if (this.eat(19))
      return e;
  }
  parseParenItem(e, t) {
    return e;
  }
  parseNewOrNewTarget() {
    const e = this.startNode();
    if (this.next(), this.match(16)) {
      const t = this.createIdentifier(this.startNodeAtNode(e), "new");
      this.next();
      const s = this.parseMetaProperty(e, t, "target");
      return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(O.UnexpectedNewTarget, s), s;
    }
    return this.parseNew(e);
  }
  parseNew(e) {
    if (this.parseNewCallee(e), this.eat(10)) {
      const t = this.parseExprList(11);
      this.toReferencedList(t), e.arguments = t;
    } else
      e.arguments = [];
    return this.finishNode(e, "NewExpression");
  }
  parseNewCallee(e) {
    const t = this.match(83), s = this.parseNoCallExpr();
    e.callee = s, t && (s.type === "Import" || s.type === "ImportExpression") && this.raise(O.ImportCallNotNewExpression, s);
  }
  parseTemplateElement(e) {
    const {
      start: t,
      startLoc: s,
      end: i,
      value: n
    } = this.state, a = t + 1, o = this.startNodeAt(Ht(s, 1));
    n === null && (e || this.raise(O.InvalidEscapeSequenceTemplate, Ht(this.state.firstInvalidTemplateEscapePos, 1)));
    const u = this.match(24), l = u ? -1 : -2, c = i + l;
    o.value = {
      raw: this.input.slice(a, c).replace(/\r\n?/g, `
`),
      cooked: n === null ? null : n.slice(1, l)
    }, o.tail = u, this.next();
    const f = this.finishNode(o, "TemplateElement");
    return this.resetEndLocation(f, Ht(this.state.lastTokEndLoc, l)), f;
  }
  parseTemplate(e) {
    const t = this.startNode();
    let s = this.parseTemplateElement(e);
    const i = [s], n = [];
    for (; !s.tail; )
      n.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i.push(s = this.parseTemplateElement(e));
    return t.expressions = n, t.quasis = i, this.finishNode(t, "TemplateLiteral");
  }
  parseTemplateSubstitution() {
    return this.parseExpression();
  }
  parseObjectLike(e, t, s, i) {
    s && this.expectPlugin("recordAndTuple");
    const n = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !1;
    const a = /* @__PURE__ */ Object.create(null);
    let o = !0;
    const u = this.startNode();
    for (u.properties = [], this.next(); !this.match(e); ) {
      if (o)
        o = !1;
      else if (this.expect(12), this.match(e)) {
        this.addTrailingCommaExtraToNode(u);
        break;
      }
      let c;
      t ? c = this.parseBindingProperty() : (c = this.parsePropertyDefinition(i), this.checkProto(c, s, a, i)), s && !this.isObjectProperty(c) && c.type !== "SpreadElement" && this.raise(O.InvalidRecordProperty, c), c.shorthand && this.addExtra(c, "shorthand", !0), u.properties.push(c);
    }
    this.next(), this.state.inFSharpPipelineDirectBody = n;
    let l = "ObjectExpression";
    return t ? l = "ObjectPattern" : s && (l = "RecordExpression"), this.finishNode(u, l);
  }
  addTrailingCommaExtraToNode(e) {
    this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
  }
  maybeAsyncOrAccessorProp(e) {
    return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
  }
  parsePropertyDefinition(e) {
    let t = [];
    if (this.match(26))
      for (this.hasPlugin("decorators") && this.raise(O.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
        t.push(this.parseDecorator());
    const s = this.startNode();
    let i = !1, n = !1, a;
    if (this.match(21))
      return t.length && this.unexpected(), this.parseSpread();
    t.length && (s.decorators = t, t = []), s.method = !1, e && (a = this.state.startLoc);
    let o = this.eat(55);
    this.parsePropertyNamePrefixOperator(s);
    const u = this.state.containsEsc;
    if (this.parsePropertyName(s, e), !o && !u && this.maybeAsyncOrAccessorProp(s)) {
      const {
        key: l
      } = s, c = l.name;
      c === "async" && !this.hasPrecedingLineBreak() && (i = !0, this.resetPreviousNodeTrailingComments(l), o = this.eat(55), this.parsePropertyName(s)), (c === "get" || c === "set") && (n = !0, this.resetPreviousNodeTrailingComments(l), s.kind = c, this.match(55) && (o = !0, this.raise(O.AccessorIsGenerator, this.state.curPosition(), {
        kind: c
      }), this.next()), this.parsePropertyName(s));
    }
    return this.parseObjPropValue(s, a, o, i, !1, n, e);
  }
  getGetterSetterExpectedParamCount(e) {
    return e.kind === "get" ? 0 : 1;
  }
  getObjectOrClassMethodParams(e) {
    return e.params;
  }
  checkGetterSetterParams(e) {
    var t;
    const s = this.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e);
    i.length !== s && this.raise(e.kind === "get" ? O.BadGetterArity : O.BadSetterArity, e), e.kind === "set" && ((t = i[i.length - 1]) == null ? void 0 : t.type) === "RestElement" && this.raise(O.BadSetterRestParameter, e);
  }
  parseObjectMethod(e, t, s, i, n) {
    if (n) {
      const a = this.parseMethod(e, t, !1, !1, !1, "ObjectMethod");
      return this.checkGetterSetterParams(a), a;
    }
    if (s || t || this.match(10))
      return i && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, t, s, !1, !1, "ObjectMethod");
  }
  parseObjectProperty(e, t, s, i) {
    if (e.shorthand = !1, this.eat(14))
      return e.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(e, "ObjectProperty");
    if (!e.computed && e.key.type === "Identifier") {
      if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), s)
        e.value = this.parseMaybeDefault(t, Ss(e.key));
      else if (this.match(29)) {
        const n = this.state.startLoc;
        i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = n) : this.raise(O.InvalidCoverInitializedName, n), e.value = this.parseMaybeDefault(t, Ss(e.key));
      } else
        e.value = Ss(e.key);
      return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
    }
  }
  parseObjPropValue(e, t, s, i, n, a, o) {
    const u = this.parseObjectMethod(e, s, i, n, a) || this.parseObjectProperty(e, t, n, o);
    return u || this.unexpected(), u;
  }
  parsePropertyName(e, t) {
    if (this.eat(0))
      e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
    else {
      const {
        type: s,
        value: i
      } = this.state;
      let n;
      if (Cr(s))
        n = this.parseIdentifier(!0);
      else
        switch (s) {
          case 134:
            n = this.parseNumericLiteral(i);
            break;
          case 133:
            n = this.parseStringLiteral(i);
            break;
          case 135:
            n = this.parseBigIntLiteral(i);
            break;
          case 136:
            n = this.parseDecimalLiteral(i);
            break;
          case 138: {
            const a = this.state.startLoc;
            t != null ? t.privateKeyLoc === null && (t.privateKeyLoc = a) : this.raise(O.UnexpectedPrivateField, a), n = this.parsePrivateName();
            break;
          }
          default:
            this.unexpected();
        }
      e.key = n, s !== 138 && (e.computed = !1);
    }
  }
  initFunction(e, t) {
    e.id = null, e.generator = !1, e.async = t;
  }
  parseMethod(e, t, s, i, n, a, o = !1) {
    this.initFunction(e, s), e.generator = t, this.scope.enter(18 | (o ? 64 : 0) | (n ? 32 : 0)), this.prodParam.enter($u(s, e.generator)), this.parseFunctionParams(e, i);
    const u = this.parseFunctionBodyAndFinish(e, a, !0);
    return this.prodParam.exit(), this.scope.exit(), u;
  }
  parseArrayLike(e, t, s, i) {
    s && this.expectPlugin("recordAndTuple");
    const n = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !1;
    const a = this.startNode();
    return this.next(), a.elements = this.parseExprList(e, !s, i, a), this.state.inFSharpPipelineDirectBody = n, this.finishNode(a, s ? "TupleExpression" : "ArrayExpression");
  }
  parseArrowExpression(e, t, s, i) {
    this.scope.enter(6);
    let n = $u(s, !1);
    !this.match(5) && this.prodParam.hasIn && (n |= 8), this.prodParam.enter(n), this.initFunction(e, s);
    const a = this.state.maybeInArrowParameters;
    return t && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, t, i)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a, this.finishNode(e, "ArrowFunctionExpression");
  }
  setArrowFunctionParameters(e, t, s) {
    this.toAssignableList(t, s, !1), e.params = t;
  }
  parseFunctionBodyAndFinish(e, t, s = !1) {
    return this.parseFunctionBody(e, !1, s), this.finishNode(e, t);
  }
  parseFunctionBody(e, t, s = !1) {
    const i = t && !this.match(5);
    if (this.expressionScope.enter(mS()), i)
      e.body = this.parseMaybeAssign(), this.checkParams(e, !1, t, !1);
    else {
      const n = this.state.strict, a = this.state.labels;
      this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (o) => {
        const u = !this.isSimpleParamList(e.params);
        o && u && this.raise(O.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
        const l = !n && this.state.strict;
        this.checkParams(e, !this.state.strict && !t && !s && !u, t, l), this.state.strict && e.id && this.checkIdentifier(e.id, 65, l);
      }), this.prodParam.exit(), this.state.labels = a;
    }
    this.expressionScope.exit();
  }
  isSimpleParameter(e) {
    return e.type === "Identifier";
  }
  isSimpleParamList(e) {
    for (let t = 0, s = e.length; t < s; t++)
      if (!this.isSimpleParameter(e[t])) return !1;
    return !0;
  }
  checkParams(e, t, s, i = !0) {
    const n = !t && /* @__PURE__ */ new Set(), a = {
      type: "FormalParameters"
    };
    for (const o of e.params)
      this.checkLVal(o, {
        in: a,
        binding: 5,
        checkClashes: n,
        strictModeChanged: i
      });
  }
  parseExprList(e, t, s, i) {
    const n = [];
    let a = !0;
    for (; !this.eat(e); ) {
      if (a)
        a = !1;
      else if (this.expect(12), this.match(e)) {
        i && this.addTrailingCommaExtraToNode(i), this.next();
        break;
      }
      n.push(this.parseExprListItem(t, s));
    }
    return n;
  }
  parseExprListItem(e, t, s) {
    let i;
    if (this.match(12))
      e || this.raise(O.UnexpectedToken, this.state.curPosition(), {
        unexpected: ","
      }), i = null;
    else if (this.match(21)) {
      const n = this.state.startLoc;
      i = this.parseParenItem(this.parseSpread(t), n);
    } else if (this.match(17)) {
      this.expectPlugin("partialApplication"), s || this.raise(O.UnexpectedArgumentPlaceholder, this.state.startLoc);
      const n = this.startNode();
      this.next(), i = this.finishNode(n, "ArgumentPlaceholder");
    } else
      i = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
    return i;
  }
  parseIdentifier(e) {
    const t = this.startNode(), s = this.parseIdentifierName(e);
    return this.createIdentifier(t, s);
  }
  createIdentifier(e, t) {
    return e.name = t, e.loc.identifierName = t, this.finishNode(e, "Identifier");
  }
  parseIdentifierName(e) {
    let t;
    const {
      startLoc: s,
      type: i
    } = this.state;
    Cr(i) ? t = this.state.value : this.unexpected();
    const n = yN(i);
    return e ? n && this.replaceToken(132) : this.checkReservedWord(t, s, n, !1), this.next(), t;
  }
  checkReservedWord(e, t, s, i) {
    if (e.length > 10 || !RN(e))
      return;
    if (s && DN(e)) {
      this.raise(O.UnexpectedKeyword, t, {
        keyword: e
      });
      return;
    }
    if ((this.state.strict ? i ? lS : oS : aS)(e, this.inModule)) {
      this.raise(O.UnexpectedReservedWord, t, {
        reservedWord: e
      });
      return;
    } else if (e === "yield") {
      if (this.prodParam.hasYield) {
        this.raise(O.YieldBindingIdentifier, t);
        return;
      }
    } else if (e === "await") {
      if (this.prodParam.hasAwait) {
        this.raise(O.AwaitBindingIdentifier, t);
        return;
      }
      if (this.scope.inStaticBlock) {
        this.raise(O.AwaitBindingIdentifierInStaticBlock, t);
        return;
      }
      this.expressionScope.recordAsyncArrowParametersError(t);
    } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
      this.raise(O.ArgumentsInClass, t);
      return;
    }
  }
  isAwaitAllowed() {
    return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
  }
  parseAwait(e) {
    const t = this.startNodeAt(e);
    return this.expressionScope.recordParameterInitializerError(O.AwaitExpressionFormalParameter, t), this.eat(55) && this.raise(O.ObsoleteAwaitStar, t), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (t.argument = this.parseMaybeUnary(null, !0)), this.finishNode(t, "AwaitExpression");
  }
  isAmbiguousAwait() {
    if (this.hasPrecedingLineBreak()) return !0;
    const {
      type: e
    } = this.state;
    return e === 53 || e === 10 || e === 0 || El(e) || e === 102 && !this.state.containsEsc || e === 137 || e === 56 || this.hasPlugin("v8intrinsic") && e === 54;
  }
  parseYield() {
    const e = this.startNode();
    this.expressionScope.recordParameterInitializerError(O.YieldInParameter, e), this.next();
    let t = !1, s = null;
    if (!this.hasPrecedingLineBreak())
      switch (t = this.eat(55), this.state.type) {
        case 13:
        case 139:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
          if (!t) break;
        default:
          s = this.parseMaybeAssign();
      }
    return e.delegate = t, e.argument = s, this.finishNode(e, "YieldExpression");
  }
  parseImportCall(e) {
    return this.next(), e.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(e, "ImportExpression");
  }
  checkPipelineAtInfixOperator(e, t) {
    this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }]) && e.type === "SequenceExpression" && this.raise(O.PipelineHeadSequenceExpression, t);
  }
  parseSmartPipelineBodyInStyle(e, t) {
    if (this.isSimpleReference(e)) {
      const s = this.startNodeAt(t);
      return s.callee = e, this.finishNode(s, "PipelineBareFunction");
    } else {
      const s = this.startNodeAt(t);
      return this.checkSmartPipeTopicBodyEarlyErrors(t), s.expression = e, this.finishNode(s, "PipelineTopicExpression");
    }
  }
  isSimpleReference(e) {
    switch (e.type) {
      case "MemberExpression":
        return !e.computed && this.isSimpleReference(e.object);
      case "Identifier":
        return !0;
      default:
        return !1;
    }
  }
  checkSmartPipeTopicBodyEarlyErrors(e) {
    if (this.match(19))
      throw this.raise(O.PipelineBodyNoArrow, this.state.startLoc);
    this.topicReferenceWasUsedInCurrentContext() || this.raise(O.PipelineTopicUnused, e);
  }
  withTopicBindingContext(e) {
    const t = this.state.topicContext;
    this.state.topicContext = {
      maxNumOfResolvableTopics: 1,
      maxTopicIndex: null
    };
    try {
      return e();
    } finally {
      this.state.topicContext = t;
    }
  }
  withSmartMixTopicForbiddingContext(e) {
    if (this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }])) {
      const t = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = t;
      }
    } else
      return e();
  }
  withSoloAwaitPermittingContext(e) {
    const t = this.state.soloAwait;
    this.state.soloAwait = !0;
    try {
      return e();
    } finally {
      this.state.soloAwait = t;
    }
  }
  allowInAnd(e) {
    const t = this.prodParam.currentFlags();
    if (8 & ~t) {
      this.prodParam.enter(t | 8);
      try {
        return e();
      } finally {
        this.prodParam.exit();
      }
    }
    return e();
  }
  disallowInAnd(e) {
    const t = this.prodParam.currentFlags();
    if (8 & t) {
      this.prodParam.enter(t & -9);
      try {
        return e();
      } finally {
        this.prodParam.exit();
      }
    }
    return e();
  }
  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0;
  }
  topicReferenceIsAllowedInCurrentContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
  }
  topicReferenceWasUsedInCurrentContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
  }
  parseFSharpPipelineBody(e) {
    const t = this.state.startLoc;
    this.state.potentialArrowAt = this.state.start;
    const s = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !0;
    const i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, e);
    return this.state.inFSharpPipelineDirectBody = s, i;
  }
  parseModuleExpression() {
    this.expectPlugin("moduleBlocks");
    const e = this.startNode();
    this.next(), this.match(5) || this.unexpected(null, 5);
    const t = this.startNodeAt(this.state.endLoc);
    this.next();
    const s = this.initializeScopes(!0);
    this.enterInitialScopes();
    try {
      e.body = this.parseProgram(t, 8, "module");
    } finally {
      s();
    }
    return this.finishNode(e, "ModuleExpression");
  }
  parsePropertyNamePrefixOperator(e) {
  }
}
const Rf = {
  kind: 1
}, IO = {
  kind: 2
}, kO = /[\uD800-\uDFFF]/u, $f = /in(?:stanceof)?/y;
function DO(r, e) {
  for (let t = 0; t < r.length; t++) {
    const s = r[t], {
      type: i
    } = s;
    if (typeof i == "number") {
      {
        if (i === 138) {
          const {
            loc: n,
            start: a,
            value: o,
            end: u
          } = s, l = a + 1, c = Ht(n.start, 1);
          r.splice(t, 1, new Vs({
            type: ls(27),
            value: "#",
            start: a,
            end: l,
            startLoc: n.start,
            endLoc: c
          }), new Vs({
            type: ls(132),
            value: o,
            start: l,
            end: u,
            startLoc: c,
            endLoc: n.end
          })), t++;
          continue;
        }
        if (El(i)) {
          const {
            loc: n,
            start: a,
            value: o,
            end: u
          } = s, l = a + 1, c = Ht(n.start, 1);
          let f;
          e.charCodeAt(a) === 96 ? f = new Vs({
            type: ls(22),
            value: "`",
            start: a,
            end: l,
            startLoc: n.start,
            endLoc: c
          }) : f = new Vs({
            type: ls(8),
            value: "}",
            start: a,
            end: l,
            startLoc: n.start,
            endLoc: c
          });
          let p, h, m, d;
          i === 24 ? (h = u - 1, m = Ht(n.end, -1), p = o === null ? null : o.slice(1, -1), d = new Vs({
            type: ls(22),
            value: "`",
            start: h,
            end: u,
            startLoc: m,
            endLoc: n.end
          })) : (h = u - 2, m = Ht(n.end, -2), p = o === null ? null : o.slice(1, -2), d = new Vs({
            type: ls(23),
            value: "${",
            start: h,
            end: u,
            startLoc: m,
            endLoc: n.end
          })), r.splice(t, 1, f, new Vs({
            type: ls(20),
            value: p,
            start: l,
            end: h,
            startLoc: c,
            endLoc: m
          }), d), t += 2;
          continue;
        }
      }
      s.type = ls(i);
    }
  }
  return r;
}
class LO extends OO {
  parseTopLevel(e, t) {
    return e.program = this.parseProgram(t), e.comments = this.comments, this.options.tokens && (e.tokens = DO(this.tokens, this.input)), this.finishNode(e, "File");
  }
  parseProgram(e, t = 139, s = this.options.sourceType) {
    if (e.sourceType = s, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, t), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
      for (const [n, a] of Array.from(this.scope.undefinedExports))
        this.raise(O.ModuleExportUndefined, a, {
          localName: n
        });
    let i;
    return t === 139 ? i = this.finishNode(e, "Program") : i = this.finishNodeAt(e, "Program", Ht(this.state.startLoc, -1)), i;
  }
  stmtToDirective(e) {
    const t = e;
    t.type = "Directive", t.value = t.expression, delete t.expression;
    const s = t.value, i = s.value, n = this.input.slice(s.start, s.end), a = s.value = n.slice(1, -1);
    return this.addExtra(s, "raw", n), this.addExtra(s, "rawValue", a), this.addExtra(s, "expressionValue", i), s.type = "DirectiveLiteral", t;
  }
  parseInterpreterDirective() {
    if (!this.match(28))
      return null;
    const e = this.startNode();
    return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
  }
  isLet() {
    return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
  }
  chStartsBindingIdentifier(e, t) {
    if (ms(e)) {
      if ($f.lastIndex = t, $f.test(this.input)) {
        const s = this.codePointAtPos($f.lastIndex);
        if (!Sn(s) && s !== 92)
          return !1;
      }
      return !0;
    } else return e === 92;
  }
  chStartsBindingPattern(e) {
    return e === 91 || e === 123;
  }
  hasFollowingBindingAtom() {
    const e = this.nextTokenStart(), t = this.codePointAtPos(e);
    return this.chStartsBindingPattern(t) || this.chStartsBindingIdentifier(t, e);
  }
  hasInLineFollowingBindingIdentifier() {
    const e = this.nextTokenInLineStart(), t = this.codePointAtPos(e);
    return this.chStartsBindingIdentifier(t, e);
  }
  startsUsingForOf() {
    const {
      type: e,
      containsEsc: t
    } = this.lookahead();
    if (e === 102 && !t)
      return !1;
    if (Le(e) && !this.hasFollowingLineBreak())
      return this.expectPlugin("explicitResourceManagement"), !0;
  }
  startsAwaitUsing() {
    let e = this.nextTokenInLineStart();
    if (this.isUnparsedContextual(e, "using")) {
      e = this.nextTokenInLineStartSince(e + 5);
      const t = this.codePointAtPos(e);
      if (this.chStartsBindingIdentifier(t, e))
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    return !1;
  }
  parseModuleItem() {
    return this.parseStatementLike(15);
  }
  parseStatementListItem() {
    return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
  }
  parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
    let t = 0;
    return this.options.annexB && !this.state.strict && (t |= 4, e && (t |= 8)), this.parseStatementLike(t);
  }
  parseStatement() {
    return this.parseStatementLike(0);
  }
  parseStatementLike(e) {
    let t = null;
    return this.match(26) && (t = this.parseDecorators(!0)), this.parseStatementContent(e, t);
  }
  parseStatementContent(e, t) {
    const s = this.state.type, i = this.startNode(), n = !!(e & 2), a = !!(e & 4), o = e & 1;
    switch (s) {
      case 60:
        return this.parseBreakContinueStatement(i, !0);
      case 63:
        return this.parseBreakContinueStatement(i, !1);
      case 64:
        return this.parseDebuggerStatement(i);
      case 90:
        return this.parseDoWhileStatement(i);
      case 91:
        return this.parseForStatement(i);
      case 68:
        if (this.lookaheadCharCode() === 46) break;
        return a || this.raise(this.state.strict ? O.StrictFunction : this.options.annexB ? O.SloppyFunctionAnnexB : O.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(i, !1, !n && a);
      case 80:
        return n || this.unexpected(), this.parseClass(this.maybeTakeDecorators(t, i), !0);
      case 69:
        return this.parseIfStatement(i);
      case 70:
        return this.parseReturnStatement(i);
      case 71:
        return this.parseSwitchStatement(i);
      case 72:
        return this.parseThrowStatement(i);
      case 73:
        return this.parseTryStatement(i);
      case 96:
        if (!this.state.containsEsc && this.startsAwaitUsing())
          return this.isAwaitAllowed() ? n || this.raise(O.UnexpectedLexicalDeclaration, i) : this.raise(O.AwaitUsingNotInAsyncContext, i), this.next(), this.parseVarStatement(i, "await using");
        break;
      case 107:
        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
          break;
        return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(O.UnexpectedUsingDeclaration, this.state.startLoc) : n || this.raise(O.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
      case 100: {
        if (this.state.containsEsc)
          break;
        const c = this.nextTokenStart(), f = this.codePointAtPos(c);
        if (f !== 91 && (!n && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(f, c) && f !== 123))
          break;
      }
      case 75:
        n || this.raise(O.UnexpectedLexicalDeclaration, this.state.startLoc);
      case 74: {
        const c = this.state.value;
        return this.parseVarStatement(i, c);
      }
      case 92:
        return this.parseWhileStatement(i);
      case 76:
        return this.parseWithStatement(i);
      case 5:
        return this.parseBlock();
      case 13:
        return this.parseEmptyStatement(i);
      case 83: {
        const c = this.lookaheadCharCode();
        if (c === 40 || c === 46)
          break;
      }
      case 82: {
        !this.options.allowImportExportEverywhere && !o && this.raise(O.UnexpectedImportExport, this.state.startLoc), this.next();
        let c;
        return s === 83 ? (c = this.parseImport(i), c.type === "ImportDeclaration" && (!c.importKind || c.importKind === "value") && (this.sawUnambiguousESM = !0)) : (c = this.parseExport(i, t), (c.type === "ExportNamedDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportAllDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(c), c;
      }
      default:
        if (this.isAsyncFunction())
          return n || this.raise(O.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i, !0, !n && a);
    }
    const u = this.state.value, l = this.parseExpression();
    return Le(s) && l.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, u, l, e) : this.parseExpressionStatement(i, l, t);
  }
  assertModuleNodeAllowed(e) {
    !this.options.allowImportExportEverywhere && !this.inModule && this.raise(O.ImportOutsideModule, e);
  }
  decoratorsEnabledBeforeExport() {
    return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
  }
  maybeTakeDecorators(e, t, s) {
    return e && (t.decorators && t.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(O.DecoratorsBeforeAfterExport, t.decorators[0]), t.decorators.unshift(...e)) : t.decorators = e, this.resetStartLocationFromNode(t, e[0]), s && this.resetStartLocationFromNode(s, t)), t;
  }
  canHaveLeadingDecorator() {
    return this.match(80);
  }
  parseDecorators(e) {
    const t = [];
    do
      t.push(this.parseDecorator());
    while (this.match(26));
    if (this.match(82))
      e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(O.DecoratorExportClass, this.state.startLoc);
    else if (!this.canHaveLeadingDecorator())
      throw this.raise(O.UnexpectedLeadingDecorator, this.state.startLoc);
    return t;
  }
  parseDecorator() {
    this.expectOnePlugin(["decorators", "decorators-legacy"]);
    const e = this.startNode();
    if (this.next(), this.hasPlugin("decorators")) {
      const t = this.state.startLoc;
      let s;
      if (this.match(10)) {
        const i = this.state.startLoc;
        this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(i, s);
        const n = this.state.startLoc;
        e.expression = this.parseMaybeDecoratorArguments(s), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !== s && this.raise(O.DecoratorArgumentsOutsideParentheses, n);
      } else {
        for (s = this.parseIdentifier(!1); this.eat(16); ) {
          const i = this.startNodeAt(t);
          i.object = s, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) : i.property = this.parseIdentifier(!0), i.computed = !1, s = this.finishNode(i, "MemberExpression");
        }
        e.expression = this.parseMaybeDecoratorArguments(s);
      }
    } else
      e.expression = this.parseExprSubscripts();
    return this.finishNode(e, "Decorator");
  }
  parseMaybeDecoratorArguments(e) {
    if (this.eat(10)) {
      const t = this.startNodeAtNode(e);
      return t.callee = e, t.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(t.arguments), this.finishNode(t, "CallExpression");
    }
    return e;
  }
  parseBreakContinueStatement(e, t) {
    return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e, t), this.finishNode(e, t ? "BreakStatement" : "ContinueStatement");
  }
  verifyBreakContinue(e, t) {
    let s;
    for (s = 0; s < this.state.labels.length; ++s) {
      const i = this.state.labels[s];
      if ((e.label == null || i.name === e.label.name) && (i.kind != null && (t || i.kind === 1) || e.label && t))
        break;
    }
    if (s === this.state.labels.length) {
      const i = t ? "BreakStatement" : "ContinueStatement";
      this.raise(O.IllegalBreakContinue, e, {
        type: i
      });
    }
  }
  parseDebuggerStatement(e) {
    return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
  }
  parseHeaderExpression() {
    this.expect(10);
    const e = this.parseExpression();
    return this.expect(11), e;
  }
  parseDoWhileStatement(e) {
    return this.next(), this.state.labels.push(Rf), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
  }
  parseForStatement(e) {
    this.next(), this.state.labels.push(Rf);
    let t = null;
    if (this.isAwaitAllowed() && this.eatContextual(96) && (t = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
      return t !== null && this.unexpected(t), this.parseFor(e, null);
    const s = this.isContextual(100);
    {
      const u = this.isContextual(96) && this.startsAwaitUsing(), l = u || this.isContextual(107) && this.startsUsingForOf(), c = s && this.hasFollowingBindingAtom() || l;
      if (this.match(74) || this.match(75) || c) {
        const f = this.startNode();
        let p;
        u ? (p = "await using", this.isAwaitAllowed() || this.raise(O.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : p = this.state.value, this.next(), this.parseVar(f, !0, p);
        const h = this.finishNode(f, "VariableDeclaration"), m = this.match(58);
        return m && l && this.raise(O.ForInUsing, h), (m || this.isContextual(102)) && h.declarations.length === 1 ? this.parseForIn(e, h, t) : (t !== null && this.unexpected(t), this.parseFor(e, h));
      }
    }
    const i = this.isContextual(95), n = new Fu(), a = this.parseExpression(!0, n), o = this.isContextual(102);
    if (o && (s && this.raise(O.ForOfLet, a), t === null && i && a.type === "Identifier" && this.raise(O.ForOfAsync, a)), o || this.match(58)) {
      this.checkDestructuringPrivate(n), this.toAssignable(a, !0);
      const u = o ? "ForOfStatement" : "ForInStatement";
      return this.checkLVal(a, {
        in: {
          type: u
        }
      }), this.parseForIn(e, a, t);
    } else
      this.checkExpressionErrors(n, !0);
    return t !== null && this.unexpected(t), this.parseFor(e, a);
  }
  parseFunctionStatement(e, t, s) {
    return this.next(), this.parseFunction(e, 1 | (s ? 2 : 0) | (t ? 8 : 0));
  }
  parseIfStatement(e) {
    return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
  }
  parseReturnStatement(e) {
    return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(O.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
  }
  parseSwitchStatement(e) {
    this.next(), e.discriminant = this.parseHeaderExpression();
    const t = e.cases = [];
    this.expect(5), this.state.labels.push(IO), this.scope.enter(0);
    let s;
    for (let i; !this.match(8); )
      if (this.match(61) || this.match(65)) {
        const n = this.match(61);
        s && this.finishNode(s, "SwitchCase"), t.push(s = this.startNode()), s.consequent = [], this.next(), n ? s.test = this.parseExpression() : (i && this.raise(O.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = !0, s.test = null), this.expect(14);
      } else
        s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
    return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchStatement");
  }
  parseThrowStatement(e) {
    return this.next(), this.hasPrecedingLineBreak() && this.raise(O.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
  }
  parseCatchClauseParam() {
    const e = this.parseBindingAtom();
    return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
      in: {
        type: "CatchClause"
      },
      binding: 9
    }), e;
  }
  parseTryStatement(e) {
    if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
      const t = this.startNode();
      this.next(), this.match(10) ? (this.expect(10), t.param = this.parseCatchClauseParam(), this.expect(11)) : (t.param = null, this.scope.enter(0)), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(t, "CatchClause");
    }
    return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(O.NoCatchOrFinally, e), this.finishNode(e, "TryStatement");
  }
  parseVarStatement(e, t, s = !1) {
    return this.next(), this.parseVar(e, !1, t, s), this.semicolon(), this.finishNode(e, "VariableDeclaration");
  }
  parseWhileStatement(e) {
    return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(Rf), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
  }
  parseWithStatement(e) {
    return this.state.strict && this.raise(O.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
  }
  parseEmptyStatement(e) {
    return this.next(), this.finishNode(e, "EmptyStatement");
  }
  parseLabeledStatement(e, t, s, i) {
    for (const a of this.state.labels)
      a.name === t && this.raise(O.LabelRedeclaration, s, {
        labelName: t
      });
    const n = EN(this.state.type) ? 1 : this.match(71) ? 2 : null;
    for (let a = this.state.labels.length - 1; a >= 0; a--) {
      const o = this.state.labels[a];
      if (o.statementStart === e.start)
        o.statementStart = this.state.start, o.kind = n;
      else
        break;
    }
    return this.state.labels.push({
      name: t,
      kind: n,
      statementStart: this.state.start
    }), e.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label = s, this.finishNode(e, "LabeledStatement");
  }
  parseExpressionStatement(e, t, s) {
    return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
  }
  parseBlock(e = !1, t = !0, s) {
    const i = this.startNode();
    return e && this.state.strictErrors.clear(), this.expect(5), t && this.scope.enter(0), this.parseBlockBody(i, e, !1, 8, s), t && this.scope.exit(), this.finishNode(i, "BlockStatement");
  }
  isValidDirective(e) {
    return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
  }
  parseBlockBody(e, t, s, i, n) {
    const a = e.body = [], o = e.directives = [];
    this.parseBlockOrModuleBlockBody(a, t ? o : void 0, s, i, n);
  }
  parseBlockOrModuleBlockBody(e, t, s, i, n) {
    const a = this.state.strict;
    let o = !1, u = !1;
    for (; !this.match(i); ) {
      const l = s ? this.parseModuleItem() : this.parseStatementListItem();
      if (t && !u) {
        if (this.isValidDirective(l)) {
          const c = this.stmtToDirective(l);
          t.push(c), !o && c.value.value === "use strict" && (o = !0, this.setStrict(!0));
          continue;
        }
        u = !0, this.state.strictErrors.clear();
      }
      e.push(l);
    }
    n == null || n.call(this, o), a || this.setStrict(!1), this.next();
  }
  parseFor(e, t) {
    return e.init = t, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
  }
  parseForIn(e, t, s) {
    const i = this.match(58);
    return this.next(), i ? s !== null && this.unexpected(s) : e.await = s !== null, t.type === "VariableDeclaration" && t.declarations[0].init != null && (!i || !this.options.annexB || this.state.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(O.ForInOfLoopInitializer, t, {
      type: i ? "ForInStatement" : "ForOfStatement"
    }), t.type === "AssignmentPattern" && this.raise(O.InvalidLhs, t, {
      ancestor: {
        type: "ForStatement"
      }
    }), e.left = t, e.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, i ? "ForInStatement" : "ForOfStatement");
  }
  parseVar(e, t, s, i = !1) {
    const n = e.declarations = [];
    for (e.kind = s; ; ) {
      const a = this.startNode();
      if (this.parseVarId(a, s), a.init = this.eat(29) ? t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a.init === null && !i && (a.id.type !== "Identifier" && !(t && (this.match(58) || this.isContextual(102))) ? this.raise(O.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
        kind: "destructuring"
      }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(O.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
        kind: s
      })), n.push(this.finishNode(a, "VariableDeclarator")), !this.eat(12)) break;
    }
    return e;
  }
  parseVarId(e, t) {
    const s = this.parseBindingAtom();
    this.checkLVal(s, {
      in: {
        type: "VariableDeclarator"
      },
      binding: t === "var" ? 5 : 8201
    }), e.id = s;
  }
  parseAsyncFunctionExpression(e) {
    return this.parseFunction(e, 8);
  }
  parseFunction(e, t = 0) {
    const s = t & 2, i = !!(t & 1), n = i && !(t & 4), a = !!(t & 8);
    this.initFunction(e, a), this.match(55) && (s && this.raise(O.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.generator = !0), i && (e.id = this.parseFunctionId(n));
    const o = this.state.maybeInArrowParameters;
    return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter($u(a, e.generator)), i || (e.id = this.parseFunctionId()), this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(e, i ? "FunctionDeclaration" : "FunctionExpression");
    }), this.prodParam.exit(), this.scope.exit(), i && !s && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = o, e;
  }
  parseFunctionId(e) {
    return e || Le(this.state.type) ? this.parseIdentifier() : null;
  }
  parseFunctionParams(e, t) {
    this.expect(10), this.expressionScope.enter(YN()), e.params = this.parseBindingList(11, 41, 2 | (t ? 4 : 0)), this.expressionScope.exit();
  }
  registerFunctionStatementId(e) {
    e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, e.id.loc.start);
  }
  parseClass(e, t, s) {
    this.next();
    const i = this.state.strict;
    return this.state.strict = !0, this.parseClassId(e, t, s), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, i), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
  }
  isClassProperty() {
    return this.match(29) || this.match(13) || this.match(8);
  }
  isClassMethod() {
    return this.match(10);
  }
  nameIsConstructor(e) {
    return e.type === "Identifier" && e.name === "constructor" || e.type === "StringLiteral" && e.value === "constructor";
  }
  isNonstaticConstructor(e) {
    return !e.computed && !e.static && this.nameIsConstructor(e.key);
  }
  parseClassBody(e, t) {
    this.classScope.enter();
    const s = {
      hadConstructor: !1,
      hadSuperClass: e
    };
    let i = [];
    const n = this.startNode();
    if (n.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
      for (; !this.match(8); ) {
        if (this.eat(13)) {
          if (i.length > 0)
            throw this.raise(O.DecoratorSemicolon, this.state.lastTokEndLoc);
          continue;
        }
        if (this.match(26)) {
          i.push(this.parseDecorator());
          continue;
        }
        const a = this.startNode();
        i.length && (a.decorators = i, this.resetStartLocationFromNode(a, i[0]), i = []), this.parseClassMember(n, a, s), a.kind === "constructor" && a.decorators && a.decorators.length > 0 && this.raise(O.DecoratorConstructor, a);
      }
    }), this.state.strict = t, this.next(), i.length)
      throw this.raise(O.TrailingDecorator, this.state.startLoc);
    return this.classScope.exit(), this.finishNode(n, "ClassBody");
  }
  parseClassMemberFromModifier(e, t) {
    const s = this.parseIdentifier(!0);
    if (this.isClassMethod()) {
      const i = t;
      return i.kind = "method", i.computed = !1, i.key = s, i.static = !1, this.pushClassMethod(e, i, !1, !1, !1, !1), !0;
    } else if (this.isClassProperty()) {
      const i = t;
      return i.computed = !1, i.key = s, i.static = !1, e.body.push(this.parseClassProperty(i)), !0;
    }
    return this.resetPreviousNodeTrailingComments(s), !1;
  }
  parseClassMember(e, t, s) {
    const i = this.isContextual(106);
    if (i) {
      if (this.parseClassMemberFromModifier(e, t))
        return;
      if (this.eat(5)) {
        this.parseClassStaticBlock(e, t);
        return;
      }
    }
    this.parseClassMemberWithIsStatic(e, t, s, i);
  }
  parseClassMemberWithIsStatic(e, t, s, i) {
    const n = t, a = t, o = t, u = t, l = t, c = n, f = n;
    if (t.static = i, this.parsePropertyNamePrefixOperator(t), this.eat(55)) {
      c.kind = "method";
      const S = this.match(138);
      if (this.parseClassElementName(c), S) {
        this.pushClassPrivateMethod(e, a, !0, !1);
        return;
      }
      this.isNonstaticConstructor(n) && this.raise(O.ConstructorIsGenerator, n.key), this.pushClassMethod(e, n, !0, !1, !1, !1);
      return;
    }
    const p = !this.state.containsEsc && Le(this.state.type), h = this.parseClassElementName(t), m = p ? h.name : null, d = this.isPrivateName(h), y = this.state.startLoc;
    if (this.parsePostMemberNameModifiers(f), this.isClassMethod()) {
      if (c.kind = "method", d) {
        this.pushClassPrivateMethod(e, a, !1, !1);
        return;
      }
      const S = this.isNonstaticConstructor(n);
      let E = !1;
      S && (n.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(O.DuplicateConstructor, h), S && this.hasPlugin("typescript") && t.override && this.raise(O.OverrideOnConstructor, h), s.hadConstructor = !0, E = s.hadSuperClass), this.pushClassMethod(e, n, !1, !1, S, E);
    } else if (this.isClassProperty())
      d ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, o);
    else if (m === "async" && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(h);
      const S = this.eat(55);
      f.optional && this.unexpected(y), c.kind = "method";
      const E = this.match(138);
      this.parseClassElementName(c), this.parsePostMemberNameModifiers(f), E ? this.pushClassPrivateMethod(e, a, S, !0) : (this.isNonstaticConstructor(n) && this.raise(O.ConstructorIsAsync, n.key), this.pushClassMethod(e, n, S, !0, !1, !1));
    } else if ((m === "get" || m === "set") && !(this.match(55) && this.isLineTerminator())) {
      this.resetPreviousNodeTrailingComments(h), c.kind = m;
      const S = this.match(138);
      this.parseClassElementName(n), S ? this.pushClassPrivateMethod(e, a, !1, !1) : (this.isNonstaticConstructor(n) && this.raise(O.ConstructorIsAccessor, n.key), this.pushClassMethod(e, n, !1, !1, !1, !1)), this.checkGetterSetterParams(n);
    } else if (m === "accessor" && !this.isLineTerminator()) {
      this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(h);
      const S = this.match(138);
      this.parseClassElementName(o), this.pushClassAccessorProperty(e, l, S);
    } else this.isLineTerminator() ? d ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, o) : this.unexpected();
  }
  parseClassElementName(e) {
    const {
      type: t,
      value: s
    } = this.state;
    if ((t === 132 || t === 133) && e.static && s === "prototype" && this.raise(O.StaticPrototype, this.state.startLoc), t === 138) {
      s === "constructor" && this.raise(O.ConstructorClassPrivateField, this.state.startLoc);
      const i = this.parsePrivateName();
      return e.key = i, i;
    }
    return this.parsePropertyName(e), e.key;
  }
  parseClassStaticBlock(e, t) {
    var s;
    this.scope.enter(208);
    const i = this.state.labels;
    this.state.labels = [], this.prodParam.enter(0);
    const n = t.body = [];
    this.parseBlockOrModuleBlockBody(n, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, e.body.push(this.finishNode(t, "StaticBlock")), (s = t.decorators) != null && s.length && this.raise(O.DecoratorStaticBlock, t);
  }
  pushClassProperty(e, t) {
    !t.computed && this.nameIsConstructor(t.key) && this.raise(O.ConstructorClassField, t.key), e.body.push(this.parseClassProperty(t));
  }
  pushClassPrivateProperty(e, t) {
    const s = this.parseClassPrivateProperty(t);
    e.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
  }
  pushClassAccessorProperty(e, t, s) {
    !s && !t.computed && this.nameIsConstructor(t.key) && this.raise(O.ConstructorClassField, t.key);
    const i = this.parseClassAccessorProperty(t);
    e.body.push(i), s && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
  }
  pushClassMethod(e, t, s, i, n, a) {
    e.body.push(this.parseMethod(t, s, i, n, a, "ClassMethod", !0));
  }
  pushClassPrivateMethod(e, t, s, i) {
    const n = this.parseMethod(t, s, i, !1, !1, "ClassPrivateMethod", !0);
    e.body.push(n);
    const a = n.kind === "get" ? n.static ? 6 : 2 : n.kind === "set" ? n.static ? 5 : 1 : 0;
    this.declareClassPrivateMethodInScope(n, a);
  }
  declareClassPrivateMethodInScope(e, t) {
    this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), t, e.key.loc.start);
  }
  parsePostMemberNameModifiers(e) {
  }
  parseClassPrivateProperty(e) {
    return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
  }
  parseClassProperty(e) {
    return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
  }
  parseClassAccessorProperty(e) {
    return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
  }
  parseInitializer(e) {
    this.scope.enter(80), this.expressionScope.enter(mS()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
  }
  parseClassId(e, t, s, i = 8331) {
    if (Le(this.state.type))
      e.id = this.parseIdentifier(), t && this.declareNameFromIdentifier(e.id, i);
    else if (s || !t)
      e.id = null;
    else
      throw this.raise(O.MissingClassName, this.state.startLoc);
  }
  parseClassSuper(e) {
    e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
  }
  parseExport(e, t) {
    const s = this.parseMaybeImportPhase(e, !0), i = this.maybeParseExportDefaultSpecifier(e, s), n = !i || this.eat(12), a = n && this.eatExportStar(e), o = a && this.maybeParseExportNamespaceSpecifier(e), u = n && (!o || this.eat(12)), l = i || a;
    if (a && !o) {
      if (i && this.unexpected(), t)
        throw this.raise(O.UnsupportedDecoratorExport, e);
      return this.parseExportFrom(e, !0), this.finishNode(e, "ExportAllDeclaration");
    }
    const c = this.maybeParseExportNamedSpecifiers(e);
    i && n && !a && !c && this.unexpected(null, 5), o && u && this.unexpected(null, 98);
    let f;
    if (l || c) {
      if (f = !1, t)
        throw this.raise(O.UnsupportedDecoratorExport, e);
      this.parseExportFrom(e, l);
    } else
      f = this.maybeParseExportDeclaration(e);
    if (l || c || f) {
      var p;
      const h = e;
      if (this.checkExport(h, !0, !1, !!h.source), ((p = h.declaration) == null ? void 0 : p.type) === "ClassDeclaration")
        this.maybeTakeDecorators(t, h.declaration, h);
      else if (t)
        throw this.raise(O.UnsupportedDecoratorExport, e);
      return this.finishNode(h, "ExportNamedDeclaration");
    }
    if (this.eat(65)) {
      const h = e, m = this.parseExportDefaultExpression();
      if (h.declaration = m, m.type === "ClassDeclaration")
        this.maybeTakeDecorators(t, m, h);
      else if (t)
        throw this.raise(O.UnsupportedDecoratorExport, e);
      return this.checkExport(h, !0, !0), this.finishNode(h, "ExportDefaultDeclaration");
    }
    this.unexpected(null, 5);
  }
  eatExportStar(e) {
    return this.eat(55);
  }
  maybeParseExportDefaultSpecifier(e, t) {
    if (t || this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom", t == null ? void 0 : t.loc.start);
      const s = t || this.parseIdentifier(!0), i = this.startNodeAtNode(s);
      return i.exported = s, e.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], !0;
    }
    return !1;
  }
  maybeParseExportNamespaceSpecifier(e) {
    if (this.isContextual(93)) {
      var t, s;
      (s = (t = e).specifiers) != null || (t.specifiers = []);
      const i = this.startNodeAt(this.state.lastTokStartLoc);
      return this.next(), i.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(i, "ExportNamespaceSpecifier")), !0;
    }
    return !1;
  }
  maybeParseExportNamedSpecifiers(e) {
    if (this.match(5)) {
      const t = e;
      t.specifiers || (t.specifiers = []);
      const s = t.exportKind === "type";
      return t.specifiers.push(...this.parseExportSpecifiers(s)), t.source = null, t.declaration = null, this.hasPlugin("importAssertions") && (t.assertions = []), !0;
    }
    return !1;
  }
  maybeParseExportDeclaration(e) {
    return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") && (e.assertions = []), e.declaration = this.parseExportDeclaration(e), !0) : !1;
  }
  isAsyncFunction() {
    if (!this.isContextual(95)) return !1;
    const e = this.nextTokenInLineStart();
    return this.isUnparsedContextual(e, "function");
  }
  parseExportDefaultExpression() {
    const e = this.startNode();
    if (this.match(68))
      return this.next(), this.parseFunction(e, 5);
    if (this.isAsyncFunction())
      return this.next(), this.next(), this.parseFunction(e, 13);
    if (this.match(80))
      return this.parseClass(e, !0, !0);
    if (this.match(26))
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(O.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
    if (this.match(75) || this.match(74) || this.isLet())
      throw this.raise(O.UnsupportedDefaultExport, this.state.startLoc);
    const t = this.parseMaybeAssignAllowIn();
    return this.semicolon(), t;
  }
  parseExportDeclaration(e) {
    return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
  }
  isExportDefaultSpecifier() {
    const {
      type: e
    } = this.state;
    if (Le(e)) {
      if (e === 95 && !this.state.containsEsc || e === 100)
        return !1;
      if ((e === 130 || e === 129) && !this.state.containsEsc) {
        const {
          type: i
        } = this.lookahead();
        if (Le(i) && i !== 98 || i === 5)
          return this.expectOnePlugin(["flow", "typescript"]), !1;
      }
    } else if (!this.match(65))
      return !1;
    const t = this.nextTokenStart(), s = this.isUnparsedContextual(t, "from");
    if (this.input.charCodeAt(t) === 44 || Le(this.state.type) && s)
      return !0;
    if (this.match(65) && s) {
      const i = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
      return i === 34 || i === 39;
    }
    return !1;
  }
  parseExportFrom(e, t) {
    this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(e)) : t && this.unexpected(), this.semicolon();
  }
  shouldParseExportDeclaration() {
    const {
      type: e
    } = this.state;
    return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(O.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.raise(O.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(O.UsingDeclarationExport, this.state.startLoc), !0) : e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
  }
  checkExport(e, t, s, i) {
    if (t) {
      var n;
      if (s) {
        if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
          var a;
          const o = e.declaration;
          o.type === "Identifier" && o.name === "from" && o.end - o.start === 4 && !((a = o.extra) != null && a.parenthesized) && this.raise(O.ExportDefaultFromAsIdentifier, o);
        }
      } else if ((n = e.specifiers) != null && n.length)
        for (const o of e.specifiers) {
          const {
            exported: u
          } = o, l = u.type === "Identifier" ? u.name : u.value;
          if (this.checkDuplicateExports(o, l), !i && o.local) {
            const {
              local: c
            } = o;
            c.type !== "Identifier" ? this.raise(O.ExportBindingIsString, o, {
              localName: c.value,
              exportName: l
            }) : (this.checkReservedWord(c.name, c.loc.start, !0, !1), this.scope.checkLocalExport(c));
          }
        }
      else if (e.declaration) {
        const o = e.declaration;
        if (o.type === "FunctionDeclaration" || o.type === "ClassDeclaration") {
          const {
            id: u
          } = o;
          if (!u) throw new Error("Assertion failure");
          this.checkDuplicateExports(e, u.name);
        } else if (o.type === "VariableDeclaration")
          for (const u of o.declarations)
            this.checkDeclaration(u.id);
      }
    }
  }
  checkDeclaration(e) {
    if (e.type === "Identifier")
      this.checkDuplicateExports(e, e.name);
    else if (e.type === "ObjectPattern")
      for (const t of e.properties)
        this.checkDeclaration(t);
    else if (e.type === "ArrayPattern")
      for (const t of e.elements)
        t && this.checkDeclaration(t);
    else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type === "AssignmentPattern" && this.checkDeclaration(e.left);
  }
  checkDuplicateExports(e, t) {
    this.exportedIdentifiers.has(t) && (t === "default" ? this.raise(O.DuplicateDefaultExport, e) : this.raise(O.DuplicateExport, e, {
      exportName: t
    })), this.exportedIdentifiers.add(t);
  }
  parseExportSpecifiers(e) {
    const t = [];
    let s = !0;
    for (this.expect(5); !this.eat(8); ) {
      if (s)
        s = !1;
      else if (this.expect(12), this.eat(8)) break;
      const i = this.isContextual(130), n = this.match(133), a = this.startNode();
      a.local = this.parseModuleExportName(), t.push(this.parseExportSpecifier(a, n, e, i));
    }
    return t;
  }
  parseExportSpecifier(e, t, s, i) {
    return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : t ? e.exported = sO(e.local) : e.exported || (e.exported = Ss(e.local)), this.finishNode(e, "ExportSpecifier");
  }
  parseModuleExportName() {
    if (this.match(133)) {
      const e = this.parseStringLiteral(this.state.value), t = e.value.match(kO);
      return t && this.raise(O.ModuleExportNameHasLoneSurrogate, e, {
        surrogateCharCode: t[0].charCodeAt(0)
      }), e;
    }
    return this.parseIdentifier(!0);
  }
  isJSONModuleImport(e) {
    return e.assertions != null ? e.assertions.some(({
      key: t,
      value: s
    }) => s.value === "json" && (t.type === "Identifier" ? t.name === "type" : t.value === "type")) : !1;
  }
  checkImportReflection(e) {
    const {
      specifiers: t
    } = e, s = t.length === 1 ? t[0].type : null;
    if (e.phase === "source")
      s !== "ImportDefaultSpecifier" && this.raise(O.SourcePhaseImportRequiresDefault, t[0].loc.start);
    else if (e.phase === "defer")
      s !== "ImportNamespaceSpecifier" && this.raise(O.DeferImportRequiresNamespace, t[0].loc.start);
    else if (e.module) {
      var i;
      s !== "ImportDefaultSpecifier" && this.raise(O.ImportReflectionNotBinding, t[0].loc.start), ((i = e.assertions) == null ? void 0 : i.length) > 0 && this.raise(O.ImportReflectionHasAssertion, t[0].loc.start);
    }
  }
  checkJSONModuleImport(e) {
    if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
      const {
        specifiers: t
      } = e;
      if (t != null) {
        const s = t.find((i) => {
          let n;
          if (i.type === "ExportSpecifier" ? n = i.local : i.type === "ImportSpecifier" && (n = i.imported), n !== void 0)
            return n.type === "Identifier" ? n.name !== "default" : n.value !== "default";
        });
        s !== void 0 && this.raise(O.ImportJSONBindingNotDefault, s.loc.start);
      }
    }
  }
  isPotentialImportPhase(e) {
    return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
  }
  applyImportPhase(e, t, s, i) {
    t || (s === "module" ? (this.expectPlugin("importReflection", i), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1), s === "source" ? (this.expectPlugin("sourcePhaseImports", i), e.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImportEvaluation", i), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
  }
  parseMaybeImportPhase(e, t) {
    if (!this.isPotentialImportPhase(t))
      return this.applyImportPhase(e, t, null), null;
    const s = this.parseIdentifier(!0), {
      type: i
    } = this.state;
    return (Cr(i) ? i !== 98 || this.lookaheadCharCode() === 102 : i !== 12) ? (this.resetPreviousIdentifierLeadingComments(s), this.applyImportPhase(e, t, s.name, s.loc.start), null) : (this.applyImportPhase(e, t, null), s);
  }
  isPrecedingIdImportPhase(e) {
    const {
      type: t
    } = this.state;
    return Le(t) ? t !== 98 || this.lookaheadCharCode() === 102 : t !== 12;
  }
  parseImport(e) {
    return this.match(133) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
  }
  parseImportSpecifiersAndAfter(e, t) {
    e.specifiers = [];
    const i = !this.maybeParseDefaultImportSpecifier(e, t) || this.eat(12), n = i && this.maybeParseStarImportSpecifier(e);
    return i && !n && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
  }
  parseImportSourceAndAttributes(e) {
    var t;
    return (t = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, "ImportDeclaration");
  }
  parseImportSource() {
    return this.match(133) || this.unexpected(), this.parseExprAtom();
  }
  parseImportSpecifierLocal(e, t, s) {
    t.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(t, s));
  }
  finishImportSpecifier(e, t, s = 8201) {
    return this.checkLVal(e.local, {
      in: {
        type: t
      },
      binding: s
    }), this.finishNode(e, t);
  }
  parseImportAttributes() {
    this.expect(5);
    const e = [], t = /* @__PURE__ */ new Set();
    do {
      if (this.match(8))
        break;
      const s = this.startNode(), i = this.state.value;
      if (t.has(i) && this.raise(O.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
        key: i
      }), t.add(i), this.match(133) ? s.key = this.parseStringLiteral(i) : s.key = this.parseIdentifier(!0), this.expect(14), !this.match(133))
        throw this.raise(O.ModuleAttributeInvalidValue, this.state.startLoc);
      s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
    } while (this.eat(12));
    return this.expect(8), e;
  }
  parseModuleAttributes() {
    const e = [], t = /* @__PURE__ */ new Set();
    do {
      const s = this.startNode();
      if (s.key = this.parseIdentifier(!0), s.key.name !== "type" && this.raise(O.ModuleAttributeDifferentFromType, s.key), t.has(s.key.name) && this.raise(O.ModuleAttributesWithDuplicateKeys, s.key, {
        key: s.key.name
      }), t.add(s.key.name), this.expect(14), !this.match(133))
        throw this.raise(O.ModuleAttributeInvalidValue, this.state.startLoc);
      s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
    } while (this.eat(12));
    return e;
  }
  maybeParseImportAttributes(e) {
    let t, s = !1;
    if (this.match(76)) {
      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
        return;
      this.next(), this.hasPlugin("moduleAttributes") ? t = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), t = this.parseImportAttributes()), s = !0;
    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
      this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(O.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(e, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), t = this.parseImportAttributes();
    else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
      t = [];
    else if (this.hasPlugin("moduleAttributes"))
      t = [];
    else return;
    !s && this.hasPlugin("importAssertions") ? e.assertions = t : e.attributes = t;
  }
  maybeParseDefaultImportSpecifier(e, t) {
    if (t) {
      const s = this.startNodeAtNode(t);
      return s.local = t, e.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), !0;
    } else if (Cr(this.state.type))
      return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
    return !1;
  }
  maybeParseStarImportSpecifier(e) {
    if (this.match(55)) {
      const t = this.startNode();
      return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, t, "ImportNamespaceSpecifier"), !0;
    }
    return !1;
  }
  parseNamedImportSpecifiers(e) {
    let t = !0;
    for (this.expect(5); !this.eat(8); ) {
      if (t)
        t = !1;
      else {
        if (this.eat(14))
          throw this.raise(O.DestructureNamedImport, this.state.startLoc);
        if (this.expect(12), this.eat(8)) break;
      }
      const s = this.startNode(), i = this.match(133), n = this.isContextual(130);
      s.imported = this.parseModuleExportName();
      const a = this.parseImportSpecifier(s, i, e.importKind === "type" || e.importKind === "typeof", n, void 0);
      e.specifiers.push(a);
    }
  }
  parseImportSpecifier(e, t, s, i, n) {
    if (this.eatContextual(93))
      e.local = this.parseIdentifier();
    else {
      const {
        imported: a
      } = e;
      if (t)
        throw this.raise(O.ImportBindingIsString, e, {
          importName: a.value
        });
      this.checkReservedWord(a.name, e.loc.start, !0, !0), e.local || (e.local = Ss(a));
    }
    return this.finishImportSpecifier(e, "ImportSpecifier", n);
  }
  isThisParam(e) {
    return e.type === "Identifier" && e.name === "this";
  }
}
let ES = class extends LO {
  constructor(e, t) {
    e = NO(e), super(e, t), this.options = e, this.initializeScopes(), this.plugins = MO(this.options.plugins), this.filename = e.sourceFilename;
  }
  getScopeHandler() {
    return pm;
  }
  parse() {
    this.enterInitialScopes();
    const e = this.startNode(), t = this.startNode();
    return this.nextToken(), e.errors = null, this.parseTopLevel(e, t), e.errors = this.state.errors, e.comments.length = this.state.commentsLen, e;
  }
};
function MO(r) {
  const e = /* @__PURE__ */ new Map();
  for (const t of r) {
    const [s, i] = Array.isArray(t) ? t : [t, {}];
    e.has(s) || e.set(s, i || {});
  }
  return e;
}
function RO(r, e) {
  var t;
  if (((t = e) == null ? void 0 : t.sourceType) === "unambiguous") {
    e = Object.assign({}, e);
    try {
      e.sourceType = "module";
      const s = Ia(e, r), i = s.parse();
      if (s.sawUnambiguousESM)
        return i;
      if (s.ambiguousScriptDifferentAst)
        try {
          return e.sourceType = "script", Ia(e, r).parse();
        } catch {
        }
      else
        i.program.sourceType = "script";
      return i;
    } catch (s) {
      try {
        return e.sourceType = "script", Ia(e, r).parse();
      } catch {
      }
      throw s;
    }
  } else
    return Ia(e, r).parse();
}
function $O(r, e) {
  const t = Ia(e, r);
  return t.options.strictMode && (t.state.strict = !0), t.getExpression();
}
function FO(r) {
  const e = {};
  for (const t of Object.keys(r))
    e[t] = ls(r[t]);
  return e;
}
const BO = FO(gN);
function Ia(r, e) {
  let t = ES;
  return r != null && r.plugins && (AO(r.plugins), t = VO(r.plugins)), new t(r, e);
}
const xy = {};
function VO(r) {
  const e = CO.filter((i) => lt(r, i)), t = e.join("/");
  let s = xy[t];
  if (!s) {
    s = ES;
    for (const i of e)
      s = vS[i](s);
    xy[t] = s;
  }
  return s;
}
var $n = Lc.parse = RO, _l = Lc.parseExpression = $O;
Lc.tokTypes = BO;
class UO {
  constructor() {
    this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (e) => this.replacement = e
    };
  }
  /**
   *
   * @param {any} parent
   * @param {string} prop
   * @param {number} index
   * @param {BaseNode} node
   */
  replace(e, t, s, i) {
    e && (s !== null ? e[t][s] = i : e[t] = i);
  }
  /**
   *
   * @param {any} parent
   * @param {string} prop
   * @param {number} index
   */
  remove(e, t, s) {
    e && (s !== null ? e[t].splice(s, 1) : delete e[t]);
  }
}
class jO extends UO {
  /**
   *
   * @param {SyncHandler} enter
   * @param {SyncHandler} leave
   */
  constructor(e, t) {
    super(), this.enter = e, this.leave = t;
  }
  /**
   *
   * @param {BaseNode} node
   * @param {BaseNode} parent
   * @param {string} [prop]
   * @param {number} [index]
   * @returns {BaseNode}
   */
  visit(e, t, s, i) {
    if (e) {
      if (this.enter) {
        const n = this.should_skip, a = this.should_remove, o = this.replacement;
        this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, e, t, s, i), this.replacement && (e = this.replacement, this.replace(t, s, i, e)), this.should_remove && this.remove(t, s, i);
        const u = this.should_skip, l = this.should_remove;
        if (this.should_skip = n, this.should_remove = a, this.replacement = o, u) return e;
        if (l) return null;
      }
      for (const n in e) {
        const a = e[n];
        if (typeof a == "object")
          if (Array.isArray(a))
            for (let o = 0; o < a.length; o += 1)
              a[o] !== null && typeof a[o].type == "string" && (this.visit(a[o], e, n, o) || o--);
          else a !== null && typeof a.type == "string" && this.visit(a, e, n, null);
      }
      if (this.leave) {
        const n = this.replacement, a = this.should_remove;
        this.replacement = null, this.should_remove = !1, this.leave.call(this.context, e, t, s, i), this.replacement && (e = this.replacement, this.replace(t, s, i, e)), this.should_remove && this.remove(t, s, i);
        const o = this.should_remove;
        if (this.replacement = n, this.should_remove = a, o) return null;
      }
    }
    return e;
  }
}
function Rc(r, { enter: e, leave: t }) {
  return new jO(e, t).visit(r, null);
}
function Uo(r, e, t = !1, s = [], i = /* @__PURE__ */ Object.create(null)) {
  const n = r.type === "Program" ? r.body[0].type === "ExpressionStatement" && r.body[0].expression : r;
  Rc(r, {
    enter(a, o) {
      if (o && s.push(o), o && o.type.startsWith("TS") && !ym.includes(o.type))
        return this.skip();
      if (a.type === "Identifier") {
        const u = !!i[a.name], l = mm(a, o, s);
        (t || l && !u) && e(a, o, s, l, u);
      } else if (a.type === "ObjectProperty" && // eslint-disable-next-line no-restricted-syntax
      (o == null ? void 0 : o.type) === "ObjectPattern")
        a.inPattern = !0;
      else if (Ys(a))
        a.scopeIds ? a.scopeIds.forEach((u) => Bp(u, i)) : gm(
          a,
          (u) => lu(a, u, i)
        );
      else if (a.type === "BlockStatement")
        a.scopeIds ? a.scopeIds.forEach((u) => Bp(u, i)) : _S(
          a,
          (u) => lu(a, u, i)
        );
      else if (a.type === "CatchClause" && a.param)
        for (const u of mr(a.param))
          lu(a, u, i);
      else xS(a) && wS(
        a,
        !1,
        (u) => lu(a, u, i)
      );
    },
    leave(a, o) {
      if (o && s.pop(), a !== n && a.scopeIds)
        for (const u of a.scopeIds)
          i[u]--, i[u] === 0 && delete i[u];
    }
  });
}
function mm(r, e, t) {
  if (!e)
    return !0;
  if (r.name === "arguments")
    return !1;
  if (qO(r, e))
    return !0;
  switch (e.type) {
    case "AssignmentExpression":
    case "AssignmentPattern":
      return !0;
    case "ObjectPattern":
    case "ArrayPattern":
      return jo(e, t);
  }
  return !1;
}
function jo(r, e) {
  if (r && (r.type === "ObjectProperty" || r.type === "ArrayPattern")) {
    let t = e.length;
    for (; t--; ) {
      const s = e[t];
      if (s.type === "AssignmentExpression")
        return !0;
      if (s.type !== "ObjectProperty" && !s.type.endsWith("Pattern"))
        break;
    }
  }
  return !1;
}
function SS(r) {
  let e = r.length;
  for (; e--; ) {
    const t = r[e];
    if (t.type === "NewExpression")
      return !0;
    if (t.type !== "MemberExpression")
      break;
  }
  return !1;
}
function gm(r, e) {
  for (const t of r.params)
    for (const s of mr(t))
      e(s);
}
function _S(r, e) {
  for (const t of r.body)
    if (t.type === "VariableDeclaration") {
      if (t.declare) continue;
      for (const s of t.declarations)
        for (const i of mr(s.id))
          e(i);
    } else if (t.type === "FunctionDeclaration" || t.type === "ClassDeclaration") {
      if (t.declare || !t.id) continue;
      e(t.id);
    } else xS(t) && wS(t, !0, e);
}
function xS(r) {
  return r.type === "ForOfStatement" || r.type === "ForInStatement" || r.type === "ForStatement";
}
function wS(r, e, t) {
  const s = r.type === "ForStatement" ? r.init : r.left;
  if (s && s.type === "VariableDeclaration" && (s.kind === "var" ? e : !e))
    for (const i of s.declarations)
      for (const n of mr(i.id))
        t(n);
}
function mr(r, e = []) {
  switch (r.type) {
    case "Identifier":
      e.push(r);
      break;
    case "MemberExpression":
      let t = r;
      for (; t.type === "MemberExpression"; )
        t = t.object;
      e.push(t);
      break;
    case "ObjectPattern":
      for (const s of r.properties)
        s.type === "RestElement" ? mr(s.argument, e) : mr(s.value, e);
      break;
    case "ArrayPattern":
      r.elements.forEach((s) => {
        s && mr(s, e);
      });
      break;
    case "RestElement":
      mr(r.argument, e);
      break;
    case "AssignmentPattern":
      mr(r.left, e);
      break;
  }
  return e;
}
function Bp(r, e) {
  r in e ? e[r]++ : e[r] = 1;
}
function lu(r, e, t) {
  const { name: s } = e;
  r.scopeIds && r.scopeIds.has(s) || (Bp(s, t), (r.scopeIds || (r.scopeIds = /* @__PURE__ */ new Set())).add(s));
}
const Ys = (r) => /Function(?:Expression|Declaration)$|Method$/.test(r.type), qo = (r) => r && (r.type === "ObjectProperty" || r.type === "ObjectMethod") && !r.computed, TS = (r, e) => qo(e) && e.key === r;
function qO(r, e, t) {
  switch (e.type) {
    case "MemberExpression":
    case "OptionalMemberExpression":
      return e.property === r ? !!e.computed : e.object === r;
    case "JSXMemberExpression":
      return e.object === r;
    case "VariableDeclarator":
      return e.init === r;
    case "ArrowFunctionExpression":
      return e.body === r;
    case "PrivateName":
      return !1;
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      return e.key === r ? !!e.computed : !1;
    case "ObjectProperty":
      return e.key === r ? !!e.computed : !t;
    case "ClassProperty":
      return e.key === r ? !!e.computed : !0;
    case "ClassPrivateProperty":
      return e.key !== r;
    case "ClassDeclaration":
    case "ClassExpression":
      return e.superClass === r;
    case "AssignmentExpression":
      return e.right === r;
    case "AssignmentPattern":
      return e.right === r;
    case "LabeledStatement":
      return !1;
    case "CatchClause":
      return !1;
    case "RestElement":
      return !1;
    case "BreakStatement":
    case "ContinueStatement":
      return !1;
    case "FunctionDeclaration":
    case "FunctionExpression":
      return !1;
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return !1;
    case "ExportSpecifier":
      return e.local === r;
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return !1;
    case "ImportAttribute":
      return !1;
    case "JSXAttribute":
      return !1;
    case "ObjectPattern":
    case "ArrayPattern":
      return !1;
    case "MetaProperty":
      return !1;
    case "ObjectTypeProperty":
      return e.key !== r;
    case "TSEnumMember":
      return e.id !== r;
    case "TSPropertySignature":
      return e.key === r ? !!e.computed : !0;
  }
  return !0;
}
const ym = [
  "TSAsExpression",
  // foo as number
  "TSTypeAssertion",
  // (<number>foo)
  "TSNonNullExpression",
  // foo!
  "TSInstantiationExpression",
  // foo<string>
  "TSSatisfiesExpression"
  // foo satisfies T
];
function br(r) {
  return ym.includes(r.type) ? br(r.expression) : r;
}
const Pt = (r) => r.type === 4 && r.isStatic;
function bm(r) {
  switch (r) {
    case "Teleport":
    case "teleport":
      return $i;
    case "Suspense":
    case "suspense":
      return Xn;
    case "KeepAlive":
    case "keep-alive":
      return oo;
    case "BaseTransition":
    case "base-transition":
      return zd;
  }
}
const HO = /^\d|[^\$\w\xA0-\uFFFF]/, Ts = (r) => !HO.test(r), WO = /[A-Za-z_$\xA0-\uFFFF]/, zO = /[\.\?\w$\xA0-\uFFFF]/, GO = /\s+[.[]\s*|\s*[.[]\s+/g, KO = (r) => {
  r = r.trim().replace(GO, (a) => a.trim());
  let e = 0, t = [], s = 0, i = 0, n = null;
  for (let a = 0; a < r.length; a++) {
    const o = r.charAt(a);
    switch (e) {
      case 0:
        if (o === "[")
          t.push(e), e = 1, s++;
        else if (o === "(")
          t.push(e), e = 2, i++;
        else if (!(a === 0 ? WO : zO).test(o))
          return !1;
        break;
      case 1:
        o === "'" || o === '"' || o === "`" ? (t.push(e), e = 3, n = o) : o === "[" ? s++ : o === "]" && (--s || (e = t.pop()));
        break;
      case 2:
        if (o === "'" || o === '"' || o === "`")
          t.push(e), e = 3, n = o;
        else if (o === "(")
          i++;
        else if (o === ")") {
          if (a === r.length - 1)
            return !1;
          --i || (e = t.pop());
        }
        break;
      case 3:
        o === n && (e = t.pop(), n = null);
        break;
    }
  }
  return !s && !i;
}, PS = (r, e) => {
  try {
    let t = _l(r, {
      plugins: e.expressionPlugins
    });
    return t = br(t), t.type === "MemberExpression" || t.type === "OptionalMemberExpression" || t.type === "Identifier" && t.name !== "undefined";
  } catch {
    return !1;
  }
}, vm = PS;
function Vp(r, e, t = e.length) {
  return Em(
    {
      offset: r.offset,
      line: r.line,
      column: r.column
    },
    e,
    t
  );
}
function Em(r, e, t = e.length) {
  let s = 0, i = -1;
  for (let n = 0; n < t; n++)
    e.charCodeAt(n) === 10 && (s++, i = n);
  return r.offset += t, r.line += s, r.column = i === -1 ? r.column + t : t - i, r;
}
function Up(r, e) {
  if (!r)
    throw new Error(e || "unexpected compiler condition");
}
function gt(r, e, t = !1) {
  for (let s = 0; s < r.props.length; s++) {
    const i = r.props[s];
    if (i.type === 7 && (t || i.exp) && (Ie(e) ? i.name === e : e.test(i.name)))
      return i;
  }
}
function Qt(r, e, t = !1, s = !1) {
  for (let i = 0; i < r.props.length; i++) {
    const n = r.props[i];
    if (n.type === 6) {
      if (t) continue;
      if (n.name === e && (n.value || s))
        return n;
    } else if (n.name === "bind" && (n.exp || s) && jr(n.arg, e))
      return n;
  }
}
function jr(r, e) {
  return !!(r && Pt(r) && r.content === e);
}
function $c(r) {
  return r.props.some(
    (e) => e.type === 7 && e.name === "bind" && (!e.arg || // v-bind="obj"
    e.arg.type !== 4 || // v-bind:[_ctx.foo]
    !e.arg.isStatic)
    // v-bind:[foo]
  );
}
function Ha(r) {
  return r.type === 5 || r.type === 2;
}
function Sm(r) {
  return r.type === 7 && r.name === "slot";
}
function Fn(r) {
  return r.type === 1 && r.tagType === 3;
}
function Bn(r) {
  return r.type === 1 && r.tagType === 2;
}
const XO = /* @__PURE__ */ new Set([Ln, Yn]);
function AS(r, e = []) {
  if (r && !Ie(r) && r.type === 14) {
    const t = r.callee;
    if (!Ie(t) && XO.has(t))
      return AS(
        r.arguments[0],
        e.concat(r)
      );
  }
  return [r, e];
}
function po(r, e, t) {
  let s, i = r.type === 13 ? r.props : r.arguments[2], n = [], a;
  if (i && !Ie(i) && i.type === 14) {
    const o = AS(i);
    i = o[0], n = o[1], a = n[n.length - 1];
  }
  if (i == null || Ie(i))
    s = Yt([e]);
  else if (i.type === 14) {
    const o = i.arguments[0];
    !Ie(o) && o.type === 15 ? wy(e, o) || o.properties.unshift(e) : i.callee === Ac ? s = ge(t.helper(Gi), [
      Yt([e]),
      i
    ]) : i.arguments.unshift(Yt([e])), !s && (s = i);
  } else i.type === 15 ? (wy(e, i) || i.properties.unshift(e), s = i) : (s = ge(t.helper(Gi), [
    Yt([e]),
    i
  ]), a && a.callee === Yn && (a = n[n.length - 2]));
  r.type === 13 ? a ? a.arguments[0] = s : r.props = s : a ? a.arguments[0] = s : r.arguments[2] = s;
}
function wy(r, e) {
  let t = !1;
  if (r.key.type === 4) {
    const s = r.key.content;
    t = e.properties.some(
      (i) => i.key.type === 4 && i.key.content === s
    );
  }
  return t;
}
function ho(r, e) {
  return `_${e}_${r.replace(/[^\w]/g, (t, s) => t === "-" ? "_" : r.charCodeAt(s).toString())}`;
}
function Xt(r, e) {
  if (!r || Object.keys(e).length === 0)
    return !1;
  switch (r.type) {
    case 1:
      for (let t = 0; t < r.props.length; t++) {
        const s = r.props[t];
        if (s.type === 7 && (Xt(s.arg, e) || Xt(s.exp, e)))
          return !0;
      }
      return r.children.some((t) => Xt(t, e));
    case 11:
      return Xt(r.source, e) ? !0 : r.children.some((t) => Xt(t, e));
    case 9:
      return r.branches.some((t) => Xt(t, e));
    case 10:
      return Xt(r.condition, e) ? !0 : r.children.some((t) => Xt(t, e));
    case 4:
      return !r.isStatic && Ts(r.content) && !!e[r.content];
    case 8:
      return r.children.some((t) => pi(t) && Xt(t, e));
    case 5:
    case 12:
      return Xt(r.content, e);
    case 2:
    case 3:
      return !1;
    default:
      return !1;
  }
}
function CS(r) {
  return r.type === 14 && r.callee === Ic ? r.arguments[1].returns : r;
}
const NS = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/, OS = {
  parseMode: "base",
  ns: 0,
  delimiters: ["{{", "}}"],
  getNamespace: () => 0,
  isVoidTag: ku,
  isPreTag: ku,
  isCustomElement: ku,
  onError: em,
  onWarn: eS,
  comments: !0,
  prefixIdentifiers: !1
};
let ze = OS, xl = null, _s = "", kt = null, Re = null, hr = "", cs = -1, Si = -1, wl = 0, zs = !1, jp = null;
const it = [], Xe = new ZC(it, {
  onerr: Ut,
  ontext(r, e) {
    cu(It(r, e), r, e);
  },
  ontextentity(r, e, t) {
    cu(r, e, t);
  },
  oninterpolation(r, e) {
    if (zs)
      return cu(It(r, e), r, e);
    let t = r + Xe.delimiterOpen.length, s = e - Xe.delimiterClose.length;
    for (; sr(_s.charCodeAt(t)); )
      t++;
    for (; sr(_s.charCodeAt(s - 1)); )
      s--;
    let i = It(t, s);
    i.includes("&") && (i = QC(i)), qp({
      type: 5,
      content: Vu(i, !1, ht(t, s)),
      loc: ht(r, e)
    });
  },
  onopentagname(r, e) {
    const t = It(r, e);
    kt = {
      type: 1,
      tag: t,
      ns: ze.getNamespace(t, it[0], ze.ns),
      tagType: 0,
      // will be refined on tag close
      props: [],
      children: [],
      loc: ht(r - 1, e),
      codegenNode: void 0
    };
  },
  onopentagend(r) {
    Py(r);
  },
  onclosetag(r, e) {
    const t = It(r, e);
    if (!ze.isVoidTag(t)) {
      let s = !1;
      for (let i = 0; i < it.length; i++)
        if (it[i].tag.toLowerCase() === t.toLowerCase()) {
          s = !0, i > 0 && Ut(24, it[0].loc.start.offset);
          for (let a = 0; a <= i; a++) {
            const o = it.shift();
            Bu(o, e, a < i);
          }
          break;
        }
      s || Ut(23, IS(r, 60));
    }
  },
  onselfclosingtag(r) {
    const e = kt.tag;
    kt.isSelfClosing = !0, Py(r), it[0] && it[0].tag === e && Bu(it.shift(), r);
  },
  onattribname(r, e) {
    Re = {
      type: 6,
      name: It(r, e),
      nameLoc: ht(r, e),
      value: void 0,
      loc: ht(r)
    };
  },
  ondirname(r, e) {
    const t = It(r, e), s = t === "." || t === ":" ? "bind" : t === "@" ? "on" : t === "#" ? "slot" : t.slice(2);
    if (!zs && s === "" && Ut(26, r), zs || s === "")
      Re = {
        type: 6,
        name: t,
        nameLoc: ht(r, e),
        value: void 0,
        loc: ht(r)
      };
    else if (Re = {
      type: 7,
      name: s,
      rawName: t,
      exp: void 0,
      arg: void 0,
      modifiers: t === "." ? ["prop"] : [],
      loc: ht(r)
    }, s === "pre") {
      zs = Xe.inVPre = !0, jp = kt;
      const i = kt.props;
      for (let n = 0; n < i.length; n++)
        i[n].type === 7 && (i[n] = aI(i[n]));
    }
  },
  ondirarg(r, e) {
    if (r === e) return;
    const t = It(r, e);
    if (zs)
      Re.name += t, Ti(Re.nameLoc, e);
    else {
      const s = t[0] !== "[";
      Re.arg = Vu(
        s ? t : t.slice(1, -1),
        s,
        ht(r, e),
        s ? 3 : 0
      );
    }
  },
  ondirmodifier(r, e) {
    const t = It(r, e);
    if (zs)
      Re.name += "." + t, Ti(Re.nameLoc, e);
    else if (Re.name === "slot") {
      const s = Re.arg;
      s && (s.content += "." + t, Ti(s.loc, e));
    } else
      Re.modifiers.push(t);
  },
  onattribdata(r, e) {
    hr += It(r, e), cs < 0 && (cs = r), Si = e;
  },
  onattribentity(r, e, t) {
    hr += r, cs < 0 && (cs = e), Si = t;
  },
  onattribnameend(r) {
    const e = Re.loc.start.offset, t = It(e, r);
    Re.type === 7 && (Re.rawName = t), kt.props.some(
      (s) => (s.type === 7 ? s.rawName : s.name) === t
    ) && Ut(2, e);
  },
  onattribend(r, e) {
    if (kt && Re) {
      if (Ti(Re.loc, e), r !== 0)
        if (Re.type === 6)
          Re.name === "class" && (hr = DS(hr).trim()), r === 1 && !hr && Ut(13, e), Re.value = {
            type: 2,
            content: hr,
            loc: r === 1 ? ht(cs, Si) : ht(cs - 1, Si + 1)
          }, Xe.inSFCRoot && kt.tag === "template" && Re.name === "lang" && hr && hr !== "html" && Xe.enterRCDATA(bl("</template"), 0);
        else {
          let t = 0;
          Re.name === "for" ? t = 3 : Re.name === "slot" ? t = 1 : Re.name === "on" && hr.includes(";") && (t = 2), Re.exp = Vu(
            hr,
            !1,
            ht(cs, Si),
            0,
            t
          ), Re.name === "for" && (Re.forParseResult = YO(Re.exp));
        }
      (Re.type !== 7 || Re.name !== "pre") && kt.props.push(Re);
    }
    hr = "", cs = Si = -1;
  },
  oncomment(r, e) {
    ze.comments && qp({
      type: 3,
      content: It(r, e),
      loc: ht(r - 4, e + 3)
    });
  },
  onend() {
    const r = _s.length;
    if (Xe.state !== 1)
      switch (Xe.state) {
        case 5:
        case 8:
          Ut(5, r);
          break;
        case 3:
        case 4:
          Ut(
            25,
            Xe.sectionStart
          );
          break;
        case 28:
          Xe.currentSequence === _t.CdataEnd ? Ut(6, r) : Ut(7, r);
          break;
        case 6:
        case 7:
        case 9:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
          Ut(9, r);
          break;
      }
    for (let e = 0; e < it.length; e++)
      Bu(it[e], r - 1), Ut(24, it[e].loc.start.offset);
  },
  oncdata(r, e) {
    it[0].ns !== 0 ? cu(It(r, e), r, e) : Ut(1, r - 9);
  },
  onprocessinginstruction(r) {
    (it[0] ? it[0].ns : ze.ns) === 0 && Ut(
      21,
      r - 1
    );
  }
}), Ty = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, JO = /^\(|\)$/g;
function YO(r) {
  const e = r.loc, t = r.content, s = t.match(NS);
  if (!s) return;
  const [, i, n] = s, a = (f, p, h = !1) => {
    const m = e.start.offset + p, d = m + f.length;
    return Vu(
      f,
      !1,
      ht(m, d),
      0,
      h ? 1 : 0
      /* Normal */
    );
  }, o = {
    source: a(n.trim(), t.indexOf(n, i.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: !1
  };
  let u = i.trim().replace(JO, "").trim();
  const l = i.indexOf(u), c = u.match(Ty);
  if (c) {
    u = u.replace(Ty, "").trim();
    const f = c[1].trim();
    let p;
    if (f && (p = t.indexOf(f, l + u.length), o.key = a(f, p, !0)), c[2]) {
      const h = c[2].trim();
      h && (o.index = a(
        h,
        t.indexOf(
          h,
          o.key ? p + f.length : l + u.length
        ),
        !0
      ));
    }
  }
  return u && (o.value = a(u, l, !0)), o;
}
function It(r, e) {
  return _s.slice(r, e);
}
function Py(r) {
  Xe.inSFCRoot && (kt.innerLoc = ht(r + 1, r + 1)), qp(kt);
  const { tag: e, ns: t } = kt;
  t === 0 && ze.isPreTag(e) && wl++, ze.isVoidTag(e) ? Bu(kt, r) : (it.unshift(kt), (t === 1 || t === 2) && (Xe.inXML = !0)), kt = null;
}
function cu(r, e, t) {
  const s = it[0] || xl, i = s.children[s.children.length - 1];
  i && i.type === 2 ? (i.content += r, Ti(i.loc, t)) : s.children.push({
    type: 2,
    content: r,
    loc: ht(e, t)
  });
}
function Bu(r, e, t = !1) {
  t ? Ti(r.loc, IS(e, 60)) : Ti(r.loc, QO(e, 62) + 1), Xe.inSFCRoot && (r.children.length ? r.innerLoc.end = Jr({}, r.children[r.children.length - 1].loc.end) : r.innerLoc.end = Jr({}, r.innerLoc.start), r.innerLoc.source = It(
    r.innerLoc.start.offset,
    r.innerLoc.end.offset
  ));
  const { tag: s, ns: i } = r;
  zs || (s === "slot" ? r.tagType = 2 : eI(r) ? r.tagType = 3 : tI(r) && (r.tagType = 1)), Xe.inRCDATA || (r.children = kS(r.children, r.tag)), i === 0 && ze.isPreTag(s) && wl--, jp === r && (zs = Xe.inVPre = !1, jp = null), Xe.inXML && (it[0] ? it[0].ns : ze.ns) === 0 && (Xe.inXML = !1);
}
function QO(r, e) {
  let t = r;
  for (; _s.charCodeAt(t) !== e && t < _s.length - 1; ) t++;
  return t;
}
function IS(r, e) {
  let t = r;
  for (; _s.charCodeAt(t) !== e && t >= 0; ) t--;
  return t;
}
const ZO = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
function eI({ tag: r, props: e }) {
  if (r === "template") {
    for (let t = 0; t < e.length; t++)
      if (e[t].type === 7 && ZO.has(e[t].name))
        return !0;
  }
  return !1;
}
function tI({ tag: r, props: e }) {
  if (ze.isCustomElement(r))
    return !1;
  if (r === "component" || rI(r.charCodeAt(0)) || bm(r) || ze.isBuiltInComponent && ze.isBuiltInComponent(r) || ze.isNativeTag && !ze.isNativeTag(r))
    return !0;
  for (let t = 0; t < e.length; t++) {
    const s = e[t];
    if (s.type === 6 && s.name === "is" && s.value && s.value.content.startsWith("vue:"))
      return !0;
  }
  return !1;
}
function rI(r) {
  return r > 64 && r < 91;
}
const sI = /\r\n/g;
function kS(r, e) {
  const t = ze.whitespace !== "preserve";
  let s = !1;
  for (let i = 0; i < r.length; i++) {
    const n = r[i];
    if (n.type === 2)
      if (wl)
        n.content = n.content.replace(sI, `
`);
      else if (iI(n.content)) {
        const a = r[i - 1] && r[i - 1].type, o = r[i + 1] && r[i + 1].type;
        !a || !o || t && (a === 3 && (o === 3 || o === 1) || a === 1 && (o === 3 || o === 1 && nI(n.content))) ? (s = !0, r[i] = null) : n.content = " ";
      } else t && (n.content = DS(n.content));
  }
  if (wl && e && ze.isPreTag(e)) {
    const i = r[0];
    i && i.type === 2 && (i.content = i.content.replace(/^\r?\n/, ""));
  }
  return s ? r.filter(Boolean) : r;
}
function iI(r) {
  for (let e = 0; e < r.length; e++)
    if (!sr(r.charCodeAt(e)))
      return !1;
  return !0;
}
function nI(r) {
  for (let e = 0; e < r.length; e++) {
    const t = r.charCodeAt(e);
    if (t === 10 || t === 13)
      return !0;
  }
  return !1;
}
function DS(r) {
  let e = "", t = !1;
  for (let s = 0; s < r.length; s++)
    sr(r.charCodeAt(s)) ? t || (e += " ", t = !0) : (e += r[s], t = !1);
  return e;
}
function qp(r) {
  (it[0] || xl).children.push(r);
}
function ht(r, e) {
  return {
    start: Xe.getPos(r),
    // @ts-expect-error allow late attachment
    end: e == null ? e : Xe.getPos(e),
    // @ts-expect-error allow late attachment
    source: e == null ? e : It(r, e)
  };
}
function Ti(r, e) {
  r.end = Xe.getPos(e), r.source = It(r.start.offset, e);
}
function aI(r) {
  const e = {
    type: 6,
    name: r.rawName,
    nameLoc: ht(
      r.loc.start.offset,
      r.loc.start.offset + r.rawName.length
    ),
    value: void 0,
    loc: r.loc
  };
  if (r.exp) {
    const t = r.exp.loc;
    t.end.offset < r.loc.end.offset && (t.start.offset--, t.start.column--, t.end.offset++, t.end.column++), e.value = {
      type: 2,
      content: r.exp.content,
      loc: t
    };
  }
  return e;
}
function Vu(r, e = !1, t, s = 0, i = 0) {
  const n = Q(r, e, t, s);
  if (!e && ze.prefixIdentifiers && i !== 3 && r.trim()) {
    if (Ts(r))
      return n.ast = null, n;
    try {
      const a = ze.expressionPlugins, o = {
        plugins: a ? [...a, "typescript"] : ["typescript"]
      };
      i === 2 ? n.ast = $n(` ${r} `, o).program : i === 1 ? n.ast = _l(`(${r})=>{}`, o) : n.ast = _l(`(${r})`, o);
    } catch (a) {
      n.ast = !1, Ut(45, t.start.offset, a.message);
    }
  }
  return n;
}
function Ut(r, e, t) {
  ze.onError(
    Me(r, ht(e, e), void 0, t)
  );
}
function oI() {
  Xe.reset(), kt = null, Re = null, hr = "", cs = -1, Si = -1, it.length = 0;
}
function Fc(r, e) {
  if (oI(), _s = r, ze = Jr({}, OS), e) {
    let i;
    for (i in e)
      e[i] != null && (ze[i] = e[i]);
  }
  ze.decodeEntities && console.warn(
    "[@vue/compiler-core] decodeEntities option is passed but will be ignored in non-browser builds."
  ), Xe.mode = ze.parseMode === "html" ? 1 : ze.parseMode === "sfc" ? 2 : 0, Xe.inXML = ze.ns === 1 || ze.ns === 2;
  const t = e && e.delimiters;
  t && (Xe.delimiterOpen = bl(t[0]), Xe.delimiterClose = bl(t[1]));
  const s = xl = rn([], r);
  return Xe.parse(_s), s.loc = ht(0, r.length), s.children = kS(s.children), xl = null, s;
}
function uI(r, e) {
  Uu(
    r,
    e,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    LS(r, r.children[0])
  );
}
function LS(r, e) {
  const { children: t } = r;
  return t.length === 1 && e.type === 1 && !Bn(e);
}
function Uu(r, e, t = !1) {
  const { children: s } = r, i = s.length;
  let n = 0;
  for (let a = 0; a < s.length; a++) {
    const o = s[a];
    if (o.type === 1 && o.tagType === 0) {
      const u = t ? 0 : ir(o, e);
      if (u > 0) {
        if (u >= 2) {
          o.codegenNode.patchFlag = -1, o.codegenNode = e.hoist(o.codegenNode), n++;
          continue;
        }
      } else {
        const l = o.codegenNode;
        if (l.type === 13) {
          const c = l.patchFlag;
          if ((c === void 0 || c === 512 || c === 1) && RS(o, e) >= 2) {
            const f = $S(o);
            f && (l.props = e.hoist(f));
          }
          l.dynamicProps && (l.dynamicProps = e.hoist(l.dynamicProps));
        }
      }
    }
    if (o.type === 1) {
      const u = o.tagType === 1;
      u && e.scopes.vSlot++, Uu(o, e), u && e.scopes.vSlot--;
    } else if (o.type === 11)
      Uu(o, e, o.children.length === 1);
    else if (o.type === 9)
      for (let u = 0; u < o.branches.length; u++)
        Uu(
          o.branches[u],
          e,
          o.branches[u].children.length === 1
        );
  }
  if (n && e.transformHoist && e.transformHoist(s, e, r), n && n === i && r.type === 1 && r.tagType === 0 && r.codegenNode && r.codegenNode.type === 13 && er(r.codegenNode.children)) {
    const a = e.hoist(
      sn(r.codegenNode.children)
    );
    e.hmr && (a.content = `[...${a.content}]`), r.codegenNode.children = a;
  }
}
function ir(r, e) {
  const { constantCache: t } = e;
  switch (r.type) {
    case 1:
      if (r.tagType !== 0)
        return 0;
      const s = t.get(r);
      if (s !== void 0)
        return s;
      const i = r.codegenNode;
      if (i.type !== 13 || i.isBlock && r.tag !== "svg" && r.tag !== "foreignObject" && r.tag !== "math")
        return 0;
      if (i.patchFlag === void 0) {
        let a = 3;
        const o = RS(r, e);
        if (o === 0)
          return t.set(r, 0), 0;
        o < a && (a = o);
        for (let u = 0; u < r.children.length; u++) {
          const l = ir(r.children[u], e);
          if (l === 0)
            return t.set(r, 0), 0;
          l < a && (a = l);
        }
        if (a > 1)
          for (let u = 0; u < r.props.length; u++) {
            const l = r.props[u];
            if (l.type === 7 && l.name === "bind" && l.exp) {
              const c = ir(l.exp, e);
              if (c === 0)
                return t.set(r, 0), 0;
              c < a && (a = c);
            }
          }
        if (i.isBlock) {
          for (let u = 0; u < r.props.length; u++)
            if (r.props[u].type === 7)
              return t.set(r, 0), 0;
          e.removeHelper(ui), e.removeHelper(
            Xi(e.inSSR, i.isComponent)
          ), i.isBlock = !1, e.helper(Ki(e.inSSR, i.isComponent));
        }
        return t.set(r, a), a;
      } else
        return t.set(r, 0), 0;
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return ir(r.content, e);
    case 4:
      return r.constType;
    case 8:
      let n = 3;
      for (let a = 0; a < r.children.length; a++) {
        const o = r.children[a];
        if (Ie(o) || fi(o))
          continue;
        const u = ir(o, e);
        if (u === 0)
          return 0;
        u < n && (n = u);
      }
      return n;
    default:
      return 0;
  }
}
const lI = /* @__PURE__ */ new Set([
  Tc,
  Pc,
  Ln,
  Yn
]);
function MS(r, e) {
  if (r.type === 14 && !Ie(r.callee) && lI.has(r.callee)) {
    const t = r.arguments[0];
    if (t.type === 4)
      return ir(t, e);
    if (t.type === 14)
      return MS(t, e);
  }
  return 0;
}
function RS(r, e) {
  let t = 3;
  const s = $S(r);
  if (s && s.type === 15) {
    const { properties: i } = s;
    for (let n = 0; n < i.length; n++) {
      const { key: a, value: o } = i[n], u = ir(a, e);
      if (u === 0)
        return u;
      u < t && (t = u);
      let l;
      if (o.type === 4 ? l = ir(o, e) : o.type === 14 ? l = MS(o, e) : l = 0, l === 0)
        return l;
      l < t && (t = l);
    }
  }
  return t;
}
function $S(r) {
  const e = r.codegenNode;
  if (e.type === 13)
    return e.props;
}
function Ho(r, {
  filename: e = "",
  prefixIdentifiers: t = !1,
  hoistStatic: s = !1,
  hmr: i = !1,
  cacheHandlers: n = !1,
  nodeTransforms: a = [],
  directiveTransforms: o = {},
  transformHoist: u = null,
  isBuiltInComponent: l = Nf,
  isCustomElement: c = Nf,
  expressionPlugins: f = [],
  scopeId: p = null,
  slotted: h = !0,
  ssr: m = !1,
  inSSR: d = !1,
  ssrCssVars: y = "",
  bindingMetadata: S = cC,
  inline: E = !1,
  isTS: g = !1,
  onError: b = em,
  onWarn: v = eS,
  compatConfig: A
}) {
  const C = e.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), x = {
    // options
    filename: e,
    selfName: C && oi(or(C[1])),
    prefixIdentifiers: t,
    hoistStatic: s,
    hmr: i,
    cacheHandlers: n,
    nodeTransforms: a,
    directiveTransforms: o,
    transformHoist: u,
    isBuiltInComponent: l,
    isCustomElement: c,
    expressionPlugins: f,
    scopeId: p,
    slotted: h,
    ssr: m,
    inSSR: d,
    ssrCssVars: y,
    bindingMetadata: S,
    inline: E,
    isTS: g,
    onError: b,
    onWarn: v,
    compatConfig: A,
    // state
    root: r,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: r,
    childIndex: 0,
    inVOnce: !1,
    // methods
    helper(P) {
      const I = x.helpers.get(P) || 0;
      return x.helpers.set(P, I + 1), P;
    },
    removeHelper(P) {
      const I = x.helpers.get(P);
      if (I) {
        const $ = I - 1;
        $ ? x.helpers.set(P, $) : x.helpers.delete(P);
      }
    },
    helperString(P) {
      return `_${Jt[x.helper(P)]}`;
    },
    replaceNode(P) {
      {
        if (!x.currentNode)
          throw new Error("Node being replaced is already removed.");
        if (!x.parent)
          throw new Error("Cannot replace root node.");
      }
      x.parent.children[x.childIndex] = x.currentNode = P;
    },
    removeNode(P) {
      if (!x.parent)
        throw new Error("Cannot remove root node.");
      const I = x.parent.children, $ = P ? I.indexOf(P) : x.currentNode ? x.childIndex : -1;
      if ($ < 0)
        throw new Error("node being removed is not a child of current parent");
      !P || P === x.currentNode ? (x.currentNode = null, x.onNodeRemoved()) : x.childIndex > $ && (x.childIndex--, x.onNodeRemoved()), x.parent.children.splice($, 1);
    },
    onNodeRemoved: Nf,
    addIdentifiers(P) {
      Ie(P) ? _(P) : P.identifiers ? P.identifiers.forEach(_) : P.type === 4 && _(P.content);
    },
    removeIdentifiers(P) {
      Ie(P) ? T(P) : P.identifiers ? P.identifiers.forEach(T) : P.type === 4 && T(P.content);
    },
    hoist(P) {
      Ie(P) && (P = Q(P)), x.hoists.push(P);
      const I = Q(
        `_hoisted_${x.hoists.length}`,
        !1,
        P.loc,
        2
      );
      return I.hoisted = P, I;
    },
    cache(P, I = !1) {
      return GE(x.cached++, P, I);
    }
  };
  function _(P) {
    const { identifiers: I } = x;
    I[P] === void 0 && (I[P] = 0), I[P]++;
  }
  function T(P) {
    x.identifiers[P]--;
  }
  return x;
}
function _m(r, e) {
  const t = Ho(r, e);
  Qn(r, t), e.hoistStatic && uI(r, t), e.ssr || cI(r, t), r.helpers = /* @__PURE__ */ new Set([...t.helpers.keys()]), r.components = [...t.components], r.directives = [...t.directives], r.imports = t.imports, r.hoists = t.hoists, r.temps = t.temps, r.cached = t.cached, r.transformed = !0;
}
function cI(r, e) {
  const { helper: t } = e, { children: s } = r;
  if (s.length === 1) {
    const i = s[0];
    if (LS(r, i) && i.codegenNode) {
      const n = i.codegenNode;
      n.type === 13 && kc(n, e), r.codegenNode = n;
    } else
      r.codegenNode = i;
  } else if (s.length > 1) {
    let i = 64, n = ti[64];
    s.filter((a) => a.type !== 3).length === 1 && (i |= 2048, n += `, ${ti[2048]}`), r.codegenNode = Rn(
      e,
      t(Dn),
      void 0,
      r.children,
      i,
      void 0,
      void 0,
      !0,
      void 0,
      !1
    );
  }
}
function fI(r, e) {
  let t = 0;
  const s = () => {
    t--;
  };
  for (; t < r.children.length; t++) {
    const i = r.children[t];
    Ie(i) || (e.grandParent = e.parent, e.parent = r, e.childIndex = t, e.onNodeRemoved = s, Qn(i, e));
  }
}
function Qn(r, e) {
  e.currentNode = r;
  const { nodeTransforms: t } = e, s = [];
  for (let n = 0; n < t.length; n++) {
    const a = t[n](r, e);
    if (a && (er(a) ? s.push(...a) : s.push(a)), e.currentNode)
      r = e.currentNode;
    else
      return;
  }
  switch (r.type) {
    case 3:
      e.ssr || e.helper(Jn);
      break;
    case 5:
      e.ssr || e.helper(Fo);
      break;
    case 9:
      for (let n = 0; n < r.branches.length; n++)
        Qn(r.branches[n], e);
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      fI(r, e);
      break;
  }
  e.currentNode = r;
  let i = s.length;
  for (; i--; )
    s[i]();
}
function Wo(r, e) {
  const t = Ie(r) ? (s) => s === r : (s) => r.test(s);
  return (s, i) => {
    if (s.type === 1) {
      const { props: n } = s;
      if (s.tagType === 3 && n.some(Sm))
        return;
      const a = [];
      for (let o = 0; o < n.length; o++) {
        const u = n[o];
        if (u.type === 7 && t(u.name)) {
          n.splice(o, 1), o--;
          const l = e(s, u, i);
          l && a.push(l);
        }
      }
      return a;
    }
  };
}
var Zn = {}, xm = {}, Bc = {}, wm = {}, Ay = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
wm.encode = function(r) {
  if (0 <= r && r < Ay.length)
    return Ay[r];
  throw new TypeError("Must be between 0 and 63: " + r);
};
wm.decode = function(r) {
  var e = 65, t = 90, s = 97, i = 122, n = 48, a = 57, o = 43, u = 47, l = 26, c = 52;
  return e <= r && r <= t ? r - e : s <= r && r <= i ? r - s + l : n <= r && r <= a ? r - n + c : r == o ? 62 : r == u ? 63 : -1;
};
var FS = wm, Tm = 5, BS = 1 << Tm, VS = BS - 1, US = BS;
function pI(r) {
  return r < 0 ? (-r << 1) + 1 : (r << 1) + 0;
}
function hI(r) {
  var e = (r & 1) === 1, t = r >> 1;
  return e ? -t : t;
}
Bc.encode = function(e) {
  var t = "", s, i = pI(e);
  do
    s = i & VS, i >>>= Tm, i > 0 && (s |= US), t += FS.encode(s);
  while (i > 0);
  return t;
};
Bc.decode = function(e, t, s) {
  var i = e.length, n = 0, a = 0, o, u;
  do {
    if (t >= i)
      throw new Error("Expected more digits in base 64 VLQ value.");
    if (u = FS.decode(e.charCodeAt(t++)), u === -1)
      throw new Error("Invalid base64 digit: " + e.charAt(t - 1));
    o = !!(u & US), u &= VS, n = n + (u << a), a += Tm;
  } while (o);
  s.value = hI(n), s.rest = t;
};
var ea = {};
(function(r) {
  function e(x, _, T) {
    if (_ in x)
      return x[_];
    if (arguments.length === 3)
      return T;
    throw new Error('"' + _ + '" is a required argument.');
  }
  r.getArg = e;
  var t = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, s = /^data:.+\,.+$/;
  function i(x) {
    var _ = x.match(t);
    return _ ? {
      scheme: _[1],
      auth: _[2],
      host: _[3],
      port: _[4],
      path: _[5]
    } : null;
  }
  r.urlParse = i;
  function n(x) {
    var _ = "";
    return x.scheme && (_ += x.scheme + ":"), _ += "//", x.auth && (_ += x.auth + "@"), x.host && (_ += x.host), x.port && (_ += ":" + x.port), x.path && (_ += x.path), _;
  }
  r.urlGenerate = n;
  var a = 32;
  function o(x) {
    var _ = [];
    return function(T) {
      for (var P = 0; P < _.length; P++)
        if (_[P].input === T) {
          var I = _[0];
          return _[0] = _[P], _[P] = I, _[0].result;
        }
      var $ = x(T);
      return _.unshift({
        input: T,
        result: $
      }), _.length > a && _.pop(), $;
    };
  }
  var u = o(function(_) {
    var T = _, P = i(_);
    if (P) {
      if (!P.path)
        return _;
      T = P.path;
    }
    for (var I = r.isAbsolute(T), $ = [], Y = 0, W = 0; ; )
      if (Y = W, W = T.indexOf("/", Y), W === -1) {
        $.push(T.slice(Y));
        break;
      } else
        for ($.push(T.slice(Y, W)); W < T.length && T[W] === "/"; )
          W++;
    for (var F, K = 0, W = $.length - 1; W >= 0; W--)
      F = $[W], F === "." ? $.splice(W, 1) : F === ".." ? K++ : K > 0 && (F === "" ? ($.splice(W + 1, K), K = 0) : ($.splice(W, 2), K--));
    return T = $.join("/"), T === "" && (T = I ? "/" : "."), P ? (P.path = T, n(P)) : T;
  });
  r.normalize = u;
  function l(x, _) {
    x === "" && (x = "."), _ === "" && (_ = ".");
    var T = i(_), P = i(x);
    if (P && (x = P.path || "/"), T && !T.scheme)
      return P && (T.scheme = P.scheme), n(T);
    if (T || _.match(s))
      return _;
    if (P && !P.host && !P.path)
      return P.host = _, n(P);
    var I = _.charAt(0) === "/" ? _ : u(x.replace(/\/+$/, "") + "/" + _);
    return P ? (P.path = I, n(P)) : I;
  }
  r.join = l, r.isAbsolute = function(x) {
    return x.charAt(0) === "/" || t.test(x);
  };
  function c(x, _) {
    x === "" && (x = "."), x = x.replace(/\/$/, "");
    for (var T = 0; _.indexOf(x + "/") !== 0; ) {
      var P = x.lastIndexOf("/");
      if (P < 0 || (x = x.slice(0, P), x.match(/^([^\/]+:\/)?\/*$/)))
        return _;
      ++T;
    }
    return Array(T + 1).join("../") + _.substr(x.length + 1);
  }
  r.relative = c;
  var f = function() {
    var x = /* @__PURE__ */ Object.create(null);
    return !("__proto__" in x);
  }();
  function p(x) {
    return x;
  }
  function h(x) {
    return d(x) ? "$" + x : x;
  }
  r.toSetString = f ? p : h;
  function m(x) {
    return d(x) ? x.slice(1) : x;
  }
  r.fromSetString = f ? p : m;
  function d(x) {
    if (!x)
      return !1;
    var _ = x.length;
    if (_ < 9 || x.charCodeAt(_ - 1) !== 95 || x.charCodeAt(_ - 2) !== 95 || x.charCodeAt(_ - 3) !== 111 || x.charCodeAt(_ - 4) !== 116 || x.charCodeAt(_ - 5) !== 111 || x.charCodeAt(_ - 6) !== 114 || x.charCodeAt(_ - 7) !== 112 || x.charCodeAt(_ - 8) !== 95 || x.charCodeAt(_ - 9) !== 95)
      return !1;
    for (var T = _ - 10; T >= 0; T--)
      if (x.charCodeAt(T) !== 36)
        return !1;
    return !0;
  }
  function y(x, _, T) {
    var P = b(x.source, _.source);
    return P !== 0 || (P = x.originalLine - _.originalLine, P !== 0) || (P = x.originalColumn - _.originalColumn, P !== 0 || T) || (P = x.generatedColumn - _.generatedColumn, P !== 0) || (P = x.generatedLine - _.generatedLine, P !== 0) ? P : b(x.name, _.name);
  }
  r.compareByOriginalPositions = y;
  function S(x, _, T) {
    var P;
    return P = x.originalLine - _.originalLine, P !== 0 || (P = x.originalColumn - _.originalColumn, P !== 0 || T) || (P = x.generatedColumn - _.generatedColumn, P !== 0) || (P = x.generatedLine - _.generatedLine, P !== 0) ? P : b(x.name, _.name);
  }
  r.compareByOriginalPositionsNoSource = S;
  function E(x, _, T) {
    var P = x.generatedLine - _.generatedLine;
    return P !== 0 || (P = x.generatedColumn - _.generatedColumn, P !== 0 || T) || (P = b(x.source, _.source), P !== 0) || (P = x.originalLine - _.originalLine, P !== 0) || (P = x.originalColumn - _.originalColumn, P !== 0) ? P : b(x.name, _.name);
  }
  r.compareByGeneratedPositionsDeflated = E;
  function g(x, _, T) {
    var P = x.generatedColumn - _.generatedColumn;
    return P !== 0 || T || (P = b(x.source, _.source), P !== 0) || (P = x.originalLine - _.originalLine, P !== 0) || (P = x.originalColumn - _.originalColumn, P !== 0) ? P : b(x.name, _.name);
  }
  r.compareByGeneratedPositionsDeflatedNoLine = g;
  function b(x, _) {
    return x === _ ? 0 : x === null ? 1 : _ === null ? -1 : x > _ ? 1 : -1;
  }
  function v(x, _) {
    var T = x.generatedLine - _.generatedLine;
    return T !== 0 || (T = x.generatedColumn - _.generatedColumn, T !== 0) || (T = b(x.source, _.source), T !== 0) || (T = x.originalLine - _.originalLine, T !== 0) || (T = x.originalColumn - _.originalColumn, T !== 0) ? T : b(x.name, _.name);
  }
  r.compareByGeneratedPositionsInflated = v;
  function A(x) {
    return JSON.parse(x.replace(/^\)]}'[^\n]*\n/, ""));
  }
  r.parseSourceMapInput = A;
  function C(x, _, T) {
    if (_ = _ || "", x && (x[x.length - 1] !== "/" && _[0] !== "/" && (x += "/"), _ = x + _), T) {
      var P = i(T);
      if (!P)
        throw new Error("sourceMapURL could not be parsed");
      if (P.path) {
        var I = P.path.lastIndexOf("/");
        I >= 0 && (P.path = P.path.substring(0, I + 1));
      }
      _ = l(n(P), _);
    }
    return u(_);
  }
  r.computeSourceURL = C;
})(ea);
var Pm = {}, Am = ea, Cm = Object.prototype.hasOwnProperty, Fi = typeof Map < "u";
function Ps() {
  this._array = [], this._set = Fi ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
}
Ps.fromArray = function(e, t) {
  for (var s = new Ps(), i = 0, n = e.length; i < n; i++)
    s.add(e[i], t);
  return s;
};
Ps.prototype.size = function() {
  return Fi ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
Ps.prototype.add = function(e, t) {
  var s = Fi ? e : Am.toSetString(e), i = Fi ? this.has(e) : Cm.call(this._set, s), n = this._array.length;
  (!i || t) && this._array.push(e), i || (Fi ? this._set.set(e, n) : this._set[s] = n);
};
Ps.prototype.has = function(e) {
  if (Fi)
    return this._set.has(e);
  var t = Am.toSetString(e);
  return Cm.call(this._set, t);
};
Ps.prototype.indexOf = function(e) {
  if (Fi) {
    var t = this._set.get(e);
    if (t >= 0)
      return t;
  } else {
    var s = Am.toSetString(e);
    if (Cm.call(this._set, s))
      return this._set[s];
  }
  throw new Error('"' + e + '" is not in the set.');
};
Ps.prototype.at = function(e) {
  if (e >= 0 && e < this._array.length)
    return this._array[e];
  throw new Error("No element indexed by " + e);
};
Ps.prototype.toArray = function() {
  return this._array.slice();
};
Pm.ArraySet = Ps;
var jS = {}, qS = ea;
function dI(r, e) {
  var t = r.generatedLine, s = e.generatedLine, i = r.generatedColumn, n = e.generatedColumn;
  return s > t || s == t && n >= i || qS.compareByGeneratedPositionsInflated(r, e) <= 0;
}
function Vc() {
  this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
}
Vc.prototype.unsortedForEach = function(e, t) {
  this._array.forEach(e, t);
};
Vc.prototype.add = function(e) {
  dI(this._last, e) ? (this._last = e, this._array.push(e)) : (this._sorted = !1, this._array.push(e));
};
Vc.prototype.toArray = function() {
  return this._sorted || (this._array.sort(qS.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
};
jS.MappingList = Vc;
var va = Bc, at = ea, Tl = Pm.ArraySet, mI = jS.MappingList;
function vr(r) {
  r || (r = {}), this._file = at.getArg(r, "file", null), this._sourceRoot = at.getArg(r, "sourceRoot", null), this._skipValidation = at.getArg(r, "skipValidation", !1), this._ignoreInvalidMapping = at.getArg(r, "ignoreInvalidMapping", !1), this._sources = new Tl(), this._names = new Tl(), this._mappings = new mI(), this._sourcesContents = null;
}
vr.prototype._version = 3;
vr.fromSourceMap = function(e, t) {
  var s = e.sourceRoot, i = new vr(Object.assign(t || {}, {
    file: e.file,
    sourceRoot: s
  }));
  return e.eachMapping(function(n) {
    var a = {
      generated: {
        line: n.generatedLine,
        column: n.generatedColumn
      }
    };
    n.source != null && (a.source = n.source, s != null && (a.source = at.relative(s, a.source)), a.original = {
      line: n.originalLine,
      column: n.originalColumn
    }, n.name != null && (a.name = n.name)), i.addMapping(a);
  }), e.sources.forEach(function(n) {
    var a = n;
    s !== null && (a = at.relative(s, n)), i._sources.has(a) || i._sources.add(a);
    var o = e.sourceContentFor(n);
    o != null && i.setSourceContent(n, o);
  }), i;
};
vr.prototype.addMapping = function(e) {
  var t = at.getArg(e, "generated"), s = at.getArg(e, "original", null), i = at.getArg(e, "source", null), n = at.getArg(e, "name", null);
  !this._skipValidation && this._validateMapping(t, s, i, n) === !1 || (i != null && (i = String(i), this._sources.has(i) || this._sources.add(i)), n != null && (n = String(n), this._names.has(n) || this._names.add(n)), this._mappings.add({
    generatedLine: t.line,
    generatedColumn: t.column,
    originalLine: s != null && s.line,
    originalColumn: s != null && s.column,
    source: i,
    name: n
  }));
};
vr.prototype.setSourceContent = function(e, t) {
  var s = e;
  this._sourceRoot != null && (s = at.relative(this._sourceRoot, s)), t != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[at.toSetString(s)] = t) : this._sourcesContents && (delete this._sourcesContents[at.toSetString(s)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
};
vr.prototype.applySourceMap = function(e, t, s) {
  var i = t;
  if (t == null) {
    if (e.file == null)
      throw new Error(
        `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
      );
    i = e.file;
  }
  var n = this._sourceRoot;
  n != null && (i = at.relative(n, i));
  var a = new Tl(), o = new Tl();
  this._mappings.unsortedForEach(function(u) {
    if (u.source === i && u.originalLine != null) {
      var l = e.originalPositionFor({
        line: u.originalLine,
        column: u.originalColumn
      });
      l.source != null && (u.source = l.source, s != null && (u.source = at.join(s, u.source)), n != null && (u.source = at.relative(n, u.source)), u.originalLine = l.line, u.originalColumn = l.column, l.name != null && (u.name = l.name));
    }
    var c = u.source;
    c != null && !a.has(c) && a.add(c);
    var f = u.name;
    f != null && !o.has(f) && o.add(f);
  }, this), this._sources = a, this._names = o, e.sources.forEach(function(u) {
    var l = e.sourceContentFor(u);
    l != null && (s != null && (u = at.join(s, u)), n != null && (u = at.relative(n, u)), this.setSourceContent(u, l));
  }, this);
};
vr.prototype._validateMapping = function(e, t, s, i) {
  if (t && typeof t.line != "number" && typeof t.column != "number") {
    var n = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
    if (this._ignoreInvalidMapping)
      return typeof console < "u" && console.warn && console.warn(n), !1;
    throw new Error(n);
  }
  if (!(e && "line" in e && "column" in e && e.line > 0 && e.column >= 0 && !t && !s && !i)) {
    if (e && "line" in e && "column" in e && t && "line" in t && "column" in t && e.line > 0 && e.column >= 0 && t.line > 0 && t.column >= 0 && s)
      return;
    var n = "Invalid mapping: " + JSON.stringify({
      generated: e,
      source: s,
      original: t,
      name: i
    });
    if (this._ignoreInvalidMapping)
      return typeof console < "u" && console.warn && console.warn(n), !1;
    throw new Error(n);
  }
};
vr.prototype._serializeMappings = function() {
  for (var e = 0, t = 1, s = 0, i = 0, n = 0, a = 0, o = "", u, l, c, f, p = this._mappings.toArray(), h = 0, m = p.length; h < m; h++) {
    if (l = p[h], u = "", l.generatedLine !== t)
      for (e = 0; l.generatedLine !== t; )
        u += ";", t++;
    else if (h > 0) {
      if (!at.compareByGeneratedPositionsInflated(l, p[h - 1]))
        continue;
      u += ",";
    }
    u += va.encode(l.generatedColumn - e), e = l.generatedColumn, l.source != null && (f = this._sources.indexOf(l.source), u += va.encode(f - a), a = f, u += va.encode(l.originalLine - 1 - i), i = l.originalLine - 1, u += va.encode(l.originalColumn - s), s = l.originalColumn, l.name != null && (c = this._names.indexOf(l.name), u += va.encode(c - n), n = c)), o += u;
  }
  return o;
};
vr.prototype._generateSourcesContent = function(e, t) {
  return e.map(function(s) {
    if (!this._sourcesContents)
      return null;
    t != null && (s = at.relative(t, s));
    var i = at.toSetString(s);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, i) ? this._sourcesContents[i] : null;
  }, this);
};
vr.prototype.toJSON = function() {
  var e = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  return this._file != null && (e.file = this._file), this._sourceRoot != null && (e.sourceRoot = this._sourceRoot), this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot)), e;
};
vr.prototype.toString = function() {
  return JSON.stringify(this.toJSON());
};
xm.SourceMapGenerator = vr;
var Uc = {}, HS = {};
(function(r) {
  r.GREATEST_LOWER_BOUND = 1, r.LEAST_UPPER_BOUND = 2;
  function e(t, s, i, n, a, o) {
    var u = Math.floor((s - t) / 2) + t, l = a(i, n[u], !0);
    return l === 0 ? u : l > 0 ? s - u > 1 ? e(u, s, i, n, a, o) : o == r.LEAST_UPPER_BOUND ? s < n.length ? s : -1 : u : u - t > 1 ? e(t, u, i, n, a, o) : o == r.LEAST_UPPER_BOUND ? u : t < 0 ? -1 : t;
  }
  r.search = function(s, i, n, a) {
    if (i.length === 0)
      return -1;
    var o = e(
      -1,
      i.length,
      s,
      i,
      n,
      a || r.GREATEST_LOWER_BOUND
    );
    if (o < 0)
      return -1;
    for (; o - 1 >= 0 && n(i[o], i[o - 1], !0) === 0; )
      --o;
    return o;
  };
})(HS);
var WS = {};
function gI(r) {
  function e(i, n, a) {
    var o = i[n];
    i[n] = i[a], i[a] = o;
  }
  function t(i, n) {
    return Math.round(i + Math.random() * (n - i));
  }
  function s(i, n, a, o) {
    if (a < o) {
      var u = t(a, o), l = a - 1;
      e(i, u, o);
      for (var c = i[o], f = a; f < o; f++)
        n(i[f], c, !1) <= 0 && (l += 1, e(i, l, f));
      e(i, l + 1, f);
      var p = l + 1;
      s(i, n, a, p - 1), s(i, n, p + 1, o);
    }
  }
  return s;
}
function yI(r) {
  let e = gI.toString();
  return new Function(`return ${e}`)()(r);
}
let Cy = /* @__PURE__ */ new WeakMap();
WS.quickSort = function(r, e, t = 0) {
  let s = Cy.get(e);
  s === void 0 && (s = yI(e), Cy.set(e, s)), s(r, e, t, r.length - 1);
};
var ue = ea, Nm = HS, Vn = Pm.ArraySet, bI = Bc, mo = WS.quickSort;
function Ye(r, e) {
  var t = r;
  return typeof r == "string" && (t = ue.parseSourceMapInput(r)), t.sections != null ? new Ir(t, e) : new Nt(t, e);
}
Ye.fromSourceMap = function(r, e) {
  return Nt.fromSourceMap(r, e);
};
Ye.prototype._version = 3;
Ye.prototype.__generatedMappings = null;
Object.defineProperty(Ye.prototype, "_generatedMappings", {
  configurable: !0,
  enumerable: !0,
  get: function() {
    return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
  }
});
Ye.prototype.__originalMappings = null;
Object.defineProperty(Ye.prototype, "_originalMappings", {
  configurable: !0,
  enumerable: !0,
  get: function() {
    return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
  }
});
Ye.prototype._charIsMappingSeparator = function(e, t) {
  var s = e.charAt(t);
  return s === ";" || s === ",";
};
Ye.prototype._parseMappings = function(e, t) {
  throw new Error("Subclasses must implement _parseMappings");
};
Ye.GENERATED_ORDER = 1;
Ye.ORIGINAL_ORDER = 2;
Ye.GREATEST_LOWER_BOUND = 1;
Ye.LEAST_UPPER_BOUND = 2;
Ye.prototype.eachMapping = function(e, t, s) {
  var i = t || null, n = s || Ye.GENERATED_ORDER, a;
  switch (n) {
    case Ye.GENERATED_ORDER:
      a = this._generatedMappings;
      break;
    case Ye.ORIGINAL_ORDER:
      a = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }
  for (var o = this.sourceRoot, u = e.bind(i), l = this._names, c = this._sources, f = this._sourceMapURL, p = 0, h = a.length; p < h; p++) {
    var m = a[p], d = m.source === null ? null : c.at(m.source);
    d = ue.computeSourceURL(o, d, f), u({
      source: d,
      generatedLine: m.generatedLine,
      generatedColumn: m.generatedColumn,
      originalLine: m.originalLine,
      originalColumn: m.originalColumn,
      name: m.name === null ? null : l.at(m.name)
    });
  }
};
Ye.prototype.allGeneratedPositionsFor = function(e) {
  var t = ue.getArg(e, "line"), s = {
    source: ue.getArg(e, "source"),
    originalLine: t,
    originalColumn: ue.getArg(e, "column", 0)
  };
  if (s.source = this._findSourceIndex(s.source), s.source < 0)
    return [];
  var i = [], n = this._findMapping(
    s,
    this._originalMappings,
    "originalLine",
    "originalColumn",
    ue.compareByOriginalPositions,
    Nm.LEAST_UPPER_BOUND
  );
  if (n >= 0) {
    var a = this._originalMappings[n];
    if (e.column === void 0)
      for (var o = a.originalLine; a && a.originalLine === o; )
        i.push({
          line: ue.getArg(a, "generatedLine", null),
          column: ue.getArg(a, "generatedColumn", null),
          lastColumn: ue.getArg(a, "lastGeneratedColumn", null)
        }), a = this._originalMappings[++n];
    else
      for (var u = a.originalColumn; a && a.originalLine === t && a.originalColumn == u; )
        i.push({
          line: ue.getArg(a, "generatedLine", null),
          column: ue.getArg(a, "generatedColumn", null),
          lastColumn: ue.getArg(a, "lastGeneratedColumn", null)
        }), a = this._originalMappings[++n];
  }
  return i;
};
Uc.SourceMapConsumer = Ye;
function Nt(r, e) {
  var t = r;
  typeof r == "string" && (t = ue.parseSourceMapInput(r));
  var s = ue.getArg(t, "version"), i = ue.getArg(t, "sources"), n = ue.getArg(t, "names", []), a = ue.getArg(t, "sourceRoot", null), o = ue.getArg(t, "sourcesContent", null), u = ue.getArg(t, "mappings"), l = ue.getArg(t, "file", null);
  if (s != this._version)
    throw new Error("Unsupported version: " + s);
  a && (a = ue.normalize(a)), i = i.map(String).map(ue.normalize).map(function(c) {
    return a && ue.isAbsolute(a) && ue.isAbsolute(c) ? ue.relative(a, c) : c;
  }), this._names = Vn.fromArray(n.map(String), !0), this._sources = Vn.fromArray(i, !0), this._absoluteSources = this._sources.toArray().map(function(c) {
    return ue.computeSourceURL(a, c, e);
  }), this.sourceRoot = a, this.sourcesContent = o, this._mappings = u, this._sourceMapURL = e, this.file = l;
}
Nt.prototype = Object.create(Ye.prototype);
Nt.prototype.consumer = Ye;
Nt.prototype._findSourceIndex = function(r) {
  var e = r;
  if (this.sourceRoot != null && (e = ue.relative(this.sourceRoot, e)), this._sources.has(e))
    return this._sources.indexOf(e);
  var t;
  for (t = 0; t < this._absoluteSources.length; ++t)
    if (this._absoluteSources[t] == r)
      return t;
  return -1;
};
Nt.fromSourceMap = function(e, t) {
  var s = Object.create(Nt.prototype), i = s._names = Vn.fromArray(e._names.toArray(), !0), n = s._sources = Vn.fromArray(e._sources.toArray(), !0);
  s.sourceRoot = e._sourceRoot, s.sourcesContent = e._generateSourcesContent(
    s._sources.toArray(),
    s.sourceRoot
  ), s.file = e._file, s._sourceMapURL = t, s._absoluteSources = s._sources.toArray().map(function(h) {
    return ue.computeSourceURL(s.sourceRoot, h, t);
  });
  for (var a = e._mappings.toArray().slice(), o = s.__generatedMappings = [], u = s.__originalMappings = [], l = 0, c = a.length; l < c; l++) {
    var f = a[l], p = new zS();
    p.generatedLine = f.generatedLine, p.generatedColumn = f.generatedColumn, f.source && (p.source = n.indexOf(f.source), p.originalLine = f.originalLine, p.originalColumn = f.originalColumn, f.name && (p.name = i.indexOf(f.name)), u.push(p)), o.push(p);
  }
  return mo(s.__originalMappings, ue.compareByOriginalPositions), s;
};
Nt.prototype._version = 3;
Object.defineProperty(Nt.prototype, "sources", {
  get: function() {
    return this._absoluteSources.slice();
  }
});
function zS() {
  this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
}
const Ff = ue.compareByGeneratedPositionsDeflatedNoLine;
function Ny(r, e) {
  let t = r.length, s = r.length - e;
  if (!(s <= 1))
    if (s == 2) {
      let i = r[e], n = r[e + 1];
      Ff(i, n) > 0 && (r[e] = n, r[e + 1] = i);
    } else if (s < 20)
      for (let i = e; i < t; i++)
        for (let n = i; n > e; n--) {
          let a = r[n - 1], o = r[n];
          if (Ff(a, o) <= 0)
            break;
          r[n - 1] = o, r[n] = a;
        }
    else
      mo(r, Ff, e);
}
Nt.prototype._parseMappings = function(e, t) {
  var s = 1, i = 0, n = 0, a = 0, o = 0, u = 0, l = e.length, c = 0, f = {}, p = [], h = [], m, d, y, S;
  let E = 0;
  for (; c < l; )
    if (e.charAt(c) === ";")
      s++, c++, i = 0, Ny(h, E), E = h.length;
    else if (e.charAt(c) === ",")
      c++;
    else {
      for (m = new zS(), m.generatedLine = s, y = c; y < l && !this._charIsMappingSeparator(e, y); y++)
        ;
      for (e.slice(c, y), d = []; c < y; )
        bI.decode(e, c, f), S = f.value, c = f.rest, d.push(S);
      if (d.length === 2)
        throw new Error("Found a source, but no line and column");
      if (d.length === 3)
        throw new Error("Found a source and line, but no column");
      if (m.generatedColumn = i + d[0], i = m.generatedColumn, d.length > 1 && (m.source = o + d[1], o += d[1], m.originalLine = n + d[2], n = m.originalLine, m.originalLine += 1, m.originalColumn = a + d[3], a = m.originalColumn, d.length > 4 && (m.name = u + d[4], u += d[4])), h.push(m), typeof m.originalLine == "number") {
        let b = m.source;
        for (; p.length <= b; )
          p.push(null);
        p[b] === null && (p[b] = []), p[b].push(m);
      }
    }
  Ny(h, E), this.__generatedMappings = h;
  for (var g = 0; g < p.length; g++)
    p[g] != null && mo(p[g], ue.compareByOriginalPositionsNoSource);
  this.__originalMappings = [].concat(...p);
};
Nt.prototype._findMapping = function(e, t, s, i, n, a) {
  if (e[s] <= 0)
    throw new TypeError("Line must be greater than or equal to 1, got " + e[s]);
  if (e[i] < 0)
    throw new TypeError("Column must be greater than or equal to 0, got " + e[i]);
  return Nm.search(e, t, n, a);
};
Nt.prototype.computeColumnSpans = function() {
  for (var e = 0; e < this._generatedMappings.length; ++e) {
    var t = this._generatedMappings[e];
    if (e + 1 < this._generatedMappings.length) {
      var s = this._generatedMappings[e + 1];
      if (t.generatedLine === s.generatedLine) {
        t.lastGeneratedColumn = s.generatedColumn - 1;
        continue;
      }
    }
    t.lastGeneratedColumn = 1 / 0;
  }
};
Nt.prototype.originalPositionFor = function(e) {
  var t = {
    generatedLine: ue.getArg(e, "line"),
    generatedColumn: ue.getArg(e, "column")
  }, s = this._findMapping(
    t,
    this._generatedMappings,
    "generatedLine",
    "generatedColumn",
    ue.compareByGeneratedPositionsDeflated,
    ue.getArg(e, "bias", Ye.GREATEST_LOWER_BOUND)
  );
  if (s >= 0) {
    var i = this._generatedMappings[s];
    if (i.generatedLine === t.generatedLine) {
      var n = ue.getArg(i, "source", null);
      n !== null && (n = this._sources.at(n), n = ue.computeSourceURL(this.sourceRoot, n, this._sourceMapURL));
      var a = ue.getArg(i, "name", null);
      return a !== null && (a = this._names.at(a)), {
        source: n,
        line: ue.getArg(i, "originalLine", null),
        column: ue.getArg(i, "originalColumn", null),
        name: a
      };
    }
  }
  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
Nt.prototype.hasContentsOfAllSources = function() {
  return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e) {
    return e == null;
  }) : !1;
};
Nt.prototype.sourceContentFor = function(e, t) {
  if (!this.sourcesContent)
    return null;
  var s = this._findSourceIndex(e);
  if (s >= 0)
    return this.sourcesContent[s];
  var i = e;
  this.sourceRoot != null && (i = ue.relative(this.sourceRoot, i));
  var n;
  if (this.sourceRoot != null && (n = ue.urlParse(this.sourceRoot))) {
    var a = i.replace(/^file:\/\//, "");
    if (n.scheme == "file" && this._sources.has(a))
      return this.sourcesContent[this._sources.indexOf(a)];
    if ((!n.path || n.path == "/") && this._sources.has("/" + i))
      return this.sourcesContent[this._sources.indexOf("/" + i)];
  }
  if (t)
    return null;
  throw new Error('"' + i + '" is not in the SourceMap.');
};
Nt.prototype.generatedPositionFor = function(e) {
  var t = ue.getArg(e, "source");
  if (t = this._findSourceIndex(t), t < 0)
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  var s = {
    source: t,
    originalLine: ue.getArg(e, "line"),
    originalColumn: ue.getArg(e, "column")
  }, i = this._findMapping(
    s,
    this._originalMappings,
    "originalLine",
    "originalColumn",
    ue.compareByOriginalPositions,
    ue.getArg(e, "bias", Ye.GREATEST_LOWER_BOUND)
  );
  if (i >= 0) {
    var n = this._originalMappings[i];
    if (n.source === s.source)
      return {
        line: ue.getArg(n, "generatedLine", null),
        column: ue.getArg(n, "generatedColumn", null),
        lastColumn: ue.getArg(n, "lastGeneratedColumn", null)
      };
  }
  return {
    line: null,
    column: null,
    lastColumn: null
  };
};
Uc.BasicSourceMapConsumer = Nt;
function Ir(r, e) {
  var t = r;
  typeof r == "string" && (t = ue.parseSourceMapInput(r));
  var s = ue.getArg(t, "version"), i = ue.getArg(t, "sections");
  if (s != this._version)
    throw new Error("Unsupported version: " + s);
  this._sources = new Vn(), this._names = new Vn();
  var n = {
    line: -1,
    column: 0
  };
  this._sections = i.map(function(a) {
    if (a.url)
      throw new Error("Support for url field in sections not implemented.");
    var o = ue.getArg(a, "offset"), u = ue.getArg(o, "line"), l = ue.getArg(o, "column");
    if (u < n.line || u === n.line && l < n.column)
      throw new Error("Section offsets must be ordered and non-overlapping.");
    return n = o, {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: u + 1,
        generatedColumn: l + 1
      },
      consumer: new Ye(ue.getArg(a, "map"), e)
    };
  });
}
Ir.prototype = Object.create(Ye.prototype);
Ir.prototype.constructor = Ye;
Ir.prototype._version = 3;
Object.defineProperty(Ir.prototype, "sources", {
  get: function() {
    for (var r = [], e = 0; e < this._sections.length; e++)
      for (var t = 0; t < this._sections[e].consumer.sources.length; t++)
        r.push(this._sections[e].consumer.sources[t]);
    return r;
  }
});
Ir.prototype.originalPositionFor = function(e) {
  var t = {
    generatedLine: ue.getArg(e, "line"),
    generatedColumn: ue.getArg(e, "column")
  }, s = Nm.search(
    t,
    this._sections,
    function(n, a) {
      var o = n.generatedLine - a.generatedOffset.generatedLine;
      return o || n.generatedColumn - a.generatedOffset.generatedColumn;
    }
  ), i = this._sections[s];
  return i ? i.consumer.originalPositionFor({
    line: t.generatedLine - (i.generatedOffset.generatedLine - 1),
    column: t.generatedColumn - (i.generatedOffset.generatedLine === t.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),
    bias: e.bias
  }) : {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
Ir.prototype.hasContentsOfAllSources = function() {
  return this._sections.every(function(e) {
    return e.consumer.hasContentsOfAllSources();
  });
};
Ir.prototype.sourceContentFor = function(e, t) {
  for (var s = 0; s < this._sections.length; s++) {
    var i = this._sections[s], n = i.consumer.sourceContentFor(e, !0);
    if (n || n === "")
      return n;
  }
  if (t)
    return null;
  throw new Error('"' + e + '" is not in the SourceMap.');
};
Ir.prototype.generatedPositionFor = function(e) {
  for (var t = 0; t < this._sections.length; t++) {
    var s = this._sections[t];
    if (s.consumer._findSourceIndex(ue.getArg(e, "source")) !== -1) {
      var i = s.consumer.generatedPositionFor(e);
      if (i) {
        var n = {
          line: i.line + (s.generatedOffset.generatedLine - 1),
          column: i.column + (s.generatedOffset.generatedLine === i.line ? s.generatedOffset.generatedColumn - 1 : 0)
        };
        return n;
      }
    }
  }
  return {
    line: null,
    column: null
  };
};
Ir.prototype._parseMappings = function(e, t) {
  this.__generatedMappings = [], this.__originalMappings = [];
  for (var s = 0; s < this._sections.length; s++)
    for (var i = this._sections[s], n = i.consumer._generatedMappings, a = 0; a < n.length; a++) {
      var o = n[a], u = i.consumer._sources.at(o.source);
      u = ue.computeSourceURL(i.consumer.sourceRoot, u, this._sourceMapURL), this._sources.add(u), u = this._sources.indexOf(u);
      var l = null;
      o.name && (l = i.consumer._names.at(o.name), this._names.add(l), l = this._names.indexOf(l));
      var c = {
        source: u,
        generatedLine: o.generatedLine + (i.generatedOffset.generatedLine - 1),
        generatedColumn: o.generatedColumn + (i.generatedOffset.generatedLine === o.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),
        originalLine: o.originalLine,
        originalColumn: o.originalColumn,
        name: l
      };
      this.__generatedMappings.push(c), typeof c.originalLine == "number" && this.__originalMappings.push(c);
    }
  mo(this.__generatedMappings, ue.compareByGeneratedPositionsDeflated), mo(this.__originalMappings, ue.compareByOriginalPositions);
};
Uc.IndexedSourceMapConsumer = Ir;
var GS = {}, vI = xm.SourceMapGenerator, Pl = ea, EI = /(\r?\n)/, SI = 10, ta = "$$$isSourceNode$$$";
function ur(r, e, t, s, i) {
  this.children = [], this.sourceContents = {}, this.line = r ?? null, this.column = e ?? null, this.source = t ?? null, this.name = i ?? null, this[ta] = !0, s != null && this.add(s);
}
ur.fromStringWithSourceMap = function(e, t, s) {
  var i = new ur(), n = e.split(EI), a = 0, o = function() {
    var p = m(), h = m() || "";
    return p + h;
    function m() {
      return a < n.length ? n[a++] : void 0;
    }
  }, u = 1, l = 0, c = null;
  return t.eachMapping(function(p) {
    if (c !== null)
      if (u < p.generatedLine)
        f(c, o()), u++, l = 0;
      else {
        var h = n[a] || "", m = h.substr(0, p.generatedColumn - l);
        n[a] = h.substr(p.generatedColumn - l), l = p.generatedColumn, f(c, m), c = p;
        return;
      }
    for (; u < p.generatedLine; )
      i.add(o()), u++;
    if (l < p.generatedColumn) {
      var h = n[a] || "";
      i.add(h.substr(0, p.generatedColumn)), n[a] = h.substr(p.generatedColumn), l = p.generatedColumn;
    }
    c = p;
  }, this), a < n.length && (c && f(c, o()), i.add(n.splice(a).join(""))), t.sources.forEach(function(p) {
    var h = t.sourceContentFor(p);
    h != null && (s != null && (p = Pl.join(s, p)), i.setSourceContent(p, h));
  }), i;
  function f(p, h) {
    if (p === null || p.source === void 0)
      i.add(h);
    else {
      var m = s ? Pl.join(s, p.source) : p.source;
      i.add(new ur(
        p.originalLine,
        p.originalColumn,
        m,
        h,
        p.name
      ));
    }
  }
};
ur.prototype.add = function(e) {
  if (Array.isArray(e))
    e.forEach(function(t) {
      this.add(t);
    }, this);
  else if (e[ta] || typeof e == "string")
    e && this.children.push(e);
  else
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e
    );
  return this;
};
ur.prototype.prepend = function(e) {
  if (Array.isArray(e))
    for (var t = e.length - 1; t >= 0; t--)
      this.prepend(e[t]);
  else if (e[ta] || typeof e == "string")
    this.children.unshift(e);
  else
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e
    );
  return this;
};
ur.prototype.walk = function(e) {
  for (var t, s = 0, i = this.children.length; s < i; s++)
    t = this.children[s], t[ta] ? t.walk(e) : t !== "" && e(t, {
      source: this.source,
      line: this.line,
      column: this.column,
      name: this.name
    });
};
ur.prototype.join = function(e) {
  var t, s, i = this.children.length;
  if (i > 0) {
    for (t = [], s = 0; s < i - 1; s++)
      t.push(this.children[s]), t.push(e);
    t.push(this.children[s]), this.children = t;
  }
  return this;
};
ur.prototype.replaceRight = function(e, t) {
  var s = this.children[this.children.length - 1];
  return s[ta] ? s.replaceRight(e, t) : typeof s == "string" ? this.children[this.children.length - 1] = s.replace(e, t) : this.children.push("".replace(e, t)), this;
};
ur.prototype.setSourceContent = function(e, t) {
  this.sourceContents[Pl.toSetString(e)] = t;
};
ur.prototype.walkSourceContents = function(e) {
  for (var t = 0, s = this.children.length; t < s; t++)
    this.children[t][ta] && this.children[t].walkSourceContents(e);
  for (var i = Object.keys(this.sourceContents), t = 0, s = i.length; t < s; t++)
    e(Pl.fromSetString(i[t]), this.sourceContents[i[t]]);
};
ur.prototype.toString = function() {
  var e = "";
  return this.walk(function(t) {
    e += t;
  }), e;
};
ur.prototype.toStringWithSourceMap = function(e) {
  var t = {
    code: "",
    line: 1,
    column: 0
  }, s = new vI(e), i = !1, n = null, a = null, o = null, u = null;
  return this.walk(function(l, c) {
    t.code += l, c.source !== null && c.line !== null && c.column !== null ? ((n !== c.source || a !== c.line || o !== c.column || u !== c.name) && s.addMapping({
      source: c.source,
      original: {
        line: c.line,
        column: c.column
      },
      generated: {
        line: t.line,
        column: t.column
      },
      name: c.name
    }), n = c.source, a = c.line, o = c.column, u = c.name, i = !0) : i && (s.addMapping({
      generated: {
        line: t.line,
        column: t.column
      }
    }), n = null, i = !1);
    for (var f = 0, p = l.length; f < p; f++)
      l.charCodeAt(f) === SI ? (t.line++, t.column = 0, f + 1 === p ? (n = null, i = !1) : i && s.addMapping({
        source: c.source,
        original: {
          line: c.line,
          column: c.column
        },
        generated: {
          line: t.line,
          column: t.column
        },
        name: c.name
      })) : t.column++;
  }), this.walkSourceContents(function(l, c) {
    s.setSourceContent(l, c);
  }), { code: t.code, map: s };
};
GS.SourceNode = ur;
var Om = Zn.SourceMapGenerator = xm.SourceMapGenerator, Oy = Zn.SourceMapConsumer = Uc.SourceMapConsumer;
Zn.SourceNode = GS.SourceNode;
const zo = "/*#__PURE__*/", ju = (r) => `${Jt[r]}: _${Jt[r]}`;
function Iy(r, {
  mode: e = "function",
  prefixIdentifiers: t = e === "module",
  sourceMap: s = !1,
  filename: i = "template.vue.html",
  scopeId: n = null,
  optimizeImports: a = !1,
  runtimeGlobalName: o = "Vue",
  runtimeModuleName: u = "vue",
  ssrRuntimeModuleName: l = "vue/server-renderer",
  ssr: c = !1,
  isTS: f = !1,
  inSSR: p = !1
}) {
  const h = {
    mode: e,
    prefixIdentifiers: t,
    sourceMap: s,
    filename: i,
    scopeId: n,
    optimizeImports: a,
    runtimeGlobalName: o,
    runtimeModuleName: u,
    ssrRuntimeModuleName: l,
    ssr: c,
    isTS: f,
    inSSR: p,
    source: r.source,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: !1,
    map: void 0,
    helper(y) {
      return `_${Jt[y]}`;
    },
    push(y, S = -2, E) {
      if (h.code += y, h.map) {
        if (E) {
          let g;
          if (E.type === 4 && !E.isStatic) {
            const b = E.content.replace(/^_ctx\./, "");
            b !== E.content && Ts(b) && (g = b);
          }
          d(E.loc.start, g);
        }
        S === -3 ? Em(h, y) : (h.offset += y.length, S === -2 ? h.column += y.length : (S === -1 && (S = y.length - 1), h.line++, h.column = y.length - S)), E && E.loc !== rt && d(E.loc.end);
      }
    },
    indent() {
      m(++h.indentLevel);
    },
    deindent(y = !1) {
      y ? --h.indentLevel : m(--h.indentLevel);
    },
    newline() {
      m(h.indentLevel);
    }
  };
  function m(y) {
    h.push(
      `
` + "  ".repeat(y),
      0
      /* Start */
    );
  }
  function d(y, S = null) {
    const { _names: E, _mappings: g } = h.map;
    S !== null && !E.has(S) && E.add(S), g.add({
      originalLine: y.line,
      originalColumn: y.column - 1,
      // source-map column is 0 based
      generatedLine: h.line,
      generatedColumn: h.column - 1,
      source: i,
      name: S
    });
  }
  return s && (h.map = new Om(), h.map.setSourceContent(i, h.source), h.map._sources.add(i)), h;
}
function Im(r, e = {}) {
  const t = Iy(r, e);
  e.onContextCreated && e.onContextCreated(t);
  const {
    mode: s,
    push: i,
    prefixIdentifiers: n,
    indent: a,
    deindent: o,
    newline: u,
    scopeId: l,
    ssr: c
  } = t, f = Array.from(r.helpers), p = f.length > 0, h = !n && s !== "module", m = l != null && s === "module", d = !!e.inline, y = d ? Iy(r, e) : t;
  s === "module" ? xI(r, y, m, d) : _I(r, y);
  const S = c ? "ssrRender" : "render", E = c ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  e.bindingMetadata && !e.inline && E.push("$props", "$setup", "$data", "$options");
  const g = e.isTS ? E.map((b) => `${b}: any`).join(",") : E.join(", ");
  if (i(d ? `(${g}) => {` : `function ${S}(${g}) {`), a(), h && (i("with (_ctx) {"), a(), p && (i(
    `const { ${f.map(ju).join(", ")} } = _Vue
`,
    -1
    /* End */
  ), u())), r.components.length && (ky(r.components, "component", t), (r.directives.length || r.temps > 0) && u()), r.directives.length && (ky(r.directives, "directive", t), r.temps > 0 && u()), r.temps > 0) {
    i("let ");
    for (let b = 0; b < r.temps; b++)
      i(`${b > 0 ? ", " : ""}_temp${b}`);
  }
  return (r.components.length || r.directives.length || r.temps) && (i(
    `
`,
    0
    /* Start */
  ), u()), c || i("return "), r.codegenNode ? tt(r.codegenNode, t) : i("null"), h && (o(), i("}")), o(), i("}"), {
    ast: r,
    code: t.code,
    preamble: d ? y.code : "",
    map: t.map ? t.map.toJSON() : void 0
  };
}
function _I(r, e) {
  const {
    ssr: t,
    prefixIdentifiers: s,
    push: i,
    newline: n,
    runtimeModuleName: a,
    runtimeGlobalName: o,
    ssrRuntimeModuleName: u
  } = e, l = t ? `require(${JSON.stringify(a)})` : o, c = Array.from(r.helpers);
  if (c.length > 0) {
    if (s)
      i(
        `const { ${c.map(ju).join(", ")} } = ${l}
`,
        -1
        /* End */
      );
    else if (i(
      `const _Vue = ${l}
`,
      -1
      /* End */
    ), r.hoists.length) {
      const f = [
        Ro,
        vc,
        Jn,
        Ec,
        Sc
      ].filter((p) => c.includes(p)).map(ju).join(", ");
      i(
        `const { ${f} } = _Vue
`,
        -1
        /* End */
      );
    }
  }
  r.ssrHelpers && r.ssrHelpers.length && i(
    `const { ${r.ssrHelpers.map(ju).join(", ")} } = require("${u}")
`,
    -1
    /* End */
  ), KS(r.hoists, e), n(), i("return ");
}
function xI(r, e, t, s) {
  const {
    push: i,
    newline: n,
    optimizeImports: a,
    runtimeModuleName: o,
    ssrRuntimeModuleName: u
  } = e;
  if (t && r.hoists.length && (r.helpers.add(Cc), r.helpers.add(Nc)), r.helpers.size) {
    const l = Array.from(r.helpers);
    a ? (i(
      `import { ${l.map((c) => Jt[c]).join(", ")} } from ${JSON.stringify(o)}
`,
      -1
      /* End */
    ), i(
      `
// Binding optimization for webpack code-split
const ${l.map((c) => `_${Jt[c]} = ${Jt[c]}`).join(", ")}
`,
      -1
      /* End */
    )) : i(
      `import { ${l.map((c) => `${Jt[c]} as _${Jt[c]}`).join(", ")} } from ${JSON.stringify(o)}
`,
      -1
      /* End */
    );
  }
  r.ssrHelpers && r.ssrHelpers.length && i(
    `import { ${r.ssrHelpers.map((l) => `${Jt[l]} as _${Jt[l]}`).join(", ")} } from "${u}"
`,
    -1
    /* End */
  ), r.imports.length && (wI(r.imports, e), n()), KS(r.hoists, e), n(), s || i("export ");
}
function ky(r, e, { helper: t, push: s, newline: i, isTS: n }) {
  const a = t(
    e === "component" ? uo : _c
  );
  for (let o = 0; o < r.length; o++) {
    let u = r[o];
    const l = u.endsWith("__self");
    l && (u = u.slice(0, -6)), s(
      `const ${ho(u, e)} = ${a}(${JSON.stringify(u)}${l ? ", true" : ""})${n ? "!" : ""}`
    ), o < r.length - 1 && i();
  }
}
function KS(r, e) {
  if (!r.length)
    return;
  e.pure = !0;
  const { push: t, newline: s, helper: i, scopeId: n, mode: a } = e, o = n != null && a !== "function";
  if (s(), o) {
    const u = e.isTS ? "(n: any)" : "n";
    t(
      `const _withScopeId = ${u} => (${i(
        Cc
      )}("${n}"),n=n(),${i(Nc)}(),n)`
    ), s();
  }
  for (let u = 0; u < r.length; u++) {
    const l = r[u];
    if (l) {
      const c = o && l.type === 13;
      t(
        `const _hoisted_${u + 1} = ${c ? `${zo} _withScopeId(() => ` : ""}`
      ), tt(l, e), c && t(")"), s();
    }
  }
  e.pure = !1;
}
function wI(r, e) {
  r.length && r.forEach((t) => {
    e.push("import "), tt(t.exp, e), e.push(` from '${t.path}'`), e.newline();
  });
}
function TI(r) {
  return Ie(r) || r.type === 4 || r.type === 2 || r.type === 5 || r.type === 8;
}
function jc(r, e) {
  const t = r.length > 3 || r.some((s) => er(s) || !TI(s));
  e.push("["), t && e.indent(), ra(r, e, t), t && e.deindent(), e.push("]");
}
function ra(r, e, t = !1, s = !0) {
  const { push: i, newline: n } = e;
  for (let a = 0; a < r.length; a++) {
    const o = r[a];
    Ie(o) ? i(
      o,
      -3
      /* Unknown */
    ) : er(o) ? jc(o, e) : tt(o, e), a < r.length - 1 && (t ? (s && i(","), n()) : s && i(", "));
  }
}
function tt(r, e) {
  if (Ie(r)) {
    e.push(
      r,
      -3
      /* Unknown */
    );
    return;
  }
  if (fi(r)) {
    e.push(e.helper(r));
    return;
  }
  switch (r.type) {
    case 1:
    case 9:
    case 11:
      Up(
        r.codegenNode != null,
        "Codegen node is missing for element/if/for node. Apply appropriate transforms first."
      ), tt(r.codegenNode, e);
      break;
    case 2:
      PI(r, e);
      break;
    case 4:
      XS(r, e);
      break;
    case 5:
      AI(r, e);
      break;
    case 12:
      tt(r.codegenNode, e);
      break;
    case 8:
      JS(r, e);
      break;
    case 3:
      NI(r, e);
      break;
    case 13:
      OI(r, e);
      break;
    case 14:
      kI(r, e);
      break;
    case 15:
      DI(r, e);
      break;
    case 17:
      LI(r, e);
      break;
    case 18:
      MI(r, e);
      break;
    case 19:
      RI(r, e);
      break;
    case 20:
      $I(r, e);
      break;
    case 21:
      ra(r.body, e, !0, !1);
      break;
    case 22:
      FI(r, e);
      break;
    case 23:
      YS(r, e);
      break;
    case 24:
      BI(r, e);
      break;
    case 25:
      VI(r, e);
      break;
    case 26:
      UI(r, e);
      break;
    case 10:
      break;
    default:
      return Up(!1, `unhandled codegen node type: ${r.type}`), r;
  }
}
function PI(r, e) {
  e.push(JSON.stringify(r.content), -3, r);
}
function XS(r, e) {
  const { content: t, isStatic: s } = r;
  e.push(
    s ? JSON.stringify(t) : t,
    -3,
    r
  );
}
function AI(r, e) {
  const { push: t, helper: s, pure: i } = e;
  i && t(zo), t(`${s(Fo)}(`), tt(r.content, e), t(")");
}
function JS(r, e) {
  for (let t = 0; t < r.children.length; t++) {
    const s = r.children[t];
    Ie(s) ? e.push(
      s,
      -3
      /* Unknown */
    ) : tt(s, e);
  }
}
function CI(r, e) {
  const { push: t } = e;
  if (r.type === 8)
    t("["), JS(r, e), t("]");
  else if (r.isStatic) {
    const s = Ts(r.content) ? r.content : JSON.stringify(r.content);
    t(s, -2, r);
  } else
    t(`[${r.content}]`, -3, r);
}
function NI(r, e) {
  const { push: t, helper: s, pure: i } = e;
  i && t(zo), t(
    `${s(Jn)}(${JSON.stringify(r.content)})`,
    -3,
    r
  );
}
function OI(r, e) {
  const { push: t, helper: s, pure: i } = e, {
    tag: n,
    props: a,
    children: o,
    patchFlag: u,
    dynamicProps: l,
    directives: c,
    isBlock: f,
    disableTracking: p,
    isComponent: h
  } = r;
  let m;
  if (u)
    if (u < 0)
      m = u + ` /* ${ti[u]} */`;
    else {
      const y = Object.keys(ti).map(Number).filter((S) => S > 0 && u & S).map((S) => ti[S]).join(", ");
      m = u + ` /* ${y} */`;
    }
  c && t(s(xc) + "("), f && t(`(${s(ui)}(${p ? "true" : ""}), `), i && t(zo);
  const d = f ? Xi(e.inSSR, h) : Ki(e.inSSR, h);
  t(s(d) + "(", -2, r), ra(
    II([n, a, o, m, l]),
    e
  ), t(")"), f && t(")"), c && (t(", "), tt(c, e), t(")"));
}
function II(r) {
  let e = r.length;
  for (; e-- && r[e] == null; )
    ;
  return r.slice(0, e + 1).map((t) => t || "null");
}
function kI(r, e) {
  const { push: t, helper: s, pure: i } = e, n = Ie(r.callee) ? r.callee : s(r.callee);
  i && t(zo), t(n + "(", -2, r), ra(r.arguments, e), t(")");
}
function DI(r, e) {
  const { push: t, indent: s, deindent: i, newline: n } = e, { properties: a } = r;
  if (!a.length) {
    t("{}", -2, r);
    return;
  }
  const o = a.length > 1 || a.some((u) => u.value.type !== 4);
  t(o ? "{" : "{ "), o && s();
  for (let u = 0; u < a.length; u++) {
    const { key: l, value: c } = a[u];
    CI(l, e), t(": "), tt(c, e), u < a.length - 1 && (t(","), n());
  }
  o && i(), t(o ? "}" : " }");
}
function LI(r, e) {
  jc(r.elements, e);
}
function MI(r, e) {
  const { push: t, indent: s, deindent: i } = e, { params: n, returns: a, body: o, newline: u, isSlot: l } = r;
  l && t(`_${Jt[Oc]}(`), t("(", -2, r), er(n) ? ra(n, e) : n && tt(n, e), t(") => "), (u || o) && (t("{"), s()), a ? (u && t("return "), er(a) ? jc(a, e) : tt(a, e)) : o && tt(o, e), (u || o) && (i(), t("}")), l && t(")");
}
function RI(r, e) {
  const { test: t, consequent: s, alternate: i, newline: n } = r, { push: a, indent: o, deindent: u, newline: l } = e;
  if (t.type === 4) {
    const f = !Ts(t.content);
    f && a("("), XS(t, e), f && a(")");
  } else
    a("("), tt(t, e), a(")");
  n && o(), e.indentLevel++, n || a(" "), a("? "), tt(s, e), e.indentLevel--, n && l(), n || a(" "), a(": ");
  const c = i.type === 19;
  c || e.indentLevel++, tt(i, e), c || e.indentLevel--, n && u(
    !0
    /* without newline */
  );
}
function $I(r, e) {
  const { push: t, helper: s, indent: i, deindent: n, newline: a } = e;
  t(`_cache[${r.index}] || (`), r.isVOnce && (i(), t(`${s(lo)}(-1),`), a(), t("(")), t(`_cache[${r.index}] = `), tt(r.value, e), r.isVOnce && (t(`).cacheIndex = ${r.index},`), a(), t(`${s(lo)}(1),`), a(), t(`_cache[${r.index}]`), n()), t(")");
}
function FI(r, e) {
  const { push: t, indent: s, deindent: i } = e;
  t("`");
  const n = r.elements.length, a = n > 3;
  for (let o = 0; o < n; o++) {
    const u = r.elements[o];
    Ie(u) ? t(
      u.replace(/(`|\$|\\)/g, "\\$1"),
      -3
      /* Unknown */
    ) : (t("${"), a && s(), tt(u, e), a && i(), t("}"));
  }
  t("`");
}
function YS(r, e) {
  const { push: t, indent: s, deindent: i } = e, { test: n, consequent: a, alternate: o } = r;
  t("if ("), tt(n, e), t(") {"), s(), tt(a, e), i(), t("}"), o && (t(" else "), o.type === 23 ? YS(o, e) : (t("{"), s(), tt(o, e), i(), t("}")));
}
function BI(r, e) {
  tt(r.left, e), e.push(" = "), tt(r.right, e);
}
function VI(r, e) {
  e.push("("), ra(r.expressions, e), e.push(")");
}
function UI({ returns: r }, e) {
  e.push("return "), er(r) ? jc(r, e) : tt(r, e);
}
const jI = /* @__PURE__ */ Rt("true,false,null,this"), km = (r, e) => {
  if (r.type === 5)
    r.content = vt(
      r.content,
      e
    );
  else if (r.type === 1)
    for (let t = 0; t < r.props.length; t++) {
      const s = r.props[t];
      if (s.type === 7 && s.name !== "for") {
        const i = s.exp, n = s.arg;
        i && i.type === 4 && !(s.name === "on" && n) && (s.exp = vt(
          i,
          e,
          // slot args must be processed as function params
          s.name === "slot"
        )), n && n.type === 4 && !n.isStatic && (s.arg = vt(n, e));
      }
    }
};
function vt(r, e, t = !1, s = !1, i = Object.create(e.identifiers)) {
  if (!e.prefixIdentifiers || !r.content.trim())
    return r;
  const { inline: n, bindingMetadata: a } = e, o = (d, y, S) => {
    const E = qd(a, d) && a[d];
    if (n) {
      const g = y && y.type === "AssignmentExpression" && y.left === S, b = y && y.type === "UpdateExpression" && y.argument === S, v = y && jo(y, f), A = y && SS(f), C = (x) => {
        const _ = `${e.helperString(Mn)}(${x})`;
        return A ? `(${_})` : _;
      };
      if (Dy(E) || E === "setup-reactive-const" || i[d])
        return d;
      if (E === "setup-ref")
        return `${d}.value`;
      if (E === "setup-maybe-ref")
        return g || b || v ? `${d}.value` : C(d);
      if (E === "setup-let")
        if (g) {
          const { right: x, operator: _ } = y, T = u.slice(x.start - 1, x.end - 1), P = qc(
            vt(
              Q(T, !1),
              e,
              !1,
              !1,
              p
            )
          );
          return `${e.helperString(co)}(${d})${e.isTS ? ` //@ts-ignore
` : ""} ? ${d}.value ${_} ${P} : ${d}`;
        } else if (b) {
          S.start = y.start, S.end = y.end;
          const { prefix: x, operator: _ } = y, T = x ? _ : "", P = x ? "" : _;
          return `${e.helperString(co)}(${d})${e.isTS ? ` //@ts-ignore
` : ""} ? ${T}${d}.value${P} : ${T}${d}${P}`;
        } else return v ? d : C(d);
      else {
        if (E === "props")
          return hl(d);
        if (E === "props-aliased")
          return hl(a.__propsAliases[d]);
      }
    } else {
      if (E && E.startsWith("setup") || E === "literal-const")
        return `$setup.${d}`;
      if (E === "props-aliased")
        return `$props['${a.__propsAliases[d]}']`;
      if (E)
        return `$${E}.${d}`;
    }
    return `_ctx.${d}`;
  }, u = r.content;
  let l = r.ast;
  if (l === !1)
    return r;
  if (l === null || !l && Ts(u)) {
    const d = e.identifiers[u], y = $E(u), S = jI(u);
    return !t && !d && !S && (!y || a[u]) ? (Dy(a[u]) && (r.constType = 1), r.content = o(u)) : d || (S ? r.constType = 3 : r.constType = 2), r;
  }
  if (!l) {
    const d = s ? ` ${u} ` : `(${u})${t ? "=>{}" : ""}`;
    try {
      l = _l(d, {
        sourceType: "module",
        plugins: e.expressionPlugins
      });
    } catch (y) {
      return e.onError(
        Me(
          45,
          r.loc,
          void 0,
          y.message
        )
      ), r;
    }
  }
  const c = [], f = [], p = Object.create(e.identifiers);
  Uo(
    l,
    (d, y, S, E, g) => {
      if (TS(d, y))
        return;
      const b = E && qI(d);
      b && !g ? (qo(y) && y.shorthand && (d.prefix = `${d.name}: `), d.name = o(d.name, y, d), c.push(d)) : (!(b && g) && (!y || y.type !== "CallExpression" && y.type !== "NewExpression" && y.type !== "MemberExpression") && (d.isConstant = !0), c.push(d));
    },
    !0,
    // invoke on ALL identifiers
    f,
    p
  );
  const h = [];
  c.sort((d, y) => d.start - y.start), c.forEach((d, y) => {
    const S = d.start - 1, E = d.end - 1, g = c[y - 1], b = u.slice(g ? g.end - 1 : 0, S);
    (b.length || d.prefix) && h.push(b + (d.prefix || ""));
    const v = u.slice(S, E);
    h.push(
      Q(
        d.name,
        !1,
        {
          start: Vp(r.loc.start, v, S),
          end: Vp(r.loc.start, v, E),
          source: v
        },
        d.isConstant ? 3 : 0
      )
    ), y === c.length - 1 && E < u.length && h.push(u.slice(E));
  });
  let m;
  return h.length ? (m = yt(h, r.loc), m.ast = l) : (m = r, m.constType = 3), m.identifiers = Object.keys(p), m;
}
function qI(r) {
  return !($E(r.name) || r.name === "require");
}
function qc(r) {
  return Ie(r) ? r : r.type === 4 ? r.content : r.children.map(qc).join("");
}
function Dy(r) {
  return r === "setup-const" || r === "literal-const";
}
const HI = Wo(
  /^(if|else|else-if)$/,
  (r, e, t) => Dm(r, e, t, (s, i, n) => {
    const a = t.parent.children;
    let o = a.indexOf(s), u = 0;
    for (; o-- >= 0; ) {
      const l = a[o];
      l && l.type === 9 && (u += l.branches.length);
    }
    return () => {
      if (n)
        s.codegenNode = My(
          i,
          u,
          t
        );
      else {
        const l = zI(s.codegenNode);
        l.alternate = My(
          i,
          u + s.branches.length - 1,
          t
        );
      }
    };
  })
);
function Dm(r, e, t, s) {
  if (e.name !== "else" && (!e.exp || !e.exp.content.trim())) {
    const i = e.exp ? e.exp.loc : r.loc;
    t.onError(
      Me(28, e.loc)
    ), e.exp = Q("true", !1, i);
  }
  if (t.prefixIdentifiers && e.exp && (e.exp = vt(e.exp, t)), e.name === "if") {
    const i = Ly(r, e), n = {
      type: 9,
      loc: r.loc,
      branches: [i]
    };
    if (t.replaceNode(n), s)
      return s(n, i, !0);
  } else {
    const i = t.parent.children, n = [];
    let a = i.indexOf(r);
    for (; a-- >= -1; ) {
      const o = i[a];
      if (o && o.type === 3) {
        t.removeNode(o), n.unshift(o);
        continue;
      }
      if (o && o.type === 2 && !o.content.trim().length) {
        t.removeNode(o);
        continue;
      }
      if (o && o.type === 9) {
        e.name === "else-if" && o.branches[o.branches.length - 1].condition === void 0 && t.onError(
          Me(30, r.loc)
        ), t.removeNode();
        const u = Ly(r, e);
        n.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(t.parent && t.parent.type === 1 && (t.parent.tag === "transition" || t.parent.tag === "Transition")) && (u.children = [...n, ...u.children]);
        {
          const c = u.userKey;
          c && o.branches.forEach(({ userKey: f }) => {
            WI(f, c) && t.onError(
              Me(
                29,
                u.userKey.loc
              )
            );
          });
        }
        o.branches.push(u);
        const l = s && s(o, u, !1);
        Qn(u, t), l && l(), t.currentNode = null;
      } else
        t.onError(
          Me(30, r.loc)
        );
      break;
    }
  }
}
function Ly(r, e) {
  const t = r.tagType === 3;
  return {
    type: 10,
    loc: r.loc,
    condition: e.name === "else" ? void 0 : e.exp,
    children: t && !gt(r, "for") ? r.children : [r],
    userKey: Qt(r, "key"),
    isTemplateIf: t
  };
}
function My(r, e, t) {
  return r.condition ? Nr(
    r.condition,
    Ry(r, e, t),
    // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    ge(t.helper(Jn), [
      '"v-if"',
      "true"
    ])
  ) : Ry(r, e, t);
}
function Ry(r, e, t) {
  const { helper: s } = t, i = Fe(
    "key",
    Q(
      `${e}`,
      !1,
      rt,
      2
    )
  ), { children: n } = r, a = n[0];
  if (n.length !== 1 || a.type !== 1)
    if (n.length === 1 && a.type === 11) {
      const u = a.codegenNode;
      return po(u, i, t), u;
    } else {
      let u = 64, l = ti[64];
      return !r.isTemplateIf && n.filter((c) => c.type !== 3).length === 1 && (u |= 2048, l += `, ${ti[2048]}`), Rn(
        t,
        s(Dn),
        Yt([i]),
        n,
        u,
        void 0,
        void 0,
        !0,
        !1,
        !1,
        r.loc
      );
    }
  else {
    const u = a.codegenNode, l = CS(u);
    return l.type === 13 && kc(l, t), po(l, i, t), u;
  }
}
function WI(r, e) {
  if (!r || r.type !== e.type)
    return !1;
  if (r.type === 6) {
    if (r.value.content !== e.value.content)
      return !1;
  } else {
    const t = r.exp, s = e.exp;
    if (t.type !== s.type || t.type !== 4 || t.isStatic !== s.isStatic || t.content !== s.content)
      return !1;
  }
  return !0;
}
function zI(r) {
  for (; ; )
    if (r.type === 19)
      if (r.alternate.type === 19)
        r = r.alternate;
      else
        return r;
    else r.type === 20 && (r = r.value);
}
const Lm = (r, e, t) => {
  const { modifiers: s, loc: i } = r, n = r.arg;
  let { exp: a } = r;
  if (a && a.type === 4 && !a.content.trim())
    return t.onError(
      Me(34, i)
    ), {
      props: [
        Fe(n, Q("", !0, i))
      ]
    };
  if (!a) {
    if (n.type !== 4 || !n.isStatic)
      return t.onError(
        Me(
          52,
          n.loc
        )
      ), {
        props: [
          Fe(n, Q("", !0, i))
        ]
      };
    QS(r, t), a = r.exp;
  }
  return n.type !== 4 ? (n.children.unshift("("), n.children.push(') || ""')) : n.isStatic || (n.content = `${n.content} || ""`), s.includes("camel") && (n.type === 4 ? n.isStatic ? n.content = or(n.content) : n.content = `${t.helperString(dl)}(${n.content})` : (n.children.unshift(`${t.helperString(dl)}(`), n.children.push(")"))), t.inSSR || (s.includes("prop") && $y(n, "."), s.includes("attr") && $y(n, "^")), {
    props: [Fe(n, a)]
  };
}, QS = (r, e) => {
  const t = r.arg, s = or(t.content);
  r.exp = Q(s, !1, t.loc), r.exp = vt(r.exp, e);
}, $y = (r, e) => {
  r.type === 4 ? r.isStatic ? r.content = e + r.content : r.content = `\`${e}\${${r.content}}\`` : (r.children.unshift(`'${e}' + (`), r.children.push(")"));
}, GI = Wo(
  "for",
  (r, e, t) => {
    const { helper: s, removeHelper: i } = t;
    return Mm(r, e, t, (n) => {
      const a = ge(s(wc), [
        n.source
      ]), o = Fn(r), u = gt(r, "memo"), l = Qt(r, "key", !1, !0);
      l && l.type === 7 && !l.exp && QS(l, t);
      const c = l && (l.type === 6 ? l.value ? Q(l.value.content, !0) : void 0 : l.exp), f = l && c ? Fe("key", c) : null;
      o && (u && (u.exp = vt(
        u.exp,
        t
      )), f && l.type !== 6 && (f.value = vt(
        f.value,
        t
      )));
      const p = n.source.type === 4 && n.source.constType > 0, h = p ? 64 : l ? 128 : 256;
      return n.codegenNode = Rn(
        t,
        s(Dn),
        void 0,
        a,
        h,
        void 0,
        void 0,
        !0,
        !p,
        !1,
        r.loc
      ), () => {
        let m;
        const { children: d } = n;
        o && r.children.some((E) => {
          if (E.type === 1) {
            const g = Qt(E, "key");
            if (g)
              return t.onError(
                Me(
                  33,
                  g.loc
                )
              ), !0;
          }
        });
        const y = d.length !== 1 || d[0].type !== 1, S = Bn(r) ? r : o && r.children.length === 1 && Bn(r.children[0]) ? r.children[0] : null;
        if (S ? (m = S.codegenNode, o && f && po(m, f, t)) : y ? m = Rn(
          t,
          s(Dn),
          f ? Yt([f]) : void 0,
          r.children,
          64,
          void 0,
          void 0,
          !0,
          void 0,
          !1
        ) : (m = d[0].codegenNode, o && f && po(m, f, t), m.isBlock !== !p && (m.isBlock ? (i(ui), i(
          Xi(t.inSSR, m.isComponent)
        )) : i(
          Ki(t.inSSR, m.isComponent)
        )), m.isBlock = !p, m.isBlock ? (s(ui), s(Xi(t.inSSR, m.isComponent))) : s(Ki(t.inSSR, m.isComponent))), u) {
          const E = fr(
            go(n.parseResult, [
              Q("_cached")
            ])
          );
          E.body = Bo([
            yt(["const _memo = (", u.exp, ")"]),
            yt([
              "if (_cached",
              ...c ? [" && _cached.key === ", c] : [],
              ` && ${t.helperString(
                Yd
              )}(_cached, _memo)) return _cached`
            ]),
            yt(["const _item = ", m]),
            Q("_item.memo = _memo"),
            Q("return _item")
          ]), a.arguments.push(
            E,
            Q("_cache"),
            Q(String(t.cached++))
          );
        } else
          a.arguments.push(
            fr(
              go(n.parseResult),
              m,
              !0
            )
          );
      };
    });
  }
);
function Mm(r, e, t, s) {
  if (!e.exp) {
    t.onError(
      Me(31, e.loc)
    );
    return;
  }
  const i = e.forParseResult;
  if (!i) {
    t.onError(
      Me(32, e.loc)
    );
    return;
  }
  Rm(i, t);
  const { addIdentifiers: n, removeIdentifiers: a, scopes: o } = t, { source: u, value: l, key: c, index: f } = i, p = {
    type: 11,
    loc: e.loc,
    source: u,
    valueAlias: l,
    keyAlias: c,
    objectIndexAlias: f,
    parseResult: i,
    children: Fn(r) ? r.children : [r]
  };
  t.replaceNode(p), o.vFor++, t.prefixIdentifiers && (l && n(l), c && n(c), f && n(f));
  const h = s && s(p);
  return () => {
    o.vFor--, t.prefixIdentifiers && (l && a(l), c && a(c), f && a(f)), h && h();
  };
}
function Rm(r, e) {
  r.finalized || (e.prefixIdentifiers && (r.source = vt(
    r.source,
    e
  ), r.key && (r.key = vt(
    r.key,
    e,
    !0
  )), r.index && (r.index = vt(
    r.index,
    e,
    !0
  )), r.value && (r.value = vt(
    r.value,
    e,
    !0
  ))), r.finalized = !0);
}
function go({ value: r, key: e, index: t }, s = []) {
  return KI([r, e, t, ...s]);
}
function KI(r) {
  let e = r.length;
  for (; e-- && !r[e]; )
    ;
  return r.slice(0, e + 1).map((t, s) => t || Q("_".repeat(s + 1), !1));
}
const Fy = Q("undefined", !1), $m = (r, e) => {
  if (r.type === 1 && (r.tagType === 1 || r.tagType === 3)) {
    const t = gt(r, "slot");
    if (t) {
      const s = t.exp;
      return e.prefixIdentifiers && s && e.addIdentifiers(s), e.scopes.vSlot++, () => {
        e.prefixIdentifiers && s && e.removeIdentifiers(s), e.scopes.vSlot--;
      };
    }
  }
}, Fm = (r, e) => {
  let t;
  if (Fn(r) && r.props.some(Sm) && (t = gt(r, "for"))) {
    const s = t.forParseResult;
    if (s) {
      Rm(s, e);
      const { value: i, key: n, index: a } = s, { addIdentifiers: o, removeIdentifiers: u } = e;
      return i && o(i), n && o(n), a && o(a), () => {
        i && u(i), n && u(n), a && u(a);
      };
    }
  }
}, XI = (r, e, t, s) => fr(
  r,
  t,
  !1,
  !0,
  t.length ? t[0].loc : s
);
function yo(r, e, t = XI) {
  e.helper(Oc);
  const { children: s, loc: i } = r, n = [], a = [];
  let o = e.scopes.vSlot > 0 || e.scopes.vFor > 0;
  !e.ssr && e.prefixIdentifiers && (o = Xt(r, e.identifiers));
  const u = gt(r, "slot", !0);
  if (u) {
    const { arg: y, exp: S } = u;
    y && !Pt(y) && (o = !0), n.push(
      Fe(
        y || Q("default", !0),
        t(S, void 0, s, i)
      )
    );
  }
  let l = !1, c = !1;
  const f = [], p = /* @__PURE__ */ new Set();
  let h = 0;
  for (let y = 0; y < s.length; y++) {
    const S = s[y];
    let E;
    if (!Fn(S) || !(E = gt(S, "slot", !0))) {
      S.type !== 3 && f.push(S);
      continue;
    }
    if (u) {
      e.onError(
        Me(37, E.loc)
      );
      break;
    }
    l = !0;
    const { children: g, loc: b } = S, {
      arg: v = Q("default", !0),
      exp: A,
      loc: C
    } = E;
    let x;
    Pt(v) ? x = v ? v.content : "default" : o = !0;
    const _ = gt(S, "for"), T = t(A, _, g, b);
    let P, I;
    if (P = gt(S, "if"))
      o = !0, a.push(
        Nr(
          P.exp,
          fu(v, T, h++),
          Fy
        )
      );
    else if (I = gt(
      S,
      /^else(-if)?$/,
      !0
      /* allowEmpty */
    )) {
      let $ = y, Y;
      for (; $-- && (Y = s[$], Y.type === 3); )
        ;
      if (Y && Fn(Y) && gt(Y, /^(else-)?if$/)) {
        let W = a[a.length - 1];
        for (; W.alternate.type === 19; )
          W = W.alternate;
        W.alternate = I.exp ? Nr(
          I.exp,
          fu(
            v,
            T,
            h++
          ),
          Fy
        ) : fu(v, T, h++);
      } else
        e.onError(
          Me(30, I.loc)
        );
    } else if (_) {
      o = !0;
      const $ = _.forParseResult;
      $ ? (Rm($, e), a.push(
        ge(e.helper(wc), [
          $.source,
          fr(
            go($),
            fu(v, T),
            !0
          )
        ])
      )) : e.onError(
        Me(
          32,
          _.loc
        )
      );
    } else {
      if (x) {
        if (p.has(x)) {
          e.onError(
            Me(
              38,
              C
            )
          );
          continue;
        }
        p.add(x), x === "default" && (c = !0);
      }
      n.push(Fe(v, T));
    }
  }
  if (!u) {
    const y = (S, E) => {
      const g = t(S, void 0, E, i);
      return Fe("default", g);
    };
    l ? f.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    f.some((S) => ZS(S)) && (c ? e.onError(
      Me(
        39,
        f[0].loc
      )
    ) : n.push(
      y(void 0, f)
    )) : n.push(y(void 0, s));
  }
  const m = o ? 2 : qu(r.children) ? 3 : 1;
  let d = Yt(
    n.concat(
      Fe(
        "_",
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        Q(
          m + ` /* ${vC[m]} */`,
          !1
        )
      )
    ),
    i
  );
  return a.length && (d = ge(e.helper(Jd), [
    d,
    sn(a)
  ])), {
    slots: d,
    hasDynamicSlots: o
  };
}
function fu(r, e, t) {
  const s = [
    Fe("name", r),
    Fe("fn", e)
  ];
  return t != null && s.push(
    Fe("key", Q(String(t), !0))
  ), Yt(s);
}
function qu(r) {
  for (let e = 0; e < r.length; e++) {
    const t = r[e];
    switch (t.type) {
      case 1:
        if (t.tagType === 2 || qu(t.children))
          return !0;
        break;
      case 9:
        if (qu(t.branches)) return !0;
        break;
      case 10:
      case 11:
        if (qu(t.children)) return !0;
        break;
    }
  }
  return !1;
}
function ZS(r) {
  return r.type !== 2 && r.type !== 12 ? !0 : r.type === 2 ? !!r.content.trim() : ZS(r.content);
}
const e2 = /* @__PURE__ */ new WeakMap(), t2 = (r, e) => function() {
  if (r = e.currentNode, !(r.type === 1 && (r.tagType === 0 || r.tagType === 1)))
    return;
  const { tag: s, props: i } = r, n = r.tagType === 1;
  let a = n ? Hc(r, e) : `"${s}"`;
  const o = pi(a) && a.callee === $o;
  let u, l, c = 0, f, p, h, m = (
    // dynamic component may resolve to plain elements
    o || a === $i || a === Xn || !n && // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    (s === "svg" || s === "foreignObject" || s === "math")
  );
  if (i.length > 0) {
    const d = sa(
      r,
      e,
      void 0,
      n,
      o
    );
    u = d.props, c = d.patchFlag, p = d.dynamicPropNames;
    const y = d.directives;
    h = y && y.length ? sn(
      y.map((S) => Bm(S, e))
    ) : void 0, d.shouldUseBlock && (m = !0);
  }
  if (r.children.length > 0)
    if (a === oo && (m = !0, c |= 1024, r.children.length > 1 && e.onError(
      Me(46, {
        start: r.children[0].loc.start,
        end: r.children[r.children.length - 1].loc.end,
        source: ""
      })
    )), n && // Teleport is not a real component and has dedicated runtime handling
    a !== $i && // explained above.
    a !== oo) {
      const { slots: y, hasDynamicSlots: S } = yo(r, e);
      l = y, S && (c |= 1024);
    } else if (r.children.length === 1 && a !== $i) {
      const y = r.children[0], S = y.type, E = S === 5 || S === 8;
      E && ir(y, e) === 0 && (c |= 1), E || S === 2 ? l = y : l = r.children;
    } else
      l = r.children;
  p && p.length && (f = YI(p)), r.codegenNode = Rn(
    e,
    a,
    u,
    l,
    c === 0 ? void 0 : c,
    f,
    h,
    !!m,
    !1,
    n,
    r.loc
  );
};
function Hc(r, e, t = !1) {
  let { tag: s } = r;
  const i = Wp(s), n = Qt(
    r,
    "is",
    !1,
    !0
    /* allow empty */
  );
  if (n)
    if (i) {
      let o;
      if (n.type === 6 ? o = n.value && Q(n.value.content, !0) : (o = n.exp, o || (o = Q("is", !1, n.arg.loc), o = n.exp = vt(o, e))), o)
        return ge(e.helper($o), [
          o
        ]);
    } else n.type === 6 && n.value.content.startsWith("vue:") && (s = n.value.content.slice(4));
  const a = bm(s) || e.isBuiltInComponent(s);
  if (a)
    return t || e.helper(a), a;
  {
    const o = Hp(s, e);
    if (o)
      return o;
    const u = s.indexOf(".");
    if (u > 0) {
      const l = Hp(s.slice(0, u), e);
      if (l)
        return l + s.slice(u);
    }
  }
  return e.selfName && oi(or(s)) === e.selfName ? (e.helper(uo), e.components.add(s + "__self"), ho(s, "component")) : (e.helper(uo), e.components.add(s), ho(s, "component"));
}
function Hp(r, e) {
  const t = e.bindingMetadata;
  if (!t || t.__isScriptSetup === !1)
    return;
  const s = or(r), i = oi(s), n = (l) => {
    if (t[r] === l)
      return r;
    if (t[s] === l)
      return s;
    if (t[i] === l)
      return i;
  }, a = n("setup-const") || n("setup-reactive-const") || n("literal-const");
  if (a)
    return e.inline ? (
      // in inline mode, const setup bindings (e.g. imports) can be used as-is
      a
    ) : `$setup[${JSON.stringify(a)}]`;
  const o = n("setup-let") || n("setup-ref") || n("setup-maybe-ref");
  if (o)
    return e.inline ? (
      // setup scope bindings that may be refs need to be unrefed
      `${e.helperString(Mn)}(${o})`
    ) : `$setup[${JSON.stringify(o)}]`;
  const u = n("props");
  if (u)
    return `${e.helperString(Mn)}(${e.inline ? "__props" : "$props"}[${JSON.stringify(u)}])`;
}
function sa(r, e, t = r.props, s, i, n = !1) {
  const { tag: a, loc: o, children: u } = r;
  let l = [];
  const c = [], f = [], p = u.length > 0;
  let h = !1, m = 0, d = !1, y = !1, S = !1, E = !1, g = !1, b = !1;
  const v = [], A = (T) => {
    l.length && (c.push(
      Yt(By(l), o)
    ), l = []), T && c.push(T);
  }, C = () => {
    e.scopes.vFor > 0 && l.push(
      Fe(
        Q("ref_for", !0),
        Q("true")
      )
    );
  }, x = ({ key: T, value: P }) => {
    if (Pt(T)) {
      const I = T.content, $ = DE(I);
      if ($ && (!s || i) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      I.toLowerCase() !== "onclick" && // omit v-model handlers
      I !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !iy(I) && (E = !0), $ && iy(I) && (b = !0), $ && P.type === 14 && (P = P.arguments[0]), P.type === 20 || (P.type === 4 || P.type === 8) && ir(P, e) > 0)
        return;
      I === "ref" ? d = !0 : I === "class" ? y = !0 : I === "style" ? S = !0 : I !== "key" && !v.includes(I) && v.push(I), s && (I === "class" || I === "style") && !v.includes(I) && v.push(I);
    } else
      g = !0;
  };
  for (let T = 0; T < t.length; T++) {
    const P = t[T];
    if (P.type === 6) {
      const { loc: I, name: $, nameLoc: Y, value: W } = P;
      let F = !0;
      if ($ === "ref" && (d = !0, C(), W && e.inline)) {
        const K = e.bindingMetadata[W.content];
        (K === "setup-let" || K === "setup-ref" || K === "setup-maybe-ref") && (F = !1, l.push(
          Fe(
            Q("ref_key", !0),
            Q(W.content, !0, W.loc)
          )
        ));
      }
      if ($ === "is" && (Wp(a) || W && W.content.startsWith("vue:")))
        continue;
      l.push(
        Fe(
          Q($, !0, Y),
          Q(
            W ? W.content : "",
            F,
            W ? W.loc : I
          )
        )
      );
    } else {
      const { name: I, arg: $, exp: Y, loc: W, modifiers: F } = P, K = I === "bind", Z = I === "on";
      if (I === "slot") {
        s || e.onError(
          Me(40, W)
        );
        continue;
      }
      if (I === "once" || I === "memo" || I === "is" || K && jr($, "is") && Wp(a) || Z && n)
        continue;
      if (
        // #938: elements with dynamic keys should be forced into blocks
        (K && jr($, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        Z && p && jr($, "vue:before-update")) && (h = !0), K && jr($, "ref") && C(), !$ && (K || Z)
      ) {
        g = !0, Y ? K ? (C(), A(), c.push(Y)) : A({
          type: 14,
          loc: W,
          callee: e.helper(Ac),
          arguments: s ? [Y] : [Y, "true"]
        }) : e.onError(
          Me(
            K ? 34 : 35,
            W
          )
        );
        continue;
      }
      K && F.includes("prop") && (m |= 32);
      const Ce = e.directiveTransforms[I];
      if (Ce) {
        const { props: Ve, needRuntime: ee } = Ce(P, r, e);
        !n && Ve.forEach(x), Z && $ && !Pt($) ? A(Yt(Ve, o)) : l.push(...Ve), ee && (f.push(P), fi(ee) && e2.set(P, ee));
      } else Wd(I) || (f.push(P), p && (h = !0));
    }
  }
  let _;
  if (c.length ? (A(), c.length > 1 ? _ = ge(
    e.helper(Gi),
    c,
    o
  ) : _ = c[0]) : l.length && (_ = Yt(
    By(l),
    o
  )), g ? m |= 16 : (y && !s && (m |= 2), S && !s && (m |= 4), v.length && (m |= 8), E && (m |= 32)), !h && (m === 0 || m === 32) && (d || b || f.length > 0) && (m |= 512), !e.inSSR && _)
    switch (_.type) {
      case 15:
        let T = -1, P = -1, I = !1;
        for (let W = 0; W < _.properties.length; W++) {
          const F = _.properties[W].key;
          Pt(F) ? F.content === "class" ? T = W : F.content === "style" && (P = W) : F.isHandlerKey || (I = !0);
        }
        const $ = _.properties[T], Y = _.properties[P];
        I ? _ = ge(
          e.helper(Ln),
          [_]
        ) : ($ && !Pt($.value) && ($.value = ge(
          e.helper(Tc),
          [$.value]
        )), Y && // the static style is compiled into an object,
        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
        (S || Y.value.type === 4 && Y.value.content.trim()[0] === "[" || // v-bind:style and style both exist,
        // v-bind:style with static literal object
        Y.value.type === 17) && (Y.value = ge(
          e.helper(Pc),
          [Y.value]
        )));
        break;
      case 14:
        break;
      default:
        _ = ge(
          e.helper(Ln),
          [
            ge(e.helper(Yn), [
              _
            ])
          ]
        );
        break;
    }
  return {
    props: _,
    directives: f,
    patchFlag: m,
    dynamicPropNames: v,
    shouldUseBlock: h
  };
}
function By(r) {
  const e = /* @__PURE__ */ new Map(), t = [];
  for (let s = 0; s < r.length; s++) {
    const i = r[s];
    if (i.key.type === 8 || !i.key.isStatic) {
      t.push(i);
      continue;
    }
    const n = i.key.content, a = e.get(n);
    a ? (n === "style" || n === "class" || DE(n)) && JI(a, i) : (e.set(n, i), t.push(i));
  }
  return t;
}
function JI(r, e) {
  r.value.type === 17 ? r.value.elements.push(e.value) : r.value = sn(
    [r.value, e.value],
    r.loc
  );
}
function Bm(r, e) {
  const t = [], s = e2.get(r);
  if (s)
    t.push(e.helperString(s));
  else {
    const n = Hp("v-" + r.name, e);
    n ? t.push(n) : (e.helper(_c), e.directives.add(r.name), t.push(ho(r.name, "directive")));
  }
  const { loc: i } = r;
  if (r.exp && t.push(r.exp), r.arg && (r.exp || t.push("void 0"), t.push(r.arg)), Object.keys(r.modifiers).length) {
    r.arg || (r.exp || t.push("void 0"), t.push("void 0"));
    const n = Q("true", !1, i);
    t.push(
      Yt(
        r.modifiers.map(
          (a) => Fe(a, n)
        ),
        i
      )
    );
  }
  return sn(t, r.loc);
}
function YI(r) {
  let e = "[";
  for (let t = 0, s = r.length; t < s; t++)
    e += JSON.stringify(r[t]), t < s - 1 && (e += ", ");
  return e + "]";
}
function Wp(r) {
  return r === "component" || r === "Component";
}
const QI = (r, e) => {
  if (Bn(r)) {
    const { children: t, loc: s } = r, { slotName: i, slotProps: n } = Vm(r, e), a = [
      e.prefixIdentifiers ? "_ctx.$slots" : "$slots",
      i,
      "{}",
      "undefined",
      "true"
    ];
    let o = 2;
    n && (a[2] = n, o = 3), t.length && (a[3] = fr([], t, !1, !1, s), o = 4), e.scopeId && !e.slotted && (o = 5), a.splice(o), r.codegenNode = ge(
      e.helper(Xd),
      a,
      s
    );
  }
};
function Vm(r, e) {
  let t = '"default"', s;
  const i = [];
  for (let n = 0; n < r.props.length; n++) {
    const a = r.props[n];
    if (a.type === 6)
      a.value && (a.name === "name" ? t = JSON.stringify(a.value.content) : (a.name = or(a.name), i.push(a)));
    else if (a.name === "bind" && jr(a.arg, "name")) {
      if (a.exp)
        t = a.exp;
      else if (a.arg && a.arg.type === 4) {
        const o = or(a.arg.content);
        t = a.exp = Q(o, !1, a.arg.loc), t = a.exp = vt(a.exp, e);
      }
    } else
      a.name === "bind" && a.arg && Pt(a.arg) && (a.arg.content = or(a.arg.content)), i.push(a);
  }
  if (i.length > 0) {
    const { props: n, directives: a } = sa(
      r,
      e,
      i,
      !1,
      !1
    );
    s = n, a.length && e.onError(
      Me(
        36,
        a[0].loc
      )
    );
  }
  return {
    slotName: t,
    slotProps: s
  };
}
const ZI = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/, Wc = (r, e, t, s) => {
  const { loc: i, modifiers: n, arg: a } = r;
  !r.exp && !n.length && t.onError(Me(35, i));
  let o;
  if (a.type === 4)
    if (a.isStatic) {
      let f = a.content;
      f.startsWith("vnode") && t.onError(Me(51, a.loc)), f.startsWith("vue:") && (f = `vnode-${f.slice(4)}`);
      const p = e.tagType !== 0 || f.startsWith("vnode") || !/[A-Z]/.test(f) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        yC(or(f))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${f}`
      );
      o = Q(p, !0, a.loc);
    } else
      o = yt([
        `${t.helperString(ml)}(`,
        a,
        ")"
      ]);
  else
    o = a, o.children.unshift(`${t.helperString(ml)}(`), o.children.push(")");
  let u = r.exp;
  u && !u.content.trim() && (u = void 0);
  let l = t.cacheHandlers && !u && !t.inVOnce;
  if (u) {
    const f = vm(u.content, t), p = !(f || ZI.test(u.content)), h = u.content.includes(";");
    t.prefixIdentifiers && (p && t.addIdentifiers("$event"), u = r.exp = vt(
      u,
      t,
      !1,
      h
    ), p && t.removeIdentifiers("$event"), l = t.cacheHandlers && // unnecessary to cache inside v-once
    !t.inVOnce && // runtime constants don't need to be cached
    // (this is analyzed by compileScript in SFC <script setup>)
    !(u.type === 4 && u.constType > 0) && // #1541 bail if this is a member exp handler passed to a component -
    // we need to use the original function to preserve arity,
    // e.g. <transition> relies on checking cb.length to determine
    // transition end handling. Inline function is ok since its arity
    // is preserved even when cached.
    !(f && e.tagType === 1) && // bail if the function references closure variables (v-for, v-slot)
    // it must be passed fresh to avoid stale values.
    !Xt(u, t.identifiers), l && f && (u.type === 4 ? u.content = `${u.content} && ${u.content}(...args)` : u.children = [...u.children, " && ", ...u.children, "(...args)"])), (p || l && f) && (u = yt([
      `${p ? t.isTS ? "($event: any)" : "$event" : `${t.isTS ? `
//@ts-ignore
` : ""}(...args)`} => ${h ? "{" : "("}`,
      u,
      h ? "}" : ")"
    ]));
  }
  let c = {
    props: [
      Fe(
        o,
        u || Q("() => {}", !1, i)
      )
    ]
  };
  return s && (c = s(c)), l && (c.props[0].value = t.cache(c.props[0].value)), c.props.forEach((f) => f.key.isHandlerKey = !0), c;
}, e6 = (r, e) => {
  if (r.type === 0 || r.type === 1 || r.type === 11 || r.type === 10)
    return () => {
      const t = r.children;
      let s, i = !1;
      for (let n = 0; n < t.length; n++) {
        const a = t[n];
        if (Ha(a)) {
          i = !0;
          for (let o = n + 1; o < t.length; o++) {
            const u = t[o];
            if (Ha(u))
              s || (s = t[n] = yt(
                [a],
                a.loc
              )), s.children.push(" + ", u), t.splice(o, 1), o--;
            else {
              s = void 0;
              break;
            }
          }
        }
      }
      if (!(!i || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      t.length === 1 && (r.type === 0 || r.type === 1 && r.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !r.props.find(
        (n) => n.type === 7 && !e.directiveTransforms[n.name]
      ))))
        for (let n = 0; n < t.length; n++) {
          const a = t[n];
          if (Ha(a) || a.type === 8) {
            const o = [];
            (a.type !== 2 || a.content !== " ") && o.push(a), !e.ssr && ir(a, e) === 0 && o.push(
              `1 /* ${ti[1]} */`
            ), t[n] = {
              type: 12,
              content: a,
              loc: a.loc,
              codegenNode: ge(
                e.helper(Ec),
                o
              )
            };
          }
        }
    };
}, Vy = /* @__PURE__ */ new WeakSet(), t6 = (r, e) => {
  if (r.type === 1 && gt(r, "once", !0))
    return Vy.has(r) || e.inVOnce || e.inSSR ? void 0 : (Vy.add(r), e.inVOnce = !0, e.helper(lo), () => {
      e.inVOnce = !1;
      const t = e.currentNode;
      t.codegenNode && (t.codegenNode = e.cache(
        t.codegenNode,
        !0
        /* isVNode */
      ));
    });
}, zc = (r, e, t) => {
  const { exp: s, arg: i } = r;
  if (!s)
    return t.onError(
      Me(41, r.loc)
    ), Ea();
  const n = s.loc.source, a = s.type === 4 ? s.content : n, o = t.bindingMetadata[n];
  if (o === "props" || o === "props-aliased")
    return t.onError(Me(44, s.loc)), Ea();
  const u = t.inline && (o === "setup-let" || o === "setup-ref" || o === "setup-maybe-ref");
  if (!a.trim() || !vm(a, t) && !u)
    return t.onError(
      Me(42, s.loc)
    ), Ea();
  if (t.prefixIdentifiers && Ts(a) && t.identifiers[a])
    return t.onError(
      Me(43, s.loc)
    ), Ea();
  const l = i || Q("modelValue", !0), c = i ? Pt(i) ? `onUpdate:${or(i.content)}` : yt(['"onUpdate:" + ', i]) : "onUpdate:modelValue";
  let f;
  const p = t.isTS ? "($event: any)" : "$event";
  if (u)
    if (o === "setup-ref")
      f = yt([
        `${p} => ((`,
        Q(n, !1, s.loc),
        ").value = $event)"
      ]);
    else {
      const m = o === "setup-let" ? `${n} = $event` : "null";
      f = yt([
        `${p} => (${t.helperString(co)}(${n}) ? (`,
        Q(n, !1, s.loc),
        `).value = $event : ${m})`
      ]);
    }
  else
    f = yt([
      `${p} => ((`,
      s,
      ") = $event)"
    ]);
  const h = [
    // modelValue: foo
    Fe(l, r.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    Fe(c, f)
  ];
  if (t.prefixIdentifiers && !t.inVOnce && t.cacheHandlers && !Xt(s, t.identifiers) && (h[1].value = t.cache(h[1].value)), r.modifiers.length && e.tagType === 1) {
    const m = r.modifiers.map((y) => (Ts(y) ? y : JSON.stringify(y)) + ": true").join(", "), d = i ? Pt(i) ? `${i.content}Modifiers` : yt([i, ' + "Modifiers"']) : "modelModifiers";
    h.push(
      Fe(
        d,
        Q(
          `{ ${m} }`,
          !1,
          r.loc,
          2
        )
      )
    );
  }
  return Ea(h);
};
function Ea(r = []) {
  return { props: r };
}
const Uy = /* @__PURE__ */ new WeakSet(), r6 = (r, e) => {
  if (r.type === 1) {
    const t = gt(r, "memo");
    return !t || Uy.has(r) ? void 0 : (Uy.add(r), () => {
      const s = r.codegenNode || e.currentNode.codegenNode;
      s && s.type === 13 && (r.tagType !== 1 && kc(s, e), r.codegenNode = ge(e.helper(Ic), [
        t.exp,
        fr(void 0, s),
        "_cache",
        String(e.cached++)
      ]));
    });
  }
};
function Um(r) {
  return [
    [
      t6,
      HI,
      r6,
      GI,
      ...r ? [
        // order is important
        Fm,
        km
      ] : [],
      QI,
      t2,
      $m,
      e6
    ],
    {
      on: Wc,
      bind: Lm,
      model: zc
    }
  ];
}
function r2(r, e = {}) {
  const t = e.onError || em, s = e.mode === "module", i = e.prefixIdentifiers === !0 || s;
  !i && e.cacheHandlers && t(Me(49)), e.scopeId && !s && t(Me(50));
  const n = Jr({}, e, {
    prefixIdentifiers: i
  }), a = Ie(r) ? Fc(r, n) : r, [o, u] = Um(i);
  if (e.isTS) {
    const { expressionPlugins: l } = e;
    (!l || !l.includes("typescript")) && (e.expressionPlugins = [...l || [], "typescript"]);
  }
  return _m(
    a,
    Jr({}, n, {
      nodeTransforms: [
        ...o,
        ...e.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: Jr(
        {},
        u,
        e.directiveTransforms || {}
        // user transforms
      )
    })
  ), Im(a, n);
}
const s6 = {
  DATA: "data",
  PROPS: "props",
  PROPS_ALIASED: "props-aliased",
  SETUP_LET: "setup-let",
  SETUP_CONST: "setup-const",
  SETUP_REACTIVE_CONST: "setup-reactive-const",
  SETUP_MAYBE_REF: "setup-maybe-ref",
  SETUP_REF: "setup-ref",
  OPTIONS: "options",
  LITERAL_CONST: "literal-const"
}, Wa = () => ({ props: [] }), jm = Symbol("vModelRadio"), qm = Symbol("vModelCheckbox"), Hm = Symbol("vModelText"), Wm = Symbol("vModelSelect"), Al = Symbol("vModelDynamic"), zm = Symbol("vOnModifiersGuard"), Gm = Symbol("vOnKeysGuard"), Km = Symbol("vShow"), nn = Symbol("Transition"), ia = Symbol("TransitionGroup");
Qd({
  [jm]: "vModelRadio",
  [qm]: "vModelCheckbox",
  [Hm]: "vModelText",
  [Wm]: "vModelSelect",
  [Al]: "vModelDynamic",
  [zm]: "withModifiers",
  [Gm]: "withKeys",
  [Km]: "vShow",
  [nn]: "Transition",
  [ia]: "TransitionGroup"
});
const Un = {
  parseMode: "html",
  isVoidTag: UE,
  isNativeTag: (r) => NC(r) || OC(r) || IC(r),
  isPreTag: (r) => r === "pre",
  decodeEntities: void 0,
  isBuiltInComponent: (r) => {
    if (r === "Transition" || r === "transition")
      return nn;
    if (r === "TransitionGroup" || r === "transition-group")
      return ia;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(r, e, t) {
    let s = e ? e.ns : t;
    if (e && s === 2)
      if (e.tag === "annotation-xml") {
        if (r === "svg")
          return 1;
        e.props.some(
          (i) => i.type === 6 && i.name === "encoding" && i.value != null && (i.value.content === "text/html" || i.value.content === "application/xhtml+xml")
        ) && (s = 0);
      } else /^m(?:[ions]|text)$/.test(e.tag) && r !== "mglyph" && r !== "malignmark" && (s = 0);
    else e && s === 1 && (e.tag === "foreignObject" || e.tag === "desc" || e.tag === "title") && (s = 0);
    if (s === 0) {
      if (r === "svg")
        return 1;
      if (r === "math")
        return 2;
    }
    return s;
  }
}, Xm = (r) => {
  r.type === 1 && r.props.forEach((e, t) => {
    e.type === 6 && e.name === "style" && e.value && (r.props[t] = {
      type: 7,
      name: "bind",
      arg: Q("style", !0, e.loc),
      exp: i6(e.value.content, e.loc),
      modifiers: [],
      loc: e.loc
    });
  });
}, i6 = (r, e) => {
  const t = BE(r);
  return Q(
    JSON.stringify(t),
    !1,
    e,
    3
  );
};
function Mt(r, e) {
  return Me(
    r,
    e,
    Jm
  );
}
const n6 = {
  X_V_HTML_NO_EXPRESSION: 53,
  53: "X_V_HTML_NO_EXPRESSION",
  X_V_HTML_WITH_CHILDREN: 54,
  54: "X_V_HTML_WITH_CHILDREN",
  X_V_TEXT_NO_EXPRESSION: 55,
  55: "X_V_TEXT_NO_EXPRESSION",
  X_V_TEXT_WITH_CHILDREN: 56,
  56: "X_V_TEXT_WITH_CHILDREN",
  X_V_MODEL_ON_INVALID_ELEMENT: 57,
  57: "X_V_MODEL_ON_INVALID_ELEMENT",
  X_V_MODEL_ARG_ON_ELEMENT: 58,
  58: "X_V_MODEL_ARG_ON_ELEMENT",
  X_V_MODEL_ON_FILE_INPUT_ELEMENT: 59,
  59: "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
  X_V_MODEL_UNNECESSARY_VALUE: 60,
  60: "X_V_MODEL_UNNECESSARY_VALUE",
  X_V_SHOW_NO_EXPRESSION: 61,
  61: "X_V_SHOW_NO_EXPRESSION",
  X_TRANSITION_INVALID_CHILDREN: 62,
  62: "X_TRANSITION_INVALID_CHILDREN",
  X_IGNORED_SIDE_EFFECT_TAG: 63,
  63: "X_IGNORED_SIDE_EFFECT_TAG",
  __EXTEND_POINT__: 64,
  64: "__EXTEND_POINT__"
}, Jm = {
  53: "v-html is missing expression.",
  54: "v-html will override element children.",
  55: "v-text is missing expression.",
  56: "v-text will override element children.",
  57: "v-model can only be used on <input>, <textarea> and <select> elements.",
  58: "v-model argument is not supported on plain elements.",
  59: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",
  60: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",
  61: "v-show is missing expression.",
  62: "<Transition> expects exactly one child element or component.",
  63: "Tags with side effect (<script> and <style>) are ignored in client component templates."
}, a6 = (r, e, t) => {
  const { exp: s, loc: i } = r;
  return s || t.onError(
    Mt(53, i)
  ), e.children.length && (t.onError(
    Mt(54, i)
  ), e.children.length = 0), {
    props: [
      Fe(
        Q("innerHTML", !0, i),
        s || Q("", !0)
      )
    ]
  };
}, o6 = (r, e, t) => {
  const { exp: s, loc: i } = r;
  return s || t.onError(
    Mt(55, i)
  ), e.children.length && (t.onError(
    Mt(56, i)
  ), e.children.length = 0), {
    props: [
      Fe(
        Q("textContent", !0),
        s ? ir(s, t) > 0 ? s : ge(
          t.helperString(Fo),
          [s],
          i
        ) : Q("", !0)
      )
    ]
  };
}, u6 = (r, e, t) => {
  const s = zc(r, e, t);
  if (!s.props.length || e.tagType === 1)
    return s;
  r.arg && t.onError(
    Mt(
      58,
      r.arg.loc
    )
  );
  function i() {
    const o = gt(e, "bind");
    o && jr(o.arg, "value") && t.onError(
      Mt(
        60,
        o.loc
      )
    );
  }
  const { tag: n } = e, a = t.isCustomElement(n);
  if (n === "input" || n === "textarea" || n === "select" || a) {
    let o = Hm, u = !1;
    if (n === "input" || a) {
      const l = Qt(e, "type");
      if (l) {
        if (l.type === 7)
          o = Al;
        else if (l.value)
          switch (l.value.content) {
            case "radio":
              o = jm;
              break;
            case "checkbox":
              o = qm;
              break;
            case "file":
              u = !0, t.onError(
                Mt(
                  59,
                  r.loc
                )
              );
              break;
            default:
              i();
              break;
          }
      } else $c(e) ? o = Al : i();
    } else n === "select" ? o = Wm : i();
    u || (s.needRuntime = t.helper(o));
  } else
    t.onError(
      Mt(
        57,
        r.loc
      )
    );
  return s.props = s.props.filter(
    (o) => !(o.key.type === 4 && o.key.content === "modelValue")
  ), s;
}, l6 = /* @__PURE__ */ Rt("passive,once,capture"), c6 = /* @__PURE__ */ Rt(
  // event propagation management
  "stop,prevent,self,ctrl,shift,alt,meta,exact,middle"
), f6 = /* @__PURE__ */ Rt("left,right"), s2 = /* @__PURE__ */ Rt(
  "onkeyup,onkeydown,onkeypress",
  !0
), p6 = (r, e, t, s) => {
  const i = [], n = [], a = [];
  for (let o = 0; o < e.length; o++) {
    const u = e[o];
    l6(u) ? a.push(u) : f6(u) ? Pt(r) ? s2(r.content) ? i.push(u) : n.push(u) : (i.push(u), n.push(u)) : c6(u) ? n.push(u) : i.push(u);
  }
  return {
    keyModifiers: i,
    nonKeyModifiers: n,
    eventOptionModifiers: a
  };
}, jy = (r, e) => Pt(r) && r.content.toLowerCase() === "onclick" ? Q(e, !0) : r.type !== 4 ? yt([
  "(",
  r,
  `) === "onClick" ? "${e}" : (`,
  r,
  ")"
]) : r, h6 = (r, e, t) => Wc(r, e, t, (s) => {
  const { modifiers: i } = r;
  if (!i.length) return s;
  let { key: n, value: a } = s.props[0];
  const { keyModifiers: o, nonKeyModifiers: u, eventOptionModifiers: l } = p6(n, i, t, r.loc);
  if (u.includes("right") && (n = jy(n, "onContextmenu")), u.includes("middle") && (n = jy(n, "onMouseup")), u.length && (a = ge(t.helper(zm), [
    a,
    JSON.stringify(u)
  ])), o.length && // if event name is dynamic, always wrap with keys guard
  (!Pt(n) || s2(n.content)) && (a = ge(t.helper(Gm), [
    a,
    JSON.stringify(o)
  ])), l.length) {
    const c = l.map(oi).join("");
    n = Pt(n) ? Q(`${n.content}${c}`, !0) : yt(["(", n, `) + "${c}"`]);
  }
  return {
    props: [Fe(n, a)]
  };
}), d6 = (r, e, t) => {
  const { exp: s, loc: i } = r;
  return s || t.onError(
    Mt(61, i)
  ), {
    props: [],
    needRuntime: t.helper(Km)
  };
}, m6 = (r, e) => {
  if (r.type === 1 && r.tagType === 1 && e.isBuiltInComponent(r.tag) === nn)
    return () => {
      if (!r.children.length)
        return;
      i2(r) && e.onError(
        Mt(
          62,
          {
            start: r.children[0].loc.start,
            end: r.children[r.children.length - 1].loc.end,
            source: ""
          }
        )
      );
      const s = r.children[0];
      if (s.type === 1)
        for (const i of s.props)
          i.type === 7 && i.name === "show" && r.props.push({
            type: 6,
            name: "persisted",
            nameLoc: r.loc,
            value: void 0,
            loc: r.loc
          });
    };
};
function i2(r) {
  const e = r.children = r.children.filter(
    (s) => s.type !== 3 && !(s.type === 2 && !s.content.trim())
  ), t = e[0];
  return e.length !== 1 || t.type === 11 || t.type === 9 && t.branches.some(i2);
}
const g6 = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g, y6 = (r, e, t) => {
  if (e.scopes.vSlot > 0)
    return;
  let s = 0, i = 0;
  const n = [], a = (u) => {
    if (s >= 20 || i >= 5) {
      const l = ge(e.helper(Sc), [
        JSON.stringify(
          n.map((c) => Ym(c, e)).join("")
        ).replace(g6, '" + $1 + "'),
        // the 2nd argument indicates the number of DOM nodes this static vnode
        // will insert / hydrate
        String(n.length)
      ]);
      if (Hy(n[0], l, e), n.length > 1) {
        for (let f = 1; f < n.length; f++)
          Hy(n[f], null, e);
        const c = n.length - 1;
        return r.splice(u - n.length + 1, c), c;
      }
    }
    return 0;
  };
  let o = 0;
  for (; o < r.length; o++) {
    const u = r[o];
    if (b6(u)) {
      const c = u, f = S6(c);
      if (f) {
        s += f[0], i += f[1], n.push(c);
        continue;
      }
    }
    o -= a(o), s = 0, i = 0, n.length = 0;
  }
  a(o);
}, b6 = (r) => (r.type === 1 && r.tagType === 0 || r.type == 12) && r.codegenNode && r.codegenNode.type === 4 && r.codegenNode.hoisted, v6 = /^(data|aria)-/, qy = (r, e) => (e === 0 ? RC(r) : e === 1 ? $C(r) : !1) || v6.test(r), Hy = (r, e, t) => {
  const s = r.codegenNode.hoisted;
  t.hoists[t.hoists.indexOf(s)] = e;
}, E6 = /* @__PURE__ */ Rt(
  "caption,thead,tr,th,tbody,td,tfoot,colgroup,col"
);
function S6(r) {
  if (r.type === 1 && E6(r.tag))
    return !1;
  if (r.type === 12)
    return [1, 0];
  let e = 1, t = r.props.length > 0 ? 1 : 0, s = !1;
  const i = () => (s = !0, !1);
  function n(a) {
    const o = a.tag === "option" && a.ns === 0;
    for (let u = 0; u < a.props.length; u++) {
      const l = a.props[u];
      if (l.type === 6 && !qy(l.name, a.ns) || l.type === 7 && l.name === "bind" && (l.arg && (l.arg.type === 8 || l.arg.isStatic && !qy(l.arg.content, a.ns)) || l.exp && (l.exp.type === 8 || l.exp.constType < 3) || o && jr(l.arg, "value") && l.exp && l.exp.ast && l.exp.ast.type !== "StringLiteral"))
        return i();
    }
    for (let u = 0; u < a.children.length; u++) {
      e++;
      const l = a.children[u];
      if (l.type === 1 && (l.props.length > 0 && t++, n(l), s))
        return !1;
    }
    return !0;
  }
  return n(r) ? [e, t] : !1;
}
function Ym(r, e) {
  if (Ie(r))
    return r;
  if (fi(r))
    return "";
  switch (r.type) {
    case 1:
      return _6(r, e);
    case 2:
      return Ur(r.content);
    case 3:
      return `<!--${Ur(r.content)}-->`;
    case 5:
      return Ur(bc(Bi(r.content)));
    case 8:
      return Ur(Bi(r));
    case 12:
      return Ym(r.content, e);
    default:
      return "";
  }
}
function _6(r, e) {
  let t = `<${r.tag}`, s = "";
  for (let i = 0; i < r.props.length; i++) {
    const n = r.props[i];
    if (n.type === 6)
      t += ` ${n.name}`, n.value && (t += `="${Ur(n.value.content)}"`);
    else if (n.type === 7)
      if (n.name === "bind") {
        const a = n.exp;
        if (a.content[0] === "_") {
          t += ` ${n.arg.content}="__VUE_EXP_START__${a.content}__VUE_EXP_END__"`;
          continue;
        }
        if (jE(n.arg.content) && a.content === "false")
          continue;
        let o = Bi(a);
        if (o != null) {
          const u = n.arg && n.arg.content;
          u === "class" ? o = VE(o) : u === "style" && (o = wC(FE(o))), t += ` ${n.arg.content}="${Ur(
            o
          )}"`;
        }
      } else n.name === "html" ? s = Bi(n.exp) : n.name === "text" && (s = Ur(
        bc(Bi(n.exp))
      ));
  }
  if (e.scopeId && (t += ` ${e.scopeId}`), t += ">", s)
    t += s;
  else
    for (let i = 0; i < r.children.length; i++)
      t += Ym(r.children[i], e);
  return UE(r.tag) || (t += `</${r.tag}>`), t;
}
function Bi(r) {
  if (r.type === 4)
    return new Function(`return (${r.content})`)();
  {
    let e = "";
    return r.children.forEach((t) => {
      Ie(t) || fi(t) || (t.type === 2 ? e += t.content : t.type === 5 ? e += bc(Bi(t.content)) : e += Bi(t));
    }), e;
  }
}
const x6 = (r, e) => {
  r.type === 1 && r.tagType === 0 && (r.tag === "script" || r.tag === "style") && (e.onError(
    Mt(
      63,
      r.loc
    )
  ), e.removeNode());
}, Qm = [
  Xm,
  m6
], Zm = {
  cloak: Wa,
  html: a6,
  text: o6,
  model: u6,
  // override compiler-core
  on: h6,
  // override compiler-core
  show: d6
};
function w6(r, e = {}) {
  return r2(
    r,
    Jr({}, Un, e, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        x6,
        ...Qm,
        ...e.nodeTransforms || []
      ],
      directiveTransforms: Jr(
        {},
        Zm,
        e.directiveTransforms || {}
      ),
      transformHoist: y6
    })
  );
}
function T6(r, e = {}) {
  return Fc(r, Jr({}, Un, e));
}
var zp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BASE_TRANSITION: zd,
  BindingTypes: s6,
  CAMELIZE: dl,
  CAPITALIZE: zE,
  CREATE_BLOCK: Gd,
  CREATE_COMMENT: Jn,
  CREATE_ELEMENT_BLOCK: Kd,
  CREATE_ELEMENT_VNODE: vc,
  CREATE_SLOTS: Jd,
  CREATE_STATIC: Sc,
  CREATE_TEXT: Ec,
  CREATE_VNODE: Ro,
  CompilerDeprecationTypes: eN,
  ConstantTypes: jC,
  DOMDirectiveTransforms: Zm,
  DOMErrorCodes: n6,
  DOMErrorMessages: Jm,
  DOMNodeTransforms: Qm,
  ElementTypes: UC,
  ErrorCodes: iN,
  FRAGMENT: Dn,
  GUARD_REACTIVE_PROPS: Yn,
  IS_MEMO_SAME: Yd,
  IS_REF: co,
  KEEP_ALIVE: oo,
  MERGE_PROPS: Gi,
  NORMALIZE_CLASS: Tc,
  NORMALIZE_PROPS: Ln,
  NORMALIZE_STYLE: Pc,
  Namespaces: BC,
  NodeTypes: VC,
  OPEN_BLOCK: ui,
  POP_SCOPE_ID: Nc,
  PUSH_SCOPE_ID: Cc,
  RENDER_LIST: wc,
  RENDER_SLOT: Xd,
  RESOLVE_COMPONENT: uo,
  RESOLVE_DIRECTIVE: _c,
  RESOLVE_DYNAMIC_COMPONENT: $o,
  RESOLVE_FILTER: WE,
  SET_BLOCK_TRACKING: lo,
  SUSPENSE: Xn,
  TELEPORT: $i,
  TO_DISPLAY_STRING: Fo,
  TO_HANDLERS: Ac,
  TO_HANDLER_KEY: ml,
  TRANSITION: nn,
  TRANSITION_GROUP: ia,
  TS_NODE_TYPES: ym,
  UNREF: Mn,
  V_MODEL_CHECKBOX: qm,
  V_MODEL_DYNAMIC: Al,
  V_MODEL_RADIO: jm,
  V_MODEL_SELECT: Wm,
  V_MODEL_TEXT: Hm,
  V_ON_WITH_KEYS: Gm,
  V_ON_WITH_MODIFIERS: zm,
  V_SHOW: Km,
  WITH_CTX: Oc,
  WITH_DIRECTIVES: xc,
  WITH_MEMO: Ic,
  advancePositionWithClone: Vp,
  advancePositionWithMutation: Em,
  assert: Up,
  baseCompile: r2,
  baseParse: Fc,
  buildDirectiveArgs: Bm,
  buildProps: sa,
  buildSlots: yo,
  checkCompatEnabled: sN,
  compile: w6,
  convertToBlock: kc,
  createArrayExpression: sn,
  createAssignmentExpression: Du,
  createBlockStatement: Bo,
  createCacheExpression: GE,
  createCallExpression: ge,
  createCompilerError: Me,
  createCompoundExpression: yt,
  createConditionalExpression: Nr,
  createDOMCompilerError: Mt,
  createForLoopParams: go,
  createFunctionExpression: fr,
  createIfStatement: yl,
  createInterpolation: gl,
  createObjectExpression: Yt,
  createObjectProperty: Fe,
  createReturnStatement: XE,
  createRoot: rn,
  createSequenceExpression: KE,
  createSimpleExpression: Q,
  createStructuralDirectiveTransform: Wo,
  createTemplateLiteral: Zd,
  createTransformContext: Ho,
  createVNodeCall: Rn,
  errorMessages: tm,
  extractIdentifiers: mr,
  findDir: gt,
  findProp: Qt,
  forAliasRE: NS,
  generate: Im,
  generateCodeFrame: kn,
  getBaseTransformPreset: Um,
  getConstantType: ir,
  getMemoedVNodeCall: CS,
  getVNodeBlockHelper: Xi,
  getVNodeHelper: Ki,
  hasDynamicKeyVBind: $c,
  hasScopeRef: Xt,
  helperNameMap: Jt,
  injectProp: po,
  isCoreComponent: bm,
  isFunctionType: Ys,
  isInDestructureAssignment: jo,
  isInNewExpression: SS,
  isMemberExpression: vm,
  isMemberExpressionBrowser: KO,
  isMemberExpressionNode: PS,
  isReferencedIdentifier: mm,
  isSimpleIdentifier: Ts,
  isSlotOutlet: Bn,
  isStaticArgOf: jr,
  isStaticExp: Pt,
  isStaticProperty: qo,
  isStaticPropertyKey: TS,
  isTemplateNode: Fn,
  isText: Ha,
  isVSlot: Sm,
  locStub: rt,
  noopDirectiveTransform: Wa,
  parse: T6,
  parserOptions: Un,
  processExpression: vt,
  processFor: Mm,
  processIf: Dm,
  processSlotOutlet: Vm,
  registerRuntimeHelpers: Qd,
  resolveComponentType: Hc,
  stringifyExpression: qc,
  toValidAssetId: ho,
  trackSlotScopes: $m,
  trackVForSlotScopes: Fm,
  transform: _m,
  transformBind: Lm,
  transformElement: t2,
  transformExpression: km,
  transformModel: zc,
  transformOn: Wc,
  transformStyle: Xm,
  traverseNode: Qn,
  unwrapTSNode: br,
  walkBlockDeclarations: _S,
  walkFunctionParams: gm,
  walkIdentifiers: Uo,
  warnDeprecation: ZE
});
function n2(r, e) {
  for (var t = 0, s = r.length - 1; s >= 0; s--) {
    var i = r[s];
    i === "." ? r.splice(s, 1) : i === ".." ? (r.splice(s, 1), t++) : t && (r.splice(s, 1), t--);
  }
  if (e)
    for (; t--; t)
      r.unshift("..");
  return r;
}
var P6 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, e0 = function(r) {
  return P6.exec(r).slice(1);
};
function Cl() {
  for (var r = "", e = !1, t = arguments.length - 1; t >= -1 && !e; t--) {
    var s = t >= 0 ? arguments[t] : "/";
    if (typeof s != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!s)
      continue;
    r = s + "/" + r, e = s.charAt(0) === "/";
  }
  return r = n2(i0(r.split("/"), function(i) {
    return !!i;
  }), !e).join("/"), (e ? "/" : "") + r || ".";
}
function t0(r) {
  var e = r0(r), t = A6(r, -1) === "/";
  return r = n2(i0(r.split("/"), function(s) {
    return !!s;
  }), !e).join("/"), !r && !e && (r = "."), r && t && (r += "/"), (e ? "/" : "") + r;
}
function r0(r) {
  return r.charAt(0) === "/";
}
function a2() {
  var r = Array.prototype.slice.call(arguments, 0);
  return t0(i0(r, function(e, t) {
    if (typeof e != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return e;
  }).join("/"));
}
function o2(r, e) {
  r = Cl(r).substr(1), e = Cl(e).substr(1);
  function t(l) {
    for (var c = 0; c < l.length && l[c] === ""; c++)
      ;
    for (var f = l.length - 1; f >= 0 && l[f] === ""; f--)
      ;
    return c > f ? [] : l.slice(c, f - c + 1);
  }
  for (var s = t(r.split("/")), i = t(e.split("/")), n = Math.min(s.length, i.length), a = n, o = 0; o < n; o++)
    if (s[o] !== i[o]) {
      a = o;
      break;
    }
  for (var u = [], o = a; o < s.length; o++)
    u.push("..");
  return u = u.concat(i.slice(a)), u.join("/");
}
var u2 = "/", l2 = ":";
function Nl(r) {
  var e = e0(r), t = e[0], s = e[1];
  return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
}
function c2(r, e) {
  var t = e0(r)[2];
  return e && t.substr(-1 * e.length) === e && (t = t.substr(0, t.length - e.length)), t;
}
function s0(r) {
  return e0(r)[3];
}
var As = {
  extname: s0,
  basename: c2,
  dirname: Nl,
  sep: u2,
  delimiter: l2,
  relative: o2,
  join: a2,
  isAbsolute: r0,
  normalize: t0,
  resolve: Cl
};
function i0(r, e) {
  if (r.filter) return r.filter(e);
  for (var t = [], s = 0; s < r.length; s++)
    e(r[s], s, r) && t.push(r[s]);
  return t;
}
var A6 = "ab".substr(-1) === "b" ? function(r, e, t) {
  return r.substr(e, t);
} : function(r, e, t) {
  return e < 0 && (e = r.length + e), r.substr(e, t);
}, C6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  basename: c2,
  default: As,
  delimiter: l2,
  dirname: Nl,
  extname: s0,
  isAbsolute: r0,
  join: a2,
  normalize: t0,
  relative: o2,
  resolve: Cl,
  sep: u2
});
const $r = "Unknown";
function n0(r, e) {
  switch (r.type) {
    case "StringLiteral":
    case "NumericLiteral":
      return String(r.value);
    case "Identifier":
      if (!e) return r.name;
  }
}
function Wy(r) {
  return r.filter((e) => !!e).join(", ");
}
function f2(r) {
  return r.type.endsWith("Literal");
}
function Wt(r, e) {
  return !!(r && e && r.type === "CallExpression" && r.callee.type === "Identifier" && (typeof e == "string" ? r.callee.name === e : e(r.callee.name)));
}
function dn(r) {
  return r.length > 1 ? `[${r.join(", ")}]` : r[0];
}
function Gp(r) {
  return r.type === "ImportSpecifier" ? r.imported.type === "Identifier" ? r.imported.name : r.imported.value : r.type === "ImportNamespaceSpecifier" ? "*" : "default";
}
function Ji(r) {
  return r.type === "Identifier" ? r.name : r.type === "StringLiteral" ? r.value : null;
}
const N6 = (As.posix || As).normalize, O6 = /\\/g;
function a0(r) {
  return N6(r.replace(O6, "/"));
}
const za = (As.posix || As).join, I6 = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~\-]/;
function p2(r) {
  return I6.test(r) ? JSON.stringify(r) : r;
}
const k6 = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function D6(r, e) {
  return r.replace(
    k6,
    (t) => e ? `\\\\${t}` : `\\${t}`
  );
}
function L6(r, e) {
  for (; r.length < e; )
    r = "0" + r;
  return r;
}
function ns(r, e) {
  var t, s, i;
  if (e.length === 0)
    return r;
  for (t = 0, i = e.length; t < i; t++)
    s = e.charCodeAt(t), r = (r << 5) - r + s, r |= 0;
  return r < 0 ? r * -2 : r;
}
function M6(r, e, t) {
  return Object.keys(e).sort().reduce(s, r);
  function s(i, n) {
    return h2(i, e[n], n, t);
  }
}
function h2(r, e, t, s) {
  var i = ns(ns(ns(r, t), R6(e)), typeof e);
  if (e === null)
    return ns(i, "null");
  if (e === void 0)
    return ns(i, "undefined");
  if (typeof e == "object" || typeof e == "function") {
    if (s.indexOf(e) !== -1)
      return ns(i, "[Circular]" + t);
    s.push(e);
    var n = M6(i, e, s);
    if (!("valueOf" in e) || typeof e.valueOf != "function")
      return n;
    try {
      return ns(n, String(e.valueOf()));
    } catch (a) {
      return ns(n, "[valueOf exception]" + (a.stack || a.message));
    }
  }
  return ns(i, e.toString());
}
function R6(r) {
  return Object.prototype.toString.call(r);
}
function $6(r) {
  return L6(h2(0, r, "", []).toString(16), 8);
}
var F6 = $6, B6 = /* @__PURE__ */ Dc(F6);
const Ol = "useCssVars";
function d2(r, e, t, s = !1) {
  return `{
  ${r.map(
    (i) => `"${s ? "--" : ""}${m2(e, i, t, s)}": (${i})`
  ).join(`,
  `)}
}`;
}
function m2(r, e, t, s = !1) {
  return t ? B6(r + e) : `${r}-${D6(e, s)}`;
}
function g2(r) {
  return r = r.trim(), r[0] === "'" && r[r.length - 1] === "'" || r[0] === '"' && r[r.length - 1] === '"' ? r.slice(1, -1) : r;
}
const Hu = /v-bind\s*\(/g;
function V6(r) {
  const e = [];
  return r.styles.forEach((t) => {
    let s;
    const i = t.content.replace(/\/\*([\s\S]*?)\*\/|\/\/.*/g, "");
    for (; s = Hu.exec(i); ) {
      const n = s.index + s[0].length, a = y2(i, n);
      if (a !== null) {
        const o = g2(i.slice(n, a));
        e.includes(o) || e.push(o);
      }
    }
  }), e;
}
function y2(r, e) {
  let t = 0, s = 0;
  for (let i = e; i < r.length; i++) {
    const n = r.charAt(i);
    switch (t) {
      case 0:
        if (n === "'")
          t = 1;
        else if (n === '"')
          t = 2;
        else if (n === "(")
          s++;
        else if (n === ")")
          if (s > 0)
            s--;
          else
            return i;
        break;
      case 1:
        n === "'" && (t = 0);
        break;
      case 2:
        n === '"' && (t = 0);
        break;
    }
  }
  return null;
}
const b2 = (r) => {
  const { id: e, isProd: t } = r;
  return {
    postcssPlugin: "vue-sfc-vars",
    Declaration(s) {
      const i = s.value;
      if (Hu.test(i)) {
        Hu.lastIndex = 0;
        let n = "", a = 0, o;
        for (; o = Hu.exec(i); ) {
          const u = o.index + o[0].length, l = y2(i, u);
          if (l !== null) {
            const c = g2(i.slice(u, l));
            n += i.slice(a, o.index) + `var(--${m2(e, c, t)})`, a = l + 1;
          }
        }
        s.value = n + i.slice(a);
      }
    }
  };
};
b2.postcss = !0;
function v2(r, e, t, s) {
  const i = d2(r, t, s), n = Q(i, !1), a = Ho(rn([]), {
    prefixIdentifiers: !0,
    inline: !0,
    bindingMetadata: e.__isScriptSetup === !1 ? void 0 : e
  }), o = vt(n, a), u = o.type === 4 ? o.content : o.children.map((l) => typeof l == "string" ? l : l.content).join("");
  return `_${Ol}(_ctx => (${u}))`;
}
function U6(r, e, t, s, i) {
  return `
import { ${Ol} as _${Ol} } from 'vue'
const __injectCSSVars__ = () => {
${v2(
    r,
    e,
    t,
    s
  )}}
const __setup__ = ${i}.setup
${i}.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
}
var li = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {};
function E2() {
  throw new Error("setTimeout has not been defined");
}
function S2() {
  throw new Error("clearTimeout has not been defined");
}
var Us = E2, js = S2;
typeof li.setTimeout == "function" && (Us = setTimeout);
typeof li.clearTimeout == "function" && (js = clearTimeout);
function _2(r) {
  if (Us === setTimeout)
    return setTimeout(r, 0);
  if ((Us === E2 || !Us) && setTimeout)
    return Us = setTimeout, setTimeout(r, 0);
  try {
    return Us(r, 0);
  } catch {
    try {
      return Us.call(null, r, 0);
    } catch {
      return Us.call(this, r, 0);
    }
  }
}
function j6(r) {
  if (js === clearTimeout)
    return clearTimeout(r);
  if ((js === S2 || !js) && clearTimeout)
    return js = clearTimeout, clearTimeout(r);
  try {
    return js(r);
  } catch {
    try {
      return js.call(null, r);
    } catch {
      return js.call(this, r);
    }
  }
}
var ys = [], _n = !1, Pi, Wu = -1;
function q6() {
  !_n || !Pi || (_n = !1, Pi.length ? ys = Pi.concat(ys) : Wu = -1, ys.length && x2());
}
function x2() {
  if (!_n) {
    var r = _2(q6);
    _n = !0;
    for (var e = ys.length; e; ) {
      for (Pi = ys, ys = []; ++Wu < e; )
        Pi && Pi[Wu].run();
      Wu = -1, e = ys.length;
    }
    Pi = null, _n = !1, j6(r);
  }
}
function H6(r) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var t = 1; t < arguments.length; t++)
      e[t - 1] = arguments[t];
  ys.push(new w2(r, e)), ys.length === 1 && !_n && _2(x2);
}
function w2(r, e) {
  this.fun = r, this.array = e;
}
w2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var W6 = "browser", z6 = "browser", G6 = !0, K6 = {}, X6 = [], J6 = "", Y6 = {}, Q6 = {}, Z6 = {};
function an() {
}
var e4 = an, t4 = an, r4 = an, s4 = an, i4 = an, n4 = an, a4 = an;
function o4(r) {
  throw new Error("process.binding is not supported");
}
function u4() {
  return "/";
}
function l4(r) {
  throw new Error("process.chdir is not supported");
}
function c4() {
  return 0;
}
var cn = li.performance || {}, f4 = cn.now || cn.mozNow || cn.msNow || cn.oNow || cn.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function p4(r) {
  var e = f4.call(cn) * 1e-3, t = Math.floor(e), s = Math.floor(e % 1 * 1e9);
  return r && (t = t - r[0], s = s - r[1], s < 0 && (t--, s += 1e9)), [t, s];
}
var h4 = /* @__PURE__ */ new Date();
function d4() {
  var r = /* @__PURE__ */ new Date(), e = r - h4;
  return e / 1e3;
}
var Zt = {
  nextTick: H6,
  title: W6,
  browser: G6,
  env: K6,
  argv: X6,
  version: J6,
  versions: Y6,
  on: e4,
  addListener: t4,
  once: r4,
  off: s4,
  removeListener: i4,
  removeAllListeners: n4,
  emit: a4,
  binding: o4,
  cwd: u4,
  chdir: l4,
  umask: c4,
  hrtime: p4,
  platform: z6,
  release: Q6,
  config: Z6,
  uptime: d4
};
function Gc(r = 500) {
  return /* @__PURE__ */ new Map();
}
function T2(r, e) {
  return m4(e).has(r);
}
const zy = Gc();
function m4(r) {
  const { content: e, ast: t } = r.template, s = zy.get(e);
  if (s)
    return s;
  const i = /* @__PURE__ */ new Set();
  t.children.forEach(n);
  function n(a) {
    var o;
    switch (a.type) {
      case 1:
        let u = a.tag;
        u.includes(".") && (u = u.split(".")[0].trim()), !Un.isNativeTag(u) && !Un.isBuiltInComponent(u) && (i.add(or(u)), i.add(oi(or(u))));
        for (let l = 0; l < a.props.length; l++) {
          const c = a.props[l];
          c.type === 7 && (Wd(c.name) || i.add(`v${oi(or(c.name))}`), c.arg && !c.arg.isStatic && pu(i, c.arg), c.name === "for" ? pu(i, c.forParseResult.source) : c.exp ? pu(i, c.exp) : c.name === "bind" && !c.exp && i.add(c.arg.content)), c.type === 6 && c.name === "ref" && ((o = c.value) != null && o.content) && i.add(c.value.content);
        }
        a.children.forEach(n);
        break;
      case 5:
        pu(i, a.content);
        break;
    }
  }
  return zy.set(e, i), i;
}
function pu(r, e) {
  e.ast ? Uo(e.ast, (t) => r.add(t.name)) : e.ast === null && r.add(e.content);
}
var g4 = Object.defineProperty, y4 = Object.defineProperties, b4 = Object.getOwnPropertyDescriptors, Gy = Object.getOwnPropertySymbols, v4 = Object.prototype.hasOwnProperty, E4 = Object.prototype.propertyIsEnumerable, Ky = (r, e, t) => e in r ? g4(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, P2 = (r, e) => {
  for (var t in e || (e = {}))
    v4.call(e, t) && Ky(r, t, e[t]);
  if (Gy)
    for (var t of Gy(e))
      E4.call(e, t) && Ky(r, t, e[t]);
  return r;
}, A2 = (r, e) => y4(r, b4(e));
const C2 = "anonymous.vue", Kp = Gc();
function S4(r, e) {
  var t;
  return r + JSON.stringify(
    A2(P2({}, e), {
      compiler: { parse: (t = e.compiler) == null ? void 0 : t.parse }
    }),
    (s, i) => typeof i == "function" ? i.toString() : i
  );
}
function N2(r, e = {}) {
  const t = S4(r, e), s = Kp.get(t);
  if (s)
    return s;
  const {
    sourceMap: i = !0,
    filename: n = C2,
    sourceRoot: a = "",
    pad: o = !1,
    ignoreEmpty: u = !0,
    compiler: l = zp,
    templateParseOptions: c = {},
    parseExpressions: f = !0
  } = e, p = {
    filename: n,
    source: r,
    template: null,
    script: null,
    scriptSetup: null,
    styles: [],
    customBlocks: [],
    cssVars: [],
    slotted: !1,
    shouldForceReload: (E) => C4(E, p)
  }, h = [];
  l.parse(r, A2(P2({
    parseMode: "sfc",
    prefixIdentifiers: f
  }, c), {
    onError: (E) => {
      h.push(E);
    }
  })).children.forEach((E) => {
    if (E.type === 1 && !(u && E.tag !== "template" && A4(E) && !P4(E)))
      switch (E.tag) {
        case "template":
          if (p.template)
            h.push(Xy(E));
          else {
            const A = p.template = hu(
              E,
              r,
              !1
            );
            if (A.attrs.src || (A.ast = rn(E.children, r)), A.attrs.functional) {
              const C = new SyntaxError(
                "<template functional> is no longer supported in Vue 3, since functional components no longer have significant performance difference from stateful ones. Just use a normal <template> instead."
              );
              C.loc = E.props.find(
                (x) => x.type === 6 && x.name === "functional"
              ).loc, h.push(C);
            }
          }
          break;
        case "script":
          const g = hu(E, r, o), b = !!g.attrs.setup;
          if (b && !p.scriptSetup) {
            p.scriptSetup = g;
            break;
          }
          if (!b && !p.script) {
            p.script = g;
            break;
          }
          h.push(Xy(E, b));
          break;
        case "style":
          const v = hu(E, r, o);
          v.attrs.vars && h.push(
            new SyntaxError(
              "<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231"
            )
          ), p.styles.push(v);
          break;
        default:
          p.customBlocks.push(hu(E, r, o));
          break;
      }
  }), !p.template && !p.script && !p.scriptSetup && h.push(
    new SyntaxError(
      "At least one <template> or <script> is required in a single file component."
    )
  ), p.scriptSetup && (p.scriptSetup.src && (h.push(
    new SyntaxError(
      '<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.'
    )
  ), p.scriptSetup = null), p.script && p.script.src && (h.push(
    new SyntaxError(
      '<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.'
    )
  ), p.script = null));
  let d = 0;
  if (p.template && (p.template.lang === "pug" || p.template.lang === "jade") && ([p.template.content, d] = N4(
    p.template.content
  )), i) {
    const E = (g, b = 0) => {
      g && !g.src && (g.map = w4(
        n,
        r,
        g.content,
        a,
        !o || g.type === "template" ? g.loc.start.line - 1 : 0,
        b
      ));
    };
    E(p.template, d), E(p.script), p.styles.forEach((g) => E(g)), p.customBlocks.forEach((g) => E(g));
  }
  p.cssVars = V6(p);
  const y = /(?:::v-|:)slotted\(/;
  p.slotted = p.styles.some(
    (E) => E.scoped && y.test(E.content)
  );
  const S = {
    descriptor: p,
    errors: h
  };
  return Kp.set(t, S), S;
}
function Xy(r, e = !1) {
  const t = new SyntaxError(
    `Single file component can contain only one <${r.tag}${e ? " setup" : ""}> element`
  );
  return t.loc = r.loc, t;
}
function hu(r, e, t) {
  const s = r.tag, i = r.innerLoc, n = {}, a = {
    type: s,
    content: e.slice(i.start.offset, i.end.offset),
    loc: i,
    attrs: n
  };
  return t && (a.content = T4(e, a, t) + a.content), r.props.forEach((o) => {
    if (o.type === 6) {
      const u = o.name;
      n[u] = o.value && o.value.content || !0, u === "lang" ? a.lang = o.value && o.value.content : u === "src" ? a.src = o.value && o.value.content : s === "style" ? u === "scoped" ? a.scoped = !0 : u === "module" && (a.module = n[u]) : s === "script" && u === "setup" && (a.setup = n.setup);
    }
  }), a;
}
const O2 = /\r?\n/g, _4 = /^(?:\/\/)?\s*$/, x4 = /./g;
function w4(r, e, t, s, i, n) {
  const a = new Om({
    file: r.replace(/\\/g, "/"),
    sourceRoot: s.replace(/\\/g, "/")
  });
  return a.setSourceContent(r, e), a._sources.add(r), t.split(O2).forEach((o, u) => {
    if (!_4.test(o)) {
      const l = u + 1 + i, c = u + 1;
      for (let f = 0; f < o.length; f++)
        /\s/.test(o[f]) || a._mappings.add({
          originalLine: l,
          originalColumn: f + n,
          generatedLine: c,
          generatedColumn: f,
          source: r,
          name: null
        });
    }
  }), a.toJSON();
}
function T4(r, e, t) {
  if (r = r.slice(0, e.loc.start.offset), t === "space")
    return r.replace(x4, " ");
  {
    const s = r.split(O2).length, i = e.type === "script" && !e.lang ? `//
` : `
`;
    return Array(s).join(i);
  }
}
function P4(r) {
  return r.props.some((e) => e.type !== 6 ? !1 : e.name === "src");
}
function A4(r) {
  for (let e = 0; e < r.children.length; e++) {
    const t = r.children[e];
    if (t.type !== 2 || t.content.trim() !== "")
      return !1;
  }
  return !0;
}
function C4(r, e) {
  if (!e.scriptSetup || e.scriptSetup.lang !== "ts" && e.scriptSetup.lang !== "tsx")
    return !1;
  for (const t in r)
    if (!r[t].isUsedInTemplate && T2(t, e))
      return !0;
  return !1;
}
function N4(r) {
  const e = r.split(`
`), t = e.reduce(function(s, i) {
    var n, a;
    if (i.trim() === "")
      return s;
    const o = ((a = (n = i.match(/^\s*/)) == null ? void 0 : n[0]) == null ? void 0 : a.length) || 0;
    return Math.min(o, s);
  }, 1 / 0);
  return t === 0 ? [r, t] : [
    e.map(function(s) {
      return s.slice(t);
    }).join(`
`),
    t
  ];
}
/*! https://mths.be/punycode v1.4.1 by @mathias */
var Bf = 2147483647, Ga = 36, I2 = 1, Xp = 26, O4 = 38, I4 = 700, k4 = 72, D4 = 128, L4 = "-", M4 = /[^\x20-\x7E]/, R4 = /[\x2E\u3002\uFF0E\uFF61]/g, $4 = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, Vf = Ga - I2, mn = Math.floor, Uf = String.fromCharCode;
function Jy(r) {
  throw new RangeError($4[r]);
}
function F4(r, e) {
  for (var t = r.length, s = []; t--; )
    s[t] = e(r[t]);
  return s;
}
function B4(r, e) {
  var t = r.split("@"), s = "";
  t.length > 1 && (s = t[0] + "@", r = t[1]), r = r.replace(R4, ".");
  var i = r.split("."), n = F4(i, e).join(".");
  return s + n;
}
function V4(r) {
  for (var e = [], t = 0, s = r.length, i, n; t < s; )
    i = r.charCodeAt(t++), i >= 55296 && i <= 56319 && t < s ? (n = r.charCodeAt(t++), (n & 64512) == 56320 ? e.push(((i & 1023) << 10) + (n & 1023) + 65536) : (e.push(i), t--)) : e.push(i);
  return e;
}
function Yy(r, e) {
  return r + 22 + 75 * (r < 26) - ((e != 0) << 5);
}
function U4(r, e, t) {
  var s = 0;
  for (r = t ? mn(r / I4) : r >> 1, r += mn(r / e); r > Vf * Xp >> 1; s += Ga)
    r = mn(r / Vf);
  return mn(s + (Vf + 1) * r / (r + O4));
}
function j4(r) {
  var e, t, s, i, n, a, o, u, l, c, f, p = [], h, m, d, y;
  for (r = V4(r), h = r.length, e = D4, t = 0, n = k4, a = 0; a < h; ++a)
    f = r[a], f < 128 && p.push(Uf(f));
  for (s = i = p.length, i && p.push(L4); s < h; ) {
    for (o = Bf, a = 0; a < h; ++a)
      f = r[a], f >= e && f < o && (o = f);
    for (m = s + 1, o - e > mn((Bf - t) / m) && Jy("overflow"), t += (o - e) * m, e = o, a = 0; a < h; ++a)
      if (f = r[a], f < e && ++t > Bf && Jy("overflow"), f == e) {
        for (u = t, l = Ga; c = l <= n ? I2 : l >= n + Xp ? Xp : l - n, !(u < c); l += Ga)
          y = u - c, d = Ga - c, p.push(
            Uf(Yy(c + y % d, 0))
          ), u = mn(y / d);
        p.push(Uf(Yy(u, 0))), n = U4(t, m, s == i), t = 0, ++s;
      }
    ++t, ++e;
  }
  return p.join("");
}
function q4(r) {
  return B4(r, function(e) {
    return M4.test(e) ? "xn--" + j4(e) : e;
  });
}
var Vr = [], dr = [], H4 = typeof Uint8Array < "u" ? Uint8Array : Array, o0 = !1;
function k2() {
  o0 = !0;
  for (var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = 0, t = r.length; e < t; ++e)
    Vr[e] = r[e], dr[r.charCodeAt(e)] = e;
  dr[45] = 62, dr[95] = 63;
}
function W4(r) {
  o0 || k2();
  var e, t, s, i, n, a, o = r.length;
  if (o % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  n = r[o - 2] === "=" ? 2 : r[o - 1] === "=" ? 1 : 0, a = new H4(o * 3 / 4 - n), s = n > 0 ? o - 4 : o;
  var u = 0;
  for (e = 0, t = 0; e < s; e += 4, t += 3)
    i = dr[r.charCodeAt(e)] << 18 | dr[r.charCodeAt(e + 1)] << 12 | dr[r.charCodeAt(e + 2)] << 6 | dr[r.charCodeAt(e + 3)], a[u++] = i >> 16 & 255, a[u++] = i >> 8 & 255, a[u++] = i & 255;
  return n === 2 ? (i = dr[r.charCodeAt(e)] << 2 | dr[r.charCodeAt(e + 1)] >> 4, a[u++] = i & 255) : n === 1 && (i = dr[r.charCodeAt(e)] << 10 | dr[r.charCodeAt(e + 1)] << 4 | dr[r.charCodeAt(e + 2)] >> 2, a[u++] = i >> 8 & 255, a[u++] = i & 255), a;
}
function z4(r) {
  return Vr[r >> 18 & 63] + Vr[r >> 12 & 63] + Vr[r >> 6 & 63] + Vr[r & 63];
}
function G4(r, e, t) {
  for (var s, i = [], n = e; n < t; n += 3)
    s = (r[n] << 16) + (r[n + 1] << 8) + r[n + 2], i.push(z4(s));
  return i.join("");
}
function Qy(r) {
  o0 || k2();
  for (var e, t = r.length, s = t % 3, i = "", n = [], a = 16383, o = 0, u = t - s; o < u; o += a)
    n.push(G4(r, o, o + a > u ? u : o + a));
  return s === 1 ? (e = r[t - 1], i += Vr[e >> 2], i += Vr[e << 4 & 63], i += "==") : s === 2 && (e = (r[t - 2] << 8) + r[t - 1], i += Vr[e >> 10], i += Vr[e >> 4 & 63], i += Vr[e << 2 & 63], i += "="), n.push(i), n.join("");
}
function Kc(r, e, t, s, i) {
  var n, a, o = i * 8 - s - 1, u = (1 << o) - 1, l = u >> 1, c = -7, f = t ? i - 1 : 0, p = t ? -1 : 1, h = r[e + f];
  for (f += p, n = h & (1 << -c) - 1, h >>= -c, c += o; c > 0; n = n * 256 + r[e + f], f += p, c -= 8)
    ;
  for (a = n & (1 << -c) - 1, n >>= -c, c += s; c > 0; a = a * 256 + r[e + f], f += p, c -= 8)
    ;
  if (n === 0)
    n = 1 - l;
  else {
    if (n === u)
      return a ? NaN : (h ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, s), n = n - l;
  }
  return (h ? -1 : 1) * a * Math.pow(2, n - s);
}
function D2(r, e, t, s, i, n) {
  var a, o, u, l = n * 8 - i - 1, c = (1 << l) - 1, f = c >> 1, p = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = s ? 0 : n - 1, m = s ? 1 : -1, d = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), a + f >= 1 ? e += p / u : e += p * Math.pow(2, 1 - f), e * u >= 2 && (a++, u /= 2), a + f >= c ? (o = 0, a = c) : a + f >= 1 ? (o = (e * u - 1) * Math.pow(2, i), a = a + f) : (o = e * Math.pow(2, f - 1) * Math.pow(2, i), a = 0)); i >= 8; r[t + h] = o & 255, h += m, o /= 256, i -= 8)
    ;
  for (a = a << i | o, l += i; l > 0; r[t + h] = a & 255, h += m, a /= 256, l -= 8)
    ;
  r[t + h - m] |= d * 128;
}
var K4 = {}.toString, L2 = Array.isArray || function(r) {
  return K4.call(r) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var X4 = 50;
H.TYPED_ARRAY_SUPPORT = li.TYPED_ARRAY_SUPPORT !== void 0 ? li.TYPED_ARRAY_SUPPORT : !0;
Il();
function Il() {
  return H.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function bs(r, e) {
  if (Il() < e)
    throw new RangeError("Invalid typed array length");
  return H.TYPED_ARRAY_SUPPORT ? (r = new Uint8Array(e), r.__proto__ = H.prototype) : (r === null && (r = new H(e)), r.length = e), r;
}
function H(r, e, t) {
  if (!H.TYPED_ARRAY_SUPPORT && !(this instanceof H))
    return new H(r, e, t);
  if (typeof r == "number") {
    if (typeof e == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return u0(this, r);
  }
  return M2(this, r, e, t);
}
H.poolSize = 8192;
H._augment = function(r) {
  return r.__proto__ = H.prototype, r;
};
function M2(r, e, t, s) {
  if (typeof e == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer ? Q4(r, e, t, s) : typeof e == "string" ? Y4(r, e, t) : Z4(r, e);
}
H.from = function(r, e, t) {
  return M2(null, r, e, t);
};
H.TYPED_ARRAY_SUPPORT && (H.prototype.__proto__ = Uint8Array.prototype, H.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && H[Symbol.species]);
function R2(r) {
  if (typeof r != "number")
    throw new TypeError('"size" argument must be a number');
  if (r < 0)
    throw new RangeError('"size" argument must not be negative');
}
function J4(r, e, t, s) {
  return R2(e), e <= 0 ? bs(r, e) : t !== void 0 ? typeof s == "string" ? bs(r, e).fill(t, s) : bs(r, e).fill(t) : bs(r, e);
}
H.alloc = function(r, e, t) {
  return J4(null, r, e, t);
};
function u0(r, e) {
  if (R2(e), r = bs(r, e < 0 ? 0 : l0(e) | 0), !H.TYPED_ARRAY_SUPPORT)
    for (var t = 0; t < e; ++t)
      r[t] = 0;
  return r;
}
H.allocUnsafe = function(r) {
  return u0(null, r);
};
H.allocUnsafeSlow = function(r) {
  return u0(null, r);
};
function Y4(r, e, t) {
  if ((typeof t != "string" || t === "") && (t = "utf8"), !H.isEncoding(t))
    throw new TypeError('"encoding" must be a valid string encoding');
  var s = $2(e, t) | 0;
  r = bs(r, s);
  var i = r.write(e, t);
  return i !== s && (r = r.slice(0, i)), r;
}
function Jp(r, e) {
  var t = e.length < 0 ? 0 : l0(e.length) | 0;
  r = bs(r, t);
  for (var s = 0; s < t; s += 1)
    r[s] = e[s] & 255;
  return r;
}
function Q4(r, e, t, s) {
  if (e.byteLength, t < 0 || e.byteLength < t)
    throw new RangeError("'offset' is out of bounds");
  if (e.byteLength < t + (s || 0))
    throw new RangeError("'length' is out of bounds");
  return t === void 0 && s === void 0 ? e = new Uint8Array(e) : s === void 0 ? e = new Uint8Array(e, t) : e = new Uint8Array(e, t, s), H.TYPED_ARRAY_SUPPORT ? (r = e, r.__proto__ = H.prototype) : r = Jp(r, e), r;
}
function Z4(r, e) {
  if (ss(e)) {
    var t = l0(e.length) | 0;
    return r = bs(r, t), r.length === 0 || e.copy(r, 0, 0, t), r;
  }
  if (e) {
    if (typeof ArrayBuffer < "u" && e.buffer instanceof ArrayBuffer || "length" in e)
      return typeof e.length != "number" || b8(e.length) ? bs(r, 0) : Jp(r, e);
    if (e.type === "Buffer" && L2(e.data))
      return Jp(r, e.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function l0(r) {
  if (r >= Il())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Il().toString(16) + " bytes");
  return r | 0;
}
H.isBuffer = v8;
function ss(r) {
  return !!(r != null && r._isBuffer);
}
H.compare = function(e, t) {
  if (!ss(e) || !ss(t))
    throw new TypeError("Arguments must be Buffers");
  if (e === t) return 0;
  for (var s = e.length, i = t.length, n = 0, a = Math.min(s, i); n < a; ++n)
    if (e[n] !== t[n]) {
      s = e[n], i = t[n];
      break;
    }
  return s < i ? -1 : i < s ? 1 : 0;
};
H.isEncoding = function(e) {
  switch (String(e).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
};
H.concat = function(e, t) {
  if (!L2(e))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (e.length === 0)
    return H.alloc(0);
  var s;
  if (t === void 0)
    for (t = 0, s = 0; s < e.length; ++s)
      t += e[s].length;
  var i = H.allocUnsafe(t), n = 0;
  for (s = 0; s < e.length; ++s) {
    var a = e[s];
    if (!ss(a))
      throw new TypeError('"list" argument must be an Array of Buffers');
    a.copy(i, n), n += a.length;
  }
  return i;
};
function $2(r, e) {
  if (ss(r))
    return r.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(r) || r instanceof ArrayBuffer))
    return r.byteLength;
  typeof r != "string" && (r = "" + r);
  var t = r.length;
  if (t === 0) return 0;
  for (var s = !1; ; )
    switch (e) {
      case "ascii":
      case "latin1":
      case "binary":
        return t;
      case "utf8":
      case "utf-8":
      case void 0:
        return kl(r).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return t * 2;
      case "hex":
        return t >>> 1;
      case "base64":
        return H2(r).length;
      default:
        if (s) return kl(r).length;
        e = ("" + e).toLowerCase(), s = !0;
    }
}
H.byteLength = $2;
function e8(r, e, t) {
  var s = !1;
  if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e))
    return "";
  for (r || (r = "utf8"); ; )
    switch (r) {
      case "hex":
        return c8(this, e, t);
      case "utf8":
      case "utf-8":
        return V2(this, e, t);
      case "ascii":
        return u8(this, e, t);
      case "latin1":
      case "binary":
        return l8(this, e, t);
      case "base64":
        return a8(this, e, t);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return f8(this, e, t);
      default:
        if (s) throw new TypeError("Unknown encoding: " + r);
        r = (r + "").toLowerCase(), s = !0;
    }
}
H.prototype._isBuffer = !0;
function Ai(r, e, t) {
  var s = r[e];
  r[e] = r[t], r[t] = s;
}
H.prototype.swap16 = function() {
  var e = this.length;
  if (e % 2 !== 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t = 0; t < e; t += 2)
    Ai(this, t, t + 1);
  return this;
};
H.prototype.swap32 = function() {
  var e = this.length;
  if (e % 4 !== 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t = 0; t < e; t += 4)
    Ai(this, t, t + 3), Ai(this, t + 1, t + 2);
  return this;
};
H.prototype.swap64 = function() {
  var e = this.length;
  if (e % 8 !== 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t = 0; t < e; t += 8)
    Ai(this, t, t + 7), Ai(this, t + 1, t + 6), Ai(this, t + 2, t + 5), Ai(this, t + 3, t + 4);
  return this;
};
H.prototype.toString = function() {
  var e = this.length | 0;
  return e === 0 ? "" : arguments.length === 0 ? V2(this, 0, e) : e8.apply(this, arguments);
};
H.prototype.equals = function(e) {
  if (!ss(e)) throw new TypeError("Argument must be a Buffer");
  return this === e ? !0 : H.compare(this, e) === 0;
};
H.prototype.inspect = function() {
  var e = "", t = X4;
  return this.length > 0 && (e = this.toString("hex", 0, t).match(/.{2}/g).join(" "), this.length > t && (e += " ... ")), "<Buffer " + e + ">";
};
H.prototype.compare = function(e, t, s, i, n) {
  if (!ss(e))
    throw new TypeError("Argument must be a Buffer");
  if (t === void 0 && (t = 0), s === void 0 && (s = e ? e.length : 0), i === void 0 && (i = 0), n === void 0 && (n = this.length), t < 0 || s > e.length || i < 0 || n > this.length)
    throw new RangeError("out of range index");
  if (i >= n && t >= s)
    return 0;
  if (i >= n)
    return -1;
  if (t >= s)
    return 1;
  if (t >>>= 0, s >>>= 0, i >>>= 0, n >>>= 0, this === e) return 0;
  for (var a = n - i, o = s - t, u = Math.min(a, o), l = this.slice(i, n), c = e.slice(t, s), f = 0; f < u; ++f)
    if (l[f] !== c[f]) {
      a = l[f], o = c[f];
      break;
    }
  return a < o ? -1 : o < a ? 1 : 0;
};
function F2(r, e, t, s, i) {
  if (r.length === 0) return -1;
  if (typeof t == "string" ? (s = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, isNaN(t) && (t = i ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
    if (i) return -1;
    t = r.length - 1;
  } else if (t < 0)
    if (i) t = 0;
    else return -1;
  if (typeof e == "string" && (e = H.from(e, s)), ss(e))
    return e.length === 0 ? -1 : Zy(r, e, t, s, i);
  if (typeof e == "number")
    return e = e & 255, H.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : Zy(r, [e], t, s, i);
  throw new TypeError("val must be string, number or Buffer");
}
function Zy(r, e, t, s, i) {
  var n = 1, a = r.length, o = e.length;
  if (s !== void 0 && (s = String(s).toLowerCase(), s === "ucs2" || s === "ucs-2" || s === "utf16le" || s === "utf-16le")) {
    if (r.length < 2 || e.length < 2)
      return -1;
    n = 2, a /= 2, o /= 2, t /= 2;
  }
  function u(h, m) {
    return n === 1 ? h[m] : h.readUInt16BE(m * n);
  }
  var l;
  if (i) {
    var c = -1;
    for (l = t; l < a; l++)
      if (u(r, l) === u(e, c === -1 ? 0 : l - c)) {
        if (c === -1 && (c = l), l - c + 1 === o) return c * n;
      } else
        c !== -1 && (l -= l - c), c = -1;
  } else
    for (t + o > a && (t = a - o), l = t; l >= 0; l--) {
      for (var f = !0, p = 0; p < o; p++)
        if (u(r, l + p) !== u(e, p)) {
          f = !1;
          break;
        }
      if (f) return l;
    }
  return -1;
}
H.prototype.includes = function(e, t, s) {
  return this.indexOf(e, t, s) !== -1;
};
H.prototype.indexOf = function(e, t, s) {
  return F2(this, e, t, s, !0);
};
H.prototype.lastIndexOf = function(e, t, s) {
  return F2(this, e, t, s, !1);
};
function t8(r, e, t, s) {
  t = Number(t) || 0;
  var i = r.length - t;
  s ? (s = Number(s), s > i && (s = i)) : s = i;
  var n = e.length;
  if (n % 2 !== 0) throw new TypeError("Invalid hex string");
  s > n / 2 && (s = n / 2);
  for (var a = 0; a < s; ++a) {
    var o = parseInt(e.substr(a * 2, 2), 16);
    if (isNaN(o)) return a;
    r[t + a] = o;
  }
  return a;
}
function r8(r, e, t, s) {
  return Yc(kl(e, r.length - t), r, t, s);
}
function B2(r, e, t, s) {
  return Yc(g8(e), r, t, s);
}
function s8(r, e, t, s) {
  return B2(r, e, t, s);
}
function i8(r, e, t, s) {
  return Yc(H2(e), r, t, s);
}
function n8(r, e, t, s) {
  return Yc(y8(e, r.length - t), r, t, s);
}
H.prototype.write = function(e, t, s, i) {
  if (t === void 0)
    i = "utf8", s = this.length, t = 0;
  else if (s === void 0 && typeof t == "string")
    i = t, s = this.length, t = 0;
  else if (isFinite(t))
    t = t | 0, isFinite(s) ? (s = s | 0, i === void 0 && (i = "utf8")) : (i = s, s = void 0);
  else
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  var n = this.length - t;
  if ((s === void 0 || s > n) && (s = n), e.length > 0 && (s < 0 || t < 0) || t > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  i || (i = "utf8");
  for (var a = !1; ; )
    switch (i) {
      case "hex":
        return t8(this, e, t, s);
      case "utf8":
      case "utf-8":
        return r8(this, e, t, s);
      case "ascii":
        return B2(this, e, t, s);
      case "latin1":
      case "binary":
        return s8(this, e, t, s);
      case "base64":
        return i8(this, e, t, s);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return n8(this, e, t, s);
      default:
        if (a) throw new TypeError("Unknown encoding: " + i);
        i = ("" + i).toLowerCase(), a = !0;
    }
};
H.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function a8(r, e, t) {
  return e === 0 && t === r.length ? Qy(r) : Qy(r.slice(e, t));
}
function V2(r, e, t) {
  t = Math.min(r.length, t);
  for (var s = [], i = e; i < t; ) {
    var n = r[i], a = null, o = n > 239 ? 4 : n > 223 ? 3 : n > 191 ? 2 : 1;
    if (i + o <= t) {
      var u, l, c, f;
      switch (o) {
        case 1:
          n < 128 && (a = n);
          break;
        case 2:
          u = r[i + 1], (u & 192) === 128 && (f = (n & 31) << 6 | u & 63, f > 127 && (a = f));
          break;
        case 3:
          u = r[i + 1], l = r[i + 2], (u & 192) === 128 && (l & 192) === 128 && (f = (n & 15) << 12 | (u & 63) << 6 | l & 63, f > 2047 && (f < 55296 || f > 57343) && (a = f));
          break;
        case 4:
          u = r[i + 1], l = r[i + 2], c = r[i + 3], (u & 192) === 128 && (l & 192) === 128 && (c & 192) === 128 && (f = (n & 15) << 18 | (u & 63) << 12 | (l & 63) << 6 | c & 63, f > 65535 && f < 1114112 && (a = f));
      }
    }
    a === null ? (a = 65533, o = 1) : a > 65535 && (a -= 65536, s.push(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), s.push(a), i += o;
  }
  return o8(s);
}
var e1 = 4096;
function o8(r) {
  var e = r.length;
  if (e <= e1)
    return String.fromCharCode.apply(String, r);
  for (var t = "", s = 0; s < e; )
    t += String.fromCharCode.apply(
      String,
      r.slice(s, s += e1)
    );
  return t;
}
function u8(r, e, t) {
  var s = "";
  t = Math.min(r.length, t);
  for (var i = e; i < t; ++i)
    s += String.fromCharCode(r[i] & 127);
  return s;
}
function l8(r, e, t) {
  var s = "";
  t = Math.min(r.length, t);
  for (var i = e; i < t; ++i)
    s += String.fromCharCode(r[i]);
  return s;
}
function c8(r, e, t) {
  var s = r.length;
  (!e || e < 0) && (e = 0), (!t || t < 0 || t > s) && (t = s);
  for (var i = "", n = e; n < t; ++n)
    i += m8(r[n]);
  return i;
}
function f8(r, e, t) {
  for (var s = r.slice(e, t), i = "", n = 0; n < s.length; n += 2)
    i += String.fromCharCode(s[n] + s[n + 1] * 256);
  return i;
}
H.prototype.slice = function(e, t) {
  var s = this.length;
  e = ~~e, t = t === void 0 ? s : ~~t, e < 0 ? (e += s, e < 0 && (e = 0)) : e > s && (e = s), t < 0 ? (t += s, t < 0 && (t = 0)) : t > s && (t = s), t < e && (t = e);
  var i;
  if (H.TYPED_ARRAY_SUPPORT)
    i = this.subarray(e, t), i.__proto__ = H.prototype;
  else {
    var n = t - e;
    i = new H(n, void 0);
    for (var a = 0; a < n; ++a)
      i[a] = this[a + e];
  }
  return i;
};
function St(r, e, t) {
  if (r % 1 !== 0 || r < 0) throw new RangeError("offset is not uint");
  if (r + e > t) throw new RangeError("Trying to access beyond buffer length");
}
H.prototype.readUIntLE = function(e, t, s) {
  e = e | 0, t = t | 0, s || St(e, t, this.length);
  for (var i = this[e], n = 1, a = 0; ++a < t && (n *= 256); )
    i += this[e + a] * n;
  return i;
};
H.prototype.readUIntBE = function(e, t, s) {
  e = e | 0, t = t | 0, s || St(e, t, this.length);
  for (var i = this[e + --t], n = 1; t > 0 && (n *= 256); )
    i += this[e + --t] * n;
  return i;
};
H.prototype.readUInt8 = function(e, t) {
  return t || St(e, 1, this.length), this[e];
};
H.prototype.readUInt16LE = function(e, t) {
  return t || St(e, 2, this.length), this[e] | this[e + 1] << 8;
};
H.prototype.readUInt16BE = function(e, t) {
  return t || St(e, 2, this.length), this[e] << 8 | this[e + 1];
};
H.prototype.readUInt32LE = function(e, t) {
  return t || St(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
};
H.prototype.readUInt32BE = function(e, t) {
  return t || St(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
};
H.prototype.readIntLE = function(e, t, s) {
  e = e | 0, t = t | 0, s || St(e, t, this.length);
  for (var i = this[e], n = 1, a = 0; ++a < t && (n *= 256); )
    i += this[e + a] * n;
  return n *= 128, i >= n && (i -= Math.pow(2, 8 * t)), i;
};
H.prototype.readIntBE = function(e, t, s) {
  e = e | 0, t = t | 0, s || St(e, t, this.length);
  for (var i = t, n = 1, a = this[e + --i]; i > 0 && (n *= 256); )
    a += this[e + --i] * n;
  return n *= 128, a >= n && (a -= Math.pow(2, 8 * t)), a;
};
H.prototype.readInt8 = function(e, t) {
  return t || St(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
};
H.prototype.readInt16LE = function(e, t) {
  t || St(e, 2, this.length);
  var s = this[e] | this[e + 1] << 8;
  return s & 32768 ? s | 4294901760 : s;
};
H.prototype.readInt16BE = function(e, t) {
  t || St(e, 2, this.length);
  var s = this[e + 1] | this[e] << 8;
  return s & 32768 ? s | 4294901760 : s;
};
H.prototype.readInt32LE = function(e, t) {
  return t || St(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
};
H.prototype.readInt32BE = function(e, t) {
  return t || St(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
};
H.prototype.readFloatLE = function(e, t) {
  return t || St(e, 4, this.length), Kc(this, e, !0, 23, 4);
};
H.prototype.readFloatBE = function(e, t) {
  return t || St(e, 4, this.length), Kc(this, e, !1, 23, 4);
};
H.prototype.readDoubleLE = function(e, t) {
  return t || St(e, 8, this.length), Kc(this, e, !0, 52, 8);
};
H.prototype.readDoubleBE = function(e, t) {
  return t || St(e, 8, this.length), Kc(this, e, !1, 52, 8);
};
function tr(r, e, t, s, i, n) {
  if (!ss(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (e > i || e < n) throw new RangeError('"value" argument is out of bounds');
  if (t + s > r.length) throw new RangeError("Index out of range");
}
H.prototype.writeUIntLE = function(e, t, s, i) {
  if (e = +e, t = t | 0, s = s | 0, !i) {
    var n = Math.pow(2, 8 * s) - 1;
    tr(this, e, t, s, n, 0);
  }
  var a = 1, o = 0;
  for (this[t] = e & 255; ++o < s && (a *= 256); )
    this[t + o] = e / a & 255;
  return t + s;
};
H.prototype.writeUIntBE = function(e, t, s, i) {
  if (e = +e, t = t | 0, s = s | 0, !i) {
    var n = Math.pow(2, 8 * s) - 1;
    tr(this, e, t, s, n, 0);
  }
  var a = s - 1, o = 1;
  for (this[t + a] = e & 255; --a >= 0 && (o *= 256); )
    this[t + a] = e / o & 255;
  return t + s;
};
H.prototype.writeUInt8 = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 1, 255, 0), H.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = e & 255, t + 1;
};
function Xc(r, e, t, s) {
  e < 0 && (e = 65535 + e + 1);
  for (var i = 0, n = Math.min(r.length - t, 2); i < n; ++i)
    r[t + i] = (e & 255 << 8 * (s ? i : 1 - i)) >>> (s ? i : 1 - i) * 8;
}
H.prototype.writeUInt16LE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 2, 65535, 0), H.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8) : Xc(this, e, t, !0), t + 2;
};
H.prototype.writeUInt16BE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 2, 65535, 0), H.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = e & 255) : Xc(this, e, t, !1), t + 2;
};
function Jc(r, e, t, s) {
  e < 0 && (e = 4294967295 + e + 1);
  for (var i = 0, n = Math.min(r.length - t, 4); i < n; ++i)
    r[t + i] = e >>> (s ? i : 3 - i) * 8 & 255;
}
H.prototype.writeUInt32LE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 4, 4294967295, 0), H.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255) : Jc(this, e, t, !0), t + 4;
};
H.prototype.writeUInt32BE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 4, 4294967295, 0), H.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255) : Jc(this, e, t, !1), t + 4;
};
H.prototype.writeIntLE = function(e, t, s, i) {
  if (e = +e, t = t | 0, !i) {
    var n = Math.pow(2, 8 * s - 1);
    tr(this, e, t, s, n - 1, -n);
  }
  var a = 0, o = 1, u = 0;
  for (this[t] = e & 255; ++a < s && (o *= 256); )
    e < 0 && u === 0 && this[t + a - 1] !== 0 && (u = 1), this[t + a] = (e / o >> 0) - u & 255;
  return t + s;
};
H.prototype.writeIntBE = function(e, t, s, i) {
  if (e = +e, t = t | 0, !i) {
    var n = Math.pow(2, 8 * s - 1);
    tr(this, e, t, s, n - 1, -n);
  }
  var a = s - 1, o = 1, u = 0;
  for (this[t + a] = e & 255; --a >= 0 && (o *= 256); )
    e < 0 && u === 0 && this[t + a + 1] !== 0 && (u = 1), this[t + a] = (e / o >> 0) - u & 255;
  return t + s;
};
H.prototype.writeInt8 = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 1, 127, -128), H.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1;
};
H.prototype.writeInt16LE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 2, 32767, -32768), H.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8) : Xc(this, e, t, !0), t + 2;
};
H.prototype.writeInt16BE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 2, 32767, -32768), H.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = e & 255) : Xc(this, e, t, !1), t + 2;
};
H.prototype.writeInt32LE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 4, 2147483647, -2147483648), H.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : Jc(this, e, t, !0), t + 4;
};
H.prototype.writeInt32BE = function(e, t, s) {
  return e = +e, t = t | 0, s || tr(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), H.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255) : Jc(this, e, t, !1), t + 4;
};
function U2(r, e, t, s, i, n) {
  if (t + s > r.length) throw new RangeError("Index out of range");
  if (t < 0) throw new RangeError("Index out of range");
}
function j2(r, e, t, s, i) {
  return i || U2(r, e, t, 4), D2(r, e, t, s, 23, 4), t + 4;
}
H.prototype.writeFloatLE = function(e, t, s) {
  return j2(this, e, t, !0, s);
};
H.prototype.writeFloatBE = function(e, t, s) {
  return j2(this, e, t, !1, s);
};
function q2(r, e, t, s, i) {
  return i || U2(r, e, t, 8), D2(r, e, t, s, 52, 8), t + 8;
}
H.prototype.writeDoubleLE = function(e, t, s) {
  return q2(this, e, t, !0, s);
};
H.prototype.writeDoubleBE = function(e, t, s) {
  return q2(this, e, t, !1, s);
};
H.prototype.copy = function(e, t, s, i) {
  if (s || (s = 0), !i && i !== 0 && (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < s && (i = s), i === s || e.length === 0 || this.length === 0) return 0;
  if (t < 0)
    throw new RangeError("targetStart out of bounds");
  if (s < 0 || s >= this.length) throw new RangeError("sourceStart out of bounds");
  if (i < 0) throw new RangeError("sourceEnd out of bounds");
  i > this.length && (i = this.length), e.length - t < i - s && (i = e.length - t + s);
  var n = i - s, a;
  if (this === e && s < t && t < i)
    for (a = n - 1; a >= 0; --a)
      e[a + t] = this[a + s];
  else if (n < 1e3 || !H.TYPED_ARRAY_SUPPORT)
    for (a = 0; a < n; ++a)
      e[a + t] = this[a + s];
  else
    Uint8Array.prototype.set.call(
      e,
      this.subarray(s, s + n),
      t
    );
  return n;
};
H.prototype.fill = function(e, t, s, i) {
  if (typeof e == "string") {
    if (typeof t == "string" ? (i = t, t = 0, s = this.length) : typeof s == "string" && (i = s, s = this.length), e.length === 1) {
      var n = e.charCodeAt(0);
      n < 256 && (e = n);
    }
    if (i !== void 0 && typeof i != "string")
      throw new TypeError("encoding must be a string");
    if (typeof i == "string" && !H.isEncoding(i))
      throw new TypeError("Unknown encoding: " + i);
  } else typeof e == "number" && (e = e & 255);
  if (t < 0 || this.length < t || this.length < s)
    throw new RangeError("Out of range index");
  if (s <= t)
    return this;
  t = t >>> 0, s = s === void 0 ? this.length : s >>> 0, e || (e = 0);
  var a;
  if (typeof e == "number")
    for (a = t; a < s; ++a)
      this[a] = e;
  else {
    var o = ss(e) ? e : kl(new H(e, i).toString()), u = o.length;
    for (a = 0; a < s - t; ++a)
      this[a + t] = o[a % u];
  }
  return this;
};
var p8 = /[^+\/0-9A-Za-z-_]/g;
function h8(r) {
  if (r = d8(r).replace(p8, ""), r.length < 2) return "";
  for (; r.length % 4 !== 0; )
    r = r + "=";
  return r;
}
function d8(r) {
  return r.trim ? r.trim() : r.replace(/^\s+|\s+$/g, "");
}
function m8(r) {
  return r < 16 ? "0" + r.toString(16) : r.toString(16);
}
function kl(r, e) {
  e = e || 1 / 0;
  for (var t, s = r.length, i = null, n = [], a = 0; a < s; ++a) {
    if (t = r.charCodeAt(a), t > 55295 && t < 57344) {
      if (!i) {
        if (t > 56319) {
          (e -= 3) > -1 && n.push(239, 191, 189);
          continue;
        } else if (a + 1 === s) {
          (e -= 3) > -1 && n.push(239, 191, 189);
          continue;
        }
        i = t;
        continue;
      }
      if (t < 56320) {
        (e -= 3) > -1 && n.push(239, 191, 189), i = t;
        continue;
      }
      t = (i - 55296 << 10 | t - 56320) + 65536;
    } else i && (e -= 3) > -1 && n.push(239, 191, 189);
    if (i = null, t < 128) {
      if ((e -= 1) < 0) break;
      n.push(t);
    } else if (t < 2048) {
      if ((e -= 2) < 0) break;
      n.push(
        t >> 6 | 192,
        t & 63 | 128
      );
    } else if (t < 65536) {
      if ((e -= 3) < 0) break;
      n.push(
        t >> 12 | 224,
        t >> 6 & 63 | 128,
        t & 63 | 128
      );
    } else if (t < 1114112) {
      if ((e -= 4) < 0) break;
      n.push(
        t >> 18 | 240,
        t >> 12 & 63 | 128,
        t >> 6 & 63 | 128,
        t & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return n;
}
function g8(r) {
  for (var e = [], t = 0; t < r.length; ++t)
    e.push(r.charCodeAt(t) & 255);
  return e;
}
function y8(r, e) {
  for (var t, s, i, n = [], a = 0; a < r.length && !((e -= 2) < 0); ++a)
    t = r.charCodeAt(a), s = t >> 8, i = t % 256, n.push(i), n.push(s);
  return n;
}
function H2(r) {
  return W4(h8(r));
}
function Yc(r, e, t, s) {
  for (var i = 0; i < s && !(i + t >= e.length || i >= r.length); ++i)
    e[i + t] = r[i];
  return i;
}
function b8(r) {
  return r !== r;
}
function v8(r) {
  return r != null && (!!r._isBuffer || W2(r) || E8(r));
}
function W2(r) {
  return !!r.constructor && typeof r.constructor.isBuffer == "function" && r.constructor.isBuffer(r);
}
function E8(r) {
  return typeof r.readFloatLE == "function" && typeof r.slice == "function" && W2(r.slice(0, 0));
}
var Dl;
typeof Object.create == "function" ? Dl = function(e, t) {
  e.super_ = t, e.prototype = Object.create(t.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  });
} : Dl = function(e, t) {
  e.super_ = t;
  var s = function() {
  };
  s.prototype = t.prototype, e.prototype = new s(), e.prototype.constructor = e;
};
var z2 = Object.getOwnPropertyDescriptors || function(e) {
  for (var t = Object.keys(e), s = {}, i = 0; i < t.length; i++)
    s[t[i]] = Object.getOwnPropertyDescriptor(e, t[i]);
  return s;
}, S8 = /%[sdj%]/g;
function Qc(r) {
  if (!hi(r)) {
    for (var e = [], t = 0; t < arguments.length; t++)
      e.push(Yr(arguments[t]));
    return e.join(" ");
  }
  for (var t = 1, s = arguments, i = s.length, n = String(r).replace(S8, function(o) {
    if (o === "%%") return "%";
    if (t >= i) return o;
    switch (o) {
      case "%s":
        return String(s[t++]);
      case "%d":
        return Number(s[t++]);
      case "%j":
        try {
          return JSON.stringify(s[t++]);
        } catch {
          return "[Circular]";
        }
      default:
        return o;
    }
  }), a = s[t]; t < i; a = s[++t])
    vs(a) || !Ds(a) ? n += " " + a : n += " " + Yr(a);
  return n;
}
function c0(r, e) {
  if (qr(li.process))
    return function() {
      return c0(r, e).apply(this, arguments);
    };
  if (Zt.noDeprecation === !0)
    return r;
  var t = !1;
  function s() {
    if (!t) {
      if (Zt.throwDeprecation)
        throw new Error(e);
      Zt.traceDeprecation ? console.trace(e) : console.error(e), t = !0;
    }
    return r.apply(this, arguments);
  }
  return s;
}
var du = {}, jf;
function G2(r) {
  if (qr(jf) && (jf = Zt.env.NODE_DEBUG || ""), r = r.toUpperCase(), !du[r])
    if (new RegExp("\\b" + r + "\\b", "i").test(jf)) {
      var e = 0;
      du[r] = function() {
        var t = Qc.apply(null, arguments);
        console.error("%s %d: %s", r, e, t);
      };
    } else
      du[r] = function() {
      };
  return du[r];
}
function Yr(r, e) {
  var t = {
    seen: [],
    stylize: x8
  };
  return arguments.length >= 3 && (t.depth = arguments[2]), arguments.length >= 4 && (t.colors = arguments[3]), Zc(e) ? t.showHidden = e : e && m0(t, e), qr(t.showHidden) && (t.showHidden = !1), qr(t.depth) && (t.depth = 2), qr(t.colors) && (t.colors = !1), qr(t.customInspect) && (t.customInspect = !0), t.colors && (t.stylize = _8), Ll(t, r, t.depth);
}
Yr.colors = {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
};
Yr.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  // "name": intentionally not styling
  regexp: "red"
};
function _8(r, e) {
  var t = Yr.styles[e];
  return t ? "\x1B[" + Yr.colors[t][0] + "m" + r + "\x1B[" + Yr.colors[t][1] + "m" : r;
}
function x8(r, e) {
  return r;
}
function w8(r) {
  var e = {};
  return r.forEach(function(t, s) {
    e[t] = !0;
  }), e;
}
function Ll(r, e, t) {
  if (r.customInspect && e && Ja(e.inspect) && // Filter out the util module, it's inspect function is special
  e.inspect !== Yr && // Also filter out any prototype objects using the circular check.
  !(e.constructor && e.constructor.prototype === e)) {
    var s = e.inspect(t, r);
    return hi(s) || (s = Ll(r, s, t)), s;
  }
  var i = T8(r, e);
  if (i)
    return i;
  var n = Object.keys(e), a = w8(n);
  if (r.showHidden && (n = Object.getOwnPropertyNames(e)), Xa(e) && (n.indexOf("message") >= 0 || n.indexOf("description") >= 0))
    return qf(e);
  if (n.length === 0) {
    if (Ja(e)) {
      var o = e.name ? ": " + e.name : "";
      return r.stylize("[Function" + o + "]", "special");
    }
    if (Ka(e))
      return r.stylize(RegExp.prototype.toString.call(e), "regexp");
    if (Ml(e))
      return r.stylize(Date.prototype.toString.call(e), "date");
    if (Xa(e))
      return qf(e);
  }
  var u = "", l = !1, c = ["{", "}"];
  if (f0(e) && (l = !0, c = ["[", "]"]), Ja(e)) {
    var f = e.name ? ": " + e.name : "";
    u = " [Function" + f + "]";
  }
  if (Ka(e) && (u = " " + RegExp.prototype.toString.call(e)), Ml(e) && (u = " " + Date.prototype.toUTCString.call(e)), Xa(e) && (u = " " + qf(e)), n.length === 0 && (!l || e.length == 0))
    return c[0] + u + c[1];
  if (t < 0)
    return Ka(e) ? r.stylize(RegExp.prototype.toString.call(e), "regexp") : r.stylize("[Object]", "special");
  r.seen.push(e);
  var p;
  return l ? p = P8(r, e, t, a, n) : p = n.map(function(h) {
    return Yp(r, e, t, a, h, l);
  }), r.seen.pop(), A8(p, u, c);
}
function T8(r, e) {
  if (qr(e))
    return r.stylize("undefined", "undefined");
  if (hi(e)) {
    var t = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return r.stylize(t, "string");
  }
  if (h0(e))
    return r.stylize("" + e, "number");
  if (Zc(e))
    return r.stylize("" + e, "boolean");
  if (vs(e))
    return r.stylize("null", "null");
}
function qf(r) {
  return "[" + Error.prototype.toString.call(r) + "]";
}
function P8(r, e, t, s, i) {
  for (var n = [], a = 0, o = e.length; a < o; ++a)
    Q2(e, String(a)) ? n.push(Yp(
      r,
      e,
      t,
      s,
      String(a),
      !0
    )) : n.push("");
  return i.forEach(function(u) {
    u.match(/^\d+$/) || n.push(Yp(
      r,
      e,
      t,
      s,
      u,
      !0
    ));
  }), n;
}
function Yp(r, e, t, s, i, n) {
  var a, o, u;
  if (u = Object.getOwnPropertyDescriptor(e, i) || { value: e[i] }, u.get ? u.set ? o = r.stylize("[Getter/Setter]", "special") : o = r.stylize("[Getter]", "special") : u.set && (o = r.stylize("[Setter]", "special")), Q2(s, i) || (a = "[" + i + "]"), o || (r.seen.indexOf(u.value) < 0 ? (vs(t) ? o = Ll(r, u.value, null) : o = Ll(r, u.value, t - 1), o.indexOf(`
`) > -1 && (n ? o = o.split(`
`).map(function(l) {
    return "  " + l;
  }).join(`
`).substr(2) : o = `
` + o.split(`
`).map(function(l) {
    return "   " + l;
  }).join(`
`))) : o = r.stylize("[Circular]", "special")), qr(a)) {
    if (n && i.match(/^\d+$/))
      return o;
    a = JSON.stringify("" + i), a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a = a.substr(1, a.length - 2), a = r.stylize(a, "name")) : (a = a.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a = r.stylize(a, "string"));
  }
  return a + ": " + o;
}
function A8(r, e, t) {
  var s = r.reduce(function(i, n) {
    return n.indexOf(`
`) >= 0, i + n.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  return s > 60 ? t[0] + (e === "" ? "" : e + `
 `) + " " + r.join(`,
  `) + " " + t[1] : t[0] + e + " " + r.join(", ") + " " + t[1];
}
function f0(r) {
  return Array.isArray(r);
}
function Zc(r) {
  return typeof r == "boolean";
}
function vs(r) {
  return r === null;
}
function p0(r) {
  return r == null;
}
function h0(r) {
  return typeof r == "number";
}
function hi(r) {
  return typeof r == "string";
}
function K2(r) {
  return typeof r == "symbol";
}
function qr(r) {
  return r === void 0;
}
function Ka(r) {
  return Ds(r) && d0(r) === "[object RegExp]";
}
function Ds(r) {
  return typeof r == "object" && r !== null;
}
function Ml(r) {
  return Ds(r) && d0(r) === "[object Date]";
}
function Xa(r) {
  return Ds(r) && (d0(r) === "[object Error]" || r instanceof Error);
}
function Ja(r) {
  return typeof r == "function";
}
function X2(r) {
  return r === null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || typeof r == "symbol" || // ES6 symbol
  typeof r > "u";
}
function J2(r) {
  return H.isBuffer(r);
}
function d0(r) {
  return Object.prototype.toString.call(r);
}
function Hf(r) {
  return r < 10 ? "0" + r.toString(10) : r.toString(10);
}
var C8 = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function N8() {
  var r = /* @__PURE__ */ new Date(), e = [
    Hf(r.getHours()),
    Hf(r.getMinutes()),
    Hf(r.getSeconds())
  ].join(":");
  return [r.getDate(), C8[r.getMonth()], e].join(" ");
}
function Y2() {
  console.log("%s - %s", N8(), Qc.apply(null, arguments));
}
function m0(r, e) {
  if (!e || !Ds(e)) return r;
  for (var t = Object.keys(e), s = t.length; s--; )
    r[t[s]] = e[t[s]];
  return r;
}
function Q2(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
var _i = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
function g0(r) {
  if (typeof r != "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (_i && r[_i]) {
    var e = r[_i];
    if (typeof e != "function")
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(e, _i, {
      value: e,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), e;
  }
  function e() {
    for (var t, s, i = new Promise(function(o, u) {
      t = o, s = u;
    }), n = [], a = 0; a < arguments.length; a++)
      n.push(arguments[a]);
    n.push(function(o, u) {
      o ? s(o) : t(u);
    });
    try {
      r.apply(this, n);
    } catch (o) {
      s(o);
    }
    return i;
  }
  return Object.setPrototypeOf(e, Object.getPrototypeOf(r)), _i && Object.defineProperty(e, _i, {
    value: e,
    enumerable: !1,
    writable: !1,
    configurable: !0
  }), Object.defineProperties(
    e,
    z2(r)
  );
}
g0.custom = _i;
function O8(r, e) {
  if (!r) {
    var t = new Error("Promise was rejected with a falsy value");
    t.reason = r, r = t;
  }
  return e(r);
}
function Z2(r) {
  if (typeof r != "function")
    throw new TypeError('The "original" argument must be of type Function');
  function e() {
    for (var t = [], s = 0; s < arguments.length; s++)
      t.push(arguments[s]);
    var i = t.pop();
    if (typeof i != "function")
      throw new TypeError("The last argument must be of type Function");
    var n = this, a = function() {
      return i.apply(n, arguments);
    };
    r.apply(this, t).then(
      function(o) {
        Zt.nextTick(a.bind(null, null, o));
      },
      function(o) {
        Zt.nextTick(O8.bind(null, o, a));
      }
    );
  }
  return Object.setPrototypeOf(e, Object.getPrototypeOf(r)), Object.defineProperties(e, z2(r)), e;
}
var I8 = {
  inherits: Dl,
  _extend: m0,
  log: Y2,
  isBuffer: J2,
  isPrimitive: X2,
  isFunction: Ja,
  isError: Xa,
  isDate: Ml,
  isObject: Ds,
  isRegExp: Ka,
  isUndefined: qr,
  isSymbol: K2,
  isString: hi,
  isNumber: h0,
  isNullOrUndefined: p0,
  isNull: vs,
  isBoolean: Zc,
  isArray: f0,
  inspect: Yr,
  deprecate: c0,
  format: Qc,
  debuglog: G2,
  promisify: g0,
  callbackify: Z2
}, k8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _extend: m0,
  callbackify: Z2,
  debuglog: G2,
  default: I8,
  deprecate: c0,
  format: Qc,
  inherits: Dl,
  inspect: Yr,
  isArray: f0,
  isBoolean: Zc,
  isBuffer: J2,
  isDate: Ml,
  isError: Xa,
  isFunction: Ja,
  isNull: vs,
  isNullOrUndefined: p0,
  isNumber: h0,
  isObject: Ds,
  isPrimitive: X2,
  isRegExp: Ka,
  isString: hi,
  isSymbol: K2,
  isUndefined: qr,
  log: Y2,
  promisify: g0
});
function D8(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
var e_ = Array.isArray || function(r) {
  return Object.prototype.toString.call(r) === "[object Array]";
};
function Wf(r) {
  switch (typeof r) {
    case "string":
      return r;
    case "boolean":
      return r ? "true" : "false";
    case "number":
      return isFinite(r) ? r : "";
    default:
      return "";
  }
}
function L8(r, e, t, s) {
  return e = e || "&", t = t || "=", r === null && (r = void 0), typeof r == "object" ? t1(M8(r), function(i) {
    var n = encodeURIComponent(Wf(i)) + t;
    return e_(r[i]) ? t1(r[i], function(a) {
      return n + encodeURIComponent(Wf(a));
    }).join(e) : n + encodeURIComponent(Wf(r[i]));
  }).join(e) : "";
}
function t1(r, e) {
  if (r.map) return r.map(e);
  for (var t = [], s = 0; s < r.length; s++)
    t.push(e(r[s], s));
  return t;
}
var M8 = Object.keys || function(r) {
  var e = [];
  for (var t in r)
    Object.prototype.hasOwnProperty.call(r, t) && e.push(t);
  return e;
};
function r1(r, e, t, s) {
  e = e || "&", t = t || "=";
  var i = {};
  if (typeof r != "string" || r.length === 0)
    return i;
  var n = /\+/g;
  r = r.split(e);
  var a = 1e3, o = r.length;
  o > a && (o = a);
  for (var u = 0; u < o; ++u) {
    var l = r[u].replace(n, "%20"), c = l.indexOf(t), f, p, h, m;
    c >= 0 ? (f = l.substr(0, c), p = l.substr(c + 1)) : (f = l, p = ""), h = decodeURIComponent(f), m = decodeURIComponent(p), D8(i, h) ? e_(i[h]) ? i[h].push(m) : i[h] = [i[h], m] : i[h] = m;
  }
  return i;
}
const t_ = li.URL, r_ = li.URLSearchParams;
var R8 = {
  parse: na,
  resolve: a_,
  resolveObject: o_,
  fileURLToPath: i_,
  format: n_,
  Url: lr,
  // WHATWG API
  URL: t_,
  URLSearchParams: r_
};
function lr() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var $8 = /^([a-z0-9.+-]+:)/i, F8 = /:[0-9]*$/, B8 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, V8 = ["<", ">", '"', "`", " ", "\r", `
`, "	"], U8 = ["{", "}", "|", "\\", "^", "`"].concat(V8), Qp = ["'"].concat(U8), s1 = ["%", "/", "?", ";", "#"].concat(Qp), i1 = ["/", "?", "#"], j8 = 255, n1 = /^[+a-z0-9A-Z_-]{0,63}$/, q8 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, H8 = {
  javascript: !0,
  "javascript:": !0
}, Zp = {
  javascript: !0,
  "javascript:": !0
}, xn = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function na(r, e, t) {
  if (r && Ds(r) && r instanceof lr) return r;
  var s = new lr();
  return s.parse(r, e, t), s;
}
lr.prototype.parse = function(r, e, t) {
  return s_(this, r, e, t);
};
function s_(r, e, t, s) {
  if (!hi(e))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
  var i = e.indexOf("?"), n = i !== -1 && i < e.indexOf("#") ? "?" : "#", a = e.split(n), o = /\\/g;
  a[0] = a[0].replace(o, "/"), e = a.join(n);
  var u = e;
  if (u = u.trim(), !s && e.split("#").length === 1) {
    var l = B8.exec(u);
    if (l)
      return r.path = u, r.href = u, r.pathname = l[1], l[2] ? (r.search = l[2], t ? r.query = r1(r.search.substr(1)) : r.query = r.search.substr(1)) : t && (r.search = "", r.query = {}), r;
  }
  var c = $8.exec(u);
  if (c) {
    c = c[0];
    var f = c.toLowerCase();
    r.protocol = f, u = u.substr(c.length);
  }
  if (s || c || u.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var p = u.substr(0, 2) === "//";
    p && !(c && Zp[c]) && (u = u.substr(2), r.slashes = !0);
  }
  var h, m, d, y;
  if (!Zp[c] && (p || c && !xn[c])) {
    var S = -1;
    for (h = 0; h < i1.length; h++)
      m = u.indexOf(i1[h]), m !== -1 && (S === -1 || m < S) && (S = m);
    var E, g;
    for (S === -1 ? g = u.lastIndexOf("@") : g = u.lastIndexOf("@", S), g !== -1 && (E = u.slice(0, g), u = u.slice(g + 1), r.auth = decodeURIComponent(E)), S = -1, h = 0; h < s1.length; h++)
      m = u.indexOf(s1[h]), m !== -1 && (S === -1 || m < S) && (S = m);
    S === -1 && (S = u.length), r.host = u.slice(0, S), u = u.slice(S), u_(r), r.hostname = r.hostname || "";
    var b = r.hostname[0] === "[" && r.hostname[r.hostname.length - 1] === "]";
    if (!b) {
      var v = r.hostname.split(/\./);
      for (h = 0, d = v.length; h < d; h++) {
        var A = v[h];
        if (A && !A.match(n1)) {
          for (var C = "", x = 0, _ = A.length; x < _; x++)
            A.charCodeAt(x) > 127 ? C += "x" : C += A[x];
          if (!C.match(n1)) {
            var T = v.slice(0, h), P = v.slice(h + 1), I = A.match(q8);
            I && (T.push(I[1]), P.unshift(I[2])), P.length && (u = "/" + P.join(".") + u), r.hostname = T.join(".");
            break;
          }
        }
      }
    }
    r.hostname.length > j8 ? r.hostname = "" : r.hostname = r.hostname.toLowerCase(), b || (r.hostname = q4(r.hostname)), y = r.port ? ":" + r.port : "";
    var $ = r.hostname || "";
    r.host = $ + y, r.href += r.host, b && (r.hostname = r.hostname.substr(1, r.hostname.length - 2), u[0] !== "/" && (u = "/" + u));
  }
  if (!H8[f])
    for (h = 0, d = Qp.length; h < d; h++) {
      var Y = Qp[h];
      if (u.indexOf(Y) !== -1) {
        var W = encodeURIComponent(Y);
        W === Y && (W = escape(Y)), u = u.split(Y).join(W);
      }
    }
  var F = u.indexOf("#");
  F !== -1 && (r.hash = u.substr(F), u = u.slice(0, F));
  var K = u.indexOf("?");
  if (K !== -1 ? (r.search = u.substr(K), r.query = u.substr(K + 1), t && (r.query = r1(r.query)), u = u.slice(0, K)) : t && (r.search = "", r.query = {}), u && (r.pathname = u), xn[f] && r.hostname && !r.pathname && (r.pathname = "/"), r.pathname || r.search) {
    y = r.pathname || "";
    var Z = r.search || "";
    r.path = y + Z;
  }
  return r.href = y0(r), r;
}
function i_(r) {
  if (typeof r == "string")
    r = new lr().parse(r);
  else if (!(r instanceof lr))
    throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof r + String(r));
  if (r.protocol !== "file:")
    throw new TypeError("The URL must be of scheme file");
  return W8(r);
}
function W8(r) {
  const e = r.pathname;
  for (let t = 0; t < e.length; t++)
    if (e[t] === "%") {
      const s = e.codePointAt(t + 2) | 32;
      if (e[t + 1] === "2" && s === 102)
        throw new TypeError(
          "must not include encoded / characters"
        );
    }
  return decodeURIComponent(e);
}
function n_(r) {
  return hi(r) && (r = s_({}, r)), y0(r);
}
function y0(r) {
  var e = r.auth || "";
  e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
  var t = r.protocol || "", s = r.pathname || "", i = r.hash || "", n = !1, a = "";
  r.host ? n = e + r.host : r.hostname && (n = e + (r.hostname.indexOf(":") === -1 ? r.hostname : "[" + this.hostname + "]"), r.port && (n += ":" + r.port)), r.query && Ds(r.query) && Object.keys(r.query).length && (a = L8(r.query));
  var o = r.search || a && "?" + a || "";
  return t && t.substr(-1) !== ":" && (t += ":"), r.slashes || (!t || xn[t]) && n !== !1 ? (n = "//" + (n || ""), s && s.charAt(0) !== "/" && (s = "/" + s)) : n || (n = ""), i && i.charAt(0) !== "#" && (i = "#" + i), o && o.charAt(0) !== "?" && (o = "?" + o), s = s.replace(/[?#]/g, function(u) {
    return encodeURIComponent(u);
  }), o = o.replace("#", "%23"), t + n + s + o + i;
}
lr.prototype.format = function() {
  return y0(this);
};
function a_(r, e) {
  return na(r, !1, !0).resolve(e);
}
lr.prototype.resolve = function(r) {
  return this.resolveObject(na(r, !1, !0)).format();
};
function o_(r, e) {
  return r ? na(r, !1, !0).resolveObject(e) : e;
}
lr.prototype.resolveObject = function(r) {
  if (hi(r)) {
    var e = new lr();
    e.parse(r, !1, !0), r = e;
  }
  for (var t = new lr(), s = Object.keys(this), i = 0; i < s.length; i++) {
    var n = s[i];
    t[n] = this[n];
  }
  if (t.hash = r.hash, r.href === "")
    return t.href = t.format(), t;
  if (r.slashes && !r.protocol) {
    for (var a = Object.keys(r), o = 0; o < a.length; o++) {
      var u = a[o];
      u !== "protocol" && (t[u] = r[u]);
    }
    return xn[t.protocol] && t.hostname && !t.pathname && (t.path = t.pathname = "/"), t.href = t.format(), t;
  }
  var l;
  if (r.protocol && r.protocol !== t.protocol) {
    if (!xn[r.protocol]) {
      for (var c = Object.keys(r), f = 0; f < c.length; f++) {
        var p = c[f];
        t[p] = r[p];
      }
      return t.href = t.format(), t;
    }
    if (t.protocol = r.protocol, !r.host && !Zp[r.protocol]) {
      for (l = (r.pathname || "").split("/"); l.length && !(r.host = l.shift()); ) ;
      r.host || (r.host = ""), r.hostname || (r.hostname = ""), l[0] !== "" && l.unshift(""), l.length < 2 && l.unshift(""), t.pathname = l.join("/");
    } else
      t.pathname = r.pathname;
    if (t.search = r.search, t.query = r.query, t.host = r.host || "", t.auth = r.auth, t.hostname = r.hostname || r.host, t.port = r.port, t.pathname || t.search) {
      var h = t.pathname || "", m = t.search || "";
      t.path = h + m;
    }
    return t.slashes = t.slashes || r.slashes, t.href = t.format(), t;
  }
  var d = t.pathname && t.pathname.charAt(0) === "/", y = r.host || r.pathname && r.pathname.charAt(0) === "/", S = y || d || t.host && r.pathname, E = S, g = t.pathname && t.pathname.split("/") || [], b = t.protocol && !xn[t.protocol];
  l = r.pathname && r.pathname.split("/") || [], b && (t.hostname = "", t.port = null, t.host && (g[0] === "" ? g[0] = t.host : g.unshift(t.host)), t.host = "", r.protocol && (r.hostname = null, r.port = null, r.host && (l[0] === "" ? l[0] = r.host : l.unshift(r.host)), r.host = null), S = S && (l[0] === "" || g[0] === ""));
  var v;
  if (y)
    t.host = r.host || r.host === "" ? r.host : t.host, t.hostname = r.hostname || r.hostname === "" ? r.hostname : t.hostname, t.search = r.search, t.query = r.query, g = l;
  else if (l.length)
    g || (g = []), g.pop(), g = g.concat(l), t.search = r.search, t.query = r.query;
  else if (!p0(r.search))
    return b && (t.hostname = t.host = g.shift(), v = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1, v && (t.auth = v.shift(), t.host = t.hostname = v.shift())), t.search = r.search, t.query = r.query, (!vs(t.pathname) || !vs(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.href = t.format(), t;
  if (!g.length)
    return t.pathname = null, t.search ? t.path = "/" + t.search : t.path = null, t.href = t.format(), t;
  for (var A = g.slice(-1)[0], C = (t.host || r.host || g.length > 1) && (A === "." || A === "..") || A === "", x = 0, _ = g.length; _ >= 0; _--)
    A = g[_], A === "." ? g.splice(_, 1) : A === ".." ? (g.splice(_, 1), x++) : x && (g.splice(_, 1), x--);
  if (!S && !E)
    for (; x--; x)
      g.unshift("..");
  S && g[0] !== "" && (!g[0] || g[0].charAt(0) !== "/") && g.unshift(""), C && g.join("/").substr(-1) !== "/" && g.push("");
  var T = g[0] === "" || g[0] && g[0].charAt(0) === "/";
  return b && (t.hostname = t.host = T ? "" : g.length ? g.shift() : "", v = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1, v && (t.auth = v.shift(), t.host = t.hostname = v.shift())), S = S || t.host && g.length, S && !T && g.unshift(""), g.length ? t.pathname = g.join("/") : (t.pathname = null, t.path = null), (!vs(t.pathname) || !vs(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.auth = r.auth || t.auth, t.slashes = t.slashes || r.slashes, t.href = t.format(), t;
};
lr.prototype.parseHost = function() {
  return u_(this);
};
function u_(r) {
  var e = r.host, t = F8.exec(e);
  t && (t = t[0], t !== ":" && (r.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (r.hostname = e);
}
var z8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  URL: t_,
  URLSearchParams: r_,
  Url: lr,
  default: R8,
  fileURLToPath: i_,
  format: n_,
  parse: na,
  resolve: a_,
  resolveObject: o_
});
function l_(r) {
  const e = r.charAt(0);
  return e === "." || e === "~" || e === "@";
}
const G8 = /^(https?:)?\/\//;
function c_(r) {
  return G8.test(r);
}
const K8 = /^\s*data:/i;
function eh(r) {
  return K8.test(r);
}
function th(r) {
  if (r.charAt(0) === "~") {
    const t = r.charAt(1);
    r = r.slice(t === "/" ? 2 : 1);
  }
  return X8(r);
}
function X8(r) {
  return na(Ie(r) ? r : "", !1, !0);
}
var J8 = Object.defineProperty, Y8 = Object.defineProperties, Q8 = Object.getOwnPropertyDescriptors, a1 = Object.getOwnPropertySymbols, Z8 = Object.prototype.hasOwnProperty, ek = Object.prototype.propertyIsEnumerable, o1 = (r, e, t) => e in r ? J8(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, zf = (r, e) => {
  for (var t in e || (e = {}))
    Z8.call(e, t) && o1(r, t, e[t]);
  if (a1)
    for (var t of a1(e))
      ek.call(e, t) && o1(r, t, e[t]);
  return r;
}, tk = (r, e) => Y8(r, Q8(e));
const bo = {
  base: null,
  includeAbsolute: !1,
  tags: {
    video: ["src", "poster"],
    source: ["src"],
    img: ["src"],
    image: ["xlink:href", "href"],
    use: ["xlink:href", "href"]
  }
}, rk = (r) => Object.keys(r).some((e) => er(r[e])) ? tk(zf({}, bo), {
  tags: r
}) : zf(zf({}, bo), r), sk = (r) => (e, t) => f_(e, t, r), f_ = (r, e, t = bo) => {
  if (r.type === 1) {
    if (!r.props.length)
      return;
    const s = t.tags || bo.tags, i = s[r.tag], n = s["*"];
    if (!i && !n)
      return;
    const a = (i || []).concat(n || []);
    r.props.forEach((o, u) => {
      if (o.type !== 6 || !a.includes(o.name) || !o.value || c_(o.value.content) || eh(o.value.content) || o.value.content[0] === "#" || !t.includeAbsolute && !l_(o.value.content))
        return;
      const l = th(o.value.content);
      if (t.base && o.value.content[0] === ".") {
        const f = th(t.base), p = f.protocol || "", h = f.host ? p + "//" + f.host : "", m = f.path || "/";
        o.value.content = h + (As.posix || As).join(m, l.path + (l.hash || ""));
        return;
      }
      const c = ik(l.path, l.hash, o.loc, e);
      r.props[u] = {
        type: 7,
        name: "bind",
        arg: Q(o.name, !0, o.loc),
        exp: c,
        modifiers: [],
        loc: o.loc
      };
    });
  }
};
function ik(r, e, t, s) {
  if (r) {
    let i, n;
    const a = s.imports.findIndex((c) => c.path === r);
    if (a > -1 ? (i = `_imports_${a}`, n = s.imports[a].exp) : (i = `_imports_${s.imports.length}`, n = Q(
      i,
      !1,
      t,
      3
    ), s.imports.push({
      exp: n,
      path: decodeURIComponent(r)
    })), !e)
      return n;
    const o = `${i} + '${e}'`, u = Q(
      o,
      !1,
      t,
      3
    );
    if (!s.hoistStatic)
      return u;
    const l = s.hoists.findIndex((c) => c && c.type === 4 && !c.isStatic && c.content === o);
    return l > -1 ? Q(
      `_hoisted_${l + 1}`,
      !1,
      t,
      3
    ) : s.hoist(u);
  } else
    return Q("''", !1, t, 3);
}
const nk = ["img", "source"], ak = /( |\\t|\\n|\\f|\\r)+/g, ok = (r) => (e, t) => p_(e, t, r), p_ = (r, e, t = bo) => {
  r.type === 1 && nk.includes(r.tag) && r.props.length && r.props.forEach((s, i) => {
    if (s.name === "srcset" && s.type === 6) {
      if (!s.value) return;
      const n = s.value.content;
      if (!n) return;
      const a = n.split(",").map((c) => {
        const [f, p] = c.replace(ak, " ").trim().split(" ", 2);
        return { url: f, descriptor: p };
      });
      for (let c = 0; c < a.length; c++) {
        const { url: f } = a[c];
        eh(f) && (a[c + 1].url = f + "," + a[c + 1].url, a.splice(c, 1));
      }
      const o = (c) => !c_(c) && !eh(c) && (t.includeAbsolute || l_(c));
      if (!a.some(({ url: c }) => o(c)))
        return;
      if (t.base) {
        const c = t.base, f = [];
        let p = !1;
        if (a.forEach((h) => {
          let { url: m, descriptor: d } = h;
          d = d ? ` ${d}` : "", m[0] === "." ? (h.url = (As.posix || As).join(c, m), f.push(h.url + d)) : o(m) ? p = !0 : f.push(m + d);
        }), !p) {
          s.value.content = f.join(", ");
          return;
        }
      }
      const u = yt([], s.loc);
      a.forEach(({ url: c, descriptor: f }, p) => {
        if (o(c)) {
          const { path: m } = th(c);
          let d;
          if (m) {
            const y = e.imports.findIndex(
              (S) => S.path === m
            );
            y > -1 ? d = Q(
              `_imports_${y}`,
              !1,
              s.loc,
              3
            ) : (d = Q(
              `_imports_${e.imports.length}`,
              !1,
              s.loc,
              3
            ), e.imports.push({ exp: d, path: m })), u.children.push(d);
          }
        } else {
          const m = Q(
            `"${c}"`,
            !1,
            s.loc,
            3
          );
          u.children.push(m);
        }
        const h = a.length - 1 > p;
        f && h ? u.children.push(` + ' ${f}, ' + `) : f ? u.children.push(` + ' ${f}'`) : h && u.children.push(" + ', ' + ");
      });
      let l = u;
      e.hoistStatic && (l = e.hoist(u), l.constType = 3), r.props[i] = {
        type: 7,
        name: "bind",
        arg: Q("srcset", !0, s.loc),
        exp: l,
        modifiers: [],
        loc: s.loc
      };
    }
  });
}, Rl = Symbol("ssrInterpolate"), h_ = Symbol("ssrRenderVNode"), d_ = Symbol("ssrRenderComponent"), m_ = Symbol("ssrRenderSlot"), g_ = Symbol("ssrRenderSlotInner"), y_ = Symbol("ssrRenderClass"), b_ = Symbol("ssrRenderStyle"), b0 = Symbol("ssrRenderAttrs"), v_ = Symbol("ssrRenderAttr"), E_ = Symbol("ssrRenderDynamicAttr"), S_ = Symbol("ssrRenderList"), v0 = Symbol("ssrIncludeBooleanAttr"), zu = Symbol("ssrLooseEqual"), rh = Symbol("ssrLooseContain"), __ = Symbol("ssrRenderDynamicModel"), x_ = Symbol("ssrGetDynamicModelProps"), w_ = Symbol("ssrRenderTeleport"), T_ = Symbol("ssrRenderSuspense"), P_ = Symbol("ssrGetDirectiveProps"), sh = {
  [Rl]: "ssrInterpolate",
  [h_]: "ssrRenderVNode",
  [d_]: "ssrRenderComponent",
  [m_]: "ssrRenderSlot",
  [g_]: "ssrRenderSlotInner",
  [y_]: "ssrRenderClass",
  [b_]: "ssrRenderStyle",
  [b0]: "ssrRenderAttrs",
  [v_]: "ssrRenderAttr",
  [E_]: "ssrRenderDynamicAttr",
  [S_]: "ssrRenderList",
  [v0]: "ssrIncludeBooleanAttr",
  [zu]: "ssrLooseEqual",
  [rh]: "ssrLooseContain",
  [__]: "ssrRenderDynamicModel",
  [x_]: "ssrGetDynamicModelProps",
  [w_]: "ssrRenderTeleport",
  [T_]: "ssrRenderSuspense",
  [P_]: "ssrGetDirectiveProps"
};
Qd(sh);
const uk = Wo(
  /^(if|else|else-if)$/,
  Dm
);
function lk(r, e, t = !1, s = !1) {
  const [i] = r.branches, n = yl(
    i.condition,
    u1(i, e, t)
  );
  e.pushStatement(n);
  let a = n;
  for (let o = 1; o < r.branches.length; o++) {
    const u = r.branches[o], l = u1(
      u,
      e,
      t
    );
    u.condition ? a = a.alternate = yl(
      u.condition,
      l
    ) : a.alternate = l;
  }
  !a.alternate && !s && (a.alternate = Bo([
    ge("_push", ["`<!---->`"])
  ]));
}
function u1(r, e, t = !1) {
  const { children: s } = r, i = !t && (s.length !== 1 || s[0].type !== 1) && // optimize away nested fragments when the only child is a ForNode
  !(s.length === 1 && s[0].type === 11);
  return aa(r, e, i);
}
const ck = Wo(
  "for",
  Mm
);
function fk(r, e, t = !1) {
  const s = !t && (r.children.length !== 1 || r.children[0].type !== 1), i = fr(
    go(r.parseResult)
  );
  i.body = aa(
    r,
    e,
    s
  ), t || e.pushStringPart("<!--[-->"), e.pushStatement(
    ge(e.helper(S_), [
      r.source,
      i
    ])
  ), t || e.pushStringPart("<!--]-->");
}
const pk = (r, e) => {
  if (Bn(r)) {
    const { slotName: t, slotProps: s } = Vm(r, e), i = [
      "_ctx.$slots",
      t,
      s || "{}",
      // fallback content placeholder. will be replaced in the process phase
      "null",
      "_push",
      "_parent"
    ];
    e.scopeId && e.slotted !== !1 && i.push(`"${e.scopeId}-s"`);
    let n = m_, a = e.parent;
    if (a) {
      const o = a.children;
      a.type === 10 && (a = e.grandParent);
      let u;
      a.type === 1 && a.tagType === 1 && ((u = Hc(a, e, !0)) === nn || u === ia) && o.filter((l) => l.type === 1).length === 1 && (n = g_, e.scopeId && e.slotted !== !1 || i.push("null"), i.push("true"));
    }
    r.ssrCodegenNode = ge(e.helper(n), i);
  }
};
function hk(r, e) {
  const t = r.ssrCodegenNode;
  if (r.children.length) {
    const s = fr([]);
    s.body = aa(r, e), t.arguments[3] = s;
  }
  if (e.withSlotScopeId) {
    const s = t.arguments[6];
    t.arguments[6] = s ? `${s} + _scopeId` : "_scopeId";
  }
  e.pushStatement(r.ssrCodegenNode);
}
function vo(r, e) {
  return Me(r, e, dk);
}
const dk = {
  65: "Unsafe attribute name for SSR.",
  66: "Missing the 'to' prop on teleport element.",
  67: "Invalid AST node during SSR transform."
};
function mk(r, e) {
  const t = Qt(r, "to");
  if (!t) {
    e.onError(
      vo(66, r.loc)
    );
    return;
  }
  let s;
  if (t.type === 6 ? s = t.value && Q(t.value.content, !0) : s = t.exp, !s) {
    e.onError(
      vo(
        66,
        t.loc
      )
    );
    return;
  }
  const i = Qt(
    r,
    "disabled",
    !1,
    !0
    /* allow empty */
  ), n = i ? i.type === 6 ? "true" : i.exp || "false" : "false", a = fr(
    ["_push"],
    void 0,
    // Body is added later
    !0,
    // newline
    !1,
    // isSlot
    r.loc
  );
  a.body = aa(r, e), e.pushStatement(
    ge(e.helper(w_), [
      "_push",
      a,
      s,
      n,
      "_parent"
    ])
  );
}
const A_ = /* @__PURE__ */ new WeakMap();
function gk(r, e) {
  return () => {
    if (r.children.length) {
      const t = {
        slotsExp: null,
        // to be immediately set
        wipSlots: []
      };
      A_.set(r, t), t.slotsExp = yo(
        r,
        e,
        (s, i, n, a) => {
          const o = fr(
            [],
            void 0,
            // no return, assign body later
            !0,
            // newline
            !1,
            // suspense slots are not treated as normal slots
            a
          );
          return t.wipSlots.push({
            fn: o,
            children: n
          }), o;
        }
      ).slots;
    }
  };
}
function yk(r, e) {
  const t = A_.get(r);
  if (!t)
    return;
  const { slotsExp: s, wipSlots: i } = t;
  for (let n = 0; n < i.length; n++) {
    const a = i[n];
    a.fn.body = aa(a, e);
  }
  e.pushStatement(
    ge(e.helper(T_), [
      "_push",
      s
    ])
  );
}
const ka = /* @__PURE__ */ new WeakMap(), bk = (r, e) => {
  if (!(r.type !== 1 || r.tagType !== 0))
    return function() {
      const s = [`<${r.tag}`], i = r.tag === "textarea" || r.tag.indexOf("-") > 0, n = $c(r), a = r.props.some(
        (f) => f.type === 7 && !Wd(f.name)
      ), o = n || a;
      if (o) {
        const { props: f, directives: p } = sa(
          r,
          e,
          r.props,
          !1,
          !1,
          !0
        );
        if (f || p.length) {
          const h = E0(f, p, e), m = ge(
            e.helper(b0),
            [h]
          );
          if (r.tag === "textarea") {
            const d = r.children[0];
            if (!d || d.type !== 5) {
              const y = `_temp${e.temps++}`;
              m.arguments = [
                Du(
                  Q(y, !1),
                  h
                )
              ], ka.set(
                r,
                ge(e.helper(Rl), [
                  Nr(
                    Q(`"value" in ${y}`, !1),
                    Q(`${y}.value`, !1),
                    Q(
                      d ? d.content : "",
                      !0
                    ),
                    !1
                  )
                ])
              );
            }
          } else if (r.tag === "input") {
            const d = _k(r);
            if (d) {
              const y = `_temp${e.temps++}`, S = Q(y, !1);
              m.arguments = [
                KE([
                  Du(S, h),
                  ge(e.helper(Gi), [
                    S,
                    ge(
                      e.helper(x_),
                      [
                        S,
                        // existing props
                        d.exp
                        // model
                      ]
                    )
                  ])
                ])
              ];
            }
          } else if (p.length && !r.children.length) {
            const d = `_temp${e.temps++}`;
            m.arguments = [
              Du(
                Q(d, !1),
                h
              )
            ], ka.set(
              r,
              Nr(
                Q(`"textContent" in ${d}`, !1),
                ge(e.helper(Rl), [
                  Q(`${d}.textContent`, !1)
                ]),
                Q(`${d}.innerHTML ?? ''`, !1),
                !1
              )
            );
          }
          i && m.arguments.push(`"${r.tag}"`), s.push(m);
        }
      }
      let u, l, c;
      for (let f = 0; f < r.props.length; f++) {
        const p = r.props[f];
        if (!(r.tag === "input" && vk(p)))
          if (p.type === 7) {
            if (p.name === "html" && p.exp)
              ka.set(
                r,
                yt(["(", p.exp, ") ?? ''"])
              );
            else if (p.name === "text" && p.exp)
              r.children = [gl(p.exp, p.loc)];
            else if (p.name === "slot")
              e.onError(
                Me(40, p.loc)
              );
            else if (Ek(r, p) && p.exp)
              o || (r.children = [gl(p.exp, p.loc)]);
            else if (!o && p.name !== "on") {
              const h = e.directiveTransforms[p.name];
              if (h) {
                const { props: m, ssrTagParts: d } = h(
                  p,
                  r,
                  e
                );
                d && s.push(...d);
                for (let y = 0; y < m.length; y++) {
                  const { key: S, value: E } = m[y];
                  if (Pt(S)) {
                    let g = S.content;
                    if (g === "key" || g === "ref")
                      continue;
                    g === "class" ? s.push(
                      ' class="',
                      u = ge(
                        e.helper(y_),
                        [E]
                      ),
                      '"'
                    ) : g === "style" ? c ? l1(c, E) : s.push(
                      ' style="',
                      c = ge(
                        e.helper(b_),
                        [E]
                      ),
                      '"'
                    ) : (g = r.tag.indexOf("-") > 0 ? g : MC[g] || g.toLowerCase(), jE(g) ? s.push(
                      Nr(
                        ge(
                          e.helper(v0),
                          [E]
                        ),
                        Q(" " + g, !0),
                        Q("", !0),
                        !1
                      )
                    ) : LC(g) ? s.push(
                      ge(e.helper(v_), [
                        S,
                        E
                      ])
                    ) : e.onError(
                      vo(
                        65,
                        S.loc
                      )
                    ));
                  } else {
                    const g = [S, E];
                    i && g.push(`"${r.tag}"`), s.push(
                      ge(
                        e.helper(E_),
                        g
                      )
                    );
                  }
                }
              }
            }
          } else {
            const h = p.name;
            if (r.tag === "textarea" && h === "value" && p.value)
              ka.set(r, Ur(p.value.content));
            else if (!o) {
              if (h === "key" || h === "ref")
                continue;
              h === "class" && p.value && (l = JSON.stringify(p.value.content)), s.push(
                ` ${p.name}` + (p.value ? `="${Ur(p.value.content)}"` : "")
              );
            }
          }
      }
      u && l && (l1(u, l), Sk(s, "class")), e.scopeId && s.push(` ${e.scopeId}`), r.ssrCodegenNode = Zd(s);
    };
};
function E0(r, e, t) {
  let s = [];
  if (r && (r.type === 14 ? s = r.arguments : s.push(r)), e.length)
    for (const i of e)
      s.push(
        ge(t.helper(P_), [
          "_ctx",
          ...Bm(i, t).elements
        ])
      );
  return s.length > 1 ? ge(t.helper(Gi), s) : s[0];
}
function vk(r) {
  return r.type === 7 ? r.name === "bind" && r.arg && Pt(r.arg) && (r.arg.content === "true-value" || r.arg.content === "false-value") : r.name === "true-value" || r.name === "false-value";
}
function Ek(r, e) {
  return !!(r.tag === "textarea" && e.name === "bind" && jr(e.arg, "value"));
}
function l1(r, e) {
  const t = r.arguments[0];
  t.type === 17 ? t.elements.push(e) : r.arguments[0] = sn([t, e]);
}
function Sk(r, e) {
  const t = new RegExp(`^ ${e}=".+"$`), s = r.findIndex((i) => typeof i == "string" && t.test(i));
  s > -1 && r.splice(s, 1);
}
function _k(r) {
  return r.props.find(
    (e) => e.type === 7 && e.name === "model" && e.exp
  );
}
function xk(r, e) {
  const t = e.options.isVoidTag || ku, s = r.ssrCodegenNode.elements;
  for (let n = 0; n < s.length; n++)
    e.pushStringPart(s[n]);
  e.withSlotScopeId && e.pushStringPart(Q("_scopeId", !1)), e.pushStringPart(">");
  const i = ka.get(r);
  i ? e.pushStringPart(i) : r.children.length && xs(r, e), t(r.tag) || e.pushStringPart(`</${r.tag}>`);
}
const C_ = /* @__PURE__ */ new WeakMap();
function wk(r, e) {
  return () => {
    const t = Qt(r, "tag");
    if (t) {
      const s = r.props.filter((o) => o !== t), { props: i, directives: n } = sa(
        r,
        e,
        s,
        !0,
        !1,
        !0
      );
      let a = null;
      (i || n.length) && (a = ge(e.helper(b0), [
        E0(i, n, e)
      ])), C_.set(r, {
        tag: t,
        propsExp: a,
        scopeId: e.scopeId || null
      });
    }
  };
}
function Tk(r, e) {
  const t = C_.get(r);
  if (t) {
    const { tag: s, propsExp: i, scopeId: n } = t;
    s.type === 7 ? (e.pushStringPart("<"), e.pushStringPart(s.exp), i && e.pushStringPart(i), n && e.pushStringPart(` ${n}`), e.pushStringPart(">"), xs(
      r,
      e,
      !1,
      /**
       * TransitionGroup has the special runtime behavior of flattening and
       * concatenating all children into a single fragment (in order for them to
       * be patched using the same key map) so we need to account for that here
       * by disabling nested fragment wrappers from being generated.
       */
      !0,
      /**
       * TransitionGroup filters out comment children at runtime and thus
       * doesn't expect comments to be present during hydration. We need to
       * account for that by disabling the empty comment that is otherwise
       * rendered for a falsy v-if that has no v-else specified. (#6715)
       */
      !0
    ), e.pushStringPart("</"), e.pushStringPart(s.exp), e.pushStringPart(">")) : (e.pushStringPart(`<${s.value.content}`), i && e.pushStringPart(i), n && e.pushStringPart(` ${n}`), e.pushStringPart(">"), xs(r, e, !1, !0, !0), e.pushStringPart(`</${s.value.content}>`));
  } else
    xs(r, e, !0, !0, !0);
}
const N_ = /* @__PURE__ */ new WeakMap();
function Pk(r, e) {
  return () => {
    const t = Qt(r, "appear", !1, !0);
    N_.set(r, !!t);
  };
}
function Ak(r, e) {
  r.children = r.children.filter((s) => s.type !== 3), N_.get(r) ? (e.pushStringPart("<template>"), xs(r, e, !1, !0), e.pushStringPart("</template>")) : xs(r, e, !1, !0);
}
var Ck = Object.defineProperty, Nk = Object.defineProperties, Ok = Object.getOwnPropertyDescriptors, c1 = Object.getOwnPropertySymbols, Ik = Object.prototype.hasOwnProperty, kk = Object.prototype.propertyIsEnumerable, f1 = (r, e, t) => e in r ? Ck(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Vi = (r, e) => {
  for (var t in e || (e = {}))
    Ik.call(e, t) && f1(r, t, e[t]);
  if (c1)
    for (var t of c1(e))
      kk.call(e, t) && f1(r, t, e[t]);
  return r;
}, Dk = (r, e) => Nk(r, Ok(e));
const O_ = /* @__PURE__ */ new WeakMap(), I_ = Symbol(), k_ = /* @__PURE__ */ new WeakMap(), Lk = (r, e) => {
  if (r.type !== 1 || r.tagType !== 1)
    return;
  const t = Hc(
    r,
    e,
    !0
    /* ssr */
  ), s = pi(t) && t.callee === $o;
  if (k_.set(r, t), fi(t))
    return t === Xn ? gk(r, e) : t === ia ? wk(r, e) : t === nn ? Pk(r) : void 0;
  const i = [], n = ih(r);
  return function() {
    n.children.length && yo(n, e, (f, p, h) => (i.push(
      Vk(f, p, h, e)
    ), fr(void 0)));
    let o = "null";
    if (r.props.length) {
      const { props: f, directives: p } = sa(
        r,
        e,
        void 0,
        !0,
        s
      );
      (f || p.length) && (o = E0(f, p, e));
    }
    const u = [];
    O_.set(r, u);
    const l = (f, p, h, m) => {
      const d = f && qc(f) || "_", y = fr(
        [d, "_push", "_parent", "_scopeId"],
        void 0,
        // no return, assign body later
        !0,
        // newline
        !0,
        // isSlot
        m
      );
      return u.push({
        type: I_,
        fn: y,
        children: h,
        // also collect the corresponding vnode branch built earlier
        vnodeBranch: i[u.length]
      }), y;
    }, c = r.children.length ? yo(r, e, l).slots : "null";
    typeof t != "string" ? r.ssrCodegenNode = ge(
      e.helper(h_),
      [
        "_push",
        ge(e.helper(Ro), [
          t,
          o,
          c
        ]),
        "_parent"
      ]
    ) : r.ssrCodegenNode = ge(
      e.helper(d_),
      [t, o, c, "_parent"]
    );
  };
};
function Mk(r, e, t) {
  const s = k_.get(r);
  if (r.ssrCodegenNode) {
    const i = O_.get(r) || [];
    for (let n = 0; n < i.length; n++) {
      const { fn: a, vnodeBranch: o } = i[n];
      a.body = yl(
        Q("_push", !1),
        aa(
          i[n],
          e,
          !1,
          !0
        ),
        o
      );
    }
    e.withSlotScopeId && r.ssrCodegenNode.arguments.push("_scopeId"), typeof s == "string" ? e.pushStatement(
      ge("_push", [r.ssrCodegenNode])
    ) : e.pushStatement(r.ssrCodegenNode);
  } else {
    if (s === $i)
      return mk(r, e);
    if (s === Xn)
      return yk(r, e);
    if (s === ia)
      return Tk(r, e);
    if (t.type === I_ && e.pushStringPart(""), s === nn)
      return Ak(r, e);
    xs(r, e);
  }
}
const D_ = /* @__PURE__ */ new WeakMap(), [Rk, $k] = Um(!0), Fk = [...Rk, ...Qm], Bk = Vi(Vi({}, $k), Zm);
function Vk(r, e, t, s) {
  const i = D_.get(s.root), n = Dk(Vi({}, i), {
    // overwrite with vnode-based transforms
    nodeTransforms: [
      ...Fk,
      ...i.nodeTransforms || []
    ],
    directiveTransforms: Vi(Vi({}, Bk), i.directiveTransforms || {})
  }), a = [];
  return r && a.push({
    type: 7,
    name: "slot",
    exp: r,
    arg: void 0,
    modifiers: [],
    loc: rt
  }), e && a.push(Jr({}, e)), Uk({
    type: 1,
    ns: 0,
    tag: "template",
    tagType: 3,
    props: a,
    children: t,
    loc: rt,
    codegenNode: void 0
  }, n, s), XE(t);
}
function Uk(r, e, t) {
  const s = rn([r]), i = Ho(s, e);
  i.ssr = !1, i.scopes = Vi({}, t.scopes), i.identifiers = Vi({}, t.identifiers), i.imports = t.imports, Qn(s, i), ["helpers", "components", "directives"].forEach((n) => {
    i[n].forEach((a, o) => {
      if (n === "helpers") {
        const u = t.helpers.get(o);
        u === void 0 ? t.helpers.set(o, a) : t.helpers.set(o, a + u);
      } else
        t[n].add(a);
    });
  });
}
function ih(r) {
  if (er(r))
    return r.map(ih);
  if (RE(r)) {
    const e = {};
    for (const t in r)
      e[t] = ih(r[t]);
    return e;
  } else
    return r;
}
function jk(r, e) {
  const t = L_(r, e);
  if (e.ssrCssVars) {
    const i = Ho(rn([]), e), n = vt(
      Q(e.ssrCssVars, !1),
      i
    );
    t.body.push(
      yt(["const _cssVars = { style: ", n, "}"])
    ), Array.from(i.helpers.keys()).forEach((a) => {
      r.helpers.add(a);
    });
  }
  const s = r.children.length > 1 && r.children.some((i) => !Ha(i));
  xs(r, t, s), r.codegenNode = Bo(t.body), r.ssrHelpers = Array.from(
    /* @__PURE__ */ new Set([
      ...Array.from(r.helpers).filter((i) => i in sh),
      ...t.helpers
    ])
  ), r.helpers = new Set(Array.from(r.helpers).filter((i) => !(i in sh)));
}
function L_(r, e, t = /* @__PURE__ */ new Set(), s = !1) {
  const i = [];
  let n = null;
  return {
    root: r,
    options: e,
    body: i,
    helpers: t,
    withSlotScopeId: s,
    onError: e.onError || ((a) => {
      throw a;
    }),
    helper(a) {
      return t.add(a), a;
    },
    pushStringPart(a) {
      if (!n) {
        const l = ge("_push");
        i.push(l), n = Zd([]), l.arguments.push(n);
      }
      const o = n.elements, u = o[o.length - 1];
      Ie(a) && Ie(u) ? o[o.length - 1] += a : o.push(a);
    },
    pushStatement(a) {
      n = null, i.push(a);
    }
  };
}
function qk(r, e = r.withSlotScopeId) {
  return L_(
    r.root,
    r.options,
    r.helpers,
    e
  );
}
function xs(r, e, t = !1, s = !1, i = !1) {
  t && e.pushStringPart("<!--[-->");
  const { children: n } = r;
  for (let a = 0; a < n.length; a++) {
    const o = n[a];
    switch (o.type) {
      case 1:
        switch (o.tagType) {
          case 0:
            xk(o, e);
            break;
          case 1:
            Mk(o, e, r);
            break;
          case 2:
            hk(o, e);
            break;
          case 3:
            break;
          default:
            return e.onError(
              vo(
                67,
                o.loc
              )
            ), o;
        }
        break;
      case 2:
        e.pushStringPart(Ur(o.content));
        break;
      case 3:
        e.pushStringPart(`<!--${o.content}-->`);
        break;
      case 5:
        e.pushStringPart(
          ge(e.helper(Rl), [
            o.content
          ])
        );
        break;
      case 9:
        lk(
          o,
          e,
          s,
          i
        );
        break;
      case 11:
        fk(o, e, s);
        break;
      case 10:
        break;
      case 12:
      case 8:
        break;
      default:
        return e.onError(
          vo(
            67,
            o.loc
          )
        ), o;
    }
  }
  t && e.pushStringPart("<!--]-->");
}
function aa(r, e, t = !1, s = e.withSlotScopeId) {
  const i = qk(e, s);
  return xs(r, i, t), Bo(i.body);
}
const Hk = (r, e, t) => {
  const s = r.exp;
  function i() {
    const a = Qt(e, "value");
    a && t.onError(
      Mt(
        60,
        a.loc
      )
    );
  }
  function n(a) {
    if (a.tag === "option") {
      if (a.props.findIndex((o) => o.name === "selected") === -1) {
        const o = p1(a);
        a.ssrCodegenNode.elements.push(
          Nr(
            ge(t.helper(v0), [
              Nr(
                ge("Array.isArray", [s]),
                ge(t.helper(rh), [
                  s,
                  o
                ]),
                ge(t.helper(zu), [
                  s,
                  o
                ])
              )
            ]),
            Q(" selected", !0),
            Q("", !0),
            !1
          )
        );
      }
    } else a.tag === "optgroup" && a.children.forEach(
      (o) => n(o)
    );
  }
  if (e.tagType === 0) {
    const a = { props: [] }, o = [
      // default value binding for text type inputs
      Fe("value", s)
    ];
    if (e.tag === "input") {
      const u = Qt(e, "type");
      if (u) {
        const l = p1(e);
        if (u.type === 7)
          a.ssrTagParts = [
            ge(t.helper(__), [
              u.exp,
              s,
              l
            ])
          ];
        else if (u.value)
          switch (u.value.content) {
            case "radio":
              a.props = [
                Fe(
                  "checked",
                  ge(t.helper(zu), [
                    s,
                    l
                  ])
                )
              ];
              break;
            case "checkbox":
              const c = Qt(e, "true-value");
              if (c) {
                const f = c.type === 6 ? JSON.stringify(c.value.content) : c.exp;
                a.props = [
                  Fe(
                    "checked",
                    ge(t.helper(zu), [
                      s,
                      f
                    ])
                  )
                ];
              } else
                a.props = [
                  Fe(
                    "checked",
                    Nr(
                      ge("Array.isArray", [s]),
                      ge(t.helper(rh), [
                        s,
                        l
                      ]),
                      s
                    )
                  )
                ];
              break;
            case "file":
              t.onError(
                Mt(
                  59,
                  r.loc
                )
              );
              break;
            default:
              i(), a.props = o;
              break;
          }
      } else $c(e) || (i(), a.props = o);
    } else e.tag === "textarea" ? (i(), e.children = [gl(s, s.loc)]) : e.tag === "select" ? e.children.forEach((u) => {
      u.type === 1 && n(u);
    }) : t.onError(
      Mt(
        57,
        r.loc
      )
    );
    return a;
  } else
    return zc(r, e, t);
};
function p1(r) {
  const e = Qt(r, "value");
  return e ? e.type === 7 ? e.exp : Q(e.value.content, !0) : Q("null", !1);
}
const Wk = (r, e, t) => (r.exp || t.onError(
  Mt(61)
), {
  props: [
    Fe(
      "style",
      Nr(
        r.exp,
        Q("null", !1),
        Yt([
          Fe(
            "display",
            Q("none", !0)
          )
        ]),
        !1
      )
    )
  ]
}), nh = (r) => r.children.filter((e) => e.type !== 3), Gf = (r) => nh(r).length === 1, zk = (r, e) => {
  if (r.type === 0 && (e.identifiers._attrs = 1), r.type === 1 && r.tagType === 1 && (r.tag === "transition" || r.tag === "Transition" || r.tag === "KeepAlive" || r.tag === "keep-alive")) {
    const s = nh(e.root);
    if (s.length === 1 && s[0] === r) {
      Gf(r) && Kf(r.children[0]);
      return;
    }
  }
  const t = e.parent;
  if (!(!t || t.type !== 0))
    if (r.type === 10 && Gf(r)) {
      let s = !1;
      for (const i of nh(t))
        if (i.type === 9 || i.type === 1 && gt(i, "if")) {
          if (s) return;
          s = !0;
        } else if (
          // node before v-if
          !s || // non else nodes
          !(i.type === 1 && gt(i, /else/, !0))
        )
          return;
      Kf(r.children[0]);
    } else Gf(t) && Kf(r);
};
function Kf(r) {
  r.type === 1 && (r.tagType === 0 || r.tagType === 1) && !gt(r, "for") && r.props.push({
    type: 7,
    name: "bind",
    arg: void 0,
    exp: Q("_attrs", !1),
    modifiers: [],
    loc: rt
  });
}
const Gk = (r, e) => {
  if (!e.ssrCssVars)
    return;
  r.type === 0 && (e.identifiers._cssVars = 1);
  const t = e.parent;
  if (!(!t || t.type !== 0))
    if (r.type === 10)
      for (const s of r.children)
        $l(s);
    else
      $l(r);
};
function $l(r) {
  if (r.type === 1 && (r.tagType === 0 || r.tagType === 1) && !gt(r, "for"))
    if (r.tag === "suspense" || r.tag === "Suspense")
      for (const e of r.children)
        e.type === 1 && e.tagType === 3 ? e.children.forEach($l) : $l(e);
    else
      r.props.push({
        type: 7,
        name: "bind",
        arg: void 0,
        exp: Q("_cssVars", !1),
        modifiers: [],
        loc: rt
      });
}
var Kk = Object.defineProperty, Xk = Object.defineProperties, Jk = Object.getOwnPropertyDescriptors, h1 = Object.getOwnPropertySymbols, Yk = Object.prototype.hasOwnProperty, Qk = Object.prototype.propertyIsEnumerable, d1 = (r, e, t) => e in r ? Kk(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, mu = (r, e) => {
  for (var t in e || (e = {}))
    Yk.call(e, t) && d1(r, t, e[t]);
  if (h1)
    for (var t of h1(e))
      Qk.call(e, t) && d1(r, t, e[t]);
  return r;
}, m1 = (r, e) => Xk(r, Jk(e));
function Zk(r, e = {}) {
  e = m1(mu(mu({}, e), Un), {
    ssr: !0,
    inSSR: !0,
    scopeId: e.mode === "function" ? null : e.scopeId,
    // always prefix since compiler-ssr doesn't have size concern
    prefixIdentifiers: !0,
    // disable optimizations that are unnecessary for ssr
    cacheHandlers: !1,
    hoistStatic: !1
  });
  const t = typeof r == "string" ? Fc(r, e) : r;
  return D_.set(t, e), _m(t, m1(mu({}, e), {
    hoistStatic: !1,
    nodeTransforms: [
      uk,
      ck,
      Fm,
      km,
      pk,
      zk,
      Gk,
      bk,
      Lk,
      $m,
      Xm,
      ...e.nodeTransforms || []
      // user transforms
    ],
    directiveTransforms: mu({
      // reusing core v-bind
      bind: Lm,
      on: Wc,
      // model and show have dedicated SSR handling
      model: Hk,
      show: Wk,
      // the following are ignored during SSR
      // on: noopDirectiveTransform,
      cloak: Wa,
      once: Wa,
      memo: Wa
    }, e.directiveTransforms || {})
  })), jk(t, e), Im(t, e);
}
var eD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  compile: Zk
});
function tD(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var rD = {}, sD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: rD
}), iD = /* @__PURE__ */ Vo(sD), S0 = /* @__PURE__ */ Vo(C6), nD = /* @__PURE__ */ Vo(k8);
const g1 = {};
function wn(r) {
  !(typeof process < "u" && process.env.NODE_ENV === "production") && !g1[r] && (g1[r] = !0, ah(r));
}
function ah(r) {
  console.warn(
    `\x1B[1m\x1B[33m[@vue/compiler-sfc]\x1B[0m\x1B[33m ${r}\x1B[0m
`
  );
}
var aD = Object.defineProperty, oD = Object.defineProperties, uD = Object.getOwnPropertyDescriptors, y1 = Object.getOwnPropertySymbols, lD = Object.prototype.hasOwnProperty, cD = Object.prototype.propertyIsEnumerable, b1 = (r, e, t) => e in r ? aD(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Fl = (r, e) => {
  for (var t in e || (e = {}))
    lD.call(e, t) && b1(r, t, e[t]);
  if (y1)
    for (var t of y1(e))
      cD.call(e, t) && b1(r, t, e[t]);
  return r;
}, oh = (r, e) => oD(r, uD(e));
function fD({ source: r, filename: e, preprocessOptions: t }, s) {
  let i = "", n = null;
  if (s.render(
    r,
    Fl({ filename: e }, t),
    (a, o) => {
      a && (n = a), i = o;
    }
  ), n) throw n;
  return i;
}
function M_(r) {
  const { preprocessLang: e, preprocessCustomRequire: t } = r;
  if (e && !t)
    throw new Error(
      "[@vue/compiler-sfc] Template preprocessing in the browser build must provide the `preprocessCustomRequire` option to return the in-browser version of the preprocessor in the shape of { render(): string }."
    );
  const s = e ? t ? t(e) : void 0 : !1;
  if (s)
    try {
      return v1(oh(Fl({}, r), {
        source: fD(r, s),
        ast: void 0
        // invalidate AST if template goes through preprocessor
      }));
    } catch (i) {
      return {
        code: "export default function render() {}",
        source: r.source,
        tips: [],
        errors: [i]
      };
    }
  else return e ? {
    code: "export default function render() {}",
    source: r.source,
    tips: [
      `Component ${r.filename} uses lang ${e} for template. Please install the language preprocessor.`
    ],
    errors: [
      `Component ${r.filename} uses lang ${e} for template, however it is not installed.`
    ]
  } : v1(r);
}
function v1({
  filename: r,
  id: e,
  scoped: t,
  slotted: s,
  inMap: i,
  source: n,
  ast: a,
  ssr: o = !1,
  ssrCssVars: u,
  isProd: l = !1,
  compiler: c,
  compilerOptions: f = {},
  transformAssetUrls: p
}) {
  const h = [], m = [];
  let d = [];
  if (pi(p)) {
    const x = rk(p);
    d = [
      sk(x),
      ok(x)
    ];
  } else p !== !1 && (d = [f_, p_]);
  o && !u && wn(
    "compileTemplate is called with `ssr: true` but no corresponding `cssVars` option."
  ), e || (wn("compileTemplate now requires the `id` option."), e = "");
  const y = e.replace(/^data-v-/, ""), S = `data-v-${y}`, E = o ? eD : zp;
  if (c = c || E, c !== E && (a = void 0), a != null && a.transformed) {
    const _ = (o ? zp : c).parse(a.source, oh(Fl({
      prefixIdentifiers: !0
    }, f), {
      parseMode: "sfc",
      onError: (T) => h.push(T)
    })).children.find(
      (T) => T.type === 1 && T.tag === "template"
    );
    a = rn(_.children, a.source);
  }
  let { code: g, ast: b, preamble: v, map: A } = c.compile(a || n, oh(Fl({
    mode: "module",
    prefixIdentifiers: !0,
    hoistStatic: !0,
    cacheHandlers: !0,
    ssrCssVars: o && u && u.length ? d2(u, y, l, !0) : "",
    scopeId: t ? S : void 0,
    slotted: s,
    sourceMap: !0
  }, f), {
    hmr: !l,
    nodeTransforms: d.concat(f.nodeTransforms || []),
    filename: r,
    onError: (x) => h.push(x),
    onWarn: (x) => m.push(x)
  }));
  i && !a && (A && (A = pD(i, A)), h.length && hD(h, n, i));
  const C = m.map((x) => {
    let _ = x.message;
    return x.loc && (_ += `
${kn(
      (a == null ? void 0 : a.source) || n,
      x.loc.start.offset,
      x.loc.end.offset
    )}`), _;
  });
  return { code: g, ast: b, preamble: v, source: n, errors: h, tips: C, map: A };
}
function pD(r, e) {
  if (!r) return e;
  if (!e) return r;
  const t = new Oy(r), s = new Oy(e), i = new Om();
  s.eachMapping((a) => {
    if (a.originalLine == null)
      return;
    const o = t.originalPositionFor({
      line: a.originalLine,
      column: a.originalColumn
    });
    o.source != null && i.addMapping({
      generated: {
        line: a.generatedLine,
        column: a.generatedColumn
      },
      original: {
        line: o.line,
        // map line
        // use current column, since the oldMap produced by @vue/compiler-sfc
        // does not
        column: a.originalColumn
      },
      source: o.source,
      name: o.name
    });
  });
  const n = i;
  return t.sources.forEach((a) => {
    n._sources.add(a);
    const o = t.sourceContentFor(a);
    o != null && i.setSourceContent(a, o);
  }), n._sourceRoot = r.sourceRoot, n._file = r.file, n.toJSON();
}
function hD(r, e, t) {
  const s = t.sourcesContent[0], i = s.indexOf(e), n = s.slice(0, i).split(/\r?\n/).length - 1;
  r.forEach((a) => {
    a.loc && (a.loc.start.line += n, a.loc.start.offset += i, a.loc.end !== a.loc.start && (a.loc.end.line += n, a.loc.end.offset += i));
  });
}
var _0 = { exports: {} };
function R_() {
  return !1;
}
function $_() {
  throw new Error("tty.ReadStream is not implemented");
}
function F_() {
  throw new Error("tty.ReadStream is not implemented");
}
var dD = {
  isatty: R_,
  ReadStream: $_,
  WriteStream: F_
}, mD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ReadStream: $_,
  WriteStream: F_,
  default: dD,
  isatty: R_
}), gD = /* @__PURE__ */ Vo(mD);
let E1 = Zt.argv || [], gu = {}, yD = !("NO_COLOR" in gu || E1.includes("--no-color")) && ("FORCE_COLOR" in gu || E1.includes("--color") || !1 || tD != null && gD.isatty(1) && gu.TERM !== "dumb" || "CI" in gu), bD = (r, e, t = r) => (s) => {
  let i = "" + s, n = i.indexOf(e, r.length);
  return ~n ? r + vD(i, e, t, n) + e : r + i + e;
}, vD = (r, e, t, s) => {
  let i = "", n = 0;
  do
    i += r.substring(n, s) + t, n = s + e.length, s = r.indexOf(e, n);
  while (~s);
  return i + r.substring(n);
}, B_ = (r = yD) => {
  let e = r ? bD : () => String;
  return {
    isColorSupported: r,
    reset: e("\x1B[0m", "\x1B[0m"),
    bold: e("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
    dim: e("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
    italic: e("\x1B[3m", "\x1B[23m"),
    underline: e("\x1B[4m", "\x1B[24m"),
    inverse: e("\x1B[7m", "\x1B[27m"),
    hidden: e("\x1B[8m", "\x1B[28m"),
    strikethrough: e("\x1B[9m", "\x1B[29m"),
    black: e("\x1B[30m", "\x1B[39m"),
    red: e("\x1B[31m", "\x1B[39m"),
    green: e("\x1B[32m", "\x1B[39m"),
    yellow: e("\x1B[33m", "\x1B[39m"),
    blue: e("\x1B[34m", "\x1B[39m"),
    magenta: e("\x1B[35m", "\x1B[39m"),
    cyan: e("\x1B[36m", "\x1B[39m"),
    white: e("\x1B[37m", "\x1B[39m"),
    gray: e("\x1B[90m", "\x1B[39m"),
    bgBlack: e("\x1B[40m", "\x1B[49m"),
    bgRed: e("\x1B[41m", "\x1B[49m"),
    bgGreen: e("\x1B[42m", "\x1B[49m"),
    bgYellow: e("\x1B[43m", "\x1B[49m"),
    bgBlue: e("\x1B[44m", "\x1B[49m"),
    bgMagenta: e("\x1B[45m", "\x1B[49m"),
    bgCyan: e("\x1B[46m", "\x1B[49m"),
    bgWhite: e("\x1B[47m", "\x1B[49m")
  };
};
_0.exports = B_();
_0.exports.createColors = B_;
var V_ = _0.exports;
const Xf = 39, S1 = 34, yu = 92, _1 = 47, bu = 10, Sa = 32, vu = 12, Eu = 9, Su = 13, ED = 91, SD = 93, _D = 40, xD = 41, wD = 123, TD = 125, PD = 59, AD = 42, CD = 58, ND = 64, _u = /[\t\n\f\r "#'()/;[\\\]{}]/g, xu = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, OD = /.[\r\n"'(/\\]/, x1 = /[\da-f]/i;
var U_ = function(e, t = {}) {
  let s = e.css.valueOf(), i = t.ignoreErrors, n, a, o, u, l, c, f, p, h, m, d = s.length, y = 0, S = [], E = [];
  function g() {
    return y;
  }
  function b(x) {
    throw e.error("Unclosed " + x, y);
  }
  function v() {
    return E.length === 0 && y >= d;
  }
  function A(x) {
    if (E.length) return E.pop();
    if (y >= d) return;
    let _ = x ? x.ignoreUnclosed : !1;
    switch (n = s.charCodeAt(y), n) {
      case bu:
      case Sa:
      case Eu:
      case Su:
      case vu: {
        a = y;
        do
          a += 1, n = s.charCodeAt(a);
        while (n === Sa || n === bu || n === Eu || n === Su || n === vu);
        m = ["space", s.slice(y, a)], y = a - 1;
        break;
      }
      case ED:
      case SD:
      case wD:
      case TD:
      case CD:
      case PD:
      case xD: {
        let T = String.fromCharCode(n);
        m = [T, T, y];
        break;
      }
      case _D: {
        if (p = S.length ? S.pop()[1] : "", h = s.charCodeAt(y + 1), p === "url" && h !== Xf && h !== S1 && h !== Sa && h !== bu && h !== Eu && h !== vu && h !== Su) {
          a = y;
          do {
            if (c = !1, a = s.indexOf(")", a + 1), a === -1)
              if (i || _) {
                a = y;
                break;
              } else
                b("bracket");
            for (f = a; s.charCodeAt(f - 1) === yu; )
              f -= 1, c = !c;
          } while (c);
          m = ["brackets", s.slice(y, a + 1), y, a], y = a;
        } else
          a = s.indexOf(")", y + 1), u = s.slice(y, a + 1), a === -1 || OD.test(u) ? m = ["(", "(", y] : (m = ["brackets", u, y, a], y = a);
        break;
      }
      case Xf:
      case S1: {
        o = n === Xf ? "'" : '"', a = y;
        do {
          if (c = !1, a = s.indexOf(o, a + 1), a === -1)
            if (i || _) {
              a = y + 1;
              break;
            } else
              b("string");
          for (f = a; s.charCodeAt(f - 1) === yu; )
            f -= 1, c = !c;
        } while (c);
        m = ["string", s.slice(y, a + 1), y, a], y = a;
        break;
      }
      case ND: {
        _u.lastIndex = y + 1, _u.test(s), _u.lastIndex === 0 ? a = s.length - 1 : a = _u.lastIndex - 2, m = ["at-word", s.slice(y, a + 1), y, a], y = a;
        break;
      }
      case yu: {
        for (a = y, l = !0; s.charCodeAt(a + 1) === yu; )
          a += 1, l = !l;
        if (n = s.charCodeAt(a + 1), l && n !== _1 && n !== Sa && n !== bu && n !== Eu && n !== Su && n !== vu && (a += 1, x1.test(s.charAt(a)))) {
          for (; x1.test(s.charAt(a + 1)); )
            a += 1;
          s.charCodeAt(a + 1) === Sa && (a += 1);
        }
        m = ["word", s.slice(y, a + 1), y, a], y = a;
        break;
      }
      default: {
        n === _1 && s.charCodeAt(y + 1) === AD ? (a = s.indexOf("*/", y + 2) + 1, a === 0 && (i || _ ? a = s.length : b("comment")), m = ["comment", s.slice(y, a + 1), y, a], y = a) : (xu.lastIndex = y + 1, xu.test(s), xu.lastIndex === 0 ? a = s.length - 1 : a = xu.lastIndex - 2, m = ["word", s.slice(y, a + 1), y, a], S.push(m), y = a);
        break;
      }
    }
    return y++, m;
  }
  function C(x) {
    E.push(x);
  }
  return {
    back: C,
    endOfFile: v,
    nextToken: A,
    position: g
  };
};
let Bt = V_, ID = U_, j_;
function kD(r) {
  j_ = r;
}
const DD = {
  ";": Bt.yellow,
  ":": Bt.yellow,
  "(": Bt.cyan,
  ")": Bt.cyan,
  "[": Bt.yellow,
  "]": Bt.yellow,
  "{": Bt.yellow,
  "}": Bt.yellow,
  "at-word": Bt.cyan,
  brackets: Bt.cyan,
  call: Bt.cyan,
  class: Bt.yellow,
  comment: Bt.gray,
  hash: Bt.magenta,
  string: Bt.green
};
function LD([r, e], t) {
  if (r === "word") {
    if (e[0] === ".")
      return "class";
    if (e[0] === "#")
      return "hash";
  }
  if (!t.endOfFile()) {
    let s = t.nextToken();
    if (t.back(s), s[0] === "brackets" || s[0] === "(") return "call";
  }
  return r;
}
function q_(r) {
  let e = ID(new j_(r), { ignoreErrors: !0 }), t = "";
  for (; !e.endOfFile(); ) {
    let s = e.nextToken(), i = DD[LD(s, e)];
    i ? t += s[1].split(/\r?\n/).map((n) => i(n)).join(`
`) : t += s[1];
  }
  return t;
}
q_.registerInput = kD;
var H_ = q_;
let w1 = V_, T1 = H_, uh = class W_ extends Error {
  constructor(e, t, s, i, n, a) {
    super(e), this.name = "CssSyntaxError", this.reason = e, n && (this.file = n), i && (this.source = i), a && (this.plugin = a), typeof t < "u" && typeof s < "u" && (typeof t == "number" ? (this.line = t, this.column = s) : (this.line = t.line, this.column = t.column, this.endLine = s.line, this.endColumn = s.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, W_);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source) return "";
    let t = this.source;
    e == null && (e = w1.isColorSupported), T1 && e && (t = T1(t));
    let s = t.split(/\r?\n/), i = Math.max(this.line - 3, 0), n = Math.min(this.line + 2, s.length), a = String(n).length, o, u;
    if (e) {
      let { bold: l, gray: c, red: f } = w1.createColors(!0);
      o = (p) => l(f(p)), u = (p) => c(p);
    } else
      o = u = (l) => l;
    return s.slice(i, n).map((l, c) => {
      let f = i + 1 + c, p = " " + (" " + f).slice(-a) + " | ";
      if (f === this.line) {
        let h = u(p.replace(/\d/g, " ")) + l.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return o(">") + u(p) + l + `
 ` + h + o("^");
      }
      return " " + u(p) + l;
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
};
var x0 = uh;
uh.default = uh;
var Go = {};
Go.isClean = Symbol("isClean");
Go.my = Symbol("my");
const P1 = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function MD(r) {
  return r[0].toUpperCase() + r.slice(1);
}
let lh = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, t) {
    let s = "@" + e.name, i = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName < "u" ? s += e.raws.afterName : i && (s += " "), e.nodes)
      this.block(e, s + i);
    else {
      let n = (e.raws.between || "") + (t ? ";" : "");
      this.builder(s + i + n, e);
    }
  }
  beforeAfter(e, t) {
    let s;
    e.type === "decl" ? s = this.raw(e, null, "beforeDecl") : e.type === "comment" ? s = this.raw(e, null, "beforeComment") : t === "before" ? s = this.raw(e, null, "beforeRule") : s = this.raw(e, null, "beforeClose");
    let i = e.parent, n = 0;
    for (; i && i.type !== "root"; )
      n += 1, i = i.parent;
    if (s.includes(`
`)) {
      let a = this.raw(e, null, "indent");
      if (a.length)
        for (let o = 0; o < n; o++) s += a;
    }
    return s;
  }
  block(e, t) {
    let s = this.raw(e, "between", "beforeOpen");
    this.builder(t + s + "{", e, "start");
    let i;
    e.nodes && e.nodes.length ? (this.body(e), i = this.raw(e, "after")) : i = this.raw(e, "after", "emptyBody"), i && this.builder(i), this.builder("}", e, "end");
  }
  body(e) {
    let t = e.nodes.length - 1;
    for (; t > 0 && e.nodes[t].type === "comment"; )
      t -= 1;
    let s = this.raw(e, "semicolon");
    for (let i = 0; i < e.nodes.length; i++) {
      let n = e.nodes[i], a = this.raw(n, "before");
      a && this.builder(a), this.stringify(n, t !== i || s);
    }
  }
  comment(e) {
    let t = this.raw(e, "left", "commentLeft"), s = this.raw(e, "right", "commentRight");
    this.builder("/*" + t + e.text + s + "*/", e);
  }
  decl(e, t) {
    let s = this.raw(e, "between", "colon"), i = e.prop + s + this.rawValue(e, "value");
    e.important && (i += e.raws.important || " !important"), t && (i += ";"), this.builder(i, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, t, s) {
    let i;
    if (s || (s = t), t && (i = e.raws[t], typeof i < "u"))
      return i;
    let n = e.parent;
    if (s === "before" && (!n || n.type === "root" && n.first === e || n && n.type === "document"))
      return "";
    if (!n) return P1[s];
    let a = e.root();
    if (a.rawCache || (a.rawCache = {}), typeof a.rawCache[s] < "u")
      return a.rawCache[s];
    if (s === "before" || s === "after")
      return this.beforeAfter(e, s);
    {
      let o = "raw" + MD(s);
      this[o] ? i = this[o](a, e) : a.walk((u) => {
        if (i = u.raws[t], typeof i < "u") return !1;
      });
    }
    return typeof i > "u" && (i = P1[s]), a.rawCache[s] = i, i;
  }
  rawBeforeClose(e) {
    let t;
    return e.walk((s) => {
      if (s.nodes && s.nodes.length > 0 && typeof s.raws.after < "u")
        return t = s.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeComment(e, t) {
    let s;
    return e.walkComments((i) => {
      if (typeof i.raws.before < "u")
        return s = i.raws.before, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), !1;
    }), typeof s > "u" ? s = this.raw(t, null, "beforeDecl") : s && (s = s.replace(/\S/g, "")), s;
  }
  rawBeforeDecl(e, t) {
    let s;
    return e.walkDecls((i) => {
      if (typeof i.raws.before < "u")
        return s = i.raws.before, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), !1;
    }), typeof s > "u" ? s = this.raw(t, null, "beforeRule") : s && (s = s.replace(/\S/g, "")), s;
  }
  rawBeforeOpen(e) {
    let t;
    return e.walk((s) => {
      if (s.type !== "decl" && (t = s.raws.between, typeof t < "u"))
        return !1;
    }), t;
  }
  rawBeforeRule(e) {
    let t;
    return e.walk((s) => {
      if (s.nodes && (s.parent !== e || e.first !== s) && typeof s.raws.before < "u")
        return t = s.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawColon(e) {
    let t;
    return e.walkDecls((s) => {
      if (typeof s.raws.between < "u")
        return t = s.raws.between.replace(/[^\s:]/g, ""), !1;
    }), t;
  }
  rawEmptyBody(e) {
    let t;
    return e.walk((s) => {
      if (s.nodes && s.nodes.length === 0 && (t = s.raws.after, typeof t < "u"))
        return !1;
    }), t;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let t;
    return e.walk((s) => {
      let i = s.parent;
      if (i && i !== e && i.parent && i.parent === e && typeof s.raws.before < "u") {
        let n = s.raws.before.split(`
`);
        return t = n[n.length - 1], t = t.replace(/\S/g, ""), !1;
      }
    }), t;
  }
  rawSemicolon(e) {
    let t;
    return e.walk((s) => {
      if (s.nodes && s.nodes.length && s.last.type === "decl" && (t = s.raws.semicolon, typeof t < "u"))
        return !1;
    }), t;
  }
  rawValue(e, t) {
    let s = e[t], i = e.raws[t];
    return i && i.value === s ? i.raw : s;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, t) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, t);
  }
};
var z_ = lh;
lh.default = lh;
let RD = z_;
function ch(r, e) {
  new RD(e).stringify(r);
}
var ef = ch;
ch.default = ch;
let { isClean: wu, my: $D } = Go, FD = x0, BD = z_, VD = ef;
function fh(r, e) {
  let t = new r.constructor();
  for (let s in r) {
    if (!Object.prototype.hasOwnProperty.call(r, s) || s === "proxyCache") continue;
    let i = r[s], n = typeof i;
    s === "parent" && n === "object" ? e && (t[s] = e) : s === "source" ? t[s] = i : Array.isArray(i) ? t[s] = i.map((a) => fh(a, t)) : (n === "object" && i !== null && (i = fh(i)), t[s] = i);
  }
  return t;
}
let ph = class {
  constructor(e = {}) {
    this.raws = {}, this[wu] = !1, this[$D] = !0;
    for (let t in e)
      if (t === "nodes") {
        this.nodes = [];
        for (let s of e[t])
          typeof s.clone == "function" ? this.append(s.clone()) : this.append(s);
      } else
        this[t] = e[t];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let t = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${t.input.from}:${t.start.line}:${t.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let t in e)
      this[t] = e[t];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let t = fh(this);
    for (let s in e)
      t[s] = e[s];
    return t;
  }
  cloneAfter(e = {}) {
    let t = this.clone(e);
    return this.parent.insertAfter(this, t), t;
  }
  cloneBefore(e = {}) {
    let t = this.clone(e);
    return this.parent.insertBefore(this, t), t;
  }
  error(e, t = {}) {
    if (this.source) {
      let { end: s, start: i } = this.rangeBy(t);
      return this.source.input.error(
        e,
        { column: i.column, line: i.line },
        { column: s.column, line: s.line },
        t
      );
    }
    return new FD(e);
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t];
      },
      set(e, t, s) {
        return e[t] === s || (e[t] = s, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || /* c8 ignore next */
        t === "text") && e.markDirty()), !0;
      }
    };
  }
  markDirty() {
    if (this[wu]) {
      this[wu] = !1;
      let e = this;
      for (; e = e.parent; )
        e[wu] = !1;
    }
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e, t) {
    let s = this.source.start;
    if (e.index)
      s = this.positionInside(e.index, t);
    else if (e.word) {
      t = this.toString();
      let i = t.indexOf(e.word);
      i !== -1 && (s = this.positionInside(i, t));
    }
    return s;
  }
  positionInside(e, t) {
    let s = t || this.toString(), i = this.source.start.column, n = this.source.start.line;
    for (let a = 0; a < e; a++)
      s[a] === `
` ? (i = 1, n += 1) : i += 1;
    return { column: i, line: n };
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e) {
    let t = {
      column: this.source.start.column,
      line: this.source.start.line
    }, s = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: t.column + 1,
      line: t.line
    };
    if (e.word) {
      let i = this.toString(), n = i.indexOf(e.word);
      n !== -1 && (t = this.positionInside(n, i), s = this.positionInside(n + e.word.length, i));
    } else
      e.start ? t = {
        column: e.start.column,
        line: e.start.line
      } : e.index && (t = this.positionInside(e.index)), e.end ? s = {
        column: e.end.column,
        line: e.end.line
      } : typeof e.endIndex == "number" ? s = this.positionInside(e.endIndex) : e.index && (s = this.positionInside(e.index + 1));
    return (s.line < t.line || s.line === t.line && s.column <= t.column) && (s = { column: t.column + 1, line: t.line }), { end: s, start: t };
  }
  raw(e, t) {
    return new BD().raw(this, e, t);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let t = this, s = !1;
      for (let i of e)
        i === this ? s = !0 : s ? (this.parent.insertAfter(t, i), t = i) : this.parent.insertBefore(t, i);
      s || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, t) {
    let s = {}, i = t == null;
    t = t || /* @__PURE__ */ new Map();
    let n = 0;
    for (let a in this) {
      if (!Object.prototype.hasOwnProperty.call(this, a) || a === "parent" || a === "proxyCache") continue;
      let o = this[a];
      if (Array.isArray(o))
        s[a] = o.map((u) => typeof u == "object" && u.toJSON ? u.toJSON(null, t) : u);
      else if (typeof o == "object" && o.toJSON)
        s[a] = o.toJSON(null, t);
      else if (a === "source") {
        let u = t.get(o.input);
        u == null && (u = n, t.set(o.input, n), n++), s[a] = {
          end: o.end,
          inputId: u,
          start: o.start
        };
      } else
        s[a] = o;
    }
    return i && (s.inputs = [...t.keys()].map((a) => a.toJSON())), s;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = VD) {
    e.stringify && (e = e.stringify);
    let t = "";
    return e(this, (s) => {
      t += s;
    }), t;
  }
  warn(e, t, s) {
    let i = { node: this };
    for (let n in s) i[n] = s[n];
    return e.warn(t, i);
  }
  get proxyOf() {
    return this;
  }
};
var tf = ph;
ph.default = ph;
let UD = tf, hh = class extends UD {
  constructor(e) {
    e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var rf = hh;
hh.default = hh;
var G_ = /* @__PURE__ */ Vo(z8);
let jD = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", qD = (r, e = 21) => (t = e) => {
  let s = "", i = t;
  for (; i--; )
    s += r[Math.random() * r.length | 0];
  return s;
}, HD = (r = 21) => {
  let e = "", t = r;
  for (; t--; )
    e += jD[Math.random() * 64 | 0];
  return e;
};
var WD = { nanoid: HD, customAlphabet: qD };
let { SourceMapConsumer: A1, SourceMapGenerator: C1 } = Zn, { existsSync: zD, readFileSync: GD } = iD, { dirname: Jf, join: KD } = S0;
function XD(r) {
  return H ? H.from(r, "base64").toString() : window.atob(r);
}
let dh = class {
  constructor(e, t) {
    if (t.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let s = t.map ? t.map.prev : void 0, i = this.loadMap(t.from, s);
    !this.mapFile && t.from && (this.mapFile = t.from), this.mapFile && (this.root = Jf(this.mapFile)), i && (this.text = i);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new A1(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let t = /^data:application\/json;charset=utf-?8;base64,/, s = /^data:application\/json;base64,/, i = /^data:application\/json;charset=utf-?8,/, n = /^data:application\/json,/;
    if (i.test(e) || n.test(e))
      return decodeURIComponent(e.substr(RegExp.lastMatch.length));
    if (t.test(e) || s.test(e))
      return XD(e.substr(RegExp.lastMatch.length));
    let a = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + a);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let t = e.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!t) return;
    let s = e.lastIndexOf(t.pop()), i = e.indexOf("*/", s);
    s > -1 && i > -1 && (this.annotation = this.getAnnotationURL(e.substring(s, i)));
  }
  loadFile(e) {
    if (this.root = Jf(e), zD(e))
      return this.mapFile = e, GD(e, "utf-8").toString().trim();
  }
  loadMap(e, t) {
    if (t === !1) return !1;
    if (t) {
      if (typeof t == "string")
        return t;
      if (typeof t == "function") {
        let s = t(e);
        if (s) {
          let i = this.loadFile(s);
          if (!i)
            throw new Error(
              "Unable to load previous source map: " + s.toString()
            );
          return i;
        }
      } else {
        if (t instanceof A1)
          return C1.fromSourceMap(t).toString();
        if (t instanceof C1)
          return t.toString();
        if (this.isMap(t))
          return JSON.stringify(t);
        throw new Error(
          "Unsupported previous source map format: " + t.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let s = this.annotation;
        return e && (s = KD(Jf(e), s)), this.loadFile(s);
      }
    }
  }
  startWith(e, t) {
    return e ? e.substr(0, t.length) === t : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var K_ = dh;
dh.default = dh;
let { SourceMapConsumer: JD, SourceMapGenerator: YD } = Zn, { fileURLToPath: N1, pathToFileURL: Tu } = G_, { isAbsolute: mh, resolve: gh } = S0, { nanoid: QD } = WD, Yf = H_, O1 = x0, ZD = K_, Qf = Symbol("fromOffsetCache"), eL = !!(JD && YD), I1 = !!(gh && mh), Bl = class {
  constructor(e, t = {}) {
    if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, t.from && (!I1 || /^\w+:\/\//.test(t.from) || mh(t.from) ? this.file = t.from : this.file = gh(t.from)), I1 && eL) {
      let s = new ZD(this.css, t);
      if (s.text) {
        this.map = s;
        let i = s.consumer().file;
        !this.file && i && (this.file = this.mapResolve(i));
      }
    }
    this.file || (this.id = "<input css " + QD(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, t, s, i = {}) {
    let n, a, o;
    if (t && typeof t == "object") {
      let l = t, c = s;
      if (typeof l.offset == "number") {
        let f = this.fromOffset(l.offset);
        t = f.line, s = f.col;
      } else
        t = l.line, s = l.column;
      if (typeof c.offset == "number") {
        let f = this.fromOffset(c.offset);
        a = f.line, o = f.col;
      } else
        a = c.line, o = c.column;
    } else if (!s) {
      let l = this.fromOffset(t);
      t = l.line, s = l.col;
    }
    let u = this.origin(t, s, a, o);
    return u ? n = new O1(
      e,
      u.endLine === void 0 ? u.line : { column: u.column, line: u.line },
      u.endLine === void 0 ? u.column : { column: u.endColumn, line: u.endLine },
      u.source,
      u.file,
      i.plugin
    ) : n = new O1(
      e,
      a === void 0 ? t : { column: s, line: t },
      a === void 0 ? s : { column: o, line: a },
      this.css,
      this.file,
      i.plugin
    ), n.input = { column: s, endColumn: o, endLine: a, line: t, source: this.css }, this.file && (Tu && (n.input.url = Tu(this.file).toString()), n.input.file = this.file), n;
  }
  fromOffset(e) {
    let t, s;
    if (this[Qf])
      s = this[Qf];
    else {
      let n = this.css.split(`
`);
      s = new Array(n.length);
      let a = 0;
      for (let o = 0, u = n.length; o < u; o++)
        s[o] = a, a += n[o].length + 1;
      this[Qf] = s;
    }
    t = s[s.length - 1];
    let i = 0;
    if (e >= t)
      i = s.length - 1;
    else {
      let n = s.length - 2, a;
      for (; i < n; )
        if (a = i + (n - i >> 1), e < s[a])
          n = a - 1;
        else if (e >= s[a + 1])
          i = a + 1;
        else {
          i = a;
          break;
        }
    }
    return {
      col: e - s[i] + 1,
      line: i + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : gh(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, t, s, i) {
    if (!this.map) return !1;
    let n = this.map.consumer(), a = n.originalPositionFor({ column: t, line: e });
    if (!a.source) return !1;
    let o;
    typeof s == "number" && (o = n.originalPositionFor({ column: i, line: s }));
    let u;
    mh(a.source) ? u = Tu(a.source) : u = new URL(
      a.source,
      this.map.consumer().sourceRoot || Tu(this.map.mapFile)
    );
    let l = {
      column: a.column,
      endColumn: o && o.column,
      endLine: o && o.line,
      line: a.line,
      url: u.toString()
    };
    if (u.protocol === "file:")
      if (N1)
        l.file = N1(u);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let c = n.sourceContentFor(a.source);
    return c && (l.source = c), l;
  }
  toJSON() {
    let e = {};
    for (let t of ["hasBOM", "css", "file", "id"])
      this[t] != null && (e[t] = this[t]);
    return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
  get from() {
    return this.file || this.id;
  }
};
var sf = Bl;
Bl.default = Bl;
Yf && Yf.registerInput && Yf.registerInput(Bl);
let { SourceMapConsumer: X_, SourceMapGenerator: Gu } = Zn, { dirname: Ku, relative: J_, resolve: Y_, sep: Q_ } = S0, { pathToFileURL: k1 } = G_, tL = sf, rL = !!(X_ && Gu), sL = !!(Ku && Y_ && J_ && Q_), iL = class {
  constructor(e, t, s, i) {
    this.stringify = e, this.mapOpts = s.map || {}, this.root = t, this.opts = s, this.css = i, this.originalCSS = i, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let t = `
`;
    this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let t = this.toUrl(this.path(e.file)), s = e.root || Ku(e.file), i;
      this.mapOpts.sourcesContent === !1 ? (i = new X_(e.text), i.sourcesContent && (i.sourcesContent = null)) : i = e.consumer(), this.map.applySourceMap(i, t, this.toUrl(this.path(s)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let t = this.root.nodes.length - 1; t >= 0; t--)
          e = this.root.nodes[t], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(t);
      } else this.css && (this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), sL && rL && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (t) => {
        e += t;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = Gu.fromSourceMap(e, {
        ignoreInvalidMapping: !0
      });
    } else
      this.map = new Gu({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new Gu({
      file: this.outputFile(),
      ignoreInvalidMapping: !0
    });
    let e = 1, t = 1, s = "<no source>", i = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, n, a;
    this.stringify(this.root, (o, u, l) => {
      if (this.css += o, u && l !== "end" && (i.generated.line = e, i.generated.column = t - 1, u.source && u.source.start ? (i.source = this.sourcePath(u), i.original.line = u.source.start.line, i.original.column = u.source.start.column - 1, this.map.addMapping(i)) : (i.source = s, i.original.line = 1, i.original.column = 0, this.map.addMapping(i))), n = o.match(/\n/g), n ? (e += n.length, a = o.lastIndexOf(`
`), t = o.length - a) : t += o.length, u && l !== "start") {
        let c = u.parent || { raws: {} };
        (!(u.type === "decl" || u.type === "atrule" && !u.nodes) || u !== c.last || c.raws.semicolon) && (u.source && u.source.end ? (i.source = this.sourcePath(u), i.original.line = u.source.end.line, i.original.column = u.source.end.column - 1, i.generated.line = e, i.generated.column = t - 2, this.map.addMapping(i)) : (i.source = s, i.original.line = 1, i.original.column = 0, i.generated.line = e, i.generated.column = t - 1, this.map.addMapping(i)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e)) return e;
    let t = this.memoizedPaths.get(e);
    if (t) return t;
    let s = this.opts.to ? Ku(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (s = Ku(Y_(s, this.mapOpts.annotation)));
    let i = J_(s, e);
    return this.memoizedPaths.set(e, i), i;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let t = e.source.input.map;
            this.previousMaps.includes(t) || this.previousMaps.push(t);
          }
        });
      else {
        let e = new tL(this.originalCSS, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((t) => {
        if (t.source) {
          let s = t.source.input.from;
          if (s && !e[s]) {
            e[s] = !0;
            let i = this.usesFileUrls ? this.toFileUrl(s) : this.toUrl(this.path(s));
            this.map.setSourceContent(i, t.source.input.css);
          }
        }
      });
    else if (this.css) {
      let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(t, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return H ? H.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let t = this.memoizedFileURLs.get(e);
    if (t) return t;
    if (k1) {
      let s = k1(e).toString();
      return this.memoizedFileURLs.set(e, s), s;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let t = this.memoizedURLs.get(e);
    if (t) return t;
    Q_ === "\\" && (e = e.replace(/\\/g, "/"));
    let s = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, s), s;
  }
};
var Z_ = iL;
let nL = tf, yh = class extends nL {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var nf = yh;
yh.default = yh;
let { isClean: ex, my: tx } = Go, rx = rf, sx = nf, aL = tf, ix, w0, T0, nx;
function ax(r) {
  return r.map((e) => (e.nodes && (e.nodes = ax(e.nodes)), delete e.source, e));
}
function ox(r) {
  if (r[ex] = !1, r.proxyOf.nodes)
    for (let e of r.proxyOf.nodes)
      ox(e);
}
let Cs = class ux extends aL {
  append(...e) {
    for (let t of e) {
      let s = this.normalize(t, this.last);
      for (let i of s) this.proxyOf.nodes.push(i);
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let t of this.nodes) t.cleanRaws(e);
  }
  each(e) {
    if (!this.proxyOf.nodes) return;
    let t = this.getIterator(), s, i;
    for (; this.indexes[t] < this.proxyOf.nodes.length && (s = this.indexes[t], i = e(this.proxyOf.nodes[s], s), i !== !1); )
      this.indexes[t] += 1;
    return delete this.indexes[t], i;
  }
  every(e) {
    return this.nodes.every(e);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : e[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? (...s) => e[t](
          ...s.map((i) => typeof i == "function" ? (n, a) => i(n.toProxy(), a) : i)
        ) : t === "every" || t === "some" ? (s) => e[t](
          (i, ...n) => s(i.toProxy(), ...n)
        ) : t === "root" ? () => e.root().toProxy() : t === "nodes" ? e.nodes.map((s) => s.toProxy()) : t === "first" || t === "last" ? e[t].toProxy() : e[t] : e[t];
      },
      set(e, t, s) {
        return e[t] === s || (e[t] = s, (t === "name" || t === "params" || t === "selector") && e.markDirty()), !0;
      }
    };
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  insertAfter(e, t) {
    let s = this.index(e), i = this.normalize(t, this.proxyOf.nodes[s]).reverse();
    s = this.index(e);
    for (let a of i) this.proxyOf.nodes.splice(s + 1, 0, a);
    let n;
    for (let a in this.indexes)
      n = this.indexes[a], s < n && (this.indexes[a] = n + i.length);
    return this.markDirty(), this;
  }
  insertBefore(e, t) {
    let s = this.index(e), i = s === 0 ? "prepend" : !1, n = this.normalize(
      t,
      this.proxyOf.nodes[s],
      i
    ).reverse();
    s = this.index(e);
    for (let o of n) this.proxyOf.nodes.splice(s, 0, o);
    let a;
    for (let o in this.indexes)
      a = this.indexes[o], s <= a && (this.indexes[o] = a + n.length);
    return this.markDirty(), this;
  }
  normalize(e, t) {
    if (typeof e == "string")
      e = ax(ix(e).nodes);
    else if (typeof e > "u")
      e = [];
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let i of e)
        i.parent && i.parent.removeChild(i, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let i of e)
        i.parent && i.parent.removeChild(i, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value > "u")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new rx(e)];
    } else if (e.selector)
      e = [new w0(e)];
    else if (e.name)
      e = [new T0(e)];
    else if (e.text)
      e = [new sx(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((i) => (i[tx] || ux.rebuild(i), i = i.proxyOf, i.parent && i.parent.removeChild(i), i[ex] && ox(i), typeof i.raws.before > "u" && t && typeof t.raws.before < "u" && (i.raws.before = t.raws.before.replace(/\S/g, "")), i.parent = this.proxyOf, i));
  }
  prepend(...e) {
    e = e.reverse();
    for (let t of e) {
      let s = this.normalize(t, this.first, "prepend").reverse();
      for (let i of s) this.proxyOf.nodes.unshift(i);
      for (let i in this.indexes)
        this.indexes[i] = this.indexes[i] + s.length;
    }
    return this.markDirty(), this;
  }
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes) e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let t;
    for (let s in this.indexes)
      t = this.indexes[s], t >= e && (this.indexes[s] = t - 1);
    return this.markDirty(), this;
  }
  replaceValues(e, t, s) {
    return s || (s = t, t = {}), this.walkDecls((i) => {
      t.props && !t.props.includes(i.prop) || t.fast && !i.value.includes(t.fast) || (i.value = i.value.replace(e, s));
    }), this.markDirty(), this;
  }
  some(e) {
    return this.nodes.some(e);
  }
  walk(e) {
    return this.each((t, s) => {
      let i;
      try {
        i = e(t, s);
      } catch (n) {
        throw t.addToError(n);
      }
      return i !== !1 && t.walk && (i = t.walk(e)), i;
    });
  }
  walkAtRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((s, i) => {
      if (s.type === "atrule" && e.test(s.name))
        return t(s, i);
    }) : this.walk((s, i) => {
      if (s.type === "atrule" && s.name === e)
        return t(s, i);
    }) : (t = e, this.walk((s, i) => {
      if (s.type === "atrule")
        return t(s, i);
    }));
  }
  walkComments(e) {
    return this.walk((t, s) => {
      if (t.type === "comment")
        return e(t, s);
    });
  }
  walkDecls(e, t) {
    return t ? e instanceof RegExp ? this.walk((s, i) => {
      if (s.type === "decl" && e.test(s.prop))
        return t(s, i);
    }) : this.walk((s, i) => {
      if (s.type === "decl" && s.prop === e)
        return t(s, i);
    }) : (t = e, this.walk((s, i) => {
      if (s.type === "decl")
        return t(s, i);
    }));
  }
  walkRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((s, i) => {
      if (s.type === "rule" && e.test(s.selector))
        return t(s, i);
    }) : this.walk((s, i) => {
      if (s.type === "rule" && s.selector === e)
        return t(s, i);
    }) : (t = e, this.walk((s, i) => {
      if (s.type === "rule")
        return t(s, i);
    }));
  }
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Cs.registerParse = (r) => {
  ix = r;
};
Cs.registerRule = (r) => {
  w0 = r;
};
Cs.registerAtRule = (r) => {
  T0 = r;
};
Cs.registerRoot = (r) => {
  nx = r;
};
var on = Cs;
Cs.default = Cs;
Cs.rebuild = (r) => {
  r.type === "atrule" ? Object.setPrototypeOf(r, T0.prototype) : r.type === "rule" ? Object.setPrototypeOf(r, w0.prototype) : r.type === "decl" ? Object.setPrototypeOf(r, rx.prototype) : r.type === "comment" ? Object.setPrototypeOf(r, sx.prototype) : r.type === "root" && Object.setPrototypeOf(r, nx.prototype), r[tx] = !0, r.nodes && r.nodes.forEach((e) => {
    Cs.rebuild(e);
  });
};
let oL = on, lx, cx, Eo = class extends oL {
  constructor(e) {
    super({ type: "document", ...e }), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new lx(new cx(), this, e).stringify();
  }
};
Eo.registerLazyResult = (r) => {
  lx = r;
};
Eo.registerProcessor = (r) => {
  cx = r;
};
var P0 = Eo;
Eo.default = Eo;
let D1 = {};
var fx = function(e) {
  D1[e] || (D1[e] = !0, typeof console < "u" && console.warn && console.warn(e));
};
let bh = class {
  constructor(e, t = {}) {
    if (this.type = "warning", this.text = e, t.node && t.node.source) {
      let s = t.node.rangeBy(t);
      this.line = s.start.line, this.column = s.start.column, this.endLine = s.end.line, this.endColumn = s.end.column;
    }
    for (let s in t) this[s] = t[s];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var px = bh;
bh.default = bh;
let uL = px, vh = class {
  constructor(e, t, s) {
    this.processor = e, this.messages = [], this.root = t, this.opts = s, this.css = void 0, this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, t = {}) {
    t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
    let s = new uL(e, t);
    return this.messages.push(s), s;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var A0 = vh;
vh.default = vh;
let hx = on, Vl = class extends hx {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var C0 = Vl;
Vl.default = Vl;
hx.registerAtRule(Vl);
let dx = on, mx, gx, jn = class extends dx {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, t, s) {
    let i = super.normalize(e);
    if (t) {
      if (s === "prepend")
        this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
      else if (this.first !== t)
        for (let n of i)
          n.raws.before = t.raws.before;
    }
    return i;
  }
  removeChild(e, t) {
    let s = this.index(e);
    return !t && s === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[s].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new mx(new gx(), this, e).stringify();
  }
};
jn.registerLazyResult = (r) => {
  mx = r;
};
jn.registerProcessor = (r) => {
  gx = r;
};
var Ko = jn;
jn.default = jn;
dx.registerRoot(jn);
let So = {
  comma(r) {
    return So.split(r, [","], !0);
  },
  space(r) {
    let e = [" ", `
`, "	"];
    return So.split(r, e);
  },
  split(r, e, t) {
    let s = [], i = "", n = !1, a = 0, o = !1, u = "", l = !1;
    for (let c of r)
      l ? l = !1 : c === "\\" ? l = !0 : o ? c === u && (o = !1) : c === '"' || c === "'" ? (o = !0, u = c) : c === "(" ? a += 1 : c === ")" ? a > 0 && (a -= 1) : a === 0 && e.includes(c) && (n = !0), n ? (i !== "" && s.push(i.trim()), i = "", n = !1) : i += c;
    return (t || i !== "") && s.push(i.trim()), s;
  }
};
var yx = So;
So.default = So;
let bx = on, lL = yx, Ul = class extends bx {
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
  get selectors() {
    return lL.comma(this.selector);
  }
  set selectors(e) {
    let t = this.selector ? this.selector.match(/,\s*/) : null, s = t ? t[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(s);
  }
};
var N0 = Ul;
Ul.default = Ul;
bx.registerRule(Ul);
let cL = rf, fL = U_, pL = nf, hL = C0, dL = Ko, L1 = N0;
const M1 = {
  empty: !0,
  space: !0
};
function mL(r) {
  for (let e = r.length - 1; e >= 0; e--) {
    let t = r[e], s = t[3] || t[2];
    if (s) return s;
  }
}
let gL = class {
  constructor(e) {
    this.input = e, this.root = new dL(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let t = new hL();
    t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
    let s, i, n, a = !1, o = !1, u = [], l = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), s = e[0], s === "(" || s === "[" ? l.push(s === "(" ? ")" : "]") : s === "{" && l.length > 0 ? l.push("}") : s === l[l.length - 1] && l.pop(), l.length === 0)
        if (s === ";") {
          t.source.end = this.getPosition(e[2]), t.source.end.offset++, this.semicolon = !0;
          break;
        } else if (s === "{") {
          o = !0;
          break;
        } else if (s === "}") {
          if (u.length > 0) {
            for (n = u.length - 1, i = u[n]; i && i[0] === "space"; )
              i = u[--n];
            i && (t.source.end = this.getPosition(i[3] || i[2]), t.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          u.push(e);
      else
        u.push(e);
      if (this.tokenizer.endOfFile()) {
        a = !0;
        break;
      }
    }
    t.raws.between = this.spacesAndCommentsFromEnd(u), u.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(u), this.raw(t, "params", u), a && (e = u[u.length - 1], t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++, this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), o && (t.nodes = [], this.current = t);
  }
  checkMissedSemicolon(e) {
    let t = this.colon(e);
    if (t === !1) return;
    let s = 0, i;
    for (let n = t - 1; n >= 0 && (i = e[n], !(i[0] !== "space" && (s += 1, s === 2))); n--)
      ;
    throw this.input.error(
      "Missed semicolon",
      i[0] === "word" ? i[3] + 1 : i[2]
    );
  }
  colon(e) {
    let t = 0, s, i, n;
    for (let [a, o] of e.entries()) {
      if (s = o, i = s[0], i === "(" && (t += 1), i === ")" && (t -= 1), t === 0 && i === ":")
        if (!n)
          this.doubleColon(s);
        else {
          if (n[0] === "word" && n[1] === "progid")
            continue;
          return a;
        }
      n = s;
    }
    return !1;
  }
  comment(e) {
    let t = new pL();
    this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++;
    let s = e[1].slice(2, -2);
    if (/^\s*$/.test(s))
      t.text = "", t.raws.left = s, t.raws.right = "";
    else {
      let i = s.match(/^(\s*)([^]*\S)(\s*)$/);
      t.text = i[2], t.raws.left = i[1], t.raws.right = i[3];
    }
  }
  createTokenizer() {
    this.tokenizer = fL(this.input);
  }
  decl(e, t) {
    let s = new cL();
    this.init(s, e[0][2]);
    let i = e[e.length - 1];
    for (i[0] === ";" && (this.semicolon = !0, e.pop()), s.source.end = this.getPosition(
      i[3] || i[2] || mL(e)
    ), s.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), s.raws.before += e.shift()[1];
    for (s.source.start = this.getPosition(e[0][2]), s.prop = ""; e.length; ) {
      let l = e[0][0];
      if (l === ":" || l === "space" || l === "comment")
        break;
      s.prop += e.shift()[1];
    }
    s.raws.between = "";
    let n;
    for (; e.length; )
      if (n = e.shift(), n[0] === ":") {
        s.raws.between += n[1];
        break;
      } else
        n[0] === "word" && /\w/.test(n[1]) && this.unknownWord([n]), s.raws.between += n[1];
    (s.prop[0] === "_" || s.prop[0] === "*") && (s.raws.before += s.prop[0], s.prop = s.prop.slice(1));
    let a = [], o;
    for (; e.length && (o = e[0][0], !(o !== "space" && o !== "comment")); )
      a.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let l = e.length - 1; l >= 0; l--) {
      if (n = e[l], n[1].toLowerCase() === "!important") {
        s.important = !0;
        let c = this.stringFrom(e, l);
        c = this.spacesFromEnd(e) + c, c !== " !important" && (s.raws.important = c);
        break;
      } else if (n[1].toLowerCase() === "important") {
        let c = e.slice(0), f = "";
        for (let p = l; p > 0; p--) {
          let h = c[p][0];
          if (f.trim().indexOf("!") === 0 && h !== "space")
            break;
          f = c.pop()[1] + f;
        }
        f.trim().indexOf("!") === 0 && (s.important = !0, s.raws.important = f, e = c);
      }
      if (n[0] !== "space" && n[0] !== "comment")
        break;
    }
    e.some((l) => l[0] !== "space" && l[0] !== "comment") && (s.raws.between += a.map((l) => l[1]).join(""), a = []), this.raw(s, "value", a.concat(e), t), s.value.includes(":") && !t && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let t = new L1();
    this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let t = this.current.nodes[this.current.nodes.length - 1];
      t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "");
    }
  }
  // Helpers
  getPosition(e) {
    let t = this.input.fromOffset(e);
    return {
      column: t.col,
      line: t.line,
      offset: e
    };
  }
  init(e, t) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(t)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let t = !1, s = null, i = !1, n = null, a = [], o = e[1].startsWith("--"), u = [], l = e;
    for (; l; ) {
      if (s = l[0], u.push(l), s === "(" || s === "[")
        n || (n = l), a.push(s === "(" ? ")" : "]");
      else if (o && i && s === "{")
        n || (n = l), a.push("}");
      else if (a.length === 0)
        if (s === ";")
          if (i) {
            this.decl(u, o);
            return;
          } else
            break;
        else if (s === "{") {
          this.rule(u);
          return;
        } else if (s === "}") {
          this.tokenizer.back(u.pop()), t = !0;
          break;
        } else s === ":" && (i = !0);
      else s === a[a.length - 1] && (a.pop(), a.length === 0 && (n = null));
      l = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (t = !0), a.length > 0 && this.unclosedBracket(n), t && i) {
      if (!o)
        for (; u.length && (l = u[u.length - 1][0], !(l !== "space" && l !== "comment")); )
          this.tokenizer.back(u.pop());
      this.decl(u, o);
    } else
      this.unknownWord(u);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, t, s, i) {
    let n, a, o = s.length, u = "", l = !0, c, f;
    for (let p = 0; p < o; p += 1)
      n = s[p], a = n[0], a === "space" && p === o - 1 && !i ? l = !1 : a === "comment" ? (f = s[p - 1] ? s[p - 1][0] : "empty", c = s[p + 1] ? s[p + 1][0] : "empty", !M1[f] && !M1[c] ? u.slice(-1) === "," ? l = !1 : u += n[1] : l = !1) : u += n[1];
    if (!l) {
      let p = s.reduce((h, m) => h + m[1], "");
      e.raws[t] = { raw: p, value: u };
    }
    e[t] = u;
  }
  rule(e) {
    e.pop();
    let t = new L1();
    this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
  }
  spacesAndCommentsFromEnd(e) {
    let t, s = "";
    for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment")); )
      s = e.pop()[1] + s;
    return s;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let t, s = "";
    for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment")); )
      s += e.shift()[1];
    return s;
  }
  spacesFromEnd(e) {
    let t, s = "";
    for (; e.length && (t = e[e.length - 1][0], t === "space"); )
      s = e.pop()[1] + s;
    return s;
  }
  stringFrom(e, t) {
    let s = "";
    for (let i = t; i < e.length; i++)
      s += e[i][1];
    return e.splice(t, e.length - t), s;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word",
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, t) {
    throw this.input.error(
      "At-rule without name",
      { offset: t[2] },
      { offset: t[2] + t[1].length }
    );
  }
};
var yL = gL;
let bL = on, vL = yL, EL = sf;
function jl(r, e) {
  let t = new EL(r, e), s = new vL(t);
  try {
    s.parse();
  } catch (i) {
    throw Zt.env.NODE_ENV !== "production" && i.name === "CssSyntaxError" && e && e.from && (/\.scss$/i.test(e.from) ? i.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(e.from) ? i.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(e.from) && (i.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), i;
  }
  return s.root;
}
var O0 = jl;
jl.default = jl;
bL.registerParse(jl);
let { isClean: Lr, my: SL } = Go, _L = Z_, xL = ef, wL = on, TL = P0, PL = fx, R1 = A0, AL = O0, CL = Ko;
const NL = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, OL = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, IL = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, qn = 0;
function _a(r) {
  return typeof r == "object" && typeof r.then == "function";
}
function vx(r) {
  let e = !1, t = NL[r.type];
  return r.type === "decl" ? e = r.prop.toLowerCase() : r.type === "atrule" && (e = r.name.toLowerCase()), e && r.append ? [
    t,
    t + "-" + e,
    qn,
    t + "Exit",
    t + "Exit-" + e
  ] : e ? [t, t + "-" + e, t + "Exit", t + "Exit-" + e] : r.append ? [t, qn, t + "Exit"] : [t, t + "Exit"];
}
function $1(r) {
  let e;
  return r.type === "document" ? e = ["Document", qn, "DocumentExit"] : r.type === "root" ? e = ["Root", qn, "RootExit"] : e = vx(r), {
    eventIndex: 0,
    events: e,
    iterator: 0,
    node: r,
    visitorIndex: 0,
    visitors: []
  };
}
function Eh(r) {
  return r[Lr] = !1, r.nodes && r.nodes.forEach((e) => Eh(e)), r;
}
let Sh = {}, Hn = class Ex {
  constructor(e, t, s) {
    this.stringified = !1, this.processed = !1;
    let i;
    if (typeof t == "object" && t !== null && (t.type === "root" || t.type === "document"))
      i = Eh(t);
    else if (t instanceof Ex || t instanceof R1)
      i = Eh(t.root), t.map && (typeof s.map > "u" && (s.map = {}), s.map.inline || (s.map.inline = !1), s.map.prev = t.map);
    else {
      let n = AL;
      s.syntax && (n = s.syntax.parse), s.parser && (n = s.parser), n.parse && (n = n.parse);
      try {
        i = n(t, s);
      } catch (a) {
        this.processed = !0, this.error = a;
      }
      i && !i[SL] && wL.rebuild(i);
    }
    this.result = new R1(e, i, s), this.helpers = { ...Sh, postcss: Sh, result: this.result }, this.plugins = this.processor.plugins.map((n) => typeof n == "object" && n.prepare ? { ...n, ...n.prepare(this.result) } : n);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, t) {
    let s = this.result.lastPlugin;
    try {
      if (t && t.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin)
        e.plugin = s.postcssPlugin, e.setMessage();
      else if (s.postcssVersion && Zt.env.NODE_ENV !== "production") {
        let i = s.postcssPlugin, n = s.postcssVersion, a = this.result.processor.version, o = n.split("."), u = a.split(".");
        (o[0] !== u[0] || parseInt(o[1]) > parseInt(u[1])) && console.error(
          "Unknown error from PostCSS plugin. Your current PostCSS version is " + a + ", but " + i + " uses " + n + ". Perhaps this is the source of the error below."
        );
      }
    } catch (i) {
      console && console.error && console.error(i);
    }
    return e;
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (t, s, i) => {
      this.listeners[s] || (this.listeners[s] = []), this.listeners[s].push([t, i]);
    };
    for (let t of this.plugins)
      if (typeof t == "object")
        for (let s in t) {
          if (!OL[s] && /^[A-Z]/.test(s))
            throw new Error(
              `Unknown event ${s} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!IL[s])
            if (typeof t[s] == "object")
              for (let i in t[s])
                i === "*" ? e(t, s, t[s][i]) : e(
                  t,
                  s + "-" + i.toLowerCase(),
                  t[s][i]
                );
            else typeof t[s] == "function" && e(t, s, t[s]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let e = 0; e < this.plugins.length; e++) {
      let t = this.plugins[e], s = this.runOnRoot(t);
      if (_a(s))
        try {
          await s;
        } catch (i) {
          throw this.handleError(i);
        }
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Lr]; ) {
        e[Lr] = !0;
        let t = [$1(e)];
        for (; t.length > 0; ) {
          let s = this.visitTick(t);
          if (_a(s))
            try {
              await s;
            } catch (i) {
              let n = t[t.length - 1].node;
              throw this.handleError(i, n);
            }
        }
      }
      if (this.listeners.OnceExit)
        for (let [t, s] of this.listeners.OnceExit) {
          this.result.lastPlugin = t;
          try {
            if (e.type === "document") {
              let i = e.nodes.map(
                (n) => s(n, this.helpers)
              );
              await Promise.all(i);
            } else
              await s(e, this.helpers);
          } catch (i) {
            throw this.handleError(i);
          }
        }
    }
    return this.processed = !0, this.stringify();
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let t = this.result.root.nodes.map(
            (s) => e.Once(s, this.helpers)
          );
          return _a(t[0]) ? Promise.all(t) : t;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (t) {
      throw this.handleError(t);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, t = xL;
    e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
    let i = new _L(t, this.result.root, this.result.opts).generate();
    return this.result.css = i[0], this.result.map = i[1], this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let t = this.runOnRoot(e);
      if (_a(t))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Lr]; )
        e[Lr] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let t of e.nodes)
            this.visitSync(this.listeners.OnceExit, t);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  then(e, t) {
    return Zt.env.NODE_ENV !== "production" && ("from" in this.opts || PL(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this.css;
  }
  visitSync(e, t) {
    for (let [s, i] of e) {
      this.result.lastPlugin = s;
      let n;
      try {
        n = i(t, this.helpers);
      } catch (a) {
        throw this.handleError(a, t.proxyOf);
      }
      if (t.type !== "root" && t.type !== "document" && !t.parent)
        return !0;
      if (_a(n))
        throw this.getAsyncError();
    }
  }
  visitTick(e) {
    let t = e[e.length - 1], { node: s, visitors: i } = t;
    if (s.type !== "root" && s.type !== "document" && !s.parent) {
      e.pop();
      return;
    }
    if (i.length > 0 && t.visitorIndex < i.length) {
      let [a, o] = i[t.visitorIndex];
      t.visitorIndex += 1, t.visitorIndex === i.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = a;
      try {
        return o(s.toProxy(), this.helpers);
      } catch (u) {
        throw this.handleError(u, s);
      }
    }
    if (t.iterator !== 0) {
      let a = t.iterator, o;
      for (; o = s.nodes[s.indexes[a]]; )
        if (s.indexes[a] += 1, !o[Lr]) {
          o[Lr] = !0, e.push($1(o));
          return;
        }
      t.iterator = 0, delete s.indexes[a];
    }
    let n = t.events;
    for (; t.eventIndex < n.length; ) {
      let a = n[t.eventIndex];
      if (t.eventIndex += 1, a === qn) {
        s.nodes && s.nodes.length && (s[Lr] = !0, t.iterator = s.getIterator());
        return;
      } else if (this.listeners[a]) {
        t.visitors = this.listeners[a];
        return;
      }
    }
    e.pop();
  }
  walkSync(e) {
    e[Lr] = !0;
    let t = vx(e);
    for (let s of t)
      if (s === qn)
        e.nodes && e.each((i) => {
          i[Lr] || this.walkSync(i);
        });
      else {
        let i = this.listeners[s];
        if (i && this.visitSync(i, e.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
Hn.registerPostcss = (r) => {
  Sh = r;
};
var Sx = Hn;
Hn.default = Hn;
CL.registerLazyResult(Hn);
TL.registerLazyResult(Hn);
let kL = Z_, DL = ef, LL = fx, ML = O0;
const RL = A0;
let _h = class {
  constructor(e, t, s) {
    t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = s, this._map = void 0;
    let i, n = DL;
    this.result = new RL(this._processor, i, this._opts), this.result.css = t;
    let a = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return a.root;
      }
    });
    let o = new kL(n, i, this._opts, t);
    if (o.isMap()) {
      let [u, l] = o.generate();
      u && (this.result.css = u), l && (this.result.map = l);
    } else
      o.clearAnnotation(), this.result.css = o.css;
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(e, t) {
    return Zt.env.NODE_ENV !== "production" && ("from" in this._opts || LL(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, t = ML;
    try {
      e = t(this._css, this._opts);
    } catch (s) {
      this.error = s;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var $L = _h;
_h.default = _h;
let FL = $L, BL = Sx, VL = P0, UL = Ko, _o = class {
  constructor(e = []) {
    this.version = "8.4.40", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let t = [];
    for (let s of e)
      if (s.postcss === !0 ? s = s() : s.postcss && (s = s.postcss), typeof s == "object" && Array.isArray(s.plugins))
        t = t.concat(s.plugins);
      else if (typeof s == "object" && s.postcssPlugin)
        t.push(s);
      else if (typeof s == "function")
        t.push(s);
      else if (typeof s == "object" && (s.parse || s.stringify)) {
        if (Zt.env.NODE_ENV !== "production")
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
      } else
        throw new Error(s + " is not a PostCSS plugin");
    return t;
  }
  process(e, t = {}) {
    return !this.plugins.length && !t.parser && !t.stringifier && !t.syntax ? new FL(this, e, t) : new BL(this, e, t);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var jL = _o;
_o.default = _o;
UL.registerProcessor(_o);
VL.registerProcessor(_o);
let qL = rf, HL = K_, WL = nf, zL = C0, GL = sf, KL = Ko, XL = N0;
function xo(r, e) {
  if (Array.isArray(r)) return r.map((i) => xo(i));
  let { inputs: t, ...s } = r;
  if (t) {
    e = [];
    for (let i of t) {
      let n = { ...i, __proto__: GL.prototype };
      n.map && (n.map = {
        ...n.map,
        __proto__: HL.prototype
      }), e.push(n);
    }
  }
  if (s.nodes && (s.nodes = r.nodes.map((i) => xo(i, e))), s.source) {
    let { inputId: i, ...n } = s.source;
    s.source = n, i != null && (s.source.input = e[i]);
  }
  if (s.type === "root")
    return new KL(s);
  if (s.type === "decl")
    return new qL(s);
  if (s.type === "rule")
    return new XL(s);
  if (s.type === "comment")
    return new WL(s);
  if (s.type === "atrule")
    return new zL(s);
  throw new Error("Unknown node type: " + r.type);
}
var JL = xo;
xo.default = xo;
let YL = x0, _x = rf, QL = Sx, ZL = on, I0 = jL, eM = ef, tM = JL, xx = P0, rM = px, wx = nf, Tx = C0, sM = A0, iM = sf, nM = O0, aM = yx, Px = N0, Ax = Ko, oM = tf;
function je(...r) {
  return r.length === 1 && Array.isArray(r[0]) && (r = r[0]), new I0(r);
}
je.plugin = function(e, t) {
  let s = !1;
  function i(...a) {
    console && console.warn && !s && (s = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), Zt.env.LANG && Zt.env.LANG.startsWith("cn") && console.warn(
      e + `:  postcss.plugin . :
https://www.w3ctech.com/topic/2226`
    ));
    let o = t(...a);
    return o.postcssPlugin = e, o.postcssVersion = new I0().version, o;
  }
  let n;
  return Object.defineProperty(i, "postcss", {
    get() {
      return n || (n = i()), n;
    }
  }), i.process = function(a, o, u) {
    return je([i(u)]).process(a, o);
  }, i;
};
je.stringify = eM;
je.parse = nM;
je.fromJSON = tM;
je.list = aM;
je.comment = (r) => new wx(r);
je.atRule = (r) => new Tx(r);
je.decl = (r) => new _x(r);
je.rule = (r) => new Px(r);
je.root = (r) => new Ax(r);
je.document = (r) => new xx(r);
je.CssSyntaxError = YL;
je.Declaration = _x;
je.Container = ZL;
je.Processor = I0;
je.Document = xx;
je.Comment = wx;
je.Warning = rM;
je.AtRule = Tx;
je.Result = sM;
je.Input = iM;
je.Rule = Px;
je.Root = Ax;
je.Node = oM;
QL.registerPostcss(je);
var uM = je;
je.default = je;
var Ze = /* @__PURE__ */ Dc(uM);
Ze.stringify;
Ze.fromJSON;
Ze.plugin;
Ze.parse;
Ze.list;
Ze.document;
Ze.comment;
Ze.atRule;
Ze.rule;
Ze.decl;
Ze.root;
Ze.CssSyntaxError;
Ze.Declaration;
Ze.Container;
Ze.Processor;
Ze.Document;
Ze.Comment;
Ze.Warning;
Ze.AtRule;
Ze.Result;
Ze.Input;
Ze.Rule;
Ze.Root;
Ze.Node;
const Cx = () => ({
  postcssPlugin: "vue-sfc-trim",
  Once(r) {
    r.walk(({ type: e, raws: t }) => {
      (e === "rule" || e === "atrule") && (t.before && (t.before = `
`), "after" in t && t.after && (t.after = `
`));
    });
  }
});
Cx.postcss = !0;
var xh = { exports: {} }, wh = { exports: {} }, Th = { exports: {} }, Ph = { exports: {} }, Ah = { exports: {} }, Ch = { exports: {} }, nr = {}, Nh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = i;
  function t(n) {
    for (var a = n.toLowerCase(), o = "", u = !1, l = 0; l < 6 && a[l] !== void 0; l++) {
      var c = a.charCodeAt(l), f = c >= 97 && c <= 102 || c >= 48 && c <= 57;
      if (u = c === 32, !f)
        break;
      o += a[l];
    }
    if (o.length !== 0) {
      var p = parseInt(o, 16), h = p >= 55296 && p <= 57343;
      return h || p === 0 || p > 1114111 ? ["", o.length + (u ? 1 : 0)] : [String.fromCodePoint(p), o.length + (u ? 1 : 0)];
    }
  }
  var s = /\\/;
  function i(n) {
    var a = s.test(n);
    if (!a)
      return n;
    for (var o = "", u = 0; u < n.length; u++) {
      if (n[u] === "\\") {
        var l = t(n.slice(u + 1, u + 7));
        if (l !== void 0) {
          o += l[0], u += l[1];
          continue;
        }
        if (n[u + 1] === "\\") {
          o += "\\", u++;
          continue;
        }
        n.length === u + 1 && (o += n[u]);
        continue;
      }
      o += n[u];
    }
    return o;
  }
  r.exports = e.default;
})(Nh, Nh.exports);
var Nx = Nh.exports, Oh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = t;
  function t(s) {
    for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
      n[a - 1] = arguments[a];
    for (; n.length > 0; ) {
      var o = n.shift();
      if (!s[o])
        return;
      s = s[o];
    }
    return s;
  }
  r.exports = e.default;
})(Oh, Oh.exports);
var lM = Oh.exports, Ih = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = t;
  function t(s) {
    for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
      n[a - 1] = arguments[a];
    for (; n.length > 0; ) {
      var o = n.shift();
      s[o] || (s[o] = {}), s = s[o];
    }
  }
  r.exports = e.default;
})(Ih, Ih.exports);
var cM = Ih.exports, kh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = t;
  function t(s) {
    for (var i = "", n = s.indexOf("/*"), a = 0; n >= 0; ) {
      i = i + s.slice(a, n);
      var o = s.indexOf("*/", n + 2);
      if (o < 0)
        return i;
      a = o + 2, n = s.indexOf("/*", a);
    }
    return i = i + s.slice(a), i;
  }
  r.exports = e.default;
})(kh, kh.exports);
var fM = kh.exports;
nr.__esModule = !0;
nr.unesc = nr.stripComments = nr.getProp = nr.ensureObject = void 0;
var pM = af(Nx);
nr.unesc = pM.default;
var hM = af(lM);
nr.getProp = hM.default;
var dM = af(cM);
nr.ensureObject = dM.default;
var mM = af(fM);
nr.stripComments = mM.default;
function af(r) {
  return r && r.__esModule ? r : { default: r };
}
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = nr;
  function s(o, u) {
    for (var l = 0; l < u.length; l++) {
      var c = u[l];
      c.enumerable = c.enumerable || !1, c.configurable = !0, "value" in c && (c.writable = !0), Object.defineProperty(o, c.key, c);
    }
  }
  function i(o, u, l) {
    return u && s(o.prototype, u), Object.defineProperty(o, "prototype", { writable: !1 }), o;
  }
  var n = function o(u, l) {
    if (typeof u != "object" || u === null)
      return u;
    var c = new u.constructor();
    for (var f in u)
      if (u.hasOwnProperty(f)) {
        var p = u[f], h = typeof p;
        f === "parent" && h === "object" ? l && (c[f] = l) : p instanceof Array ? c[f] = p.map(function(m) {
          return o(m, c);
        }) : c[f] = o(p, c);
      }
    return c;
  }, a = /* @__PURE__ */ function() {
    function o(l) {
      l === void 0 && (l = {}), Object.assign(this, l), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var u = o.prototype;
    return u.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, u.replaceWith = function() {
      if (this.parent) {
        for (var c in arguments)
          this.parent.insertBefore(this, arguments[c]);
        this.remove();
      }
      return this;
    }, u.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, u.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, u.clone = function(c) {
      c === void 0 && (c = {});
      var f = n(this);
      for (var p in c)
        f[p] = c[p];
      return f;
    }, u.appendToPropertyAndEscape = function(c, f, p) {
      this.raws || (this.raws = {});
      var h = this[c], m = this.raws[c];
      this[c] = h + f, m || p !== f ? this.raws[c] = (m || h) + p : delete this.raws[c];
    }, u.setPropertyAndEscape = function(c, f, p) {
      this.raws || (this.raws = {}), this[c] = f, this.raws[c] = p;
    }, u.setPropertyWithoutEscape = function(c, f) {
      this[c] = f, this.raws && delete this.raws[c];
    }, u.isAtPosition = function(c, f) {
      if (this.source && this.source.start && this.source.end)
        return !(this.source.start.line > c || this.source.end.line < c || this.source.start.line === c && this.source.start.column > f || this.source.end.line === c && this.source.end.column < f);
    }, u.stringifyProperty = function(c) {
      return this.raws && this.raws[c] || this[c];
    }, u.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, u.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, i(o, [{
      key: "rawSpaceBefore",
      get: function() {
        var c = this.raws && this.raws.spaces && this.raws.spaces.before;
        return c === void 0 && (c = this.spaces && this.spaces.before), c || "";
      },
      set: function(c) {
        (0, t.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = c;
      }
    }, {
      key: "rawSpaceAfter",
      get: function() {
        var c = this.raws && this.raws.spaces && this.raws.spaces.after;
        return c === void 0 && (c = this.spaces.after), c || "";
      },
      set: function(c) {
        (0, t.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = c;
      }
    }]), o;
  }();
  e.default = a, r.exports = e.default;
})(Ch, Ch.exports);
var di = Ch.exports, Se = {};
Se.__esModule = !0;
Se.UNIVERSAL = Se.TAG = Se.STRING = Se.SELECTOR = Se.ROOT = Se.PSEUDO = Se.NESTING = Se.ID = Se.COMMENT = Se.COMBINATOR = Se.CLASS = Se.ATTRIBUTE = void 0;
var gM = "tag";
Se.TAG = gM;
var yM = "string";
Se.STRING = yM;
var bM = "selector";
Se.SELECTOR = bM;
var vM = "root";
Se.ROOT = vM;
var EM = "pseudo";
Se.PSEUDO = EM;
var SM = "nesting";
Se.NESTING = SM;
var _M = "id";
Se.ID = _M;
var xM = "comment";
Se.COMMENT = xM;
var wM = "combinator";
Se.COMBINATOR = wM;
var TM = "class";
Se.CLASS = TM;
var PM = "attribute";
Se.ATTRIBUTE = PM;
var AM = "universal";
Se.UNIVERSAL = AM;
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = a(di), s = n(Se);
  function i(d) {
    if (typeof WeakMap != "function") return null;
    var y = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new WeakMap();
    return (i = function(g) {
      return g ? S : y;
    })(d);
  }
  function n(d, y) {
    if (d && d.__esModule)
      return d;
    if (d === null || typeof d != "object" && typeof d != "function")
      return { default: d };
    var S = i(y);
    if (S && S.has(d))
      return S.get(d);
    var E = {}, g = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var b in d)
      if (b !== "default" && Object.prototype.hasOwnProperty.call(d, b)) {
        var v = g ? Object.getOwnPropertyDescriptor(d, b) : null;
        v && (v.get || v.set) ? Object.defineProperty(E, b, v) : E[b] = d[b];
      }
    return E.default = d, S && S.set(d, E), E;
  }
  function a(d) {
    return d && d.__esModule ? d : { default: d };
  }
  function o(d, y) {
    var S = typeof Symbol < "u" && d[Symbol.iterator] || d["@@iterator"];
    if (S) return (S = S.call(d)).next.bind(S);
    if (Array.isArray(d) || (S = u(d)) || y) {
      S && (d = S);
      var E = 0;
      return function() {
        return E >= d.length ? { done: !0 } : { done: !1, value: d[E++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function u(d, y) {
    if (d) {
      if (typeof d == "string") return l(d, y);
      var S = Object.prototype.toString.call(d).slice(8, -1);
      if (S === "Object" && d.constructor && (S = d.constructor.name), S === "Map" || S === "Set") return Array.from(d);
      if (S === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(S)) return l(d, y);
    }
  }
  function l(d, y) {
    (y == null || y > d.length) && (y = d.length);
    for (var S = 0, E = new Array(y); S < y; S++)
      E[S] = d[S];
    return E;
  }
  function c(d, y) {
    for (var S = 0; S < y.length; S++) {
      var E = y[S];
      E.enumerable = E.enumerable || !1, E.configurable = !0, "value" in E && (E.writable = !0), Object.defineProperty(d, E.key, E);
    }
  }
  function f(d, y, S) {
    return y && c(d.prototype, y), Object.defineProperty(d, "prototype", { writable: !1 }), d;
  }
  function p(d, y) {
    d.prototype = Object.create(y.prototype), d.prototype.constructor = d, h(d, y);
  }
  function h(d, y) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(E, g) {
      return E.__proto__ = g, E;
    }, h(d, y);
  }
  var m = /* @__PURE__ */ function(d) {
    p(y, d);
    function y(E) {
      var g;
      return g = d.call(this, E) || this, g.nodes || (g.nodes = []), g;
    }
    var S = y.prototype;
    return S.append = function(g) {
      return g.parent = this, this.nodes.push(g), this;
    }, S.prepend = function(g) {
      return g.parent = this, this.nodes.unshift(g), this;
    }, S.at = function(g) {
      return this.nodes[g];
    }, S.index = function(g) {
      return typeof g == "number" ? g : this.nodes.indexOf(g);
    }, S.removeChild = function(g) {
      g = this.index(g), this.at(g).parent = void 0, this.nodes.splice(g, 1);
      var b;
      for (var v in this.indexes)
        b = this.indexes[v], b >= g && (this.indexes[v] = b - 1);
      return this;
    }, S.removeAll = function() {
      for (var g = o(this.nodes), b; !(b = g()).done; ) {
        var v = b.value;
        v.parent = void 0;
      }
      return this.nodes = [], this;
    }, S.empty = function() {
      return this.removeAll();
    }, S.insertAfter = function(g, b) {
      b.parent = this;
      var v = this.index(g);
      this.nodes.splice(v + 1, 0, b), b.parent = this;
      var A;
      for (var C in this.indexes)
        A = this.indexes[C], v <= A && (this.indexes[C] = A + 1);
      return this;
    }, S.insertBefore = function(g, b) {
      b.parent = this;
      var v = this.index(g);
      this.nodes.splice(v, 0, b), b.parent = this;
      var A;
      for (var C in this.indexes)
        A = this.indexes[C], A <= v && (this.indexes[C] = A + 1);
      return this;
    }, S._findChildAtPosition = function(g, b) {
      var v = void 0;
      return this.each(function(A) {
        if (A.atPosition) {
          var C = A.atPosition(g, b);
          if (C)
            return v = C, !1;
        } else if (A.isAtPosition(g, b))
          return v = A, !1;
      }), v;
    }, S.atPosition = function(g, b) {
      if (this.isAtPosition(g, b))
        return this._findChildAtPosition(g, b) || this;
    }, S._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, S.each = function(g) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var b = this.lastEach;
      if (this.indexes[b] = 0, !!this.length) {
        for (var v, A; this.indexes[b] < this.length && (v = this.indexes[b], A = g(this.at(v), v), A !== !1); )
          this.indexes[b] += 1;
        if (delete this.indexes[b], A === !1)
          return !1;
      }
    }, S.walk = function(g) {
      return this.each(function(b, v) {
        var A = g(b, v);
        if (A !== !1 && b.length && (A = b.walk(g)), A === !1)
          return !1;
      });
    }, S.walkAttributes = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.ATTRIBUTE)
          return g.call(b, v);
      });
    }, S.walkClasses = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.CLASS)
          return g.call(b, v);
      });
    }, S.walkCombinators = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.COMBINATOR)
          return g.call(b, v);
      });
    }, S.walkComments = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.COMMENT)
          return g.call(b, v);
      });
    }, S.walkIds = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.ID)
          return g.call(b, v);
      });
    }, S.walkNesting = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.NESTING)
          return g.call(b, v);
      });
    }, S.walkPseudos = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.PSEUDO)
          return g.call(b, v);
      });
    }, S.walkTags = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.TAG)
          return g.call(b, v);
      });
    }, S.walkUniversals = function(g) {
      var b = this;
      return this.walk(function(v) {
        if (v.type === s.UNIVERSAL)
          return g.call(b, v);
      });
    }, S.split = function(g) {
      var b = this, v = [];
      return this.reduce(function(A, C, x) {
        var _ = g.call(b, C);
        return v.push(C), _ ? (A.push(v), v = []) : x === b.length - 1 && A.push(v), A;
      }, []);
    }, S.map = function(g) {
      return this.nodes.map(g);
    }, S.reduce = function(g, b) {
      return this.nodes.reduce(g, b);
    }, S.every = function(g) {
      return this.nodes.every(g);
    }, S.some = function(g) {
      return this.nodes.some(g);
    }, S.filter = function(g) {
      return this.nodes.filter(g);
    }, S.sort = function(g) {
      return this.nodes.sort(g);
    }, S.toString = function() {
      return this.map(String).join("");
    }, f(y, [{
      key: "first",
      get: function() {
        return this.at(0);
      }
    }, {
      key: "last",
      get: function() {
        return this.at(this.length - 1);
      }
    }, {
      key: "length",
      get: function() {
        return this.nodes.length;
      }
    }]), y;
  }(t.default);
  e.default = m, r.exports = e.default;
})(Ah, Ah.exports);
var k0 = Ah.exports;
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(k0), s = Se;
  function i(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function n(c, f) {
    for (var p = 0; p < f.length; p++) {
      var h = f[p];
      h.enumerable = h.enumerable || !1, h.configurable = !0, "value" in h && (h.writable = !0), Object.defineProperty(c, h.key, h);
    }
  }
  function a(c, f, p) {
    return f && n(c.prototype, f), Object.defineProperty(c, "prototype", { writable: !1 }), c;
  }
  function o(c, f) {
    c.prototype = Object.create(f.prototype), c.prototype.constructor = c, u(c, f);
  }
  function u(c, f) {
    return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(h, m) {
      return h.__proto__ = m, h;
    }, u(c, f);
  }
  var l = /* @__PURE__ */ function(c) {
    o(f, c);
    function f(h) {
      var m;
      return m = c.call(this, h) || this, m.type = s.ROOT, m;
    }
    var p = f.prototype;
    return p.toString = function() {
      var m = this.reduce(function(d, y) {
        return d.push(String(y)), d;
      }, []).join(",");
      return this.trailingComma ? m + "," : m;
    }, p.error = function(m, d) {
      return this._error ? this._error(m, d) : new Error(m);
    }, a(f, [{
      key: "errorGenerator",
      set: function(m) {
        this._error = m;
      }
    }]), f;
  }(t.default);
  e.default = l, r.exports = e.default;
})(Ph, Ph.exports);
var Ox = Ph.exports, Dh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(k0), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.SELECTOR, f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(Dh, Dh.exports);
var Ix = Dh.exports, Lh = { exports: {} };
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var CM = {}, NM = CM.hasOwnProperty, OM = function(e, t) {
  if (!e)
    return t;
  var s = {};
  for (var i in t)
    s[i] = NM.call(e, i) ? e[i] : t[i];
  return s;
}, IM = /[ -,\.\/:-@\[-\^`\{-~]/, kM = /[ -,\.\/:-@\[\]\^`\{-~]/, DM = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, D0 = function r(e, t) {
  t = OM(t, r.options), t.quotes != "single" && t.quotes != "double" && (t.quotes = "single");
  for (var s = t.quotes == "double" ? '"' : "'", i = t.isIdentifier, n = e.charAt(0), a = "", o = 0, u = e.length; o < u; ) {
    var l = e.charAt(o++), c = l.charCodeAt(), f = void 0;
    if (c < 32 || c > 126) {
      if (c >= 55296 && c <= 56319 && o < u) {
        var p = e.charCodeAt(o++);
        (p & 64512) == 56320 ? c = ((c & 1023) << 10) + (p & 1023) + 65536 : o--;
      }
      f = "\\" + c.toString(16).toUpperCase() + " ";
    } else
      t.escapeEverything ? IM.test(l) ? f = "\\" + l : f = "\\" + c.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(l) ? f = "\\" + c.toString(16).toUpperCase() + " " : l == "\\" || !i && (l == '"' && s == l || l == "'" && s == l) || i && kM.test(l) ? f = "\\" + l : f = l;
    a += f;
  }
  return i && (/^-[-\d]/.test(a) ? a = "\\-" + a.slice(1) : /\d/.test(n) && (a = "\\3" + n + " " + a.slice(1))), a = a.replace(DM, function(h, m, d) {
    return m && m.length % 2 ? h : (m || "") + d;
  }), !i && t.wrap ? s + a + s : a;
};
D0.options = {
  escapeEverything: !1,
  isIdentifier: !1,
  quotes: "single",
  wrap: !1
};
D0.version = "3.0.0";
var L0 = D0;
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = a(L0), s = nr, i = a(di), n = Se;
  function a(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, h) {
    for (var m = 0; m < h.length; m++) {
      var d = h[m];
      d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(p, d.key, d);
    }
  }
  function u(p, h, m) {
    return h && o(p.prototype, h), Object.defineProperty(p, "prototype", { writable: !1 }), p;
  }
  function l(p, h) {
    p.prototype = Object.create(h.prototype), p.prototype.constructor = p, c(p, h);
  }
  function c(p, h) {
    return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, y) {
      return d.__proto__ = y, d;
    }, c(p, h);
  }
  var f = /* @__PURE__ */ function(p) {
    l(h, p);
    function h(d) {
      var y;
      return y = p.call(this, d) || this, y.type = n.CLASS, y._constructed = !0, y;
    }
    var m = h.prototype;
    return m.valueToString = function() {
      return "." + p.prototype.valueToString.call(this);
    }, u(h, [{
      key: "value",
      get: function() {
        return this._value;
      },
      set: function(y) {
        if (this._constructed) {
          var S = (0, t.default)(y, {
            isIdentifier: !0
          });
          S !== y ? ((0, s.ensureObject)(this, "raws"), this.raws.value = S) : this.raws && delete this.raws.value;
        }
        this._value = y;
      }
    }]), h;
  }(i.default);
  e.default = f, r.exports = e.default;
})(Lh, Lh.exports);
var kx = Lh.exports, Mh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(di), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.COMMENT, f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(Mh, Mh.exports);
var Dx = Mh.exports, Rh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(di), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(f) {
      var p;
      return p = u.call(this, f) || this, p.type = s.ID, p;
    }
    var c = l.prototype;
    return c.valueToString = function() {
      return "#" + u.prototype.valueToString.call(this);
    }, l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(Rh, Rh.exports);
var Lx = Rh.exports, $h = { exports: {} }, Fh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = n(L0), s = nr, i = n(di);
  function n(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function a(f, p) {
    for (var h = 0; h < p.length; h++) {
      var m = p[h];
      m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(f, m.key, m);
    }
  }
  function o(f, p, h) {
    return p && a(f.prototype, p), Object.defineProperty(f, "prototype", { writable: !1 }), f;
  }
  function u(f, p) {
    f.prototype = Object.create(p.prototype), f.prototype.constructor = f, l(f, p);
  }
  function l(f, p) {
    return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, d) {
      return m.__proto__ = d, m;
    }, l(f, p);
  }
  var c = /* @__PURE__ */ function(f) {
    u(p, f);
    function p() {
      return f.apply(this, arguments) || this;
    }
    var h = p.prototype;
    return h.qualifiedName = function(d) {
      return this.namespace ? this.namespaceString + "|" + d : d;
    }, h.valueToString = function() {
      return this.qualifiedName(f.prototype.valueToString.call(this));
    }, o(p, [{
      key: "namespace",
      get: function() {
        return this._namespace;
      },
      set: function(d) {
        if (d === !0 || d === "*" || d === "&") {
          this._namespace = d, this.raws && delete this.raws.namespace;
          return;
        }
        var y = (0, t.default)(d, {
          isIdentifier: !0
        });
        this._namespace = d, y !== d ? ((0, s.ensureObject)(this, "raws"), this.raws.namespace = y) : this.raws && delete this.raws.namespace;
      }
    }, {
      key: "ns",
      get: function() {
        return this._namespace;
      },
      set: function(d) {
        this.namespace = d;
      }
    }, {
      key: "namespaceString",
      get: function() {
        if (this.namespace) {
          var d = this.stringifyProperty("namespace");
          return d === !0 ? "" : d;
        } else
          return "";
      }
    }]), p;
  }(i.default);
  e.default = c, r.exports = e.default;
})(Fh, Fh.exports);
var M0 = Fh.exports;
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(M0), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.TAG, f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})($h, $h.exports);
var Mx = $h.exports, Bh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(di), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.STRING, f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(Bh, Bh.exports);
var Rx = Bh.exports, Vh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(k0), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(f) {
      var p;
      return p = u.call(this, f) || this, p.type = s.PSEUDO, p;
    }
    var c = l.prototype;
    return c.toString = function() {
      var p = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), p, this.rawSpaceAfter].join("");
    }, l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(Vh, Vh.exports);
var $x = Vh.exports, R0 = {}, LM = nD.deprecate;
(function(r) {
  r.__esModule = !0, r.default = void 0, r.unescapeValue = y;
  var e = a(L0), t = a(Nx), s = a(M0), i = Se, n;
  function a(v) {
    return v && v.__esModule ? v : { default: v };
  }
  function o(v, A) {
    for (var C = 0; C < A.length; C++) {
      var x = A[C];
      x.enumerable = x.enumerable || !1, x.configurable = !0, "value" in x && (x.writable = !0), Object.defineProperty(v, x.key, x);
    }
  }
  function u(v, A, C) {
    return A && o(v.prototype, A), Object.defineProperty(v, "prototype", { writable: !1 }), v;
  }
  function l(v, A) {
    v.prototype = Object.create(A.prototype), v.prototype.constructor = v, c(v, A);
  }
  function c(v, A) {
    return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(x, _) {
      return x.__proto__ = _, x;
    }, c(v, A);
  }
  var f = LM, p = /^('|")([^]*)\1$/, h = f(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), m = f(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), d = f(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function y(v) {
    var A = !1, C = null, x = v, _ = x.match(p);
    return _ && (C = _[1], x = _[2]), x = (0, t.default)(x), x !== v && (A = !0), {
      deprecatedUsage: A,
      unescaped: x,
      quoteMark: C
    };
  }
  function S(v) {
    if (v.quoteMark !== void 0 || v.value === void 0)
      return v;
    d();
    var A = y(v.value), C = A.quoteMark, x = A.unescaped;
    return v.raws || (v.raws = {}), v.raws.value === void 0 && (v.raws.value = v.value), v.value = x, v.quoteMark = C, v;
  }
  var E = /* @__PURE__ */ function(v) {
    l(A, v);
    function A(x) {
      var _;
      return x === void 0 && (x = {}), _ = v.call(this, S(x)) || this, _.type = i.ATTRIBUTE, _.raws = _.raws || {}, Object.defineProperty(_.raws, "unquoted", {
        get: f(function() {
          return _.value;
        }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
        set: f(function() {
          return _.value;
        }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
      }), _._constructed = !0, _;
    }
    var C = A.prototype;
    return C.getQuotedValue = function(_) {
      _ === void 0 && (_ = {});
      var T = this._determineQuoteMark(_), P = g[T], I = (0, e.default)(this._value, P);
      return I;
    }, C._determineQuoteMark = function(_) {
      return _.smart ? this.smartQuoteMark(_) : this.preferredQuoteMark(_);
    }, C.setValue = function(_, T) {
      T === void 0 && (T = {}), this._value = _, this._quoteMark = this._determineQuoteMark(T), this._syncRawValue();
    }, C.smartQuoteMark = function(_) {
      var T = this.value, P = T.replace(/[^']/g, "").length, I = T.replace(/[^"]/g, "").length;
      if (P + I === 0) {
        var $ = (0, e.default)(T, {
          isIdentifier: !0
        });
        if ($ === T)
          return A.NO_QUOTE;
        var Y = this.preferredQuoteMark(_);
        if (Y === A.NO_QUOTE) {
          var W = this.quoteMark || _.quoteMark || A.DOUBLE_QUOTE, F = g[W], K = (0, e.default)(T, F);
          if (K.length < $.length)
            return W;
        }
        return Y;
      } else return I === P ? this.preferredQuoteMark(_) : I < P ? A.DOUBLE_QUOTE : A.SINGLE_QUOTE;
    }, C.preferredQuoteMark = function(_) {
      var T = _.preferCurrentQuoteMark ? this.quoteMark : _.quoteMark;
      return T === void 0 && (T = _.preferCurrentQuoteMark ? _.quoteMark : this.quoteMark), T === void 0 && (T = A.DOUBLE_QUOTE), T;
    }, C._syncRawValue = function() {
      var _ = (0, e.default)(this._value, g[this.quoteMark]);
      _ === this._value ? this.raws && delete this.raws.value : this.raws.value = _;
    }, C._handleEscapes = function(_, T) {
      if (this._constructed) {
        var P = (0, e.default)(T, {
          isIdentifier: !0
        });
        P !== T ? this.raws[_] = P : delete this.raws[_];
      }
    }, C._spacesFor = function(_) {
      var T = {
        before: "",
        after: ""
      }, P = this.spaces[_] || {}, I = this.raws.spaces && this.raws.spaces[_] || {};
      return Object.assign(T, P, I);
    }, C._stringFor = function(_, T, P) {
      T === void 0 && (T = _), P === void 0 && (P = b);
      var I = this._spacesFor(T);
      return P(this.stringifyProperty(_), I);
    }, C.offsetOf = function(_) {
      var T = 1, P = this._spacesFor("attribute");
      if (T += P.before.length, _ === "namespace" || _ === "ns")
        return this.namespace ? T : -1;
      if (_ === "attributeNS" || (T += this.namespaceString.length, this.namespace && (T += 1), _ === "attribute"))
        return T;
      T += this.stringifyProperty("attribute").length, T += P.after.length;
      var I = this._spacesFor("operator");
      T += I.before.length;
      var $ = this.stringifyProperty("operator");
      if (_ === "operator")
        return $ ? T : -1;
      T += $.length, T += I.after.length;
      var Y = this._spacesFor("value");
      T += Y.before.length;
      var W = this.stringifyProperty("value");
      if (_ === "value")
        return W ? T : -1;
      T += W.length, T += Y.after.length;
      var F = this._spacesFor("insensitive");
      return T += F.before.length, _ === "insensitive" && this.insensitive ? T : -1;
    }, C.toString = function() {
      var _ = this, T = [this.rawSpaceBefore, "["];
      return T.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (T.push(this._stringFor("operator")), T.push(this._stringFor("value")), T.push(this._stringFor("insensitiveFlag", "insensitive", function(P, I) {
        return P.length > 0 && !_.quoted && I.before.length === 0 && !(_.spaces.value && _.spaces.value.after) && (I.before = " "), b(P, I);
      }))), T.push("]"), T.push(this.rawSpaceAfter), T.join("");
    }, u(A, [{
      key: "quoted",
      get: function() {
        var _ = this.quoteMark;
        return _ === "'" || _ === '"';
      },
      set: function(_) {
        m();
      }
      /**
       * returns a single (`'`) or double (`"`) quote character if the value is quoted.
       * returns `null` if the value is not quoted.
       * returns `undefined` if the quotation state is unknown (this can happen when
       * the attribute is constructed without specifying a quote mark.)
       */
    }, {
      key: "quoteMark",
      get: function() {
        return this._quoteMark;
      },
      set: function(_) {
        if (!this._constructed) {
          this._quoteMark = _;
          return;
        }
        this._quoteMark !== _ && (this._quoteMark = _, this._syncRawValue());
      }
    }, {
      key: "qualifiedAttribute",
      get: function() {
        return this.qualifiedName(this.raws.attribute || this.attribute);
      }
    }, {
      key: "insensitiveFlag",
      get: function() {
        return this.insensitive ? "i" : "";
      }
    }, {
      key: "value",
      get: function() {
        return this._value;
      },
      set: (
        /**
         * Before 3.0, the value had to be set to an escaped value including any wrapped
         * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
         * is unescaped during parsing and any quote marks are removed.
         *
         * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
         * a deprecation warning is raised when the new value contains any characters that would
         * require escaping (including if it contains wrapped quotes).
         *
         * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
         * how the new value is quoted.
         */
        function(_) {
          if (this._constructed) {
            var T = y(_), P = T.deprecatedUsage, I = T.unescaped, $ = T.quoteMark;
            if (P && h(), I === this._value && $ === this._quoteMark)
              return;
            this._value = I, this._quoteMark = $, this._syncRawValue();
          } else
            this._value = _;
        }
      )
    }, {
      key: "insensitive",
      get: function() {
        return this._insensitive;
      },
      set: function(_) {
        _ || (this._insensitive = !1, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = _;
      }
    }, {
      key: "attribute",
      get: function() {
        return this._attribute;
      },
      set: function(_) {
        this._handleEscapes("attribute", _), this._attribute = _;
      }
    }]), A;
  }(s.default);
  r.default = E, E.NO_QUOTE = null, E.SINGLE_QUOTE = "'", E.DOUBLE_QUOTE = '"';
  var g = (n = {
    "'": {
      quotes: "single",
      wrap: !0
    },
    '"': {
      quotes: "double",
      wrap: !0
    }
  }, n[null] = {
    isIdentifier: !0
  }, n);
  function b(v, A) {
    return "" + A.before + v + A.after;
  }
})(R0);
var Uh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(M0), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.UNIVERSAL, f.value = "*", f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(Uh, Uh.exports);
var Fx = Uh.exports, jh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(di), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.COMBINATOR, f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(jh, jh.exports);
var Bx = jh.exports, qh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(di), s = Se;
  function i(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, a(u, l);
  }
  function a(u, l) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, p) {
      return f.__proto__ = p, f;
    }, a(u, l);
  }
  var o = /* @__PURE__ */ function(u) {
    n(l, u);
    function l(c) {
      var f;
      return f = u.call(this, c) || this, f.type = s.NESTING, f.value = "&", f;
    }
    return l;
  }(t.default);
  e.default = o, r.exports = e.default;
})(qh, qh.exports);
var Vx = qh.exports, Hh = { exports: {} };
(function(r, e) {
  e.__esModule = !0, e.default = t;
  function t(s) {
    return s.sort(function(i, n) {
      return i - n;
    });
  }
  r.exports = e.default;
})(Hh, Hh.exports);
var MM = Hh.exports, Ux = {}, ae = {};
ae.__esModule = !0;
ae.word = ae.tilde = ae.tab = ae.str = ae.space = ae.slash = ae.singleQuote = ae.semicolon = ae.plus = ae.pipe = ae.openSquare = ae.openParenthesis = ae.newline = ae.greaterThan = ae.feed = ae.equals = ae.doubleQuote = ae.dollar = ae.cr = ae.comment = ae.comma = ae.combinator = ae.colon = ae.closeSquare = ae.closeParenthesis = ae.caret = ae.bang = ae.backslash = ae.at = ae.asterisk = ae.ampersand = void 0;
var RM = 38;
ae.ampersand = RM;
var $M = 42;
ae.asterisk = $M;
var FM = 64;
ae.at = FM;
var BM = 44;
ae.comma = BM;
var VM = 58;
ae.colon = VM;
var UM = 59;
ae.semicolon = UM;
var jM = 40;
ae.openParenthesis = jM;
var qM = 41;
ae.closeParenthesis = qM;
var HM = 91;
ae.openSquare = HM;
var WM = 93;
ae.closeSquare = WM;
var zM = 36;
ae.dollar = zM;
var GM = 126;
ae.tilde = GM;
var KM = 94;
ae.caret = KM;
var XM = 43;
ae.plus = XM;
var JM = 61;
ae.equals = JM;
var YM = 124;
ae.pipe = YM;
var QM = 62;
ae.greaterThan = QM;
var ZM = 32;
ae.space = ZM;
var jx = 39;
ae.singleQuote = jx;
var e5 = 34;
ae.doubleQuote = e5;
var t5 = 47;
ae.slash = t5;
var r5 = 33;
ae.bang = r5;
var s5 = 92;
ae.backslash = s5;
var i5 = 13;
ae.cr = i5;
var n5 = 12;
ae.feed = n5;
var a5 = 10;
ae.newline = a5;
var o5 = 9;
ae.tab = o5;
var u5 = jx;
ae.str = u5;
var l5 = -1;
ae.comment = l5;
var c5 = -2;
ae.word = c5;
var f5 = -3;
ae.combinator = f5;
(function(r) {
  r.__esModule = !0, r.FIELDS = void 0, r.default = m;
  var e = n(ae), t, s;
  function i(d) {
    if (typeof WeakMap != "function") return null;
    var y = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new WeakMap();
    return (i = function(g) {
      return g ? S : y;
    })(d);
  }
  function n(d, y) {
    if (d && d.__esModule)
      return d;
    if (d === null || typeof d != "object" && typeof d != "function")
      return { default: d };
    var S = i(y);
    if (S && S.has(d))
      return S.get(d);
    var E = {}, g = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var b in d)
      if (b !== "default" && Object.prototype.hasOwnProperty.call(d, b)) {
        var v = g ? Object.getOwnPropertyDescriptor(d, b) : null;
        v && (v.get || v.set) ? Object.defineProperty(E, b, v) : E[b] = d[b];
      }
    return E.default = d, S && S.set(d, E), E;
  }
  for (var a = (t = {}, t[e.tab] = !0, t[e.newline] = !0, t[e.cr] = !0, t[e.feed] = !0, t), o = (s = {}, s[e.space] = !0, s[e.tab] = !0, s[e.newline] = !0, s[e.cr] = !0, s[e.feed] = !0, s[e.ampersand] = !0, s[e.asterisk] = !0, s[e.bang] = !0, s[e.comma] = !0, s[e.colon] = !0, s[e.semicolon] = !0, s[e.openParenthesis] = !0, s[e.closeParenthesis] = !0, s[e.openSquare] = !0, s[e.closeSquare] = !0, s[e.singleQuote] = !0, s[e.doubleQuote] = !0, s[e.plus] = !0, s[e.pipe] = !0, s[e.tilde] = !0, s[e.greaterThan] = !0, s[e.equals] = !0, s[e.dollar] = !0, s[e.caret] = !0, s[e.slash] = !0, s), u = {}, l = "0123456789abcdefABCDEF", c = 0; c < l.length; c++)
    u[l.charCodeAt(c)] = !0;
  function f(d, y) {
    var S = y, E;
    do {
      if (E = d.charCodeAt(S), o[E])
        return S - 1;
      E === e.backslash ? S = p(d, S) + 1 : S++;
    } while (S < d.length);
    return S - 1;
  }
  function p(d, y) {
    var S = y, E = d.charCodeAt(S + 1);
    if (!a[E]) if (u[E]) {
      var g = 0;
      do
        S++, g++, E = d.charCodeAt(S + 1);
      while (u[E] && g < 6);
      g < 6 && E === e.space && S++;
    } else
      S++;
    return S;
  }
  var h = {
    TYPE: 0,
    START_LINE: 1,
    START_COL: 2,
    END_LINE: 3,
    END_COL: 4,
    START_POS: 5,
    END_POS: 6
  };
  r.FIELDS = h;
  function m(d) {
    var y = [], S = d.css.valueOf(), E = S, g = E.length, b = -1, v = 1, A = 0, C = 0, x, _, T, P, I, $, Y, W, F, K, Z, Ce, Ve;
    function ee(k, R) {
      if (d.safe)
        S += R, F = S.length - 1;
      else
        throw d.error("Unclosed " + k, v, A - b, A);
    }
    for (; A < g; ) {
      switch (x = S.charCodeAt(A), x === e.newline && (b = A, v += 1), x) {
        case e.space:
        case e.tab:
        case e.newline:
        case e.cr:
        case e.feed:
          F = A;
          do
            F += 1, x = S.charCodeAt(F), x === e.newline && (b = F, v += 1);
          while (x === e.space || x === e.newline || x === e.tab || x === e.cr || x === e.feed);
          Ve = e.space, P = v, T = F - b - 1, C = F;
          break;
        case e.plus:
        case e.greaterThan:
        case e.tilde:
        case e.pipe:
          F = A;
          do
            F += 1, x = S.charCodeAt(F);
          while (x === e.plus || x === e.greaterThan || x === e.tilde || x === e.pipe);
          Ve = e.combinator, P = v, T = A - b, C = F;
          break;
        case e.asterisk:
        case e.ampersand:
        case e.bang:
        case e.comma:
        case e.equals:
        case e.dollar:
        case e.caret:
        case e.openSquare:
        case e.closeSquare:
        case e.colon:
        case e.semicolon:
        case e.openParenthesis:
        case e.closeParenthesis:
          F = A, Ve = x, P = v, T = A - b, C = F + 1;
          break;
        case e.singleQuote:
        case e.doubleQuote:
          Ce = x === e.singleQuote ? "'" : '"', F = A;
          do
            for (I = !1, F = S.indexOf(Ce, F + 1), F === -1 && ee("quote", Ce), $ = F; S.charCodeAt($ - 1) === e.backslash; )
              $ -= 1, I = !I;
          while (I);
          Ve = e.str, P = v, T = A - b, C = F + 1;
          break;
        default:
          x === e.slash && S.charCodeAt(A + 1) === e.asterisk ? (F = S.indexOf("*/", A + 2) + 1, F === 0 && ee("comment", "*/"), _ = S.slice(A, F + 1), W = _.split(`
`), Y = W.length - 1, Y > 0 ? (K = v + Y, Z = F - W[Y].length) : (K = v, Z = b), Ve = e.comment, v = K, P = K, T = F - Z) : x === e.slash ? (F = A, Ve = x, P = v, T = A - b, C = F + 1) : (F = f(S, A), Ve = e.word, P = v, T = F - b), C = F + 1;
          break;
      }
      y.push([
        Ve,
        // [0] Token type
        v,
        // [1] Starting line
        A - b,
        // [2] Starting column
        P,
        // [3] Ending line
        T,
        // [4] Ending column
        A,
        // [5] Start position / Source index
        C
        // [6] End position
      ]), Z && (b = Z, Z = null), A = C;
    }
    return y;
  }
})(Ux);
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = C(Ox), s = C(Ix), i = C(kx), n = C(Dx), a = C(Lx), o = C(Mx), u = C(Rx), l = C($x), c = A(R0), f = C(Fx), p = C(Bx), h = C(Vx), m = C(MM), d = A(Ux), y = A(ae), S = A(Se), E = nr, g, b;
  function v(ee) {
    if (typeof WeakMap != "function") return null;
    var k = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap();
    return (v = function(B) {
      return B ? R : k;
    })(ee);
  }
  function A(ee, k) {
    if (ee && ee.__esModule)
      return ee;
    if (ee === null || typeof ee != "object" && typeof ee != "function")
      return { default: ee };
    var R = v(k);
    if (R && R.has(ee))
      return R.get(ee);
    var D = {}, B = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var ie in ee)
      if (ie !== "default" && Object.prototype.hasOwnProperty.call(ee, ie)) {
        var L = B ? Object.getOwnPropertyDescriptor(ee, ie) : null;
        L && (L.get || L.set) ? Object.defineProperty(D, ie, L) : D[ie] = ee[ie];
      }
    return D.default = ee, R && R.set(ee, D), D;
  }
  function C(ee) {
    return ee && ee.__esModule ? ee : { default: ee };
  }
  function x(ee, k) {
    for (var R = 0; R < k.length; R++) {
      var D = k[R];
      D.enumerable = D.enumerable || !1, D.configurable = !0, "value" in D && (D.writable = !0), Object.defineProperty(ee, D.key, D);
    }
  }
  function _(ee, k, R) {
    return k && x(ee.prototype, k), Object.defineProperty(ee, "prototype", { writable: !1 }), ee;
  }
  var T = (g = {}, g[y.space] = !0, g[y.cr] = !0, g[y.feed] = !0, g[y.newline] = !0, g[y.tab] = !0, g), P = Object.assign({}, T, (b = {}, b[y.comment] = !0, b));
  function I(ee) {
    return {
      line: ee[d.FIELDS.START_LINE],
      column: ee[d.FIELDS.START_COL]
    };
  }
  function $(ee) {
    return {
      line: ee[d.FIELDS.END_LINE],
      column: ee[d.FIELDS.END_COL]
    };
  }
  function Y(ee, k, R, D) {
    return {
      start: {
        line: ee,
        column: k
      },
      end: {
        line: R,
        column: D
      }
    };
  }
  function W(ee) {
    return Y(ee[d.FIELDS.START_LINE], ee[d.FIELDS.START_COL], ee[d.FIELDS.END_LINE], ee[d.FIELDS.END_COL]);
  }
  function F(ee, k) {
    if (ee)
      return Y(ee[d.FIELDS.START_LINE], ee[d.FIELDS.START_COL], k[d.FIELDS.END_LINE], k[d.FIELDS.END_COL]);
  }
  function K(ee, k) {
    var R = ee[k];
    if (typeof R == "string")
      return R.indexOf("\\") !== -1 && ((0, E.ensureObject)(ee, "raws"), ee[k] = (0, E.unesc)(R), ee.raws[k] === void 0 && (ee.raws[k] = R)), ee;
  }
  function Z(ee, k) {
    for (var R = -1, D = []; (R = ee.indexOf(k, R + 1)) !== -1; )
      D.push(R);
    return D;
  }
  function Ce() {
    var ee = Array.prototype.concat.apply([], arguments);
    return ee.filter(function(k, R) {
      return R === ee.indexOf(k);
    });
  }
  var Ve = /* @__PURE__ */ function() {
    function ee(R, D) {
      D === void 0 && (D = {}), this.rule = R, this.options = Object.assign({
        lossy: !1,
        safe: !1
      }, D), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, d.default)({
        css: this.css,
        error: this._errorGenerator(),
        safe: this.options.safe
      });
      var B = F(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new t.default({
        source: B
      }), this.root.errorGenerator = this._errorGenerator();
      var ie = new s.default({
        source: {
          start: {
            line: 1,
            column: 1
          }
        },
        sourceIndex: 0
      });
      this.root.append(ie), this.current = ie, this.loop();
    }
    var k = ee.prototype;
    return k._errorGenerator = function() {
      var D = this;
      return function(B, ie) {
        return typeof D.rule == "string" ? new Error(B) : D.rule.error(B, ie);
      };
    }, k.attribute = function() {
      var D = [], B = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[d.FIELDS.TYPE] !== y.closeSquare; )
        D.push(this.currToken), this.position++;
      if (this.currToken[d.FIELDS.TYPE] !== y.closeSquare)
        return this.expected("closing square bracket", this.currToken[d.FIELDS.START_POS]);
      var ie = D.length, L = {
        source: Y(B[1], B[2], this.currToken[3], this.currToken[4]),
        sourceIndex: B[d.FIELDS.START_POS]
      };
      if (ie === 1 && !~[y.word].indexOf(D[0][d.FIELDS.TYPE]))
        return this.expected("attribute", D[0][d.FIELDS.START_POS]);
      for (var ne = 0, ye = "", be = "", me = null, ke = !1; ne < ie; ) {
        var Ke = D[ne], w = this.content(Ke), N = D[ne + 1];
        switch (Ke[d.FIELDS.TYPE]) {
          case y.space:
            if (ke = !0, this.options.lossy)
              break;
            if (me) {
              (0, E.ensureObject)(L, "spaces", me);
              var M = L.spaces[me].after || "";
              L.spaces[me].after = M + w;
              var q = (0, E.getProp)(L, "raws", "spaces", me, "after") || null;
              q && (L.raws.spaces[me].after = q + w);
            } else
              ye = ye + w, be = be + w;
            break;
          case y.asterisk:
            if (N[d.FIELDS.TYPE] === y.equals)
              L.operator = w, me = "operator";
            else if ((!L.namespace || me === "namespace" && !ke) && N) {
              ye && ((0, E.ensureObject)(L, "spaces", "attribute"), L.spaces.attribute.before = ye, ye = ""), be && ((0, E.ensureObject)(L, "raws", "spaces", "attribute"), L.raws.spaces.attribute.before = ye, be = ""), L.namespace = (L.namespace || "") + w;
              var V = (0, E.getProp)(L, "raws", "namespace") || null;
              V && (L.raws.namespace += w), me = "namespace";
            }
            ke = !1;
            break;
          case y.dollar:
            if (me === "value") {
              var U = (0, E.getProp)(L, "raws", "value");
              L.value += "$", U && (L.raws.value = U + "$");
              break;
            }
          case y.caret:
            N[d.FIELDS.TYPE] === y.equals && (L.operator = w, me = "operator"), ke = !1;
            break;
          case y.combinator:
            if (w === "~" && N[d.FIELDS.TYPE] === y.equals && (L.operator = w, me = "operator"), w !== "|") {
              ke = !1;
              break;
            }
            N[d.FIELDS.TYPE] === y.equals ? (L.operator = w, me = "operator") : !L.namespace && !L.attribute && (L.namespace = !0), ke = !1;
            break;
          case y.word:
            if (N && this.content(N) === "|" && D[ne + 2] && D[ne + 2][d.FIELDS.TYPE] !== y.equals && // this look-ahead probably fails with comment nodes involved.
            !L.operator && !L.namespace)
              L.namespace = w, me = "namespace";
            else if (!L.attribute || me === "attribute" && !ke) {
              ye && ((0, E.ensureObject)(L, "spaces", "attribute"), L.spaces.attribute.before = ye, ye = ""), be && ((0, E.ensureObject)(L, "raws", "spaces", "attribute"), L.raws.spaces.attribute.before = be, be = ""), L.attribute = (L.attribute || "") + w;
              var J = (0, E.getProp)(L, "raws", "attribute") || null;
              J && (L.raws.attribute += w), me = "attribute";
            } else if (!L.value && L.value !== "" || me === "value" && !(ke || L.quoteMark)) {
              var G = (0, E.unesc)(w), X = (0, E.getProp)(L, "raws", "value") || "", z = L.value || "";
              L.value = z + G, L.quoteMark = null, (G !== w || X) && ((0, E.ensureObject)(L, "raws"), L.raws.value = (X || z) + w), me = "value";
            } else {
              var re = w === "i" || w === "I";
              (L.value || L.value === "") && (L.quoteMark || ke) ? (L.insensitive = re, (!re || w === "I") && ((0, E.ensureObject)(L, "raws"), L.raws.insensitiveFlag = w), me = "insensitive", ye && ((0, E.ensureObject)(L, "spaces", "insensitive"), L.spaces.insensitive.before = ye, ye = ""), be && ((0, E.ensureObject)(L, "raws", "spaces", "insensitive"), L.raws.spaces.insensitive.before = be, be = "")) : (L.value || L.value === "") && (me = "value", L.value += w, L.raws.value && (L.raws.value += w));
            }
            ke = !1;
            break;
          case y.str:
            if (!L.attribute || !L.operator)
              return this.error("Expected an attribute followed by an operator preceding the string.", {
                index: Ke[d.FIELDS.START_POS]
              });
            var ce = (0, c.unescapeValue)(w), pe = ce.unescaped, ve = ce.quoteMark;
            L.value = pe, L.quoteMark = ve, me = "value", (0, E.ensureObject)(L, "raws"), L.raws.value = w, ke = !1;
            break;
          case y.equals:
            if (!L.attribute)
              return this.expected("attribute", Ke[d.FIELDS.START_POS], w);
            if (L.value)
              return this.error('Unexpected "=" found; an operator was already defined.', {
                index: Ke[d.FIELDS.START_POS]
              });
            L.operator = L.operator ? L.operator + w : w, me = "operator", ke = !1;
            break;
          case y.comment:
            if (me)
              if (ke || N && N[d.FIELDS.TYPE] === y.space || me === "insensitive") {
                var xe = (0, E.getProp)(L, "spaces", me, "after") || "", qe = (0, E.getProp)(L, "raws", "spaces", me, "after") || xe;
                (0, E.ensureObject)(L, "raws", "spaces", me), L.raws.spaces[me].after = qe + w;
              } else {
                var De = L[me] || "", ut = (0, E.getProp)(L, "raws", me) || De;
                (0, E.ensureObject)(L, "raws"), L.raws[me] = ut + w;
              }
            else
              be = be + w;
            break;
          default:
            return this.error('Unexpected "' + w + '" found.', {
              index: Ke[d.FIELDS.START_POS]
            });
        }
        ne++;
      }
      K(L, "attribute"), K(L, "namespace"), this.newNode(new c.default(L)), this.position++;
    }, k.parseWhitespaceEquivalentTokens = function(D) {
      D < 0 && (D = this.tokens.length);
      var B = this.position, ie = [], L = "", ne = void 0;
      do
        if (T[this.currToken[d.FIELDS.TYPE]])
          this.options.lossy || (L += this.content());
        else if (this.currToken[d.FIELDS.TYPE] === y.comment) {
          var ye = {};
          L && (ye.before = L, L = ""), ne = new n.default({
            value: this.content(),
            source: W(this.currToken),
            sourceIndex: this.currToken[d.FIELDS.START_POS],
            spaces: ye
          }), ie.push(ne);
        }
      while (++this.position < D);
      if (L) {
        if (ne)
          ne.spaces.after = L;
        else if (!this.options.lossy) {
          var be = this.tokens[B], me = this.tokens[this.position - 1];
          ie.push(new u.default({
            value: "",
            source: Y(be[d.FIELDS.START_LINE], be[d.FIELDS.START_COL], me[d.FIELDS.END_LINE], me[d.FIELDS.END_COL]),
            sourceIndex: be[d.FIELDS.START_POS],
            spaces: {
              before: L,
              after: ""
            }
          }));
        }
      }
      return ie;
    }, k.convertWhitespaceNodesToSpace = function(D, B) {
      var ie = this;
      B === void 0 && (B = !1);
      var L = "", ne = "";
      D.forEach(function(be) {
        var me = ie.lossySpace(be.spaces.before, B), ke = ie.lossySpace(be.rawSpaceBefore, B);
        L += me + ie.lossySpace(be.spaces.after, B && me.length === 0), ne += me + be.value + ie.lossySpace(be.rawSpaceAfter, B && ke.length === 0);
      }), ne === L && (ne = void 0);
      var ye = {
        space: L,
        rawSpace: ne
      };
      return ye;
    }, k.isNamedCombinator = function(D) {
      return D === void 0 && (D = this.position), this.tokens[D + 0] && this.tokens[D + 0][d.FIELDS.TYPE] === y.slash && this.tokens[D + 1] && this.tokens[D + 1][d.FIELDS.TYPE] === y.word && this.tokens[D + 2] && this.tokens[D + 2][d.FIELDS.TYPE] === y.slash;
    }, k.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var D = this.content(this.tokens[this.position + 1]), B = (0, E.unesc)(D).toLowerCase(), ie = {};
        B !== D && (ie.value = "/" + D + "/");
        var L = new p.default({
          value: "/" + B + "/",
          source: Y(this.currToken[d.FIELDS.START_LINE], this.currToken[d.FIELDS.START_COL], this.tokens[this.position + 2][d.FIELDS.END_LINE], this.tokens[this.position + 2][d.FIELDS.END_COL]),
          sourceIndex: this.currToken[d.FIELDS.START_POS],
          raws: ie
        });
        return this.position = this.position + 3, L;
      } else
        this.unexpected();
    }, k.combinator = function() {
      var D = this;
      if (this.content() === "|")
        return this.namespace();
      var B = this.locateNextMeaningfulToken(this.position);
      if (B < 0 || this.tokens[B][d.FIELDS.TYPE] === y.comma) {
        var ie = this.parseWhitespaceEquivalentTokens(B);
        if (ie.length > 0) {
          var L = this.current.last;
          if (L) {
            var ne = this.convertWhitespaceNodesToSpace(ie), ye = ne.space, be = ne.rawSpace;
            be !== void 0 && (L.rawSpaceAfter += be), L.spaces.after += ye;
          } else
            ie.forEach(function(X) {
              return D.newNode(X);
            });
        }
        return;
      }
      var me = this.currToken, ke = void 0;
      B > this.position && (ke = this.parseWhitespaceEquivalentTokens(B));
      var Ke;
      if (this.isNamedCombinator() ? Ke = this.namedCombinator() : this.currToken[d.FIELDS.TYPE] === y.combinator ? (Ke = new p.default({
        value: this.content(),
        source: W(this.currToken),
        sourceIndex: this.currToken[d.FIELDS.START_POS]
      }), this.position++) : T[this.currToken[d.FIELDS.TYPE]] || ke || this.unexpected(), Ke) {
        if (ke) {
          var w = this.convertWhitespaceNodesToSpace(ke), N = w.space, M = w.rawSpace;
          Ke.spaces.before = N, Ke.rawSpaceBefore = M;
        }
      } else {
        var q = this.convertWhitespaceNodesToSpace(ke, !0), V = q.space, U = q.rawSpace;
        U || (U = V);
        var J = {}, G = {
          spaces: {}
        };
        V.endsWith(" ") && U.endsWith(" ") ? (J.before = V.slice(0, V.length - 1), G.spaces.before = U.slice(0, U.length - 1)) : V.startsWith(" ") && U.startsWith(" ") ? (J.after = V.slice(1), G.spaces.after = U.slice(1)) : G.value = U, Ke = new p.default({
          value: " ",
          source: F(me, this.tokens[this.position - 1]),
          sourceIndex: me[d.FIELDS.START_POS],
          spaces: J,
          raws: G
        });
      }
      return this.currToken && this.currToken[d.FIELDS.TYPE] === y.space && (Ke.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(Ke);
    }, k.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = !0, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var D = new s.default({
        source: {
          start: I(this.tokens[this.position + 1])
        },
        sourceIndex: this.tokens[this.position + 1][d.FIELDS.START_POS]
      });
      this.current.parent.append(D), this.current = D, this.position++;
    }, k.comment = function() {
      var D = this.currToken;
      this.newNode(new n.default({
        value: this.content(),
        source: W(D),
        sourceIndex: D[d.FIELDS.START_POS]
      })), this.position++;
    }, k.error = function(D, B) {
      throw this.root.error(D, B);
    }, k.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", {
        index: this.currToken[d.FIELDS.START_POS]
      });
    }, k.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[d.FIELDS.START_POS]);
    }, k.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[d.FIELDS.START_POS]);
    }, k.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[d.FIELDS.START_POS]);
    }, k.unexpectedPipe = function() {
      return this.error("Unexpected '|'.", this.currToken[d.FIELDS.START_POS]);
    }, k.namespace = function() {
      var D = this.prevToken && this.content(this.prevToken) || !0;
      if (this.nextToken[d.FIELDS.TYPE] === y.word)
        return this.position++, this.word(D);
      if (this.nextToken[d.FIELDS.TYPE] === y.asterisk)
        return this.position++, this.universal(D);
      this.unexpectedPipe();
    }, k.nesting = function() {
      if (this.nextToken) {
        var D = this.content(this.nextToken);
        if (D === "|") {
          this.position++;
          return;
        }
      }
      var B = this.currToken;
      this.newNode(new h.default({
        value: this.content(),
        source: W(B),
        sourceIndex: B[d.FIELDS.START_POS]
      })), this.position++;
    }, k.parentheses = function() {
      var D = this.current.last, B = 1;
      if (this.position++, D && D.type === S.PSEUDO) {
        var ie = new s.default({
          source: {
            start: I(this.tokens[this.position])
          },
          sourceIndex: this.tokens[this.position][d.FIELDS.START_POS]
        }), L = this.current;
        for (D.append(ie), this.current = ie; this.position < this.tokens.length && B; )
          this.currToken[d.FIELDS.TYPE] === y.openParenthesis && B++, this.currToken[d.FIELDS.TYPE] === y.closeParenthesis && B--, B ? this.parse() : (this.current.source.end = $(this.currToken), this.current.parent.source.end = $(this.currToken), this.position++);
        this.current = L;
      } else {
        for (var ne = this.currToken, ye = "(", be; this.position < this.tokens.length && B; )
          this.currToken[d.FIELDS.TYPE] === y.openParenthesis && B++, this.currToken[d.FIELDS.TYPE] === y.closeParenthesis && B--, be = this.currToken, ye += this.parseParenthesisToken(this.currToken), this.position++;
        D ? D.appendToPropertyAndEscape("value", ye, ye) : this.newNode(new u.default({
          value: ye,
          source: Y(ne[d.FIELDS.START_LINE], ne[d.FIELDS.START_COL], be[d.FIELDS.END_LINE], be[d.FIELDS.END_COL]),
          sourceIndex: ne[d.FIELDS.START_POS]
        }));
      }
      if (B)
        return this.expected("closing parenthesis", this.currToken[d.FIELDS.START_POS]);
    }, k.pseudo = function() {
      for (var D = this, B = "", ie = this.currToken; this.currToken && this.currToken[d.FIELDS.TYPE] === y.colon; )
        B += this.content(), this.position++;
      if (!this.currToken)
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[d.FIELDS.TYPE] === y.word)
        this.splitWord(!1, function(L, ne) {
          B += L, D.newNode(new l.default({
            value: B,
            source: F(ie, D.currToken),
            sourceIndex: ie[d.FIELDS.START_POS]
          })), ne > 1 && D.nextToken && D.nextToken[d.FIELDS.TYPE] === y.openParenthesis && D.error("Misplaced parenthesis.", {
            index: D.nextToken[d.FIELDS.START_POS]
          });
        });
      else
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[d.FIELDS.START_POS]);
    }, k.space = function() {
      var D = this.content();
      this.position === 0 || this.prevToken[d.FIELDS.TYPE] === y.comma || this.prevToken[d.FIELDS.TYPE] === y.openParenthesis || this.current.nodes.every(function(B) {
        return B.type === "comment";
      }) ? (this.spaces = this.optionalSpace(D), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[d.FIELDS.TYPE] === y.comma || this.nextToken[d.FIELDS.TYPE] === y.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(D), this.position++) : this.combinator();
    }, k.string = function() {
      var D = this.currToken;
      this.newNode(new u.default({
        value: this.content(),
        source: W(D),
        sourceIndex: D[d.FIELDS.START_POS]
      })), this.position++;
    }, k.universal = function(D) {
      var B = this.nextToken;
      if (B && this.content(B) === "|")
        return this.position++, this.namespace();
      var ie = this.currToken;
      this.newNode(new f.default({
        value: this.content(),
        source: W(ie),
        sourceIndex: ie[d.FIELDS.START_POS]
      }), D), this.position++;
    }, k.splitWord = function(D, B) {
      for (var ie = this, L = this.nextToken, ne = this.content(); L && ~[y.dollar, y.caret, y.equals, y.word].indexOf(L[d.FIELDS.TYPE]); ) {
        this.position++;
        var ye = this.content();
        if (ne += ye, ye.lastIndexOf("\\") === ye.length - 1) {
          var be = this.nextToken;
          be && be[d.FIELDS.TYPE] === y.space && (ne += this.requiredSpace(this.content(be)), this.position++);
        }
        L = this.nextToken;
      }
      var me = Z(ne, ".").filter(function(N) {
        var M = ne[N - 1] === "\\", q = /^\d+\.\d+%$/.test(ne);
        return !M && !q;
      }), ke = Z(ne, "#").filter(function(N) {
        return ne[N - 1] !== "\\";
      }), Ke = Z(ne, "#{");
      Ke.length && (ke = ke.filter(function(N) {
        return !~Ke.indexOf(N);
      }));
      var w = (0, m.default)(Ce([0].concat(me, ke)));
      w.forEach(function(N, M) {
        var q = w[M + 1] || ne.length, V = ne.slice(N, q);
        if (M === 0 && B)
          return B.call(ie, V, w.length);
        var U, J = ie.currToken, G = J[d.FIELDS.START_POS] + w[M], X = Y(J[1], J[2] + N, J[3], J[2] + (q - 1));
        if (~me.indexOf(N)) {
          var z = {
            value: V.slice(1),
            source: X,
            sourceIndex: G
          };
          U = new i.default(K(z, "value"));
        } else if (~ke.indexOf(N)) {
          var re = {
            value: V.slice(1),
            source: X,
            sourceIndex: G
          };
          U = new a.default(K(re, "value"));
        } else {
          var ce = {
            value: V,
            source: X,
            sourceIndex: G
          };
          K(ce, "value"), U = new o.default(ce);
        }
        ie.newNode(U, D), D = null;
      }), this.position++;
    }, k.word = function(D) {
      var B = this.nextToken;
      return B && this.content(B) === "|" ? (this.position++, this.namespace()) : this.splitWord(D);
    }, k.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(!0);
      return this.current._inferEndPosition(), this.root;
    }, k.parse = function(D) {
      switch (this.currToken[d.FIELDS.TYPE]) {
        case y.space:
          this.space();
          break;
        case y.comment:
          this.comment();
          break;
        case y.openParenthesis:
          this.parentheses();
          break;
        case y.closeParenthesis:
          D && this.missingParenthesis();
          break;
        case y.openSquare:
          this.attribute();
          break;
        case y.dollar:
        case y.caret:
        case y.equals:
        case y.word:
          this.word();
          break;
        case y.colon:
          this.pseudo();
          break;
        case y.comma:
          this.comma();
          break;
        case y.asterisk:
          this.universal();
          break;
        case y.ampersand:
          this.nesting();
          break;
        case y.slash:
        case y.combinator:
          this.combinator();
          break;
        case y.str:
          this.string();
          break;
        case y.closeSquare:
          this.missingSquareBracket();
        case y.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, k.expected = function(D, B, ie) {
      if (Array.isArray(D)) {
        var L = D.pop();
        D = D.join(", ") + " or " + L;
      }
      var ne = /^[aeiou]/.test(D[0]) ? "an" : "a";
      return ie ? this.error("Expected " + ne + " " + D + ', found "' + ie + '" instead.', {
        index: B
      }) : this.error("Expected " + ne + " " + D + ".", {
        index: B
      });
    }, k.requiredSpace = function(D) {
      return this.options.lossy ? " " : D;
    }, k.optionalSpace = function(D) {
      return this.options.lossy ? "" : D;
    }, k.lossySpace = function(D, B) {
      return this.options.lossy ? B ? " " : "" : D;
    }, k.parseParenthesisToken = function(D) {
      var B = this.content(D);
      return D[d.FIELDS.TYPE] === y.space ? this.requiredSpace(B) : B;
    }, k.newNode = function(D, B) {
      return B && (/^ +$/.test(B) && (this.options.lossy || (this.spaces = (this.spaces || "") + B), B = !0), D.namespace = B, K(D, "namespace")), this.spaces && (D.spaces.before = this.spaces, this.spaces = ""), this.current.append(D);
    }, k.content = function(D) {
      return D === void 0 && (D = this.currToken), this.css.slice(D[d.FIELDS.START_POS], D[d.FIELDS.END_POS]);
    }, k.locateNextMeaningfulToken = function(D) {
      D === void 0 && (D = this.position + 1);
      for (var B = D; B < this.tokens.length; )
        if (P[this.tokens[B][d.FIELDS.TYPE]]) {
          B++;
          continue;
        } else
          return B;
      return -1;
    }, _(ee, [{
      key: "currToken",
      get: function() {
        return this.tokens[this.position];
      }
    }, {
      key: "nextToken",
      get: function() {
        return this.tokens[this.position + 1];
      }
    }, {
      key: "prevToken",
      get: function() {
        return this.tokens[this.position - 1];
      }
    }]), ee;
  }();
  e.default = Ve, r.exports = e.default;
})(Th, Th.exports);
var p5 = Th.exports;
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = s(p5);
  function s(n) {
    return n && n.__esModule ? n : { default: n };
  }
  var i = /* @__PURE__ */ function() {
    function n(o, u) {
      this.func = o || function() {
      }, this.funcRes = null, this.options = u;
    }
    var a = n.prototype;
    return a._shouldUpdateSelector = function(u, l) {
      l === void 0 && (l = {});
      var c = Object.assign({}, this.options, l);
      return c.updateSelector === !1 ? !1 : typeof u != "string";
    }, a._isLossy = function(u) {
      u === void 0 && (u = {});
      var l = Object.assign({}, this.options, u);
      return l.lossless === !1;
    }, a._root = function(u, l) {
      l === void 0 && (l = {});
      var c = new t.default(u, this._parseOptions(l));
      return c.root;
    }, a._parseOptions = function(u) {
      return {
        lossy: this._isLossy(u)
      };
    }, a._run = function(u, l) {
      var c = this;
      return l === void 0 && (l = {}), new Promise(function(f, p) {
        try {
          var h = c._root(u, l);
          Promise.resolve(c.func(h)).then(function(m) {
            var d = void 0;
            return c._shouldUpdateSelector(u, l) && (d = h.toString(), u.selector = d), {
              transform: m,
              root: h,
              string: d
            };
          }).then(f, p);
        } catch (m) {
          p(m);
          return;
        }
      });
    }, a._runSync = function(u, l) {
      l === void 0 && (l = {});
      var c = this._root(u, l), f = this.func(c);
      if (f && typeof f.then == "function")
        throw new Error("Selector processor returned a promise to a synchronous call.");
      var p = void 0;
      return l.updateSelector && typeof u != "string" && (p = c.toString(), u.selector = p), {
        transform: f,
        root: c,
        string: p
      };
    }, a.ast = function(u, l) {
      return this._run(u, l).then(function(c) {
        return c.root;
      });
    }, a.astSync = function(u, l) {
      return this._runSync(u, l).root;
    }, a.transform = function(u, l) {
      return this._run(u, l).then(function(c) {
        return c.transform;
      });
    }, a.transformSync = function(u, l) {
      return this._runSync(u, l).transform;
    }, a.process = function(u, l) {
      return this._run(u, l).then(function(c) {
        return c.string || c.root.toString();
      });
    }, a.processSync = function(u, l) {
      var c = this._runSync(u, l);
      return c.string || c.root.toString();
    }, n;
  }();
  e.default = i, r.exports = e.default;
})(wh, wh.exports);
var h5 = wh.exports, qx = {}, We = {};
We.__esModule = !0;
We.universal = We.tag = We.string = We.selector = We.root = We.pseudo = We.nesting = We.id = We.comment = We.combinator = We.className = We.attribute = void 0;
var d5 = Sr(R0), m5 = Sr(kx), g5 = Sr(Bx), y5 = Sr(Dx), b5 = Sr(Lx), v5 = Sr(Vx), E5 = Sr($x), S5 = Sr(Ox), _5 = Sr(Ix), x5 = Sr(Rx), w5 = Sr(Mx), T5 = Sr(Fx);
function Sr(r) {
  return r && r.__esModule ? r : { default: r };
}
var P5 = function(e) {
  return new d5.default(e);
};
We.attribute = P5;
var A5 = function(e) {
  return new m5.default(e);
};
We.className = A5;
var C5 = function(e) {
  return new g5.default(e);
};
We.combinator = C5;
var N5 = function(e) {
  return new y5.default(e);
};
We.comment = N5;
var O5 = function(e) {
  return new b5.default(e);
};
We.id = O5;
var I5 = function(e) {
  return new v5.default(e);
};
We.nesting = I5;
var k5 = function(e) {
  return new E5.default(e);
};
We.pseudo = k5;
var D5 = function(e) {
  return new S5.default(e);
};
We.root = D5;
var L5 = function(e) {
  return new _5.default(e);
};
We.selector = L5;
var M5 = function(e) {
  return new x5.default(e);
};
We.string = M5;
var R5 = function(e) {
  return new w5.default(e);
};
We.tag = R5;
var $5 = function(e) {
  return new T5.default(e);
};
We.universal = $5;
var $e = {};
$e.__esModule = !0;
$e.isComment = $e.isCombinator = $e.isClassName = $e.isAttribute = void 0;
$e.isContainer = X5;
$e.isIdentifier = void 0;
$e.isNamespace = J5;
$e.isNesting = void 0;
$e.isNode = $0;
$e.isPseudo = void 0;
$e.isPseudoClass = K5;
$e.isPseudoElement = zx;
$e.isUniversal = $e.isTag = $e.isString = $e.isSelector = $e.isRoot = void 0;
var et = Se, Gt, F5 = (Gt = {}, Gt[et.ATTRIBUTE] = !0, Gt[et.CLASS] = !0, Gt[et.COMBINATOR] = !0, Gt[et.COMMENT] = !0, Gt[et.ID] = !0, Gt[et.NESTING] = !0, Gt[et.PSEUDO] = !0, Gt[et.ROOT] = !0, Gt[et.SELECTOR] = !0, Gt[et.STRING] = !0, Gt[et.TAG] = !0, Gt[et.UNIVERSAL] = !0, Gt);
function $0(r) {
  return typeof r == "object" && F5[r.type];
}
function _r(r, e) {
  return $0(e) && e.type === r;
}
var Hx = _r.bind(null, et.ATTRIBUTE);
$e.isAttribute = Hx;
var B5 = _r.bind(null, et.CLASS);
$e.isClassName = B5;
var V5 = _r.bind(null, et.COMBINATOR);
$e.isCombinator = V5;
var U5 = _r.bind(null, et.COMMENT);
$e.isComment = U5;
var j5 = _r.bind(null, et.ID);
$e.isIdentifier = j5;
var q5 = _r.bind(null, et.NESTING);
$e.isNesting = q5;
var F0 = _r.bind(null, et.PSEUDO);
$e.isPseudo = F0;
var H5 = _r.bind(null, et.ROOT);
$e.isRoot = H5;
var W5 = _r.bind(null, et.SELECTOR);
$e.isSelector = W5;
var z5 = _r.bind(null, et.STRING);
$e.isString = z5;
var Wx = _r.bind(null, et.TAG);
$e.isTag = Wx;
var G5 = _r.bind(null, et.UNIVERSAL);
$e.isUniversal = G5;
function zx(r) {
  return F0(r) && r.value && (r.value.startsWith("::") || r.value.toLowerCase() === ":before" || r.value.toLowerCase() === ":after" || r.value.toLowerCase() === ":first-letter" || r.value.toLowerCase() === ":first-line");
}
function K5(r) {
  return F0(r) && !zx(r);
}
function X5(r) {
  return !!($0(r) && r.walk);
}
function J5(r) {
  return Hx(r) || Wx(r);
}
(function(r) {
  r.__esModule = !0;
  var e = Se;
  Object.keys(e).forEach(function(i) {
    i === "default" || i === "__esModule" || i in r && r[i] === e[i] || (r[i] = e[i]);
  });
  var t = We;
  Object.keys(t).forEach(function(i) {
    i === "default" || i === "__esModule" || i in r && r[i] === t[i] || (r[i] = t[i]);
  });
  var s = $e;
  Object.keys(s).forEach(function(i) {
    i === "default" || i === "__esModule" || i in r && r[i] === s[i] || (r[i] = s[i]);
  });
})(qx);
(function(r, e) {
  e.__esModule = !0, e.default = void 0;
  var t = a(h5), s = n(qx);
  function i(l) {
    if (typeof WeakMap != "function") return null;
    var c = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap();
    return (i = function(h) {
      return h ? f : c;
    })(l);
  }
  function n(l, c) {
    if (l && l.__esModule)
      return l;
    if (l === null || typeof l != "object" && typeof l != "function")
      return { default: l };
    var f = i(c);
    if (f && f.has(l))
      return f.get(l);
    var p = {}, h = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var m in l)
      if (m !== "default" && Object.prototype.hasOwnProperty.call(l, m)) {
        var d = h ? Object.getOwnPropertyDescriptor(l, m) : null;
        d && (d.get || d.set) ? Object.defineProperty(p, m, d) : p[m] = l[m];
      }
    return p.default = l, f && f.set(l, p), p;
  }
  function a(l) {
    return l && l.__esModule ? l : { default: l };
  }
  var o = function(c) {
    return new t.default(c);
  };
  Object.assign(o, s), delete o.__esModule;
  var u = o;
  e.default = u, r.exports = e.default;
})(xh, xh.exports);
var Y5 = xh.exports, Xu = /* @__PURE__ */ Dc(Y5);
const Q5 = /^(-\w+-)?animation-name$/, Z5 = /^(-\w+-)?animation$/, Gx = (r = "") => {
  const e = /* @__PURE__ */ Object.create(null), t = r.replace(/^data-v-/, "");
  return {
    postcssPlugin: "vue-sfc-scoped",
    Rule(s) {
      eR(r, s);
    },
    AtRule(s) {
      /-?keyframes$/.test(s.name) && !s.params.endsWith(`-${t}`) && (e[s.params] = s.params = s.params + "-" + t);
    },
    OnceExit(s) {
      Object.keys(e).length && s.walkDecls((i) => {
        Q5.test(i.prop) && (i.value = i.value.split(",").map((n) => e[n.trim()] || n.trim()).join(",")), Z5.test(i.prop) && (i.value = i.value.split(",").map((n) => {
          const a = n.trim().split(/\s+/), o = a.findIndex((u) => e[u]);
          return o !== -1 ? (a.splice(o, 1, e[a[o]]), a.join(" ")) : n;
        }).join(","));
      });
    }
  };
}, F1 = /* @__PURE__ */ new WeakSet();
function eR(r, e) {
  F1.has(e) || e.parent && e.parent.type === "atrule" && /-?keyframes$/.test(e.parent.name) || (F1.add(e), e.selector = Xu((t) => {
    t.each((s) => {
      Wh(r, s, t);
    });
  }).processSync(e.selector));
}
function Wh(r, e, t, s = !1) {
  let i = null, n = !0;
  if (e.each((a) => {
    if (a.type === "combinator" && (a.value === ">>>" || a.value === "/deep/"))
      return a.value = " ", a.spaces.before = a.spaces.after = "", ah(
        "the >>> and /deep/ combinators have been deprecated. Use :deep() instead."
      ), !1;
    if (a.type === "pseudo") {
      const { value: o } = a;
      if (o === ":deep" || o === "::v-deep") {
        if (a.nodes.length) {
          let u = a;
          a.nodes[0].each((c) => {
            e.insertAfter(u, c), u = c;
          });
          const l = e.at(e.index(a) - 1);
          (!l || !B1(l)) && e.insertAfter(
            a,
            Xu.combinator({
              value: " "
            })
          ), e.removeChild(a);
        } else {
          ah(
            `${o} usage as a combinator has been deprecated. Use :deep(<inner-selector>) instead of ${o} <inner-selector>.`
          );
          const u = e.at(e.index(a) - 1);
          u && B1(u) && e.removeChild(u), e.removeChild(a);
        }
        return !1;
      }
      if (o === ":slotted" || o === "::v-slotted") {
        Wh(
          r,
          a.nodes[0],
          t,
          !0
          /* slotted */
        );
        let u = a;
        return a.nodes[0].each((l) => {
          e.insertAfter(u, l), u = l;
        }), e.removeChild(a), n = !1, !1;
      }
      if (o === ":global" || o === "::v-global")
        return t.insertAfter(e, a.nodes[0]), t.removeChild(e), !1;
    }
    if (a.type === "universal") {
      const o = e.at(e.index(a) - 1), u = e.at(e.index(a) + 1);
      if (!o)
        if (u) {
          u.type === "combinator" && u.value === " " && e.removeChild(u), e.removeChild(a);
          return;
        } else
          return i = Xu.combinator({
            value: ""
          }), e.insertBefore(a, i), e.removeChild(a), !1;
      if (i) return;
    }
    (a.type !== "pseudo" && a.type !== "combinator" || a.type === "pseudo" && (a.value === ":is" || a.value === ":where") && !i) && (i = a);
  }), i) {
    const { type: a, value: o } = i;
    a === "pseudo" && (o === ":is" || o === ":where") && (i.nodes.forEach(
      (u) => Wh(r, u, t, s)
    ), n = !1);
  }
  if (i ? i.spaces.after = "" : e.first.spaces.before = "", n) {
    const a = s ? r + "-s" : r;
    e.insertAfter(
      // If node is null it means we need to inject [id] at the start
      // insertAfter can handle `null` here
      i,
      Xu.attribute({
        attribute: a,
        value: a,
        raws: {},
        quoteMark: '"'
      })
    );
  }
}
function B1(r) {
  return r.type === "combinator" && /^\s+$/.test(r.value);
}
Gx.postcss = !0;
var of = {}, B0 = {}, uf = {}, V0 = {}, V1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
V0.encode = function(r) {
  if (0 <= r && r < V1.length)
    return V1[r];
  throw new TypeError("Must be between 0 and 63: " + r);
};
V0.decode = function(r) {
  var e = 65, t = 90, s = 97, i = 122, n = 48, a = 57, o = 43, u = 47, l = 26, c = 52;
  return e <= r && r <= t ? r - e : s <= r && r <= i ? r - s + l : n <= r && r <= a ? r - n + c : r == o ? 62 : r == u ? 63 : -1;
};
var Kx = V0, U0 = 5, Xx = 1 << U0, Jx = Xx - 1, Yx = Xx;
function tR(r) {
  return r < 0 ? (-r << 1) + 1 : (r << 1) + 0;
}
function rR(r) {
  var e = (r & 1) === 1, t = r >> 1;
  return e ? -t : t;
}
uf.encode = function(e) {
  var t = "", s, i = tR(e);
  do
    s = i & Jx, i >>>= U0, i > 0 && (s |= Yx), t += Kx.encode(s);
  while (i > 0);
  return t;
};
uf.decode = function(e, t, s) {
  var i = e.length, n = 0, a = 0, o, u;
  do {
    if (t >= i)
      throw new Error("Expected more digits in base 64 VLQ value.");
    if (u = Kx.decode(e.charCodeAt(t++)), u === -1)
      throw new Error("Invalid base64 digit: " + e.charAt(t - 1));
    o = !!(u & Yx), u &= Jx, n = n + (u << a), a += U0;
  } while (o);
  s.value = rR(n), s.rest = t;
};
var oa = {};
(function(r) {
  function e(b, v, A) {
    if (v in b)
      return b[v];
    if (arguments.length === 3)
      return A;
    throw new Error('"' + v + '" is a required argument.');
  }
  r.getArg = e;
  var t = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, s = /^data:.+\,.+$/;
  function i(b) {
    var v = b.match(t);
    return v ? {
      scheme: v[1],
      auth: v[2],
      host: v[3],
      port: v[4],
      path: v[5]
    } : null;
  }
  r.urlParse = i;
  function n(b) {
    var v = "";
    return b.scheme && (v += b.scheme + ":"), v += "//", b.auth && (v += b.auth + "@"), b.host && (v += b.host), b.port && (v += ":" + b.port), b.path && (v += b.path), v;
  }
  r.urlGenerate = n;
  function a(b) {
    var v = b, A = i(b);
    if (A) {
      if (!A.path)
        return b;
      v = A.path;
    }
    for (var C = r.isAbsolute(v), x = v.split(/\/+/), _, T = 0, P = x.length - 1; P >= 0; P--)
      _ = x[P], _ === "." ? x.splice(P, 1) : _ === ".." ? T++ : T > 0 && (_ === "" ? (x.splice(P + 1, T), T = 0) : (x.splice(P, 2), T--));
    return v = x.join("/"), v === "" && (v = C ? "/" : "."), A ? (A.path = v, n(A)) : v;
  }
  r.normalize = a;
  function o(b, v) {
    b === "" && (b = "."), v === "" && (v = ".");
    var A = i(v), C = i(b);
    if (C && (b = C.path || "/"), A && !A.scheme)
      return C && (A.scheme = C.scheme), n(A);
    if (A || v.match(s))
      return v;
    if (C && !C.host && !C.path)
      return C.host = v, n(C);
    var x = v.charAt(0) === "/" ? v : a(b.replace(/\/+$/, "") + "/" + v);
    return C ? (C.path = x, n(C)) : x;
  }
  r.join = o, r.isAbsolute = function(b) {
    return b.charAt(0) === "/" || t.test(b);
  };
  function u(b, v) {
    b === "" && (b = "."), b = b.replace(/\/$/, "");
    for (var A = 0; v.indexOf(b + "/") !== 0; ) {
      var C = b.lastIndexOf("/");
      if (C < 0 || (b = b.slice(0, C), b.match(/^([^\/]+:\/)?\/*$/)))
        return v;
      ++A;
    }
    return Array(A + 1).join("../") + v.substr(b.length + 1);
  }
  r.relative = u;
  var l = function() {
    var b = /* @__PURE__ */ Object.create(null);
    return !("__proto__" in b);
  }();
  function c(b) {
    return b;
  }
  function f(b) {
    return h(b) ? "$" + b : b;
  }
  r.toSetString = l ? c : f;
  function p(b) {
    return h(b) ? b.slice(1) : b;
  }
  r.fromSetString = l ? c : p;
  function h(b) {
    if (!b)
      return !1;
    var v = b.length;
    if (v < 9 || b.charCodeAt(v - 1) !== 95 || b.charCodeAt(v - 2) !== 95 || b.charCodeAt(v - 3) !== 111 || b.charCodeAt(v - 4) !== 116 || b.charCodeAt(v - 5) !== 111 || b.charCodeAt(v - 6) !== 114 || b.charCodeAt(v - 7) !== 112 || b.charCodeAt(v - 8) !== 95 || b.charCodeAt(v - 9) !== 95)
      return !1;
    for (var A = v - 10; A >= 0; A--)
      if (b.charCodeAt(A) !== 36)
        return !1;
    return !0;
  }
  function m(b, v, A) {
    var C = y(b.source, v.source);
    return C !== 0 || (C = b.originalLine - v.originalLine, C !== 0) || (C = b.originalColumn - v.originalColumn, C !== 0 || A) || (C = b.generatedColumn - v.generatedColumn, C !== 0) || (C = b.generatedLine - v.generatedLine, C !== 0) ? C : y(b.name, v.name);
  }
  r.compareByOriginalPositions = m;
  function d(b, v, A) {
    var C = b.generatedLine - v.generatedLine;
    return C !== 0 || (C = b.generatedColumn - v.generatedColumn, C !== 0 || A) || (C = y(b.source, v.source), C !== 0) || (C = b.originalLine - v.originalLine, C !== 0) || (C = b.originalColumn - v.originalColumn, C !== 0) ? C : y(b.name, v.name);
  }
  r.compareByGeneratedPositionsDeflated = d;
  function y(b, v) {
    return b === v ? 0 : b === null ? 1 : v === null ? -1 : b > v ? 1 : -1;
  }
  function S(b, v) {
    var A = b.generatedLine - v.generatedLine;
    return A !== 0 || (A = b.generatedColumn - v.generatedColumn, A !== 0) || (A = y(b.source, v.source), A !== 0) || (A = b.originalLine - v.originalLine, A !== 0) || (A = b.originalColumn - v.originalColumn, A !== 0) ? A : y(b.name, v.name);
  }
  r.compareByGeneratedPositionsInflated = S;
  function E(b) {
    return JSON.parse(b.replace(/^\)]}'[^\n]*\n/, ""));
  }
  r.parseSourceMapInput = E;
  function g(b, v, A) {
    if (v = v || "", b && (b[b.length - 1] !== "/" && v[0] !== "/" && (b += "/"), v = b + v), A) {
      var C = i(A);
      if (!C)
        throw new Error("sourceMapURL could not be parsed");
      if (C.path) {
        var x = C.path.lastIndexOf("/");
        x >= 0 && (C.path = C.path.substring(0, x + 1));
      }
      v = o(n(C), v);
    }
    return a(v);
  }
  r.computeSourceURL = g;
})(oa);
var j0 = {}, q0 = oa, H0 = Object.prototype.hasOwnProperty, Ui = typeof Map < "u";
function Ns() {
  this._array = [], this._set = Ui ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
}
Ns.fromArray = function(e, t) {
  for (var s = new Ns(), i = 0, n = e.length; i < n; i++)
    s.add(e[i], t);
  return s;
};
Ns.prototype.size = function() {
  return Ui ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
Ns.prototype.add = function(e, t) {
  var s = Ui ? e : q0.toSetString(e), i = Ui ? this.has(e) : H0.call(this._set, s), n = this._array.length;
  (!i || t) && this._array.push(e), i || (Ui ? this._set.set(e, n) : this._set[s] = n);
};
Ns.prototype.has = function(e) {
  if (Ui)
    return this._set.has(e);
  var t = q0.toSetString(e);
  return H0.call(this._set, t);
};
Ns.prototype.indexOf = function(e) {
  if (Ui) {
    var t = this._set.get(e);
    if (t >= 0)
      return t;
  } else {
    var s = q0.toSetString(e);
    if (H0.call(this._set, s))
      return this._set[s];
  }
  throw new Error('"' + e + '" is not in the set.');
};
Ns.prototype.at = function(e) {
  if (e >= 0 && e < this._array.length)
    return this._array[e];
  throw new Error("No element indexed by " + e);
};
Ns.prototype.toArray = function() {
  return this._array.slice();
};
j0.ArraySet = Ns;
var Qx = {}, Zx = oa;
function sR(r, e) {
  var t = r.generatedLine, s = e.generatedLine, i = r.generatedColumn, n = e.generatedColumn;
  return s > t || s == t && n >= i || Zx.compareByGeneratedPositionsInflated(r, e) <= 0;
}
function lf() {
  this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
}
lf.prototype.unsortedForEach = function(e, t) {
  this._array.forEach(e, t);
};
lf.prototype.add = function(e) {
  sR(this._last, e) ? (this._last = e, this._array.push(e)) : (this._sorted = !1, this._array.push(e));
};
lf.prototype.toArray = function() {
  return this._sorted || (this._array.sort(Zx.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
};
Qx.MappingList = lf;
var xa = uf, ft = oa, ql = j0.ArraySet, iR = Qx.MappingList;
function Er(r) {
  r || (r = {}), this._file = ft.getArg(r, "file", null), this._sourceRoot = ft.getArg(r, "sourceRoot", null), this._skipValidation = ft.getArg(r, "skipValidation", !1), this._sources = new ql(), this._names = new ql(), this._mappings = new iR(), this._sourcesContents = null;
}
Er.prototype._version = 3;
Er.fromSourceMap = function(e) {
  var t = e.sourceRoot, s = new Er({
    file: e.file,
    sourceRoot: t
  });
  return e.eachMapping(function(i) {
    var n = {
      generated: {
        line: i.generatedLine,
        column: i.generatedColumn
      }
    };
    i.source != null && (n.source = i.source, t != null && (n.source = ft.relative(t, n.source)), n.original = {
      line: i.originalLine,
      column: i.originalColumn
    }, i.name != null && (n.name = i.name)), s.addMapping(n);
  }), e.sources.forEach(function(i) {
    var n = i;
    t !== null && (n = ft.relative(t, i)), s._sources.has(n) || s._sources.add(n);
    var a = e.sourceContentFor(i);
    a != null && s.setSourceContent(i, a);
  }), s;
};
Er.prototype.addMapping = function(e) {
  var t = ft.getArg(e, "generated"), s = ft.getArg(e, "original", null), i = ft.getArg(e, "source", null), n = ft.getArg(e, "name", null);
  this._skipValidation || this._validateMapping(t, s, i, n), i != null && (i = String(i), this._sources.has(i) || this._sources.add(i)), n != null && (n = String(n), this._names.has(n) || this._names.add(n)), this._mappings.add({
    generatedLine: t.line,
    generatedColumn: t.column,
    originalLine: s != null && s.line,
    originalColumn: s != null && s.column,
    source: i,
    name: n
  });
};
Er.prototype.setSourceContent = function(e, t) {
  var s = e;
  this._sourceRoot != null && (s = ft.relative(this._sourceRoot, s)), t != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[ft.toSetString(s)] = t) : this._sourcesContents && (delete this._sourcesContents[ft.toSetString(s)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
};
Er.prototype.applySourceMap = function(e, t, s) {
  var i = t;
  if (t == null) {
    if (e.file == null)
      throw new Error(
        `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
      );
    i = e.file;
  }
  var n = this._sourceRoot;
  n != null && (i = ft.relative(n, i));
  var a = new ql(), o = new ql();
  this._mappings.unsortedForEach(function(u) {
    if (u.source === i && u.originalLine != null) {
      var l = e.originalPositionFor({
        line: u.originalLine,
        column: u.originalColumn
      });
      l.source != null && (u.source = l.source, s != null && (u.source = ft.join(s, u.source)), n != null && (u.source = ft.relative(n, u.source)), u.originalLine = l.line, u.originalColumn = l.column, l.name != null && (u.name = l.name));
    }
    var c = u.source;
    c != null && !a.has(c) && a.add(c);
    var f = u.name;
    f != null && !o.has(f) && o.add(f);
  }, this), this._sources = a, this._names = o, e.sources.forEach(function(u) {
    var l = e.sourceContentFor(u);
    l != null && (s != null && (u = ft.join(s, u)), n != null && (u = ft.relative(n, u)), this.setSourceContent(u, l));
  }, this);
};
Er.prototype._validateMapping = function(e, t, s, i) {
  if (t && typeof t.line != "number" && typeof t.column != "number")
    throw new Error(
      "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
    );
  if (!(e && "line" in e && "column" in e && e.line > 0 && e.column >= 0 && !t && !s && !i)) {
    if (e && "line" in e && "column" in e && t && "line" in t && "column" in t && e.line > 0 && e.column >= 0 && t.line > 0 && t.column >= 0 && s)
      return;
    throw new Error("Invalid mapping: " + JSON.stringify({
      generated: e,
      source: s,
      original: t,
      name: i
    }));
  }
};
Er.prototype._serializeMappings = function() {
  for (var e = 0, t = 1, s = 0, i = 0, n = 0, a = 0, o = "", u, l, c, f, p = this._mappings.toArray(), h = 0, m = p.length; h < m; h++) {
    if (l = p[h], u = "", l.generatedLine !== t)
      for (e = 0; l.generatedLine !== t; )
        u += ";", t++;
    else if (h > 0) {
      if (!ft.compareByGeneratedPositionsInflated(l, p[h - 1]))
        continue;
      u += ",";
    }
    u += xa.encode(l.generatedColumn - e), e = l.generatedColumn, l.source != null && (f = this._sources.indexOf(l.source), u += xa.encode(f - a), a = f, u += xa.encode(l.originalLine - 1 - i), i = l.originalLine - 1, u += xa.encode(l.originalColumn - s), s = l.originalColumn, l.name != null && (c = this._names.indexOf(l.name), u += xa.encode(c - n), n = c)), o += u;
  }
  return o;
};
Er.prototype._generateSourcesContent = function(e, t) {
  return e.map(function(s) {
    if (!this._sourcesContents)
      return null;
    t != null && (s = ft.relative(t, s));
    var i = ft.toSetString(s);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, i) ? this._sourcesContents[i] : null;
  }, this);
};
Er.prototype.toJSON = function() {
  var e = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  return this._file != null && (e.file = this._file), this._sourceRoot != null && (e.sourceRoot = this._sourceRoot), this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot)), e;
};
Er.prototype.toString = function() {
  return JSON.stringify(this.toJSON());
};
B0.SourceMapGenerator = Er;
var cf = {}, ew = {};
(function(r) {
  r.GREATEST_LOWER_BOUND = 1, r.LEAST_UPPER_BOUND = 2;
  function e(t, s, i, n, a, o) {
    var u = Math.floor((s - t) / 2) + t, l = a(i, n[u], !0);
    return l === 0 ? u : l > 0 ? s - u > 1 ? e(u, s, i, n, a, o) : o == r.LEAST_UPPER_BOUND ? s < n.length ? s : -1 : u : u - t > 1 ? e(t, u, i, n, a, o) : o == r.LEAST_UPPER_BOUND ? u : t < 0 ? -1 : t;
  }
  r.search = function(s, i, n, a) {
    if (i.length === 0)
      return -1;
    var o = e(
      -1,
      i.length,
      s,
      i,
      n,
      a || r.GREATEST_LOWER_BOUND
    );
    if (o < 0)
      return -1;
    for (; o - 1 >= 0 && n(i[o], i[o - 1], !0) === 0; )
      --o;
    return o;
  };
})(ew);
var tw = {};
function Zf(r, e, t) {
  var s = r[e];
  r[e] = r[t], r[t] = s;
}
function nR(r, e) {
  return Math.round(r + Math.random() * (e - r));
}
function zh(r, e, t, s) {
  if (t < s) {
    var i = nR(t, s), n = t - 1;
    Zf(r, i, s);
    for (var a = r[s], o = t; o < s; o++)
      e(r[o], a) <= 0 && (n += 1, Zf(r, n, o));
    Zf(r, n + 1, o);
    var u = n + 1;
    zh(r, e, t, u - 1), zh(r, e, u + 1, s);
  }
}
tw.quickSort = function(r, e) {
  zh(r, e, 0, r.length - 1);
};
var le = oa, W0 = ew, Wn = j0.ArraySet, aR = uf, wo = tw.quickSort;
function Qe(r, e) {
  var t = r;
  return typeof r == "string" && (t = le.parseSourceMapInput(r)), t.sections != null ? new kr(t, e) : new Ot(t, e);
}
Qe.fromSourceMap = function(r, e) {
  return Ot.fromSourceMap(r, e);
};
Qe.prototype._version = 3;
Qe.prototype.__generatedMappings = null;
Object.defineProperty(Qe.prototype, "_generatedMappings", {
  configurable: !0,
  enumerable: !0,
  get: function() {
    return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
  }
});
Qe.prototype.__originalMappings = null;
Object.defineProperty(Qe.prototype, "_originalMappings", {
  configurable: !0,
  enumerable: !0,
  get: function() {
    return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
  }
});
Qe.prototype._charIsMappingSeparator = function(e, t) {
  var s = e.charAt(t);
  return s === ";" || s === ",";
};
Qe.prototype._parseMappings = function(e, t) {
  throw new Error("Subclasses must implement _parseMappings");
};
Qe.GENERATED_ORDER = 1;
Qe.ORIGINAL_ORDER = 2;
Qe.GREATEST_LOWER_BOUND = 1;
Qe.LEAST_UPPER_BOUND = 2;
Qe.prototype.eachMapping = function(e, t, s) {
  var i = t || null, n = s || Qe.GENERATED_ORDER, a;
  switch (n) {
    case Qe.GENERATED_ORDER:
      a = this._generatedMappings;
      break;
    case Qe.ORIGINAL_ORDER:
      a = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }
  var o = this.sourceRoot;
  a.map(function(u) {
    var l = u.source === null ? null : this._sources.at(u.source);
    return l = le.computeSourceURL(o, l, this._sourceMapURL), {
      source: l,
      generatedLine: u.generatedLine,
      generatedColumn: u.generatedColumn,
      originalLine: u.originalLine,
      originalColumn: u.originalColumn,
      name: u.name === null ? null : this._names.at(u.name)
    };
  }, this).forEach(e, i);
};
Qe.prototype.allGeneratedPositionsFor = function(e) {
  var t = le.getArg(e, "line"), s = {
    source: le.getArg(e, "source"),
    originalLine: t,
    originalColumn: le.getArg(e, "column", 0)
  };
  if (s.source = this._findSourceIndex(s.source), s.source < 0)
    return [];
  var i = [], n = this._findMapping(
    s,
    this._originalMappings,
    "originalLine",
    "originalColumn",
    le.compareByOriginalPositions,
    W0.LEAST_UPPER_BOUND
  );
  if (n >= 0) {
    var a = this._originalMappings[n];
    if (e.column === void 0)
      for (var o = a.originalLine; a && a.originalLine === o; )
        i.push({
          line: le.getArg(a, "generatedLine", null),
          column: le.getArg(a, "generatedColumn", null),
          lastColumn: le.getArg(a, "lastGeneratedColumn", null)
        }), a = this._originalMappings[++n];
    else
      for (var u = a.originalColumn; a && a.originalLine === t && a.originalColumn == u; )
        i.push({
          line: le.getArg(a, "generatedLine", null),
          column: le.getArg(a, "generatedColumn", null),
          lastColumn: le.getArg(a, "lastGeneratedColumn", null)
        }), a = this._originalMappings[++n];
  }
  return i;
};
cf.SourceMapConsumer = Qe;
function Ot(r, e) {
  var t = r;
  typeof r == "string" && (t = le.parseSourceMapInput(r));
  var s = le.getArg(t, "version"), i = le.getArg(t, "sources"), n = le.getArg(t, "names", []), a = le.getArg(t, "sourceRoot", null), o = le.getArg(t, "sourcesContent", null), u = le.getArg(t, "mappings"), l = le.getArg(t, "file", null);
  if (s != this._version)
    throw new Error("Unsupported version: " + s);
  a && (a = le.normalize(a)), i = i.map(String).map(le.normalize).map(function(c) {
    return a && le.isAbsolute(a) && le.isAbsolute(c) ? le.relative(a, c) : c;
  }), this._names = Wn.fromArray(n.map(String), !0), this._sources = Wn.fromArray(i, !0), this._absoluteSources = this._sources.toArray().map(function(c) {
    return le.computeSourceURL(a, c, e);
  }), this.sourceRoot = a, this.sourcesContent = o, this._mappings = u, this._sourceMapURL = e, this.file = l;
}
Ot.prototype = Object.create(Qe.prototype);
Ot.prototype.consumer = Qe;
Ot.prototype._findSourceIndex = function(r) {
  var e = r;
  if (this.sourceRoot != null && (e = le.relative(this.sourceRoot, e)), this._sources.has(e))
    return this._sources.indexOf(e);
  var t;
  for (t = 0; t < this._absoluteSources.length; ++t)
    if (this._absoluteSources[t] == r)
      return t;
  return -1;
};
Ot.fromSourceMap = function(e, t) {
  var s = Object.create(Ot.prototype), i = s._names = Wn.fromArray(e._names.toArray(), !0), n = s._sources = Wn.fromArray(e._sources.toArray(), !0);
  s.sourceRoot = e._sourceRoot, s.sourcesContent = e._generateSourcesContent(
    s._sources.toArray(),
    s.sourceRoot
  ), s.file = e._file, s._sourceMapURL = t, s._absoluteSources = s._sources.toArray().map(function(h) {
    return le.computeSourceURL(s.sourceRoot, h, t);
  });
  for (var a = e._mappings.toArray().slice(), o = s.__generatedMappings = [], u = s.__originalMappings = [], l = 0, c = a.length; l < c; l++) {
    var f = a[l], p = new rw();
    p.generatedLine = f.generatedLine, p.generatedColumn = f.generatedColumn, f.source && (p.source = n.indexOf(f.source), p.originalLine = f.originalLine, p.originalColumn = f.originalColumn, f.name && (p.name = i.indexOf(f.name)), u.push(p)), o.push(p);
  }
  return wo(s.__originalMappings, le.compareByOriginalPositions), s;
};
Ot.prototype._version = 3;
Object.defineProperty(Ot.prototype, "sources", {
  get: function() {
    return this._absoluteSources.slice();
  }
});
function rw() {
  this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
}
Ot.prototype._parseMappings = function(e, t) {
  for (var s = 1, i = 0, n = 0, a = 0, o = 0, u = 0, l = e.length, c = 0, f = {}, p = {}, h = [], m = [], d, y, S, E, g; c < l; )
    if (e.charAt(c) === ";")
      s++, c++, i = 0;
    else if (e.charAt(c) === ",")
      c++;
    else {
      for (d = new rw(), d.generatedLine = s, E = c; E < l && !this._charIsMappingSeparator(e, E); E++)
        ;
      if (y = e.slice(c, E), S = f[y], S)
        c += y.length;
      else {
        for (S = []; c < E; )
          aR.decode(e, c, p), g = p.value, c = p.rest, S.push(g);
        if (S.length === 2)
          throw new Error("Found a source, but no line and column");
        if (S.length === 3)
          throw new Error("Found a source and line, but no column");
        f[y] = S;
      }
      d.generatedColumn = i + S[0], i = d.generatedColumn, S.length > 1 && (d.source = o + S[1], o += S[1], d.originalLine = n + S[2], n = d.originalLine, d.originalLine += 1, d.originalColumn = a + S[3], a = d.originalColumn, S.length > 4 && (d.name = u + S[4], u += S[4])), m.push(d), typeof d.originalLine == "number" && h.push(d);
    }
  wo(m, le.compareByGeneratedPositionsDeflated), this.__generatedMappings = m, wo(h, le.compareByOriginalPositions), this.__originalMappings = h;
};
Ot.prototype._findMapping = function(e, t, s, i, n, a) {
  if (e[s] <= 0)
    throw new TypeError("Line must be greater than or equal to 1, got " + e[s]);
  if (e[i] < 0)
    throw new TypeError("Column must be greater than or equal to 0, got " + e[i]);
  return W0.search(e, t, n, a);
};
Ot.prototype.computeColumnSpans = function() {
  for (var e = 0; e < this._generatedMappings.length; ++e) {
    var t = this._generatedMappings[e];
    if (e + 1 < this._generatedMappings.length) {
      var s = this._generatedMappings[e + 1];
      if (t.generatedLine === s.generatedLine) {
        t.lastGeneratedColumn = s.generatedColumn - 1;
        continue;
      }
    }
    t.lastGeneratedColumn = 1 / 0;
  }
};
Ot.prototype.originalPositionFor = function(e) {
  var t = {
    generatedLine: le.getArg(e, "line"),
    generatedColumn: le.getArg(e, "column")
  }, s = this._findMapping(
    t,
    this._generatedMappings,
    "generatedLine",
    "generatedColumn",
    le.compareByGeneratedPositionsDeflated,
    le.getArg(e, "bias", Qe.GREATEST_LOWER_BOUND)
  );
  if (s >= 0) {
    var i = this._generatedMappings[s];
    if (i.generatedLine === t.generatedLine) {
      var n = le.getArg(i, "source", null);
      n !== null && (n = this._sources.at(n), n = le.computeSourceURL(this.sourceRoot, n, this._sourceMapURL));
      var a = le.getArg(i, "name", null);
      return a !== null && (a = this._names.at(a)), {
        source: n,
        line: le.getArg(i, "originalLine", null),
        column: le.getArg(i, "originalColumn", null),
        name: a
      };
    }
  }
  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
Ot.prototype.hasContentsOfAllSources = function() {
  return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e) {
    return e == null;
  }) : !1;
};
Ot.prototype.sourceContentFor = function(e, t) {
  if (!this.sourcesContent)
    return null;
  var s = this._findSourceIndex(e);
  if (s >= 0)
    return this.sourcesContent[s];
  var i = e;
  this.sourceRoot != null && (i = le.relative(this.sourceRoot, i));
  var n;
  if (this.sourceRoot != null && (n = le.urlParse(this.sourceRoot))) {
    var a = i.replace(/^file:\/\//, "");
    if (n.scheme == "file" && this._sources.has(a))
      return this.sourcesContent[this._sources.indexOf(a)];
    if ((!n.path || n.path == "/") && this._sources.has("/" + i))
      return this.sourcesContent[this._sources.indexOf("/" + i)];
  }
  if (t)
    return null;
  throw new Error('"' + i + '" is not in the SourceMap.');
};
Ot.prototype.generatedPositionFor = function(e) {
  var t = le.getArg(e, "source");
  if (t = this._findSourceIndex(t), t < 0)
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  var s = {
    source: t,
    originalLine: le.getArg(e, "line"),
    originalColumn: le.getArg(e, "column")
  }, i = this._findMapping(
    s,
    this._originalMappings,
    "originalLine",
    "originalColumn",
    le.compareByOriginalPositions,
    le.getArg(e, "bias", Qe.GREATEST_LOWER_BOUND)
  );
  if (i >= 0) {
    var n = this._originalMappings[i];
    if (n.source === s.source)
      return {
        line: le.getArg(n, "generatedLine", null),
        column: le.getArg(n, "generatedColumn", null),
        lastColumn: le.getArg(n, "lastGeneratedColumn", null)
      };
  }
  return {
    line: null,
    column: null,
    lastColumn: null
  };
};
cf.BasicSourceMapConsumer = Ot;
function kr(r, e) {
  var t = r;
  typeof r == "string" && (t = le.parseSourceMapInput(r));
  var s = le.getArg(t, "version"), i = le.getArg(t, "sections");
  if (s != this._version)
    throw new Error("Unsupported version: " + s);
  this._sources = new Wn(), this._names = new Wn();
  var n = {
    line: -1,
    column: 0
  };
  this._sections = i.map(function(a) {
    if (a.url)
      throw new Error("Support for url field in sections not implemented.");
    var o = le.getArg(a, "offset"), u = le.getArg(o, "line"), l = le.getArg(o, "column");
    if (u < n.line || u === n.line && l < n.column)
      throw new Error("Section offsets must be ordered and non-overlapping.");
    return n = o, {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: u + 1,
        generatedColumn: l + 1
      },
      consumer: new Qe(le.getArg(a, "map"), e)
    };
  });
}
kr.prototype = Object.create(Qe.prototype);
kr.prototype.constructor = Qe;
kr.prototype._version = 3;
Object.defineProperty(kr.prototype, "sources", {
  get: function() {
    for (var r = [], e = 0; e < this._sections.length; e++)
      for (var t = 0; t < this._sections[e].consumer.sources.length; t++)
        r.push(this._sections[e].consumer.sources[t]);
    return r;
  }
});
kr.prototype.originalPositionFor = function(e) {
  var t = {
    generatedLine: le.getArg(e, "line"),
    generatedColumn: le.getArg(e, "column")
  }, s = W0.search(
    t,
    this._sections,
    function(n, a) {
      var o = n.generatedLine - a.generatedOffset.generatedLine;
      return o || n.generatedColumn - a.generatedOffset.generatedColumn;
    }
  ), i = this._sections[s];
  return i ? i.consumer.originalPositionFor({
    line: t.generatedLine - (i.generatedOffset.generatedLine - 1),
    column: t.generatedColumn - (i.generatedOffset.generatedLine === t.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),
    bias: e.bias
  }) : {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
kr.prototype.hasContentsOfAllSources = function() {
  return this._sections.every(function(e) {
    return e.consumer.hasContentsOfAllSources();
  });
};
kr.prototype.sourceContentFor = function(e, t) {
  for (var s = 0; s < this._sections.length; s++) {
    var i = this._sections[s], n = i.consumer.sourceContentFor(e, !0);
    if (n)
      return n;
  }
  if (t)
    return null;
  throw new Error('"' + e + '" is not in the SourceMap.');
};
kr.prototype.generatedPositionFor = function(e) {
  for (var t = 0; t < this._sections.length; t++) {
    var s = this._sections[t];
    if (s.consumer._findSourceIndex(le.getArg(e, "source")) !== -1) {
      var i = s.consumer.generatedPositionFor(e);
      if (i) {
        var n = {
          line: i.line + (s.generatedOffset.generatedLine - 1),
          column: i.column + (s.generatedOffset.generatedLine === i.line ? s.generatedOffset.generatedColumn - 1 : 0)
        };
        return n;
      }
    }
  }
  return {
    line: null,
    column: null
  };
};
kr.prototype._parseMappings = function(e, t) {
  this.__generatedMappings = [], this.__originalMappings = [];
  for (var s = 0; s < this._sections.length; s++)
    for (var i = this._sections[s], n = i.consumer._generatedMappings, a = 0; a < n.length; a++) {
      var o = n[a], u = i.consumer._sources.at(o.source);
      u = le.computeSourceURL(i.consumer.sourceRoot, u, this._sourceMapURL), this._sources.add(u), u = this._sources.indexOf(u);
      var l = null;
      o.name && (l = i.consumer._names.at(o.name), this._names.add(l), l = this._names.indexOf(l));
      var c = {
        source: u,
        generatedLine: o.generatedLine + (i.generatedOffset.generatedLine - 1),
        generatedColumn: o.generatedColumn + (i.generatedOffset.generatedLine === o.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),
        originalLine: o.originalLine,
        originalColumn: o.originalColumn,
        name: l
      };
      this.__generatedMappings.push(c), typeof c.originalLine == "number" && this.__originalMappings.push(c);
    }
  wo(this.__generatedMappings, le.compareByGeneratedPositionsDeflated), wo(this.__originalMappings, le.compareByOriginalPositions);
};
cf.IndexedSourceMapConsumer = kr;
var sw = {}, oR = B0.SourceMapGenerator, Hl = oa, uR = /(\r?\n)/, lR = 10, ua = "$$$isSourceNode$$$";
function cr(r, e, t, s, i) {
  this.children = [], this.sourceContents = {}, this.line = r ?? null, this.column = e ?? null, this.source = t ?? null, this.name = i ?? null, this[ua] = !0, s != null && this.add(s);
}
cr.fromStringWithSourceMap = function(e, t, s) {
  var i = new cr(), n = e.split(uR), a = 0, o = function() {
    var p = m(), h = m() || "";
    return p + h;
    function m() {
      return a < n.length ? n[a++] : void 0;
    }
  }, u = 1, l = 0, c = null;
  return t.eachMapping(function(p) {
    if (c !== null)
      if (u < p.generatedLine)
        f(c, o()), u++, l = 0;
      else {
        var h = n[a] || "", m = h.substr(0, p.generatedColumn - l);
        n[a] = h.substr(p.generatedColumn - l), l = p.generatedColumn, f(c, m), c = p;
        return;
      }
    for (; u < p.generatedLine; )
      i.add(o()), u++;
    if (l < p.generatedColumn) {
      var h = n[a] || "";
      i.add(h.substr(0, p.generatedColumn)), n[a] = h.substr(p.generatedColumn), l = p.generatedColumn;
    }
    c = p;
  }, this), a < n.length && (c && f(c, o()), i.add(n.splice(a).join(""))), t.sources.forEach(function(p) {
    var h = t.sourceContentFor(p);
    h != null && (s != null && (p = Hl.join(s, p)), i.setSourceContent(p, h));
  }), i;
  function f(p, h) {
    if (p === null || p.source === void 0)
      i.add(h);
    else {
      var m = s ? Hl.join(s, p.source) : p.source;
      i.add(new cr(
        p.originalLine,
        p.originalColumn,
        m,
        h,
        p.name
      ));
    }
  }
};
cr.prototype.add = function(e) {
  if (Array.isArray(e))
    e.forEach(function(t) {
      this.add(t);
    }, this);
  else if (e[ua] || typeof e == "string")
    e && this.children.push(e);
  else
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e
    );
  return this;
};
cr.prototype.prepend = function(e) {
  if (Array.isArray(e))
    for (var t = e.length - 1; t >= 0; t--)
      this.prepend(e[t]);
  else if (e[ua] || typeof e == "string")
    this.children.unshift(e);
  else
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e
    );
  return this;
};
cr.prototype.walk = function(e) {
  for (var t, s = 0, i = this.children.length; s < i; s++)
    t = this.children[s], t[ua] ? t.walk(e) : t !== "" && e(t, {
      source: this.source,
      line: this.line,
      column: this.column,
      name: this.name
    });
};
cr.prototype.join = function(e) {
  var t, s, i = this.children.length;
  if (i > 0) {
    for (t = [], s = 0; s < i - 1; s++)
      t.push(this.children[s]), t.push(e);
    t.push(this.children[s]), this.children = t;
  }
  return this;
};
cr.prototype.replaceRight = function(e, t) {
  var s = this.children[this.children.length - 1];
  return s[ua] ? s.replaceRight(e, t) : typeof s == "string" ? this.children[this.children.length - 1] = s.replace(e, t) : this.children.push("".replace(e, t)), this;
};
cr.prototype.setSourceContent = function(e, t) {
  this.sourceContents[Hl.toSetString(e)] = t;
};
cr.prototype.walkSourceContents = function(e) {
  for (var t = 0, s = this.children.length; t < s; t++)
    this.children[t][ua] && this.children[t].walkSourceContents(e);
  for (var i = Object.keys(this.sourceContents), t = 0, s = i.length; t < s; t++)
    e(Hl.fromSetString(i[t]), this.sourceContents[i[t]]);
};
cr.prototype.toString = function() {
  var e = "";
  return this.walk(function(t) {
    e += t;
  }), e;
};
cr.prototype.toStringWithSourceMap = function(e) {
  var t = {
    code: "",
    line: 1,
    column: 0
  }, s = new oR(e), i = !1, n = null, a = null, o = null, u = null;
  return this.walk(function(l, c) {
    t.code += l, c.source !== null && c.line !== null && c.column !== null ? ((n !== c.source || a !== c.line || o !== c.column || u !== c.name) && s.addMapping({
      source: c.source,
      original: {
        line: c.line,
        column: c.column
      },
      generated: {
        line: t.line,
        column: t.column
      },
      name: c.name
    }), n = c.source, a = c.line, o = c.column, u = c.name, i = !0) : i && (s.addMapping({
      generated: {
        line: t.line,
        column: t.column
      }
    }), n = null, i = !1);
    for (var f = 0, p = l.length; f < p; f++)
      l.charCodeAt(f) === lR ? (t.line++, t.column = 0, f + 1 === p ? (n = null, i = !1) : i && s.addMapping({
        source: c.source,
        original: {
          line: c.line,
          column: c.column
        },
        generated: {
          line: t.line,
          column: t.column
        },
        name: c.name
      })) : t.column++;
  }), this.walkSourceContents(function(l, c) {
    s.setSourceContent(l, c);
  }), { code: t.code, map: s };
};
sw.SourceNode = cr;
of.SourceMapGenerator = B0.SourceMapGenerator;
of.SourceMapConsumer = cf.SourceMapConsumer;
of.SourceNode = sw.SourceNode;
var iw = of, U1 = iw.SourceMapConsumer, cR = iw.SourceMapGenerator, fR = pR;
function pR(r, e) {
  if (!r) return e;
  if (!e) return r;
  var t = new U1(r), s = new U1(e), i = new cR();
  s.eachMapping(function(a) {
    if (a.originalLine != null) {
      var o = t.originalPositionFor({
        line: a.originalLine,
        column: a.originalColumn
      });
      o.source != null && i.addMapping({
        original: {
          line: o.line,
          column: o.column
        },
        generated: {
          line: a.generatedLine,
          column: a.generatedColumn
        },
        source: o.source,
        name: o.name
      });
    }
  });
  var n = [t, s];
  return n.forEach(function(a) {
    a.sources.forEach(function(o) {
      i._sources.add(o);
      var u = a.sourceContentFor(o);
      u != null && i.setSourceContent(o, u);
    });
  }), i._sourceRoot = r.sourceRoot, i._file = r.file, JSON.parse(i.toString());
}
var z0 = /* @__PURE__ */ Dc(fR), hR = Object.defineProperty, dR = Object.defineProperties, mR = Object.getOwnPropertyDescriptors, j1 = Object.getOwnPropertySymbols, gR = Object.prototype.hasOwnProperty, yR = Object.prototype.propertyIsEnumerable, q1 = (r, e, t) => e in r ? hR(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, G0 = (r, e) => {
  for (var t in e || (e = {}))
    gR.call(e, t) && q1(r, t, e[t]);
  if (j1)
    for (var t of j1(e))
      yR.call(e, t) && q1(r, t, e[t]);
  return r;
}, K0 = (r, e) => dR(r, mR(e));
const nw = (r, e, t, s = require) => {
  const i = s("sass"), n = K0(G0({}, t), {
    data: aw(r, t.filename, t.additionalData),
    file: t.filename,
    outFile: t.filename,
    sourceMap: !!e
  });
  try {
    const a = i.renderSync(n), o = a.stats.includedFiles;
    return e ? {
      code: a.css.toString(),
      map: z0(e, JSON.parse(a.map.toString())),
      errors: [],
      dependencies: o
    } : { code: a.css.toString(), errors: [], dependencies: o };
  } catch (a) {
    return { code: "", errors: [a], dependencies: [] };
  }
}, bR = (r, e, t, s) => nw(
  r,
  e,
  K0(G0({}, t), {
    indentedSyntax: !0
  }),
  s
), vR = (r, e, t, s = require) => {
  const i = s("less");
  let n, a = null;
  if (i.render(
    aw(r, t.filename, t.additionalData),
    K0(G0({}, t), { syncImport: !0 }),
    (u, l) => {
      a = u, n = l;
    }
  ), a) return { code: "", errors: [a], dependencies: [] };
  const o = n.imports;
  return e ? {
    code: n.css.toString(),
    map: z0(e, n.map),
    errors: [],
    dependencies: o
  } : {
    code: n.css.toString(),
    errors: [],
    dependencies: o
  };
}, H1 = (r, e, t, s = require) => {
  const i = s("stylus");
  try {
    const n = i(r, t);
    e && n.set("sourcemap", { inline: !1, comment: !1 });
    const a = n.render(), o = n.deps();
    return e ? {
      code: a,
      map: z0(e, n.sourcemap),
      errors: [],
      dependencies: o
    } : { code: a, errors: [], dependencies: o };
  } catch (n) {
    return { code: "", errors: [n], dependencies: [] };
  }
};
function aw(r, e, t) {
  return t ? LE(t) ? t(r, e) : t + r : r;
}
const ER = {
  less: vR,
  sass: bR,
  scss: nw,
  styl: H1,
  stylus: H1
};
var SR = Object.defineProperty, _R = Object.defineProperties, xR = Object.getOwnPropertyDescriptors, W1 = Object.getOwnPropertySymbols, wR = Object.prototype.hasOwnProperty, TR = Object.prototype.propertyIsEnumerable, z1 = (r, e, t) => e in r ? SR(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, ff = (r, e) => {
  for (var t in e || (e = {}))
    wR.call(e, t) && z1(r, t, e[t]);
  if (W1)
    for (var t of W1(e))
      TR.call(e, t) && z1(r, t, e[t]);
  return r;
}, X0 = (r, e) => _R(r, xR(e));
function PR(r) {
  return ow(X0(ff({}, r), {
    isAsync: !1
  }));
}
function AR(r) {
  return ow(X0(ff({}, r), {
    isAsync: !0
  }));
}
function ow(r) {
  const {
    filename: e,
    id: t,
    scoped: s = !1,
    trim: i = !0,
    isProd: n = !1,
    modules: a = !1,
    modulesOptions: o = {},
    preprocessLang: u,
    postcssOptions: l,
    postcssPlugins: c
  } = r, f = u && ER[u], p = f && CR(r, f), h = p ? p.map : r.inMap || r.map, m = p ? p.code : r.source, d = t.replace(/^data-v-/, ""), y = `data-v-${d}`, S = (c || []).slice();
  S.unshift(b2({ id: d, isProd: n })), i && S.push(Cx()), s && S.push(Gx(y));
  let E;
  if (a)
    throw new Error(
      "[@vue/compiler-sfc] `modules` option is not supported in the browser build."
    );
  const g = X0(ff({}, l), {
    to: e,
    from: e
  });
  h && (g.map = {
    inline: !1,
    annotation: !1,
    prev: h
  });
  let b, v, A;
  const C = new Set(
    p ? p.dependencies : []
  );
  C.delete(e);
  const x = [];
  p && p.errors.length && x.push(...p.errors);
  const _ = (T) => (T.forEach((P) => {
    P.type === "dependency" && C.add(P.file);
  }), C);
  try {
    if (b = Ze(S).process(m, g), r.isAsync)
      return b.then((T) => ({
        code: T.css || "",
        map: T.map && T.map.toJSON(),
        errors: x,
        modules: E,
        rawResult: T,
        dependencies: _(T.messages)
      })).catch((T) => ({
        code: "",
        map: void 0,
        errors: [...x, T],
        rawResult: void 0,
        dependencies: C
      }));
    _(b.messages), v = b.css, A = b.map;
  } catch (T) {
    x.push(T);
  }
  return {
    code: v || "",
    map: A && A.toJSON(),
    errors: x,
    rawResult: b,
    dependencies: C
  };
}
function CR(r, e) {
  if (!r.preprocessCustomRequire)
    throw new Error(
      "[@vue/compiler-sfc] Style preprocessing in the browser build must provide the `preprocessCustomRequire` option to return the in-browser version of the preprocessor."
    );
  return e(
    r.source,
    r.inMap || r.map,
    ff({
      filename: r.filename
    }, r.preprocessOptions),
    r.preprocessCustomRequire
  );
}
function uw(r) {
  for (const e of r)
    if (e.type === "ExportDefaultDeclaration" && e.declaration.type === "ObjectExpression")
      return NR(e.declaration);
  return {};
}
function NR(r) {
  const e = {};
  Object.defineProperty(e, "__isScriptSetup", {
    enumerable: !1,
    value: !1
  });
  for (const t of r.properties)
    if (t.type === "ObjectProperty" && !t.computed && t.key.type === "Identifier") {
      if (t.key.name === "props")
        for (const s of Kh(t.value))
          e[s] = "props";
      else if (t.key.name === "inject")
        for (const s of Kh(t.value))
          e[s] = "options";
      else if (t.value.type === "ObjectExpression" && (t.key.name === "computed" || t.key.name === "methods"))
        for (const s of Gh(t.value))
          e[s] = "options";
    } else if (t.type === "ObjectMethod" && t.key.type === "Identifier" && (t.key.name === "setup" || t.key.name === "data")) {
      for (const s of t.body.body)
        if (s.type === "ReturnStatement" && s.argument && s.argument.type === "ObjectExpression")
          for (const i of Gh(s.argument))
            e[i] = t.key.name === "setup" ? "setup-maybe-ref" : "data";
    }
  return e;
}
function Gh(r) {
  const e = [];
  for (const t of r.properties) {
    if (t.type === "SpreadElement") continue;
    const s = n0(t.key, t.computed);
    s && e.push(String(s));
  }
  return e;
}
function OR(r) {
  const e = [];
  for (const t of r.elements)
    t && t.type === "StringLiteral" && e.push(t.value);
  return e;
}
function Kh(r) {
  return r.type === "ArrayExpression" ? OR(r) : r.type === "ObjectExpression" ? Gh(r) : [];
}
const IR = 44, kR = 59, G1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lw = new Uint8Array(64), DR = new Uint8Array(128);
for (let r = 0; r < G1.length; r++) {
  const e = G1.charCodeAt(r);
  lw[r] = e, DR[e] = r;
}
const ep = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
  decode(r) {
    return Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString();
  }
} : {
  decode(r) {
    let e = "";
    for (let t = 0; t < r.length; t++)
      e += String.fromCharCode(r[t]);
    return e;
  }
};
function LR(r) {
  const e = new Int32Array(5), t = 1024 * 16, s = t - 36, i = new Uint8Array(t), n = i.subarray(0, s);
  let a = 0, o = "";
  for (let u = 0; u < r.length; u++) {
    const l = r[u];
    if (u > 0 && (a === t && (o += ep.decode(i), a = 0), i[a++] = kR), l.length !== 0) {
      e[0] = 0;
      for (let c = 0; c < l.length; c++) {
        const f = l[c];
        a > s && (o += ep.decode(n), i.copyWithin(0, s, a), a -= s), c > 0 && (i[a++] = IR), a = wa(i, a, e, f, 0), f.length !== 1 && (a = wa(i, a, e, f, 1), a = wa(i, a, e, f, 2), a = wa(i, a, e, f, 3), f.length !== 4 && (a = wa(i, a, e, f, 4)));
      }
    }
  }
  return o + ep.decode(i.subarray(0, a));
}
function wa(r, e, t, s, i) {
  const n = s[i];
  let a = n - t[i];
  t[i] = n, a = a < 0 ? -a << 1 | 1 : a << 1;
  do {
    let o = a & 31;
    a >>>= 5, a > 0 && (o |= 32), r[e++] = lw[o];
  } while (a > 0);
  return e;
}
class Wl {
  constructor(e) {
    this.bits = e instanceof Wl ? e.bits.slice() : [];
  }
  add(e) {
    this.bits[e >> 5] |= 1 << (e & 31);
  }
  has(e) {
    return !!(this.bits[e >> 5] & 1 << (e & 31));
  }
}
class To {
  constructor(e, t, s) {
    this.start = e, this.end = t, this.original = s, this.intro = "", this.outro = "", this.content = s, this.storeName = !1, this.edited = !1, this.previous = null, this.next = null;
  }
  appendLeft(e) {
    this.outro += e;
  }
  appendRight(e) {
    this.intro = this.intro + e;
  }
  clone() {
    const e = new To(this.start, this.end, this.original);
    return e.intro = this.intro, e.outro = this.outro, e.content = this.content, e.storeName = this.storeName, e.edited = this.edited, e;
  }
  contains(e) {
    return this.start < e && e < this.end;
  }
  eachNext(e) {
    let t = this;
    for (; t; )
      e(t), t = t.next;
  }
  eachPrevious(e) {
    let t = this;
    for (; t; )
      e(t), t = t.previous;
  }
  edit(e, t, s) {
    return this.content = e, s || (this.intro = "", this.outro = ""), this.storeName = t, this.edited = !0, this;
  }
  prependLeft(e) {
    this.outro = e + this.outro;
  }
  prependRight(e) {
    this.intro = e + this.intro;
  }
  reset() {
    this.intro = "", this.outro = "", this.edited && (this.content = this.original, this.storeName = !1, this.edited = !1);
  }
  split(e) {
    const t = e - this.start, s = this.original.slice(0, t), i = this.original.slice(t);
    this.original = s;
    const n = new To(e, this.end, i);
    return n.outro = this.outro, this.outro = "", this.end = e, this.edited ? (n.edit("", !1), this.content = "") : this.content = s, n.next = this.next, n.next && (n.next.previous = n), n.previous = this, this.next = n, n;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(e) {
    if (this.outro = this.outro.replace(e, ""), this.outro.length) return !0;
    const t = this.content.replace(e, "");
    if (t.length)
      return t !== this.content && (this.split(this.start + t.length).edit("", void 0, !0), this.edited && this.edit(t, this.storeName, !0)), !0;
    if (this.edit("", void 0, !0), this.intro = this.intro.replace(e, ""), this.intro.length) return !0;
  }
  trimStart(e) {
    if (this.intro = this.intro.replace(e, ""), this.intro.length) return !0;
    const t = this.content.replace(e, "");
    if (t.length) {
      if (t !== this.content) {
        const s = this.split(this.end - t.length);
        this.edited && s.edit(t, this.storeName, !0), this.edit("", void 0, !0);
      }
      return !0;
    } else if (this.edit("", void 0, !0), this.outro = this.outro.replace(e, ""), this.outro.length) return !0;
  }
}
function MR() {
  return typeof globalThis < "u" && typeof globalThis.btoa == "function" ? (r) => globalThis.btoa(unescape(encodeURIComponent(r))) : typeof Buffer == "function" ? (r) => Buffer.from(r, "utf-8").toString("base64") : () => {
    throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
  };
}
const RR = /* @__PURE__ */ MR();
class $R {
  constructor(e) {
    this.version = 3, this.file = e.file, this.sources = e.sources, this.sourcesContent = e.sourcesContent, this.names = e.names, this.mappings = LR(e.mappings), typeof e.x_google_ignoreList < "u" && (this.x_google_ignoreList = e.x_google_ignoreList);
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + RR(this.toString());
  }
}
function FR(r) {
  const e = r.split(`
`), t = e.filter((n) => /^\t+/.test(n)), s = e.filter((n) => /^ {2,}/.test(n));
  if (t.length === 0 && s.length === 0)
    return null;
  if (t.length >= s.length)
    return "	";
  const i = s.reduce((n, a) => {
    const o = /^ +/.exec(a)[0].length;
    return Math.min(o, n);
  }, 1 / 0);
  return new Array(i + 1).join(" ");
}
function BR(r, e) {
  const t = r.split(/[/\\]/), s = e.split(/[/\\]/);
  for (t.pop(); t[0] === s[0]; )
    t.shift(), s.shift();
  if (t.length) {
    let i = t.length;
    for (; i--; ) t[i] = "..";
  }
  return t.concat(s).join("/");
}
const VR = Object.prototype.toString;
function UR(r) {
  return VR.call(r) === "[object Object]";
}
function K1(r) {
  const e = r.split(`
`), t = [];
  for (let s = 0, i = 0; s < e.length; s++)
    t.push(i), i += e[s].length + 1;
  return function(i) {
    let n = 0, a = t.length;
    for (; n < a; ) {
      const l = n + a >> 1;
      i < t[l] ? a = l : n = l + 1;
    }
    const o = n - 1, u = i - t[o];
    return { line: o, column: u };
  };
}
const jR = /\w/;
class qR {
  constructor(e) {
    this.hires = e, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
  }
  addEdit(e, t, s, i) {
    if (t.length) {
      const n = t.length - 1;
      let a = t.indexOf(`
`, 0), o = -1;
      for (; a >= 0 && n > a; ) {
        const l = [this.generatedCodeColumn, e, s.line, s.column];
        i >= 0 && l.push(i), this.rawSegments.push(l), this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, o = a, a = t.indexOf(`
`, a + 1);
      }
      const u = [this.generatedCodeColumn, e, s.line, s.column];
      i >= 0 && u.push(i), this.rawSegments.push(u), this.advance(t.slice(o + 1));
    } else this.pending && (this.rawSegments.push(this.pending), this.advance(t));
    this.pending = null;
  }
  addUneditedChunk(e, t, s, i, n) {
    let a = t.start, o = !0, u = !1;
    for (; a < t.end; ) {
      if (this.hires || o || n.has(a)) {
        const l = [this.generatedCodeColumn, e, i.line, i.column];
        this.hires === "boundary" ? jR.test(s[a]) ? u || (this.rawSegments.push(l), u = !0) : (this.rawSegments.push(l), u = !1) : this.rawSegments.push(l);
      }
      s[a] === `
` ? (i.line += 1, i.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, o = !0) : (i.column += 1, this.generatedCodeColumn += 1, o = !1), a += 1;
    }
    this.pending = null;
  }
  advance(e) {
    if (!e) return;
    const t = e.split(`
`);
    if (t.length > 1) {
      for (let s = 0; s < t.length - 1; s++)
        this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += t[t.length - 1].length;
  }
}
const Ta = `
`, ln = {
  insertLeft: !1,
  insertRight: !1,
  storeName: !1
};
class la {
  constructor(e, t = {}) {
    const s = new To(0, e.length, e);
    Object.defineProperties(this, {
      original: { writable: !0, value: e },
      outro: { writable: !0, value: "" },
      intro: { writable: !0, value: "" },
      firstChunk: { writable: !0, value: s },
      lastChunk: { writable: !0, value: s },
      lastSearchedChunk: { writable: !0, value: s },
      byStart: { writable: !0, value: {} },
      byEnd: { writable: !0, value: {} },
      filename: { writable: !0, value: t.filename },
      indentExclusionRanges: { writable: !0, value: t.indentExclusionRanges },
      sourcemapLocations: { writable: !0, value: new Wl() },
      storedNames: { writable: !0, value: {} },
      indentStr: { writable: !0, value: void 0 },
      ignoreList: { writable: !0, value: t.ignoreList }
    }), this.byStart[0] = s, this.byEnd[e.length] = s;
  }
  addSourcemapLocation(e) {
    this.sourcemapLocations.add(e);
  }
  append(e) {
    if (typeof e != "string") throw new TypeError("outro content must be a string");
    return this.outro += e, this;
  }
  appendLeft(e, t) {
    if (typeof t != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    const s = this.byEnd[e];
    return s ? s.appendLeft(t) : this.intro += t, this;
  }
  appendRight(e, t) {
    if (typeof t != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    const s = this.byStart[e];
    return s ? s.appendRight(t) : this.outro += t, this;
  }
  clone() {
    const e = new la(this.original, { filename: this.filename });
    let t = this.firstChunk, s = e.firstChunk = e.lastSearchedChunk = t.clone();
    for (; t; ) {
      e.byStart[s.start] = s, e.byEnd[s.end] = s;
      const i = t.next, n = i && i.clone();
      n && (s.next = n, n.previous = s, s = n), t = i;
    }
    return e.lastChunk = s, this.indentExclusionRanges && (e.indentExclusionRanges = this.indentExclusionRanges.slice()), e.sourcemapLocations = new Wl(this.sourcemapLocations), e.intro = this.intro, e.outro = this.outro, e;
  }
  generateDecodedMap(e) {
    e = e || {};
    const t = 0, s = Object.keys(this.storedNames), i = new qR(e.hires), n = K1(this.original);
    return this.intro && i.advance(this.intro), this.firstChunk.eachNext((a) => {
      const o = n(a.start);
      a.intro.length && i.advance(a.intro), a.edited ? i.addEdit(
        t,
        a.content,
        o,
        a.storeName ? s.indexOf(a.original) : -1
      ) : i.addUneditedChunk(t, a, this.original, o, this.sourcemapLocations), a.outro.length && i.advance(a.outro);
    }), {
      file: e.file ? e.file.split(/[/\\]/).pop() : void 0,
      sources: [
        e.source ? BR(e.file || "", e.source) : e.file || ""
      ],
      sourcesContent: e.includeContent ? [this.original] : void 0,
      names: s,
      mappings: i.raw,
      x_google_ignoreList: this.ignoreList ? [t] : void 0
    };
  }
  generateMap(e) {
    return new $R(this.generateDecodedMap(e));
  }
  _ensureindentStr() {
    this.indentStr === void 0 && (this.indentStr = FR(this.original));
  }
  _getRawIndentString() {
    return this._ensureindentStr(), this.indentStr;
  }
  getIndentString() {
    return this._ensureindentStr(), this.indentStr === null ? "	" : this.indentStr;
  }
  indent(e, t) {
    const s = /^[^\r\n]/gm;
    if (UR(e) && (t = e, e = void 0), e === void 0 && (this._ensureindentStr(), e = this.indentStr || "	"), e === "") return this;
    t = t || {};
    const i = {};
    t.exclude && (typeof t.exclude[0] == "number" ? [t.exclude] : t.exclude).forEach((c) => {
      for (let f = c[0]; f < c[1]; f += 1)
        i[f] = !0;
    });
    let n = t.indentStart !== !1;
    const a = (l) => n ? `${e}${l}` : (n = !0, l);
    this.intro = this.intro.replace(s, a);
    let o = 0, u = this.firstChunk;
    for (; u; ) {
      const l = u.end;
      if (u.edited)
        i[o] || (u.content = u.content.replace(s, a), u.content.length && (n = u.content[u.content.length - 1] === `
`));
      else
        for (o = u.start; o < l; ) {
          if (!i[o]) {
            const c = this.original[o];
            c === `
` ? n = !0 : c !== "\r" && n && (n = !1, o === u.start || (this._splitChunk(u, o), u = u.next), u.prependRight(e));
          }
          o += 1;
        }
      o = u.end, u = u.next;
    }
    return this.outro = this.outro.replace(s, a), this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(e, t) {
    return ln.insertLeft || (console.warn(
      "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
    ), ln.insertLeft = !0), this.appendLeft(e, t);
  }
  insertRight(e, t) {
    return ln.insertRight || (console.warn(
      "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
    ), ln.insertRight = !0), this.prependRight(e, t);
  }
  move(e, t, s) {
    if (s >= e && s <= t) throw new Error("Cannot move a selection inside itself");
    this._split(e), this._split(t), this._split(s);
    const i = this.byStart[e], n = this.byEnd[t], a = i.previous, o = n.next, u = this.byStart[s];
    if (!u && n === this.lastChunk) return this;
    const l = u ? u.previous : this.lastChunk;
    return a && (a.next = o), o && (o.previous = a), l && (l.next = i), u && (u.previous = n), i.previous || (this.firstChunk = n.next), n.next || (this.lastChunk = i.previous, this.lastChunk.next = null), i.previous = l, n.next = u || null, l || (this.firstChunk = i), u || (this.lastChunk = n), this;
  }
  overwrite(e, t, s, i) {
    return i = i || {}, this.update(e, t, s, { ...i, overwrite: !i.contentOnly });
  }
  update(e, t, s, i) {
    if (typeof s != "string") throw new TypeError("replacement content must be a string");
    for (; e < 0; ) e += this.original.length;
    for (; t < 0; ) t += this.original.length;
    if (t > this.original.length) throw new Error("end is out of bounds");
    if (e === t)
      throw new Error(
        "Cannot overwrite a zero-length range  use appendLeft or prependRight instead"
      );
    this._split(e), this._split(t), i === !0 && (ln.storeName || (console.warn(
      "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
    ), ln.storeName = !0), i = { storeName: !0 });
    const n = i !== void 0 ? i.storeName : !1, a = i !== void 0 ? i.overwrite : !1;
    if (n) {
      const l = this.original.slice(e, t);
      Object.defineProperty(this.storedNames, l, {
        writable: !0,
        value: !0,
        enumerable: !0
      });
    }
    const o = this.byStart[e], u = this.byEnd[t];
    if (o) {
      let l = o;
      for (; l !== u; ) {
        if (l.next !== this.byStart[l.end])
          throw new Error("Cannot overwrite across a split point");
        l = l.next, l.edit("", !1);
      }
      o.edit(s, n, !a);
    } else {
      const l = new To(e, t, "").edit(s, n);
      u.next = l, l.previous = u;
    }
    return this;
  }
  prepend(e) {
    if (typeof e != "string") throw new TypeError("outro content must be a string");
    return this.intro = e + this.intro, this;
  }
  prependLeft(e, t) {
    if (typeof t != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    const s = this.byEnd[e];
    return s ? s.prependLeft(t) : this.intro = t + this.intro, this;
  }
  prependRight(e, t) {
    if (typeof t != "string") throw new TypeError("inserted content must be a string");
    this._split(e);
    const s = this.byStart[e];
    return s ? s.prependRight(t) : this.outro = t + this.outro, this;
  }
  remove(e, t) {
    for (; e < 0; ) e += this.original.length;
    for (; t < 0; ) t += this.original.length;
    if (e === t) return this;
    if (e < 0 || t > this.original.length) throw new Error("Character is out of bounds");
    if (e > t) throw new Error("end must be greater than start");
    this._split(e), this._split(t);
    let s = this.byStart[e];
    for (; s; )
      s.intro = "", s.outro = "", s.edit(""), s = t > s.end ? this.byStart[s.end] : null;
    return this;
  }
  reset(e, t) {
    for (; e < 0; ) e += this.original.length;
    for (; t < 0; ) t += this.original.length;
    if (e === t) return this;
    if (e < 0 || t > this.original.length) throw new Error("Character is out of bounds");
    if (e > t) throw new Error("end must be greater than start");
    this._split(e), this._split(t);
    let s = this.byStart[e];
    for (; s; )
      s.reset(), s = t > s.end ? this.byStart[s.end] : null;
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let e = this.lastChunk;
    do {
      if (e.outro.length) return e.outro[e.outro.length - 1];
      if (e.content.length) return e.content[e.content.length - 1];
      if (e.intro.length) return e.intro[e.intro.length - 1];
    } while (e = e.previous);
    return this.intro.length ? this.intro[this.intro.length - 1] : "";
  }
  lastLine() {
    let e = this.outro.lastIndexOf(Ta);
    if (e !== -1) return this.outro.substr(e + 1);
    let t = this.outro, s = this.lastChunk;
    do {
      if (s.outro.length > 0) {
        if (e = s.outro.lastIndexOf(Ta), e !== -1) return s.outro.substr(e + 1) + t;
        t = s.outro + t;
      }
      if (s.content.length > 0) {
        if (e = s.content.lastIndexOf(Ta), e !== -1) return s.content.substr(e + 1) + t;
        t = s.content + t;
      }
      if (s.intro.length > 0) {
        if (e = s.intro.lastIndexOf(Ta), e !== -1) return s.intro.substr(e + 1) + t;
        t = s.intro + t;
      }
    } while (s = s.previous);
    return e = this.intro.lastIndexOf(Ta), e !== -1 ? this.intro.substr(e + 1) + t : this.intro + t;
  }
  slice(e = 0, t = this.original.length) {
    for (; e < 0; ) e += this.original.length;
    for (; t < 0; ) t += this.original.length;
    let s = "", i = this.firstChunk;
    for (; i && (i.start > e || i.end <= e); ) {
      if (i.start < t && i.end >= t)
        return s;
      i = i.next;
    }
    if (i && i.edited && i.start !== e)
      throw new Error(`Cannot use replaced character ${e} as slice start anchor.`);
    const n = i;
    for (; i; ) {
      i.intro && (n !== i || i.start === e) && (s += i.intro);
      const a = i.start < t && i.end >= t;
      if (a && i.edited && i.end !== t)
        throw new Error(`Cannot use replaced character ${t} as slice end anchor.`);
      const o = n === i ? e - i.start : 0, u = a ? i.content.length + t - i.end : i.content.length;
      if (s += i.content.slice(o, u), i.outro && (!a || i.end === t) && (s += i.outro), a)
        break;
      i = i.next;
    }
    return s;
  }
  // TODO deprecate this? not really very useful
  snip(e, t) {
    const s = this.clone();
    return s.remove(0, e), s.remove(t, s.original.length), s;
  }
  _split(e) {
    if (this.byStart[e] || this.byEnd[e]) return;
    let t = this.lastSearchedChunk;
    const s = e > t.end;
    for (; t; ) {
      if (t.contains(e)) return this._splitChunk(t, e);
      t = s ? this.byStart[t.end] : this.byEnd[t.start];
    }
  }
  _splitChunk(e, t) {
    if (e.edited && e.content.length) {
      const i = K1(this.original)(t);
      throw new Error(
        `Cannot split a chunk that has already been edited (${i.line}:${i.column}  "${e.original}")`
      );
    }
    const s = e.split(t);
    return this.byEnd[t] = e, this.byStart[t] = s, this.byEnd[s.end] = s, e === this.lastChunk && (this.lastChunk = s), this.lastSearchedChunk = e, !0;
  }
  toString() {
    let e = this.intro, t = this.firstChunk;
    for (; t; )
      e += t.toString(), t = t.next;
    return e + this.outro;
  }
  isEmpty() {
    let e = this.firstChunk;
    do
      if (e.intro.length && e.intro.trim() || e.content.length && e.content.trim() || e.outro.length && e.outro.trim())
        return !1;
    while (e = e.next);
    return !0;
  }
  length() {
    let e = this.firstChunk, t = 0;
    do
      t += e.intro.length + e.content.length + e.outro.length;
    while (e = e.next);
    return t;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(e) {
    return this.trimStart(e).trimEnd(e);
  }
  trimEndAborted(e) {
    const t = new RegExp((e || "\\s") + "+$");
    if (this.outro = this.outro.replace(t, ""), this.outro.length) return !0;
    let s = this.lastChunk;
    do {
      const i = s.end, n = s.trimEnd(t);
      if (s.end !== i && (this.lastChunk === s && (this.lastChunk = s.next), this.byEnd[s.end] = s, this.byStart[s.next.start] = s.next, this.byEnd[s.next.end] = s.next), n) return !0;
      s = s.previous;
    } while (s);
    return !1;
  }
  trimEnd(e) {
    return this.trimEndAborted(e), this;
  }
  trimStartAborted(e) {
    const t = new RegExp("^" + (e || "\\s") + "+");
    if (this.intro = this.intro.replace(t, ""), this.intro.length) return !0;
    let s = this.firstChunk;
    do {
      const i = s.end, n = s.trimStart(t);
      if (s.end !== i && (s === this.lastChunk && (this.lastChunk = s.next), this.byEnd[s.end] = s, this.byStart[s.next.start] = s.next, this.byEnd[s.next.end] = s.next), n) return !0;
      s = s.next;
    } while (s);
    return !1;
  }
  trimStart(e) {
    return this.trimStartAborted(e), this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(e, t) {
    function s(n, a) {
      return typeof t == "string" ? t.replace(/\$(\$|&|\d+)/g, (o, u) => u === "$" ? "$" : u === "&" ? n[0] : +u < n.length ? n[+u] : `$${u}`) : t(...n, n.index, a, n.groups);
    }
    function i(n, a) {
      let o;
      const u = [];
      for (; o = n.exec(a); )
        u.push(o);
      return u;
    }
    if (e.global)
      i(e, this.original).forEach((a) => {
        if (a.index != null) {
          const o = s(a, this.original);
          o !== a[0] && this.overwrite(
            a.index,
            a.index + a[0].length,
            o
          );
        }
      });
    else {
      const n = this.original.match(e);
      if (n && n.index != null) {
        const a = s(n, this.original);
        a !== n[0] && this.overwrite(
          n.index,
          n.index + n[0].length,
          a
        );
      }
    }
    return this;
  }
  _replaceString(e, t) {
    const { original: s } = this, i = s.indexOf(e);
    return i !== -1 && this.overwrite(i, i + e.length, t), this;
  }
  replace(e, t) {
    return typeof e == "string" ? this._replaceString(e, t) : this._replaceRegexp(e, t);
  }
  _replaceAllString(e, t) {
    const { original: s } = this, i = e.length;
    for (let n = s.indexOf(e); n !== -1; n = s.indexOf(e, n + i))
      s.slice(n, n + i) !== t && this.overwrite(n, n + i, t);
    return this;
  }
  replaceAll(e, t) {
    if (typeof e == "string")
      return this._replaceAllString(e, t);
    if (!e.global)
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    return this._replaceRegexp(e, t);
  }
}
var X1, J1;
class HR {
  constructor(e, t) {
    this.descriptor = e, this.options = t, this.isCE = !1, this.source = this.descriptor.source, this.filename = this.descriptor.filename, this.s = new la(this.source), this.startOffset = (X1 = this.descriptor.scriptSetup) == null ? void 0 : X1.loc.start.offset, this.endOffset = (J1 = this.descriptor.scriptSetup) == null ? void 0 : J1.loc.end.offset, this.userImports = /* @__PURE__ */ Object.create(null), this.hasDefinePropsCall = !1, this.hasDefineEmitCall = !1, this.hasDefineExposeCall = !1, this.hasDefaultExportName = !1, this.hasDefaultExportRender = !1, this.hasDefineOptionsCall = !1, this.hasDefineSlotsCall = !1, this.hasDefineModelCall = !1, this.propsDestructuredBindings = /* @__PURE__ */ Object.create(null), this.modelDecls = /* @__PURE__ */ Object.create(null), this.bindingMetadata = {}, this.helperImports = /* @__PURE__ */ new Set();
    const { script: s, scriptSetup: i } = e, n = s && s.lang, a = i && i.lang;
    this.isJS = n === "js" || n === "jsx" || a === "js" || a === "jsx", this.isTS = n === "ts" || n === "tsx" || a === "ts" || a === "tsx";
    const o = t.customElement, u = this.descriptor.filename;
    o && (this.isCE = typeof o == "boolean" ? o : o(u));
    const l = zl(
      n || a,
      t.babelParserPlugins
    );
    function c(f, p) {
      try {
        return $n(f, {
          plugins: l,
          sourceType: "module"
        }).program;
      } catch (h) {
        throw h.message = `[vue/compiler-sfc] ${h.message}

${e.filename}
${kn(
          e.source,
          h.pos + p,
          h.pos + p + 1
        )}`, h;
      }
    }
    this.scriptAst = e.script && c(e.script.content, e.script.loc.start.offset), this.scriptSetupAst = e.scriptSetup && c(e.scriptSetup.content, this.startOffset);
  }
  helper(e) {
    return this.helperImports.add(e), `_${e}`;
  }
  getString(e, t = !0) {
    return (t ? this.descriptor.scriptSetup : this.descriptor.script).content.slice(e.start, e.end);
  }
  error(e, t, s) {
    const i = s ? s.offset : this.startOffset;
    throw new Error(
      `[@vue/compiler-sfc] ${e}

${(s || this.descriptor).filename}
${kn(
        (s || this.descriptor).source,
        t.start + i,
        t.end + i
      )}`
    );
  }
}
function zl(r, e, t = !1) {
  const s = [];
  return (!e || !e.some(
    (i) => i === "importAssertions" || i === "importAttributes" || er(i) && i[0] === "importAttributes"
  )) && s.push("importAttributes"), r === "jsx" || r === "tsx" || r === "mtsx" ? s.push("jsx") : e && (e = e.filter((i) => i !== "jsx")), (r === "ts" || r === "mts" || r === "tsx" || r === "mtsx") && (s.push(["typescript", { dts: t }], "explicitResourceManagement"), (!e || !e.includes("decorators")) && s.push("decorators-legacy")), e && s.push(...e), s;
}
function WR(r, e, t) {
  const s = $n(r, {
    sourceType: "module",
    plugins: zl("js", t)
  }).program.body, i = new la(r);
  return J0(s, i, e), i.toString();
}
function J0(r, e, t) {
  if (!zR(r)) {
    e.append(`
const ${t} = {}`);
    return;
  }
  r.forEach((s) => {
    if (s.type === "ExportDefaultDeclaration")
      if (s.declaration.type === "ClassDeclaration" && s.declaration.id) {
        let i = s.declaration.decorators && s.declaration.decorators.length > 0 ? s.declaration.decorators[s.declaration.decorators.length - 1].end : s.start;
        e.overwrite(i, s.declaration.id.start, " class "), e.append(`
const ${t} = ${s.declaration.id.name}`);
      } else
        e.overwrite(s.start, s.declaration.start, `const ${t} = `);
    else if (s.type === "ExportNamedDeclaration") {
      for (const i of s.specifiers)
        if (i.type === "ExportSpecifier" && i.exported.type === "Identifier" && i.exported.name === "default") {
          if (s.source)
            if (i.local.name === "default") {
              e.prepend(
                `import { default as __VUE_DEFAULT__ } from '${s.source.value}'
`
              );
              const a = tp(e, i.local.end, s.end);
              e.remove(i.start, a), e.append(`
const ${t} = __VUE_DEFAULT__`);
              continue;
            } else {
              e.prepend(
                `import { ${e.slice(
                  i.local.start,
                  i.local.end
                )} as __VUE_DEFAULT__ } from '${s.source.value}'
`
              );
              const a = tp(e, i.exported.end, s.end);
              e.remove(i.start, a), e.append(`
const ${t} = __VUE_DEFAULT__`);
              continue;
            }
          const n = tp(e, i.end, s.end);
          e.remove(i.start, n), e.append(`
const ${t} = ${i.local.name}`);
        }
    }
  });
}
function zR(r) {
  for (const e of r) {
    if (e.type === "ExportDefaultDeclaration")
      return !0;
    if (e.type === "ExportNamedDeclaration" && e.specifiers.some(
      (t) => t.exported.name === "default"
    ))
      return !0;
  }
  return !1;
}
function tp(r, e, t) {
  let s = !1, i = e;
  for (; e < t; )
    if (/\s/.test(r.slice(e, e + 1)))
      e++;
    else if (r.slice(e, e + 1) === ",") {
      e++, s = !0;
      break;
    } else if (r.slice(e, e + 1) === "}")
      break;
  return s ? e : i;
}
var GR = Object.defineProperty, KR = Object.defineProperties, XR = Object.getOwnPropertyDescriptors, Y1 = Object.getOwnPropertySymbols, JR = Object.prototype.hasOwnProperty, YR = Object.prototype.propertyIsEnumerable, Q1 = (r, e, t) => e in r ? GR(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, QR = (r, e) => {
  for (var t in e || (e = {}))
    JR.call(e, t) && Q1(r, t, e[t]);
  if (Y1)
    for (var t of Y1(e))
      YR.call(e, t) && Q1(r, t, e[t]);
  return r;
}, ZR = (r, e) => KR(r, XR(e));
const fn = "__default__";
function e9(r, e) {
  var t;
  const s = r.descriptor.script;
  if (s.lang && !r.isJS && !r.isTS)
    return s;
  try {
    let i = s.content, n = s.map;
    const a = r.scriptAst, o = uw(a.body), { cssVars: u } = r.descriptor, { genDefaultAs: l, isProd: c } = r.options;
    if (u.length || l) {
      const f = l || fn, p = new la(i);
      J0(a.body, p, f), i = p.toString(), u.length && !((t = r.options.templateOptions) != null && t.ssr) && (i += U6(
        u,
        o,
        e,
        !!c,
        f
      )), l || (i += `
export default ${f}`);
    }
    return ZR(QR({}, s), {
      content: i,
      map: n,
      bindings: o,
      scriptAst: a.body
    });
  } catch {
    return s;
  }
}
var t9 = Object.defineProperty, r9 = Object.defineProperties, s9 = Object.getOwnPropertyDescriptors, Z1 = Object.getOwnPropertySymbols, i9 = Object.prototype.hasOwnProperty, n9 = Object.prototype.propertyIsEnumerable, eb = (r, e, t) => e in r ? t9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Gl = (r, e) => {
  for (var t in e || (e = {}))
    i9.call(e, t) && eb(r, t, e[t]);
  if (Z1)
    for (var t of Z1(e))
      n9.call(e, t) && eb(r, t, e[t]);
  return r;
}, Kl = (r, e) => r9(r, s9(e));
class Y0 {
  constructor(e, t, s = 0, i = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null)) {
    this.filename = e, this.source = t, this.offset = s, this.imports = i, this.types = n, this.declares = a, this.isGenericScope = !1, this.resolvedImportSources = /* @__PURE__ */ Object.create(null), this.exportedTypes = /* @__PURE__ */ Object.create(null), this.exportedDeclares = /* @__PURE__ */ Object.create(null);
  }
}
function wt(r, e, t, s) {
  const i = !s;
  if (i && e._resolvedElements)
    return e._resolvedElements;
  const n = a9(
    r,
    e,
    e._ownerScope || t || hf(r),
    s
  );
  return i ? e._resolvedElements = n : n;
}
function a9(r, e, t, s) {
  var i, n;
  if (e.leadingComments && e.leadingComments.some((a) => a.value.includes("@vue-ignore")))
    return { props: {} };
  switch (e.type) {
    case "TSTypeLiteral":
      return cw(r, e.members, t, s);
    case "TSInterfaceDeclaration":
      return o9(r, e, t, s);
    case "TSTypeAliasDeclaration":
    case "TSTypeAnnotation":
    case "TSParenthesizedType":
      return wt(
        r,
        e.typeAnnotation,
        t,
        s
      );
    case "TSFunctionType":
      return { props: {}, calls: [e] };
    case "TSUnionType":
    case "TSIntersectionType":
      return tb(
        e.types.map((a) => wt(r, a, t, s)),
        e.type
      );
    case "TSMappedType":
      return u9(r, e, t, s);
    case "TSIndexedAccessType": {
      const a = fw(r, e, t);
      return tb(
        a.map((o) => wt(r, o, o._ownerScope)),
        "TSUnionType"
      );
    }
    case "TSExpressionWithTypeArguments":
    case "TSTypeReference": {
      const a = Z0(e);
      if ((a === "ExtractPropTypes" || a === "ExtractPublicPropTypes") && e.typeParameters && ((i = t.imports[a]) == null ? void 0 : i.source) === "vue")
        return nb(
          wt(
            r,
            e.typeParameters.params[0],
            t,
            s
          ),
          t
        );
      const o = Qr(r, e, t);
      if (o) {
        let u;
        return (o.type === "TSTypeAliasDeclaration" || o.type === "TSInterfaceDeclaration") && o.typeParameters && e.typeParameters && (u = /* @__PURE__ */ Object.create(null), o.typeParameters.params.forEach((l, c) => {
          let f = s && s[l.name];
          f || (f = e.typeParameters.params[c]), u[l.name] = f;
        })), wt(
          r,
          o,
          o._ownerScope,
          u
        );
      } else {
        if (typeof a == "string") {
          if (s && s[a])
            return wt(
              r,
              s[a],
              t,
              s
            );
          if (
            // @ts-expect-error
            l9.has(a)
          )
            return c9(
              r,
              e,
              a,
              t,
              s
            );
          if (a === "ReturnType" && e.typeParameters) {
            const u = _9(
              r,
              e.typeParameters.params[0],
              t
            );
            if (u)
              return wt(r, u, t);
          }
        }
        return r.error(
          "Unresolvable type reference or unsupported built-in utility type",
          e,
          t
        );
      }
    }
    case "TSImportType": {
      if (Ji(e.argument) === "vue" && ((n = e.qualifier) == null ? void 0 : n.type) === "Identifier" && e.qualifier.name === "ExtractPropTypes" && e.typeParameters)
        return nb(
          wt(r, e.typeParameters.params[0], t),
          t
        );
      const a = pf(
        r,
        e.argument,
        t,
        e.argument.value
      ), o = Qr(r, e, a);
      if (o)
        return wt(r, o, o._ownerScope);
      break;
    }
    case "TSTypeQuery":
      {
        const a = Qr(r, e, t);
        if (a)
          return wt(r, a, a._ownerScope);
      }
      break;
  }
  return r.error(`Unresolvable type: ${e.type}`, e, t);
}
function cw(r, e, t = hf(r), s) {
  const i = { props: {} };
  for (const n of e)
    if (n.type === "TSPropertySignature" || n.type === "TSMethodSignature") {
      s && (t = tg(t), t.isGenericScope = !0, Object.assign(t.types, s)), n._ownerScope = t;
      const a = Ji(n.key);
      if (a && !n.computed)
        i.props[a] = n;
      else if (n.key.type === "TemplateLiteral")
        for (const o of Q0(r, n.key, t))
          i.props[o] = n;
      else
        r.error(
          "Unsupported computed key in type referenced by a macro",
          n.key,
          t
        );
    } else n.type === "TSCallSignatureDeclaration" && (i.calls || (i.calls = [])).push(n);
  return i;
}
function tb(r, e) {
  if (r.length === 1) return r[0];
  const t = { props: {} }, { props: s } = t;
  for (const { props: i, calls: n } of r) {
    for (const a in i)
      qd(s, a) ? s[a] = Ya(
        s[a].key,
        {
          type: e,
          // @ts-expect-error
          types: [s[a], i[a]]
        },
        s[a]._ownerScope,
        s[a].optional || i[a].optional
      ) : s[a] = i[a];
    n && (t.calls || (t.calls = [])).push(...n);
  }
  return t;
}
function Ya(r, e, t, s) {
  return {
    type: "TSPropertySignature",
    key: r,
    kind: "get",
    optional: s,
    typeAnnotation: {
      type: "TSTypeAnnotation",
      typeAnnotation: e
    },
    _ownerScope: t
  };
}
function o9(r, e, t, s) {
  const i = cw(
    r,
    e.body.body,
    e._ownerScope,
    s
  );
  if (e.extends)
    for (const n of e.extends)
      try {
        const { props: a, calls: o } = wt(r, n, t);
        for (const u in a)
          qd(i.props, u) || (i.props[u] = a[u]);
        o && (i.calls || (i.calls = [])).push(...o);
      } catch {
        r.error(
          `Failed to resolve extends base type.
If this previously worked in 3.2, you can instruct the compiler to ignore this extend by adding /* @vue-ignore */ before it, for example:

interface Props extends /* @vue-ignore */ Base {}

Note: both in 3.2 or with the ignore, the properties in the base type are treated as fallthrough attrs at runtime.`,
          n,
          t
        );
      }
  return i;
}
function u9(r, e, t, s) {
  const i = { props: {} };
  let n;
  if (e.nameType) {
    const { name: a, constraint: o } = e.typeParameter;
    t = tg(t), Object.assign(t.types, Kl(Gl({}, s), { [a]: o })), n = Hr(r, e.nameType, t);
  } else
    n = Hr(r, e.typeParameter.constraint, t);
  for (const a of n)
    i.props[a] = Ya(
      {
        type: "Identifier",
        name: a
      },
      e.typeAnnotation,
      t,
      !!e.optional
    );
  return i;
}
function fw(r, e, t) {
  var s, i;
  if (e.indexType.type === "TSNumberKeyword")
    return pw(r, e.objectType, t);
  const { indexType: n, objectType: a } = e, o = [];
  let u, l;
  n.type === "TSStringKeyword" ? (l = wt(r, a, t), u = Object.keys(l.props)) : (u = Hr(r, n, t), l = wt(r, a, t));
  for (const c of u) {
    const f = (i = (s = l.props[c]) == null ? void 0 : s.typeAnnotation) == null ? void 0 : i.typeAnnotation;
    f && (f._ownerScope = l.props[c]._ownerScope, o.push(f));
  }
  return o;
}
function pw(r, e, t) {
  if (e.type === "TSArrayType")
    return [e.elementType];
  if (e.type === "TSTupleType")
    return e.elementTypes.map(
      (s) => s.type === "TSNamedTupleMember" ? s.elementType : s
    );
  if (e.type === "TSTypeReference") {
    if (Z0(e) === "Array" && e.typeParameters)
      return e.typeParameters.params;
    {
      const s = Qr(r, e, t);
      if (s)
        return pw(r, s, t);
    }
  }
  return r.error(
    "Failed to resolve element type from target type",
    e,
    t
  );
}
function Hr(r, e, t) {
  switch (e.type) {
    case "StringLiteral":
      return [e.value];
    case "TSLiteralType":
      return Hr(r, e.literal, t);
    case "TSUnionType":
      return e.types.map((s) => Hr(r, s, t)).flat();
    case "TemplateLiteral":
      return Q0(r, e, t);
    case "TSTypeReference": {
      const s = Qr(r, e, t);
      if (s)
        return Hr(r, s, t);
      if (e.typeName.type === "Identifier") {
        const i = (n = 0) => Hr(r, e.typeParameters.params[n], t);
        switch (e.typeName.name) {
          case "Extract":
            return i(1);
          case "Exclude": {
            const n = i(1);
            return i().filter((a) => !n.includes(a));
          }
          case "Uppercase":
            return i().map((n) => n.toUpperCase());
          case "Lowercase":
            return i().map((n) => n.toLowerCase());
          case "Capitalize":
            return i().map(oi);
          case "Uncapitalize":
            return i().map((n) => n[0].toLowerCase() + n.slice(1));
          default:
            r.error(
              "Unsupported type when resolving index type",
              e.typeName,
              t
            );
        }
      }
    }
  }
  return r.error("Failed to resolve index type into finite keys", e, t);
}
function Q0(r, e, t) {
  if (!e.expressions.length)
    return [e.quasis[0].value.raw];
  const s = [], i = e.expressions[0], n = e.quasis[0], a = n ? n.value.raw : "", o = Hr(r, i, t), u = Q0(
    r,
    Kl(Gl({}, e), {
      expressions: e.expressions.slice(1),
      quasis: n ? e.quasis.slice(1) : e.quasis
    }),
    t
  );
  for (const l of o)
    for (const c of u)
      s.push(a + l + c);
  return s;
}
const l9 = /* @__PURE__ */ new Set([
  "Partial",
  "Required",
  "Readonly",
  "Pick",
  "Omit"
]);
function c9(r, e, t, s, i) {
  const n = wt(
    r,
    e.typeParameters.params[0],
    s,
    i
  );
  switch (t) {
    case "Partial": {
      const u = { props: {}, calls: n.calls };
      return Object.keys(n.props).forEach((l) => {
        u.props[l] = Kl(Gl({}, n.props[l]), { optional: !0 });
      }), u;
    }
    case "Required": {
      const u = { props: {}, calls: n.calls };
      return Object.keys(n.props).forEach((l) => {
        u.props[l] = Kl(Gl({}, n.props[l]), { optional: !1 });
      }), u;
    }
    case "Readonly":
      return n;
    case "Pick": {
      const u = Hr(
        r,
        e.typeParameters.params[1],
        s
      ), l = { props: {}, calls: n.calls };
      for (const c of u)
        l.props[c] = n.props[c];
      return l;
    }
    case "Omit":
      const a = Hr(
        r,
        e.typeParameters.params[1],
        s
      ), o = { props: {}, calls: n.calls };
      for (const u in n.props)
        a.includes(u) || (o.props[u] = n.props[u]);
      return o;
  }
}
function Qr(r, e, t, s, i = !1) {
  const n = !(t != null && t.isGenericScope);
  if (n && e._resolvedReference)
    return e._resolvedReference;
  const a = Xh(
    r,
    t || hf(r),
    s || Z0(e),
    e,
    i
  );
  return n ? e._resolvedReference = a : a;
}
function Xh(r, e, t, s, i) {
  if (typeof t == "string") {
    if (e.imports[t])
      return h9(r, s, t, e);
    {
      const n = s.type === "TSTypeQuery" ? i ? e.exportedDeclares : e.declares : i ? e.exportedTypes : e.types;
      if (n[t])
        return n[t];
      {
        const a = f9(r);
        if (a)
          for (const o of a) {
            const u = s.type === "TSTypeQuery" ? o.declares : o.types;
            if (u[t])
              return (r.deps || (r.deps = /* @__PURE__ */ new Set())).add(o.filename), u[t];
          }
      }
    }
  } else {
    let n = Xh(r, e, t[0], s, i);
    if (n && (n.type !== "TSModuleDeclaration" && (n = n._ns), n)) {
      const a = y9(r, n, n._ownerScope || e);
      return Xh(
        r,
        a,
        t.length > 2 ? t.slice(1) : t[t.length - 1],
        s,
        !n.declare
      );
    }
  }
}
function Z0(r) {
  const e = r.type === "TSTypeReference" ? r.typeName : r.type === "TSExpressionWithTypeArguments" ? r.expression : r.type === "TSImportType" ? r.qualifier : r.exprName;
  return (e == null ? void 0 : e.type) === "Identifier" ? e.name : (e == null ? void 0 : e.type) === "TSQualifiedName" ? hw(e) : "default";
}
function hw(r) {
  return r.type === "Identifier" ? [r.name] : [...hw(r.left), r.right.name];
}
function f9(r) {
  if (r.options.globalTypeFiles) {
    if (!eg(r))
      throw new Error("[vue/compiler-sfc] globalTypeFiles requires fs access.");
    return r.options.globalTypeFiles.map(
      (t) => dw(r, a0(t), !0)
    );
  }
}
let Pu, Jh;
function p9(r) {
  Jh = () => {
    try {
      return r();
    } catch (e) {
      throw typeof e.message == "string" && e.message.includes("Cannot find module") ? new Error(
        'Failed to load TypeScript, which is required for resolving imported types. Please make sure "typescript" is installed as a project dependency.'
      ) : new Error(
        "Failed to load TypeScript for resolving imported types."
      );
    }
  };
}
function eg(r) {
  if (r.fs)
    return r.fs;
  !Pu && Jh && (Pu = Jh());
  const e = r.options.fs || (Pu == null ? void 0 : Pu.sys);
  if (e)
    return r.fs = {
      fileExists(t) {
        return t.endsWith(".vue.ts") && (t = t.replace(/\.ts$/, "")), e.fileExists(t);
      },
      readFile(t) {
        return t.endsWith(".vue.ts") && (t = t.replace(/\.ts$/, "")), e.readFile(t);
      },
      realpath: e.realpath
    };
}
function h9(r, e, t, s) {
  const { source: i, imported: n } = s.imports[t], a = pf(r, e, s, i);
  return Qr(r, e, a, n, !0);
}
function pf(r, e, t, s) {
  let i;
  try {
    i = eg(r);
  } catch (a) {
    return r.error(a.message, e, t);
  }
  if (!i)
    return r.error(
      "No fs option provided to `compileScript` in non-Node environment. File system access is required for resolving imported types.",
      e,
      t
    );
  let n = t.resolvedImportSources[s];
  if (!n) {
    if (s.startsWith("..")) {
      const o = za(Nl(t.filename), s);
      n = rb(o, i);
    } else if (s[0] === ".") {
      const a = za(Nl(t.filename), s);
      n = rb(a, i);
    } else
      return r.error(
        "Type import from non-relative sources is not supported in the browser build.",
        e,
        t
      );
    n && (n = t.resolvedImportSources[s] = a0(n));
  }
  return n ? ((r.deps || (r.deps = /* @__PURE__ */ new Set())).add(n), dw(r, n)) : r.error(
    `Failed to resolve import source ${JSON.stringify(s)}.`,
    e,
    t
  );
}
function rb(r, e) {
  r = r.replace(/\.js$/, "");
  const t = (s) => {
    if (e.fileExists(s)) return s;
  };
  return t(r) || t(r + ".ts") || t(r + ".tsx") || t(r + ".d.ts") || t(za(r, "index.ts")) || t(za(r, "index.tsx")) || t(za(r, "index.d.ts"));
}
const sb = Gc(), d9 = /* @__PURE__ */ new Map(), Yh = Gc();
function m9(r) {
  r = a0(r), Yh.delete(r), sb.delete(r);
  const e = d9.get(r);
  e && sb.delete(e);
}
function dw(r, e, t = !1) {
  const s = Yh.get(e);
  if (s)
    return s;
  const n = eg(r).readFile(e) || "", a = g9(e, n, r.options.babelParserPlugins), o = new Y0(e, n, 0, mw(a));
  return rg(r, a, o, t), Yh.set(e, o), o;
}
function g9(r, e, t) {
  const s = s0(r);
  if (s === ".ts" || s === ".mts" || s === ".tsx" || s === ".mtsx")
    return $n(e, {
      plugins: zl(
        s.slice(1),
        t,
        /\.d\.m?ts$/.test(r)
      ),
      sourceType: "module"
    }).program.body;
  if (s === ".vue") {
    const {
      descriptor: { script: i, scriptSetup: n }
    } = N2(e);
    if (!i && !n)
      return [];
    const a = i ? i.loc.start.offset : 1 / 0, o = n ? n.loc.start.offset : 1 / 0, u = a < o ? i : n, l = a < o ? n : i;
    let c = " ".repeat(Math.min(a, o)) + u.content;
    l && (c += " ".repeat(l.loc.start.offset - i.loc.end.offset) + l.content);
    const f = (i == null ? void 0 : i.lang) || (n == null ? void 0 : n.lang);
    return $n(c, {
      plugins: zl(f, t),
      sourceType: "module"
    }).program.body;
  }
  return [];
}
function hf(r) {
  if (r.scope)
    return r.scope;
  const e = "ast" in r ? r.ast : r.scriptAst ? [...r.scriptAst.body, ...r.scriptSetupAst.body] : r.scriptSetupAst.body, t = new Y0(
    r.filename,
    r.source,
    "startOffset" in r ? r.startOffset : 0,
    "userImports" in r ? Object.create(r.userImports) : mw(e)
  );
  return rg(r, e, t), r.scope = t;
}
function y9(r, e, t) {
  if (e._resolvedChildScope)
    return e._resolvedChildScope;
  const s = tg(t);
  if (e.body.type === "TSModuleDeclaration") {
    const i = e.body;
    i._ownerScope = s;
    const n = Ji(i.id);
    s.types[n] = s.exportedTypes[n] = i;
  } else
    rg(r, e.body.body, s);
  return e._resolvedChildScope = s;
}
function tg(r) {
  return new Y0(
    r.filename,
    r.source,
    r.offset,
    Object.create(r.imports),
    Object.create(r.types),
    Object.create(r.declares)
  );
}
const b9 = /^Import|^Export/;
function rg(r, e, t, s = !1) {
  const { types: i, declares: n, exportedTypes: a, exportedDeclares: o, imports: u } = t, l = s ? !e.some((c) => b9.test(c.type)) : !1;
  for (const c of e)
    if (s) {
      if (l)
        c.declare && Ei(c, i, n);
      else if (c.type === "TSModuleDeclaration" && c.global)
        for (const f of c.body.body)
          Ei(f, i, n);
    } else
      Ei(c, i, n);
  if (!s)
    for (const c of e)
      if (c.type === "ExportNamedDeclaration") {
        if (c.declaration)
          Ei(c.declaration, i, n), Ei(c.declaration, a, o);
        else
          for (const f of c.specifiers)
            if (f.type === "ExportSpecifier") {
              const p = f.local.name, h = Ji(f.exported);
              c.source ? (u[h] = {
                source: c.source.value,
                imported: p
              }, a[h] = {
                type: "TSTypeReference",
                typeName: {
                  type: "Identifier",
                  name: p
                },
                _ownerScope: t
              }) : i[p] && (a[h] = i[p]);
            }
      } else if (c.type === "ExportAllDeclaration") {
        const f = pf(
          r,
          c.source,
          t,
          c.source.value
        );
        Object.assign(t.exportedTypes, f.exportedTypes);
      } else c.type === "ExportDefaultDeclaration" && c.declaration && (c.declaration.type !== "Identifier" ? (Ei(c.declaration, i, n, "default"), Ei(
        c.declaration,
        a,
        o,
        "default"
      )) : i[c.declaration.name] && (a.default = i[c.declaration.name]));
  for (const c of Object.keys(i)) {
    const f = i[c];
    f._ownerScope = t, f._ns && (f._ns._ownerScope = t);
  }
  for (const c of Object.keys(n))
    n[c]._ownerScope = t;
}
function Ei(r, e, t, s) {
  switch (r.type) {
    case "TSInterfaceDeclaration":
    case "TSEnumDeclaration":
    case "TSModuleDeclaration": {
      const i = s || Ji(r.id);
      let n = e[i];
      if (n) {
        if (r.type === "TSModuleDeclaration") {
          n.type === "TSModuleDeclaration" ? sg(n, r) : ib(n, r);
          break;
        }
        if (n.type === "TSModuleDeclaration") {
          e[i] = r, ib(r, n);
          break;
        }
        if (n.type !== r.type)
          break;
        r.type === "TSInterfaceDeclaration" ? n.body.body.push(...r.body.body) : n.members.push(...r.members);
      } else
        e[i] = r;
      break;
    }
    case "ClassDeclaration":
      (s || r.id) && (e[s || Ji(r.id)] = r);
      break;
    case "TSTypeAliasDeclaration":
      e[r.id.name] = r.typeParameters ? r : r.typeAnnotation;
      break;
    case "TSDeclareFunction":
      r.id && (t[r.id.name] = r);
      break;
    case "VariableDeclaration": {
      if (r.declare)
        for (const i of r.declarations)
          i.id.type === "Identifier" && i.id.typeAnnotation && (t[i.id.name] = i.id.typeAnnotation.typeAnnotation);
      break;
    }
  }
}
function sg(r, e) {
  const t = r.body, s = e.body;
  t.type === "TSModuleDeclaration" ? s.type === "TSModuleDeclaration" ? sg(t, s) : s.body.push({
    type: "ExportNamedDeclaration",
    declaration: t,
    exportKind: "type",
    specifiers: []
  }) : s.type === "TSModuleDeclaration" ? t.body.push({
    type: "ExportNamedDeclaration",
    declaration: s,
    exportKind: "type",
    specifiers: []
  }) : t.body.push(...s.body);
}
function ib(r, e) {
  r._ns ? sg(r._ns, e) : r._ns = e;
}
function mw(r) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const t of r)
    v9(t, e);
  return e;
}
function v9(r, e) {
  if (r.type === "ImportDeclaration")
    for (const t of r.specifiers)
      e[t.local.name] = {
        imported: Gp(t),
        source: r.source.value
      };
}
function xt(r, e, t = e._ownerScope || hf(r), s = !1) {
  try {
    switch (e.type) {
      case "TSStringKeyword":
        return ["String"];
      case "TSNumberKeyword":
        return ["Number"];
      case "TSBooleanKeyword":
        return ["Boolean"];
      case "TSObjectKeyword":
        return ["Object"];
      case "TSNullKeyword":
        return ["null"];
      case "TSTypeLiteral":
      case "TSInterfaceDeclaration": {
        const i = /* @__PURE__ */ new Set(), n = e.type === "TSTypeLiteral" ? e.members : e.body.body;
        for (const a of n)
          if (s)
            if (a.type === "TSPropertySignature" && a.key.type === "NumericLiteral")
              i.add("Number");
            else if (a.type === "TSIndexSignature") {
              const o = a.parameters[0].typeAnnotation;
              if (o && o.type !== "Noop") {
                const u = xt(
                  r,
                  o.typeAnnotation,
                  t
                )[0];
                if (u === $r) return [$r];
                i.add(u);
              }
            } else
              i.add("String");
          else a.type === "TSCallSignatureDeclaration" || a.type === "TSConstructSignatureDeclaration" ? i.add("Function") : i.add("Object");
        return i.size ? Array.from(i) : [s ? $r : "Object"];
      }
      case "TSPropertySignature":
        if (e.typeAnnotation)
          return xt(
            r,
            e.typeAnnotation.typeAnnotation,
            t
          );
        break;
      case "TSMethodSignature":
      case "TSFunctionType":
        return ["Function"];
      case "TSArrayType":
      case "TSTupleType":
        return ["Array"];
      case "TSLiteralType":
        switch (e.literal.type) {
          case "StringLiteral":
            return ["String"];
          case "BooleanLiteral":
            return ["Boolean"];
          case "NumericLiteral":
          case "BigIntLiteral":
            return ["Number"];
          default:
            return [$r];
        }
      case "TSTypeReference": {
        const i = Qr(r, e, t);
        if (i)
          return xt(r, i, i._ownerScope, s);
        if (e.typeName.type === "Identifier")
          if (s)
            switch (e.typeName.name) {
              case "String":
              case "Array":
              case "ArrayLike":
              case "Parameters":
              case "ConstructorParameters":
              case "ReadonlyArray":
                return ["String", "Number"];
              case "Record":
              case "Partial":
              case "Required":
              case "Readonly":
                if (e.typeParameters && e.typeParameters.params[0])
                  return xt(
                    r,
                    e.typeParameters.params[0],
                    t,
                    !0
                  );
                break;
              case "Pick":
              case "Extract":
                if (e.typeParameters && e.typeParameters.params[1])
                  return xt(
                    r,
                    e.typeParameters.params[1],
                    t
                  );
                break;
              case "Function":
              case "Object":
              case "Set":
              case "Map":
              case "WeakSet":
              case "WeakMap":
              case "Date":
              case "Promise":
              case "Error":
              case "Uppercase":
              case "Lowercase":
              case "Capitalize":
              case "Uncapitalize":
              case "ReadonlyMap":
              case "ReadonlySet":
                return ["String"];
            }
          else
            switch (e.typeName.name) {
              case "Array":
              case "Function":
              case "Object":
              case "Set":
              case "Map":
              case "WeakSet":
              case "WeakMap":
              case "Date":
              case "Promise":
              case "Error":
                return [e.typeName.name];
              case "Partial":
              case "Required":
              case "Readonly":
              case "Record":
              case "Pick":
              case "Omit":
              case "InstanceType":
                return ["Object"];
              case "Uppercase":
              case "Lowercase":
              case "Capitalize":
              case "Uncapitalize":
                return ["String"];
              case "Parameters":
              case "ConstructorParameters":
              case "ReadonlyArray":
                return ["Array"];
              case "ReadonlyMap":
                return ["Map"];
              case "ReadonlySet":
                return ["Set"];
              case "NonNullable":
                if (e.typeParameters && e.typeParameters.params[0])
                  return xt(
                    r,
                    e.typeParameters.params[0],
                    t
                  ).filter((n) => n !== "null");
                break;
              case "Extract":
                if (e.typeParameters && e.typeParameters.params[1])
                  return xt(
                    r,
                    e.typeParameters.params[1],
                    t
                  );
                break;
              case "Exclude":
              case "OmitThisParameter":
                if (e.typeParameters && e.typeParameters.params[0])
                  return xt(
                    r,
                    e.typeParameters.params[0],
                    t
                  );
                break;
            }
        break;
      }
      case "TSParenthesizedType":
        return xt(r, e.typeAnnotation, t);
      case "TSUnionType":
        return rp(r, e.types, t, s);
      case "TSIntersectionType":
        return rp(r, e.types, t, s).filter(
          (i) => i !== $r
        );
      case "TSEnumDeclaration":
        return E9(e);
      case "TSSymbolKeyword":
        return ["Symbol"];
      case "TSIndexedAccessType": {
        const i = fw(r, e, t);
        return rp(r, i, t);
      }
      case "ClassDeclaration":
        return ["Object"];
      case "TSImportType": {
        const i = pf(
          r,
          e.argument,
          t,
          e.argument.value
        ), n = Qr(r, e, i);
        if (n)
          return xt(r, n, n._ownerScope);
        break;
      }
      case "TSTypeQuery": {
        const i = e.exprName;
        if (i.type === "Identifier") {
          const n = t.declares[i.name];
          if (n)
            return xt(r, n, n._ownerScope, s);
        }
        break;
      }
      case "TSTypeOperator":
        return xt(
          r,
          e.typeAnnotation,
          t,
          e.operator === "keyof"
        );
      case "TSAnyKeyword": {
        if (s)
          return ["String", "Number", "Symbol"];
        break;
      }
    }
  } catch {
  }
  return [$r];
}
function rp(r, e, t, s = !1) {
  return e.length === 1 ? xt(r, e[0], t, s) : [
    ...new Set(
      [].concat(
        ...e.map((i) => xt(r, i, t, s))
      )
    )
  ];
}
function E9(r) {
  const e = /* @__PURE__ */ new Set();
  for (const t of r.members)
    if (t.initializer)
      switch (t.initializer.type) {
        case "StringLiteral":
          e.add("String");
          break;
        case "NumericLiteral":
          e.add("Number");
          break;
      }
  return e.size ? [...e] : ["Number"];
}
function nb({ props: r }, e) {
  const t = { props: {} };
  for (const s in r) {
    const i = r[s];
    t.props[s] = Qh(
      i.key,
      i.typeAnnotation.typeAnnotation,
      e
    );
  }
  return t;
}
function Qh(r, e, t, s = !0, i = !0) {
  if (i && e.type === "TSTypeLiteral") {
    const n = ab(e, "type");
    if (n) {
      const a = ab(e, "required"), o = a && a.type === "TSLiteralType" && a.literal.type === "BooleanLiteral" ? !a.literal.value : !0;
      return Qh(r, n, t, o, !1);
    }
  } else if (e.type === "TSTypeReference" && e.typeName.type === "Identifier") {
    if (e.typeName.name.endsWith("Constructor"))
      return Ya(
        r,
        S9(e.typeName.name),
        t,
        s
      );
    if (e.typeName.name === "PropType" && e.typeParameters)
      return Ya(r, e.typeParameters.params[0], t, s);
  }
  if ((e.type === "TSTypeReference" || e.type === "TSImportType") && e.typeParameters)
    for (const n of e.typeParameters.params) {
      const a = Qh(r, n, t, s);
      if (a) return a;
    }
  return Ya(r, { type: "TSNullKeyword" }, t, s);
}
function S9(r) {
  const e = r.slice(0, -11);
  switch (e) {
    case "String":
    case "Number":
    case "Boolean":
      return { type: `TS${e}Keyword` };
    case "Array":
    case "Function":
    case "Object":
    case "Set":
    case "Map":
    case "WeakSet":
    case "WeakMap":
    case "Date":
    case "Promise":
      return {
        type: "TSTypeReference",
        typeName: { type: "Identifier", name: e }
      };
  }
  return { type: "TSNullKeyword" };
}
function ab(r, e) {
  const t = r.members.find(
    (s) => s.type === "TSPropertySignature" && !s.computed && Ji(s.key) === e && s.typeAnnotation
  );
  return t && t.typeAnnotation.typeAnnotation;
}
function _9(r, e, t) {
  var s;
  let i = e;
  if ((e.type === "TSTypeReference" || e.type === "TSTypeQuery" || e.type === "TSImportType") && (i = Qr(r, e, t)), !!i) {
    if (i.type === "TSFunctionType")
      return (s = i.typeAnnotation) == null ? void 0 : s.typeAnnotation;
    if (i.type === "TSDeclareFunction")
      return i.returnType;
  }
}
function gw(r, e, t) {
  if (e.type === "TSTypeReference") {
    const i = Qr(r, e, t);
    i && (e = i);
  }
  let s;
  return e.type === "TSUnionType" ? s = e.types.flatMap((i) => gw(r, i, t)) : s = [e], s;
}
const df = "defineModel";
function ob(r, e, t) {
  if (!Wt(e, df))
    return !1;
  r.hasDefineModelCall = !0;
  const s = e.typeParameters && e.typeParameters.params[0] || void 0;
  let i, n;
  const a = e.arguments[0] && br(e.arguments[0]), o = a && a.type === "StringLiteral";
  o ? (i = a.value, n = e.arguments[1]) : (i = "modelValue", n = a), r.modelDecls[i] && r.error(`duplicate model name ${JSON.stringify(i)}`, e);
  let u = n && r.getString(n), l = !n;
  const c = [];
  if (n && n.type === "ObjectExpression" && !n.properties.some((f) => f.type === "SpreadElement" || f.computed)) {
    let f = 0;
    for (let p = n.properties.length - 1; p >= 0; p--) {
      const h = n.properties[p], m = n.properties[p + 1], d = h.start, y = m ? m.start : n.end - 1;
      (h.type === "ObjectProperty" || h.type === "ObjectMethod") && (h.key.type === "Identifier" && (h.key.name === "get" || h.key.name === "set") || h.key.type === "StringLiteral" && (h.key.value === "get" || h.key.value === "set")) ? u = u.slice(0, d - n.start) + u.slice(y - n.start) : (f++, r.s.remove(r.startOffset + d, r.startOffset + y), c.push(h));
    }
    f === n.properties.length && (l = !0, r.s.remove(
      r.startOffset + (o ? a.end : n.start),
      r.startOffset + n.end
    ));
  }
  return r.modelDecls[i] = {
    type: s,
    options: u,
    runtimeOptionNodes: c,
    identifier: t && t.type === "Identifier" ? t.name : void 0
  }, r.bindingMetadata[i] = "props", r.s.overwrite(
    r.startOffset + e.callee.start,
    r.startOffset + e.callee.end,
    r.helper("useModel")
  ), r.s.appendLeft(
    r.startOffset + (e.arguments.length ? e.arguments[0].start : e.end - 1),
    "__props, " + (o ? "" : `${JSON.stringify(i)}${l ? "" : ", "}`)
  ), !0;
}
function x9(r) {
  if (!r.hasDefineModelCall) return;
  const e = !!r.options.isProd;
  let t = "";
  for (const [s, { type: i, options: n }] of Object.entries(
    r.modelDecls
  )) {
    let a = !1, o = "", u = i && xt(r, i);
    if (u) {
      const f = u.includes("Boolean"), p = u.includes("Function");
      u.includes($r) && (f || p ? (u = u.filter((m) => m !== $r), a = !0) : u = ["null"]), e ? (f || n && p) && (o = `type: ${dn(u)}`) : o = `type: ${dn(u)}` + (a ? ", skipCheck: true" : "");
    }
    let l;
    o && n ? l = r.isTS ? `{ ${o}, ...${n} }` : `Object.assign({ ${o} }, ${n})` : o ? l = `{ ${o} }` : n ? l = n : l = "{}", t += `
    ${JSON.stringify(s)}: ${l},`;
    const c = JSON.stringify(
      s === "modelValue" ? "modelModifiers" : `${s}Modifiers`
    );
    t += `
    ${c}: {},`;
  }
  return `{${t}
  }`;
}
const At = "defineProps", wi = "withDefaults";
function Zh(r, e, t) {
  if (!Wt(e, At))
    return w9(r, e, t);
  if (r.hasDefinePropsCall && r.error(`duplicate ${At}() call`, e), r.hasDefinePropsCall = !0, r.propsRuntimeDecl = e.arguments[0], r.propsRuntimeDecl)
    for (const s of Kh(r.propsRuntimeDecl))
      s in r.bindingMetadata || (r.bindingMetadata[s] = "props");
  return e.typeParameters && (r.propsRuntimeDecl && r.error(
    `${At}() cannot accept both type and non-type arguments at the same time. Use one or the other.`,
    e
  ), r.propsTypeDecl = e.typeParameters.params[0]), t && t.type === "ObjectPattern" && O9(r, t), r.propsCall = e, r.propsDecl = t, !0;
}
function w9(r, e, t) {
  return Wt(e, wi) ? (Zh(r, e.arguments[0], t) || r.error(
    `${wi}' first argument must be a ${At} call.`,
    e.arguments[0] || e
  ), r.propsRuntimeDecl && r.error(
    `${wi} can only be used with type-based ${At} declaration.`,
    e
  ), r.propsDestructureDecl && r.error(
    `${wi}() is unnecessary when using destructure with ${At}().
Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...).`,
    e.callee
  ), r.propsRuntimeDefaults = e.arguments[1], r.propsRuntimeDefaults || r.error(`The 2nd argument of ${wi} is required.`, e), r.propsCall = e, !0) : !1;
}
function T9(r) {
  let e;
  if (r.propsRuntimeDecl) {
    if (e = r.getString(r.propsRuntimeDecl).trim(), r.propsDestructureDecl) {
      const s = [];
      for (const i in r.propsDestructuredBindings) {
        const n = bw(r, i), a = p2(i);
        n && s.push(
          `${a}: ${n.valueString}${n.needSkipFactory ? `, __skip_${a}: true` : ""}`
        );
      }
      s.length && (e = `/*#__PURE__*/${r.helper(
        "mergeDefaults"
      )}(${e}, {
  ${s.join(`,
  `)}
})`);
    }
  } else r.propsTypeDecl && (e = yw(r));
  const t = x9(r);
  return e && t ? `/*#__PURE__*/${r.helper(
    "mergeModels"
  )}(${e}, ${t})` : t || e;
}
function yw(r) {
  const e = P9(r, r.propsTypeDecl);
  if (!e.length)
    return;
  const t = [], s = C9(r);
  for (const n of e)
    t.push(A9(r, n, s)), "bindingMetadata" in r && !(n.key in r.bindingMetadata) && (r.bindingMetadata[n.key] = "props");
  let i = `{
    ${t.join(`,
    `)}
  }`;
  return r.propsRuntimeDefaults && !s && (i = `/*#__PURE__*/${r.helper(
    "mergeDefaults"
  )}(${i}, ${r.getString(r.propsRuntimeDefaults)})`), i;
}
function P9(r, e) {
  const t = [], s = wt(r, e);
  for (const i in s.props) {
    const n = s.props[i];
    let a = xt(r, n), o = !1;
    a.includes($r) && (a.includes("Boolean") || a.includes("Function") ? (a = a.filter((u) => u !== $r), o = !0) : a = ["null"]), t.push({
      key: i,
      required: !n.optional,
      type: a || ["null"],
      skipCheck: o
    });
  }
  return t;
}
function A9(r, { key: e, required: t, type: s, skipCheck: i }, n) {
  let a;
  const o = bw(r, e, s);
  if (o)
    a = `default: ${o.valueString}${o.needSkipFactory ? ", skipFactory: true" : ""}`;
  else if (n) {
    const l = r.propsRuntimeDefaults.properties.find(
      (c) => c.type === "SpreadElement" ? !1 : n0(c.key, c.computed) === e
    );
    l && (l.type === "ObjectProperty" ? a = `default: ${r.getString(l.value)}` : a = `${l.async ? "async " : ""}${l.kind !== "method" ? `${l.kind} ` : ""}default() ${r.getString(l.body)}`);
  }
  const u = p2(e);
  return r.options.isProd ? s.some(
    (l) => l === "Boolean" || (!n || a) && l === "Function"
  ) ? `${u}: { ${Wy([
    `type: ${dn(s)}`,
    a
  ])} }` : r.isCE ? a ? `${u}: ${`{ ${a}, type: ${dn(
    s
  )} }`}` : `${u}: {type: ${dn(s)}}` : `${u}: ${a ? `{ ${a} }` : "{}"}` : `${u}: { ${Wy([
    `type: ${dn(s)}`,
    `required: ${t}`,
    i && "skipCheck: true",
    a
  ])} }`;
}
function C9(r) {
  return !!(r.propsRuntimeDefaults && r.propsRuntimeDefaults.type === "ObjectExpression" && r.propsRuntimeDefaults.properties.every(
    (e) => e.type !== "SpreadElement" && (!e.computed || e.key.type.endsWith("Literal"))
  ));
}
function bw(r, e, t) {
  const s = r.propsDestructuredBindings[e], i = s && s.default;
  if (i) {
    const n = r.getString(i), a = br(i);
    if (t && t.length && !t.includes("null")) {
      const l = N9(a);
      l && !t.includes(l) && r.error(
        `Default value of prop "${e}" does not match declared type.`,
        a
      );
    }
    const o = !t && (Ys(a) || a.type === "Identifier");
    return {
      valueString: !o && !f2(a) && !(t != null && t.includes("Function")) ? `() => (${n})` : n,
      needSkipFactory: o
    };
  }
}
function N9(r) {
  switch (r.type) {
    case "StringLiteral":
      return "String";
    case "NumericLiteral":
      return "Number";
    case "BooleanLiteral":
      return "Boolean";
    case "ObjectExpression":
      return "Object";
    case "ArrayExpression":
      return "Array";
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      return "Function";
  }
}
function O9(r, e) {
  if (!r.options.propsDestructure)
    return;
  wn(
    `This project is using reactive props destructure, which is an experimental feature. It may receive breaking changes or be removed in the future, so use at your own risk.
To stay updated, follow the RFC at https://github.com/vuejs/rfcs/discussions/502.`
  ), r.propsDestructureDecl = e;
  const t = (s, i, n) => {
    r.propsDestructuredBindings[s] = { local: i, default: n }, i !== s && (r.bindingMetadata[i] = "props-aliased", (r.bindingMetadata.__propsAliases || (r.bindingMetadata.__propsAliases = {}))[i] = s);
  };
  for (const s of e.properties)
    if (s.type === "ObjectProperty") {
      const i = n0(s.key, s.computed);
      if (i || r.error(
        `${At}() destructure cannot use computed key.`,
        s.key
      ), s.value.type === "AssignmentPattern") {
        const { left: n, right: a } = s.value;
        n.type !== "Identifier" && r.error(
          `${At}() destructure does not support nested patterns.`,
          n
        ), t(i, n.name, a);
      } else s.value.type === "Identifier" ? t(i, s.value.name) : r.error(
        `${At}() destructure does not support nested patterns.`,
        s.value
      );
    } else
      r.propsDestructureRestId = s.argument.name, r.bindingMetadata[r.propsDestructureRestId] = "setup-reactive-const";
}
function I9(r, e) {
  if (!r.options.propsDestructure)
    return;
  const t = {}, s = [t];
  let i = t;
  const n = /* @__PURE__ */ new WeakSet(), a = [], o = /* @__PURE__ */ Object.create(null);
  for (const y in r.propsDestructuredBindings) {
    const { local: S } = r.propsDestructuredBindings[y];
    t[S] = !0, o[S] = y;
  }
  function u() {
    s.push(i = Object.create(i));
  }
  function l() {
    s.pop(), i = s[s.length - 1] || null;
  }
  function c(y) {
    n.add(y), i ? i[y.name] = !1 : r.error(
      "registerBinding called without active scope, something is wrong.",
      y
    );
  }
  function f(y, S = !1) {
    for (const E of y.body)
      if (E.type === "VariableDeclaration")
        p(E, S);
      else if (E.type === "FunctionDeclaration" || E.type === "ClassDeclaration") {
        if (E.declare || !E.id) continue;
        c(E.id);
      } else (E.type === "ForOfStatement" || E.type === "ForInStatement") && E.left.type === "VariableDeclaration" ? p(E.left) : E.type === "ExportNamedDeclaration" && E.declaration && E.declaration.type === "VariableDeclaration" ? p(E.declaration, S) : E.type === "LabeledStatement" && E.body.type === "VariableDeclaration" && p(E.body, S);
  }
  function p(y, S = !1) {
    if (!y.declare)
      for (const E of y.declarations) {
        const g = S && E.init && Wt(br(E.init), "defineProps");
        for (const b of mr(E.id))
          g ? n.add(b) : c(b);
      }
  }
  function h(y, S, E) {
    (S.type === "AssignmentExpression" && y === S.left || S.type === "UpdateExpression") && r.error("Cannot assign to destructured props as they are readonly.", y), qo(S) && S.shorthand ? (!S.inPattern || jo(S, E)) && r.s.appendLeft(
      y.end + r.startOffset,
      `: ${hl(o[y.name])}`
    ) : r.s.overwrite(
      y.start + r.startOffset,
      y.end + r.startOffset,
      hl(o[y.name])
    );
  }
  function m(y, S, E = S) {
    if (Wt(y, E)) {
      const g = br(y.arguments[0]);
      g.type === "Identifier" && i[g.name] && r.error(
        `"${g.name}" is a destructured prop and should not be passed directly to ${S}(). Pass a getter () => ${g.name} instead.`,
        g
      );
    }
  }
  const d = r.scriptSetupAst;
  f(d, !0), Rc(d, {
    enter(y, S) {
      if (S && a.push(S), S && S.type.startsWith("TS") && S.type !== "TSAsExpression" && S.type !== "TSNonNullExpression" && S.type !== "TSTypeAssertion")
        return this.skip();
      if (m(y, "watch", e.watch), m(y, "toRef", e.toRef), Ys(y)) {
        u(), gm(y, c), y.body.type === "BlockStatement" && f(y.body);
        return;
      }
      if (y.type === "CatchClause") {
        u(), y.param && y.param.type === "Identifier" && c(y.param), f(y.body);
        return;
      }
      if (y.type === "BlockStatement" && !Ys(S)) {
        u(), f(y);
        return;
      }
      y.type === "Identifier" && mm(y, S, a) && !n.has(y) && i[y.name] && h(y, S, a);
    },
    leave(y, S) {
      S && a.pop(), (y.type === "BlockStatement" && !Ys(S) || Ys(y)) && l();
    }
  });
}
const ji = "defineEmits";
function ub(r, e, t) {
  return Wt(e, ji) ? (r.hasDefineEmitCall && r.error(`duplicate ${ji}() call`, e), r.hasDefineEmitCall = !0, r.emitsRuntimeDecl = e.arguments[0], e.typeParameters && (r.emitsRuntimeDecl && r.error(
    `${ji}() cannot accept both type and non-type arguments at the same time. Use one or the other.`,
    e
  ), r.emitsTypeDecl = e.typeParameters.params[0]), r.emitDecl = t, !0) : !1;
}
function k9(r) {
  let e = "";
  if (r.emitsRuntimeDecl)
    e = r.getString(r.emitsRuntimeDecl).trim();
  else if (r.emitsTypeDecl) {
    const t = vw(r);
    e = t.size ? `[${Array.from(t).map((s) => JSON.stringify(s)).join(", ")}]` : "";
  }
  if (r.hasDefineModelCall) {
    let t = `[${Object.keys(r.modelDecls).map((s) => JSON.stringify(`update:${s}`)).join(", ")}]`;
    e = e ? `/*#__PURE__*/${r.helper(
      "mergeModels"
    )}(${e}, ${t})` : t;
  }
  return e;
}
function vw(r) {
  const e = /* @__PURE__ */ new Set(), t = r.emitsTypeDecl;
  if (t.type === "TSFunctionType")
    return lb(r, t.parameters[0], e), e;
  const { props: s, calls: i } = wt(r, t);
  let n = !1;
  for (const a in s)
    e.add(a), n = !0;
  if (i) {
    n && r.error(
      "defineEmits() type cannot mixed call signature and property syntax.",
      t
    );
    for (const a of i)
      lb(r, a.parameters[0], e);
  }
  return e;
}
function lb(r, e, t) {
  if (e.type === "Identifier" && e.typeAnnotation && e.typeAnnotation.type === "TSTypeAnnotation") {
    const s = gw(r, e.typeAnnotation.typeAnnotation);
    for (const i of s)
      i.type === "TSLiteralType" && i.literal.type !== "UnaryExpression" && i.literal.type !== "TemplateLiteral" && t.add(String(i.literal.value));
  }
}
const Xl = "defineExpose";
function D9(r, e) {
  return Wt(e, Xl) ? (r.hasDefineExposeCall && r.error(`duplicate ${Xl}() call`, e), r.hasDefineExposeCall = !0, !0) : !1;
}
const Tn = "defineSlots";
function cb(r, e, t) {
  return Wt(e, Tn) ? (r.hasDefineSlotsCall && r.error(`duplicate ${Tn}() call`, e), r.hasDefineSlotsCall = !0, e.arguments.length > 0 && r.error(`${Tn}() cannot accept arguments`, e), t && r.s.overwrite(
    r.startOffset + e.start,
    r.startOffset + e.end,
    `${r.helper("useSlots")}()`
  ), !0) : !1;
}
const Rr = "defineOptions";
function fb(r, e) {
  if (!Wt(e, Rr))
    return !1;
  if (r.hasDefineOptionsCall && r.error(`duplicate ${Rr}() call`, e), e.typeParameters && r.error(`${Rr}() cannot accept type arguments`, e), !e.arguments[0]) return !0;
  r.hasDefineOptionsCall = !0, r.optionsRuntimeDecl = br(e.arguments[0]);
  let t, s, i, n;
  if (r.optionsRuntimeDecl.type === "ObjectExpression") {
    for (const a of r.optionsRuntimeDecl.properties)
      if ((a.type === "ObjectProperty" || a.type === "ObjectMethod") && a.key.type === "Identifier")
        switch (a.key.name) {
          case "props":
            t = a;
            break;
          case "emits":
            s = a;
            break;
          case "expose":
            i = a;
            break;
          case "slots":
            n = a;
            break;
        }
  }
  return t && r.error(
    `${Rr}() cannot be used to declare props. Use ${At}() instead.`,
    t
  ), s && r.error(
    `${Rr}() cannot be used to declare emits. Use ${ji}() instead.`,
    s
  ), i && r.error(
    `${Rr}() cannot be used to declare expose. Use ${Xl}() instead.`,
    i
  ), n && r.error(
    `${Rr}() cannot be used to declare slots. Use ${Tn}() instead.`,
    n
  ), !0;
}
function L9(r, e, t, s) {
  const i = e.argument.extra && e.argument.extra.parenthesized ? e.argument.extra.parenStart : e.argument.start, n = r.startOffset, a = r.descriptor.source.slice(
    i + n,
    e.argument.end + n
  ), o = /\bawait\b/.test(a);
  r.s.overwrite(
    e.start + n,
    i + n,
    `${t ? ";" : ""}(
  ([__temp,__restore] = ${r.helper(
      "withAsyncContext"
    )}(${o ? "async " : ""}() => `
  ), r.s.appendLeft(
    e.end + n,
    `)),
  ${s ? "" : "__temp = "}await __temp,
  __restore()${s ? "" : `,
  __temp`}
)`
  );
}
var M9 = Object.defineProperty, R9 = Object.defineProperties, $9 = Object.getOwnPropertyDescriptors, pb = Object.getOwnPropertySymbols, F9 = Object.prototype.hasOwnProperty, B9 = Object.prototype.propertyIsEnumerable, hb = (r, e, t) => e in r ? M9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Pa = (r, e) => {
  for (var t in e || (e = {}))
    F9.call(e, t) && hb(r, t, e[t]);
  if (pb)
    for (var t of pb(e))
      B9.call(e, t) && hb(r, t, e[t]);
  return r;
}, sp = (r, e) => R9(r, $9(e));
const V9 = [
  At,
  ji,
  Xl,
  Rr,
  Tn,
  df,
  wi
];
function U9(r, e) {
  var t, s, i;
  e.id || wn(
    "compileScript now requires passing the `id` option.\nUpgrade your vite or vue-loader version for compatibility with the latest experimental proposals."
  );
  const n = new HR(r, e), { script: a, scriptSetup: o, source: u, filename: l } = r, c = e.hoistStatic !== !1 && !a, f = e.id ? e.id.replace(/^data-v-/, "") : "", p = a && a.lang, h = o && o.lang;
  if (!o) {
    if (!a)
      throw new Error("[@vue/compiler-sfc] SFC contains no <script> tags.");
    return e9(n, f);
  }
  if (a && p !== h)
    throw new Error(
      "[@vue/compiler-sfc] <script> and <script setup> must have the same language type."
    );
  if (h && !n.isJS && !n.isTS)
    return o;
  const m = /* @__PURE__ */ Object.create(null), d = /* @__PURE__ */ Object.create(null);
  let y, S = !1, E = !1;
  const g = n.startOffset, b = n.endOffset, v = a && a.loc.start.offset, A = a && a.loc.end.offset;
  function C(k) {
    const R = k.start + g;
    let D = k.end + g;
    for (k.trailingComments && k.trailingComments.length > 0 && (D = k.trailingComments[k.trailingComments.length - 1].end + g); D <= u.length && /\s/.test(u.charAt(D)); )
      D++;
    n.s.move(R, D, 0);
  }
  function x(k, R, D, B, ie, L) {
    let ne = L;
    L && n.isTS && r.template && !r.template.src && !r.template.lang && (ne = T2(R, r)), n.userImports[R] = {
      isType: B,
      imported: D,
      local: R,
      source: k,
      isFromSetup: ie,
      isUsedInTemplate: ne
    };
  }
  function _(k, R) {
    k && Uo(k, (D) => {
      const B = d[D.name];
      B && B !== "literal-const" && n.error(
        `\`${R}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options require initialization in the module scope, use a separate normal <script> to export the options instead.`,
        D
      );
    });
  }
  const T = n.scriptAst, P = n.scriptSetupAst;
  if (T) {
    for (const k of T.body)
      if (k.type === "ImportDeclaration")
        for (const R of k.specifiers) {
          const D = Gp(R);
          x(
            k.source.value,
            R.local.name,
            D,
            k.importKind === "type" || R.type === "ImportSpecifier" && R.importKind === "type",
            !1,
            !e.inlineTemplate
          );
        }
  }
  for (const k of P.body)
    if (k.type === "ImportDeclaration") {
      C(k);
      let R = 0;
      const D = (B) => {
        const ie = B > R;
        R++;
        const L = k.specifiers[B], ne = k.specifiers[B + 1];
        n.s.remove(
          ie ? k.specifiers[B - 1].end + g : L.start + g,
          ne && !ie ? ne.start + g : L.end + g
        );
      };
      for (let B = 0; B < k.specifiers.length; B++) {
        const ie = k.specifiers[B], L = ie.local.name, ne = Gp(ie), ye = k.source.value, be = n.userImports[L];
        ye === "vue" && V9.includes(ne) ? (L === ne ? wn(
          `\`${ne}\` is a compiler macro and no longer needs to be imported.`
        ) : n.error(
          `\`${ne}\` is a compiler macro and cannot be aliased to a different name.`,
          ie
        ), D(B)) : be ? be.source === ye && be.imported === ne ? D(B) : n.error(
          "different imports aliased to same local name.",
          ie
        ) : x(
          ye,
          L,
          ne,
          k.importKind === "type" || ie.type === "ImportSpecifier" && ie.importKind === "type",
          !0,
          !e.inlineTemplate
        );
      }
      k.specifiers.length && R === k.specifiers.length && n.s.remove(k.start + g, k.end + g);
    }
  const I = {};
  for (const k in n.userImports) {
    const { source: R, imported: D, local: B } = n.userImports[k];
    R === "vue" && (I[D] = B);
  }
  if (a && T) {
    for (const k of T.body)
      if (k.type === "ExportDefaultDeclaration") {
        y = k;
        let R;
        if (y.declaration.type === "ObjectExpression" ? R = y.declaration.properties : y.declaration.type === "CallExpression" && y.declaration.arguments[0] && y.declaration.arguments[0].type === "ObjectExpression" && (R = y.declaration.arguments[0].properties), R)
          for (const ie of R)
            ie.type === "ObjectProperty" && ie.key.type === "Identifier" && ie.key.name === "name" && (n.hasDefaultExportName = !0), (ie.type === "ObjectMethod" || ie.type === "ObjectProperty") && ie.key.type === "Identifier" && ie.key.name === "render" && (n.hasDefaultExportRender = !0);
        const D = k.start + v, B = k.declaration.start + v;
        n.s.overwrite(D, B, `const ${fn} = `);
      } else if (k.type === "ExportNamedDeclaration") {
        const R = k.specifiers.find(
          (D) => D.exported.type === "Identifier" && D.exported.name === "default"
        );
        R && (y = k, k.specifiers.length > 1 ? n.s.remove(
          R.start + v,
          R.end + v
        ) : n.s.remove(
          k.start + v,
          k.end + v
        ), k.source ? n.s.prepend(
          `import { ${R.local.name} as ${fn} } from '${k.source.value}'
`
        ) : n.s.appendLeft(
          A,
          `
const ${fn} = ${R.local.name}
`
        )), k.declaration && ip(
          "script",
          k.declaration,
          m,
          I,
          c
        );
      } else (k.type === "VariableDeclaration" || k.type === "FunctionDeclaration" || k.type === "ClassDeclaration" || k.type === "TSEnumDeclaration") && !k.declare && ip(
        "script",
        k,
        m,
        I,
        c
      );
    v > g && (/\n$/.test(a.content.trim()) || n.s.appendLeft(A, `
`), n.s.move(v, A, 0));
  }
  for (const k of P.body) {
    if (k.type === "ExpressionStatement") {
      const D = br(k.expression);
      if (Zh(n, D) || ub(n, D) || fb(n, D) || cb(n, D))
        n.s.remove(k.start + g, k.end + g);
      else if (D9(n, D)) {
        const B = D.callee;
        n.s.overwrite(
          B.start + g,
          B.end + g,
          "__expose"
        );
      } else
        ob(n, D);
    }
    if (k.type === "VariableDeclaration" && !k.declare) {
      const D = k.declarations.length;
      let B = D, ie;
      for (let L = 0; L < D; L++) {
        const ne = k.declarations[L], ye = ne.init && br(ne.init);
        if (ye) {
          fb(n, ye) && n.error(
            `${Rr}() has no returning value, it cannot be assigned.`,
            k
          );
          const be = Zh(n, ye, ne.id);
          n.propsDestructureRestId && (d[n.propsDestructureRestId] = "setup-reactive-const");
          const me = !be && ub(n, ye, ne.id);
          if (!me && (cb(n, ye, ne.id) || ob(n, ye, ne.id)), be && !n.propsDestructureRestId && n.propsDestructureDecl)
            if (B === 1)
              n.s.remove(k.start + g, k.end + g);
            else {
              let ke = ne.start + g, Ke = ne.end + g;
              L === D - 1 ? ke = k.declarations[ie].end + g : Ke = k.declarations[L + 1].start + g, n.s.remove(ke, Ke), B--;
            }
          else me ? n.s.overwrite(
            g + ye.start,
            g + ye.end,
            "__emit"
          ) : ie = L;
        }
      }
    }
    let R = !1;
    if ((k.type === "VariableDeclaration" || k.type === "FunctionDeclaration" || k.type === "ClassDeclaration" || k.type === "TSEnumDeclaration") && !k.declare && (R = ip(
      "scriptSetup",
      k,
      d,
      I,
      c
    )), c && R && C(k), k.type === "VariableDeclaration" && !k.declare || k.type.endsWith("Statement")) {
      const D = [P.body];
      Rc(k, {
        enter(B, ie) {
          if (Ys(B) && this.skip(), B.type === "BlockStatement" && D.push(B.body), B.type === "AwaitExpression") {
            S = !0;
            const ne = D[D.length - 1].some((ye, be) => (D.length === 1 || be > 0) && ye.type === "ExpressionStatement" && ye.start === B.start);
            L9(
              n,
              B,
              ne,
              ie.type === "ExpressionStatement"
            );
          }
        },
        exit(B) {
          B.type === "BlockStatement" && D.pop();
        }
      });
    }
    (k.type === "ExportNamedDeclaration" && k.exportKind !== "type" || k.type === "ExportAllDeclaration" || k.type === "ExportDefaultDeclaration") && n.error(
      "<script setup> cannot contain ES module exports. If you are using a previous version of <script setup>, please consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.",
      k
    ), n.isTS && (k.type.startsWith("TS") || k.type === "ExportNamedDeclaration" && k.exportKind === "type" || k.type === "VariableDeclaration" && k.declare) && k.type !== "TSEnumDeclaration" && C(k);
  }
  n.propsDestructureDecl && I9(n, I), _(n.propsRuntimeDecl, At), _(n.propsRuntimeDefaults, At), _(n.propsDestructureDecl, At), _(n.emitsRuntimeDecl, ji), _(n.optionsRuntimeDecl, Rr);
  for (const { runtimeOptionNodes: k } of Object.values(n.modelDecls))
    for (const R of k)
      _(R, df);
  a ? g < v ? (n.s.remove(0, g), n.s.remove(b, v), n.s.remove(A, u.length)) : (n.s.remove(0, v), n.s.remove(A, g), n.s.remove(b, u.length)) : (n.s.remove(0, g), n.s.remove(b, u.length)), T && Object.assign(n.bindingMetadata, uw(T.body));
  for (const [k, { isType: R, imported: D, source: B }] of Object.entries(
    n.userImports
  ))
    R || (n.bindingMetadata[k] = D === "*" || D === "default" && B.endsWith(".vue") || B === "vue" ? "setup-const" : "setup-maybe-ref");
  for (const k in m)
    n.bindingMetadata[k] = m[k];
  for (const k in d)
    n.bindingMetadata[k] = d[k];
  r.cssVars.length && // no need to do this when targeting SSR
  !((t = e.templateOptions) != null && t.ssr) && (n.helperImports.add(Ol), n.helperImports.add("unref"), n.s.prependLeft(
    g,
    `
${v2(
      r.cssVars,
      n.bindingMetadata,
      f,
      !!e.isProd
    )}
`
  ));
  let $ = "__props";
  if (n.propsTypeDecl && ($ += ": any"), n.propsDecl && (n.propsDestructureRestId ? (n.s.overwrite(
    g + n.propsCall.start,
    g + n.propsCall.end,
    `${n.helper("createPropsRestProxy")}(__props, ${JSON.stringify(
      Object.keys(n.propsDestructuredBindings)
    )})`
  ), n.s.overwrite(
    g + n.propsDestructureDecl.start,
    g + n.propsDestructureDecl.end,
    n.propsDestructureRestId
  )) : n.propsDestructureDecl || n.s.overwrite(
    g + n.propsCall.start,
    g + n.propsCall.end,
    "__props"
  )), S) {
    const k = n.isTS ? ": any" : "";
    n.s.prependLeft(g, `
let __temp${k}, __restore${k}
`);
  }
  const Y = n.hasDefineExposeCall || !e.inlineTemplate ? ["expose: __expose"] : [];
  n.emitDecl && Y.push("emit: __emit"), Y.length && ($ += `, { ${Y.join(", ")} }`);
  let W;
  if (!e.inlineTemplate || !r.template && n.hasDefaultExportRender) {
    const k = Pa(Pa({}, m), d);
    for (const R in n.userImports)
      !n.userImports[R].isType && n.userImports[R].isUsedInTemplate && (k[R] = !0);
    W = "{ ";
    for (const R in k)
      if (k[R] === !0 && n.userImports[R].source !== "vue" && !n.userImports[R].source.endsWith(".vue"))
        W += `get ${R}() { return ${R} }, `;
      else if (n.bindingMetadata[R] === "setup-let") {
        const D = R === "v" ? "_v" : "v";
        W += `get ${R}() { return ${R} }, set ${R}(${D}) { ${R} = ${D} }, `;
      } else
        W += `${R}, `;
    W = W.replace(/, $/, "") + " }";
  } else if (r.template && !r.template.src) {
    e.templateOptions && e.templateOptions.ssr && (E = !0);
    const { code: k, ast: R, preamble: D, tips: B, errors: ie } = M_(sp(Pa({
      filename: l,
      ast: r.template.ast,
      source: r.template.content,
      inMap: r.template.map
    }, e.templateOptions), {
      id: f,
      scoped: r.styles.some((ne) => ne.scoped),
      isProd: e.isProd,
      ssrCssVars: r.cssVars,
      compilerOptions: sp(Pa({}, e.templateOptions && e.templateOptions.compilerOptions), {
        inline: !0,
        isTS: n.isTS,
        bindingMetadata: n.bindingMetadata
      })
    }));
    B.length && B.forEach(wn);
    const L = ie[0];
    if (typeof L == "string")
      throw new Error(L);
    if (L)
      throw L.loc && (L.message += `

` + r.filename + `
` + kn(
        u,
        L.loc.start.offset,
        L.loc.end.offset
      ) + `
`), L;
    D && n.s.prepend(D), R && R.helpers.has(Mn) && n.helperImports.delete("unref"), W = k;
  } else
    W = "() => {}";
  e.inlineTemplate ? n.s.appendRight(b, `
return ${W}
}

`) : n.s.appendRight(
    b,
    `
const __returned__ = ${W}
Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
return __returned__
}

`
  );
  const F = e.genDefaultAs ? `const ${e.genDefaultAs} =` : "export default";
  let K = "";
  if (!n.hasDefaultExportName && l && l !== C2) {
    const k = l.match(/([^/\\]+)\.\w+$/);
    k && (K += `
  __name: '${k[1]}',`);
  }
  E && (K += `
  __ssrInlineRender: true,`);
  const Z = T9(n);
  Z && (K += `
  props: ${Z},`);
  const Ce = k9(n);
  Ce && (K += `
  emits: ${Ce},`);
  let Ve = "";
  n.optionsRuntimeDecl && (Ve = o.content.slice(n.optionsRuntimeDecl.start, n.optionsRuntimeDecl.end).trim());
  const ee = n.hasDefineExposeCall || e.inlineTemplate ? "" : `  __expose();
`;
  if (n.isTS) {
    const k = (y ? `
  ...${fn},` : "") + (Ve ? `
  ...${Ve},` : "");
    n.s.prependLeft(
      g,
      `
${F} /*#__PURE__*/${n.helper(
        "defineComponent"
      )}({${k}${K}
  ${S ? "async " : ""}setup(${$}) {
${ee}`
    ), n.s.appendRight(b, "})");
  } else
    y || Ve ? (n.s.prependLeft(
      g,
      `
${F} /*#__PURE__*/Object.assign(${y ? `${fn}, ` : ""}${Ve ? `${Ve}, ` : ""}{${K}
  ${S ? "async " : ""}setup(${$}) {
${ee}`
    ), n.s.appendRight(b, "})")) : (n.s.prependLeft(
      g,
      `
${F} {${K}
  ${S ? "async " : ""}setup(${$}) {
${ee}`
    ), n.s.appendRight(b, "}"));
  if (n.helperImports.size > 0) {
    const k = (i = (s = e.templateOptions) == null ? void 0 : s.compilerOptions) == null ? void 0 : i.runtimeModuleName, R = k ? JSON.stringify(k) : "'vue'";
    n.s.prepend(
      `import { ${[...n.helperImports].map((D) => `${D} as _${D}`).join(", ")} } from ${R}
`
    );
  }
  return sp(Pa({}, o), {
    bindings: n.bindingMetadata,
    imports: n.userImports,
    content: n.s.toString(),
    map: e.sourceMap !== !1 ? n.s.generateMap({
      source: l,
      hires: !0,
      includeContent: !0
    }) : void 0,
    scriptAst: T == null ? void 0 : T.body,
    scriptSetupAst: P == null ? void 0 : P.body,
    deps: n.deps ? [...n.deps] : void 0
  });
}
function Pn(r, e, t) {
  r[e.name] = t;
}
function ip(r, e, t, s, i) {
  let n = !1;
  if (e.type === "VariableDeclaration") {
    const a = e.kind === "const";
    n = a && e.declarations.every(
      (o) => o.id.type === "Identifier" && wr(o.init)
    );
    for (const { id: o, init: u } of e.declarations) {
      const l = u && br(u), c = a && Wt(
        l,
        (f) => f === At || f === ji || f === wi || f === Tn
      );
      if (o.type === "Identifier") {
        let f;
        const p = s.reactive;
        (i || r === "script") && (n || a && wr(l)) ? f = "literal-const" : Wt(l, p) ? f = a ? "setup-reactive-const" : "setup-let" : /* if a declaration is a const literal, we can mark it so that */ /* the generated render fn code doesn't need to unref() it */ c || a && _w(l, p) ? f = Wt(l, At) ? "setup-reactive-const" : "setup-const" : a ? Wt(
          l,
          (h) => h === s.ref || h === s.computed || h === s.shallowRef || h === s.customRef || h === s.toRef || h === df
        ) ? f = "setup-ref" : f = "setup-maybe-ref" : f = "setup-let", Pn(t, o, f);
      } else {
        if (Wt(l, At))
          continue;
        o.type === "ObjectPattern" ? Ew(o, t, a, c) : o.type === "ArrayPattern" && Sw(o, t, a, c);
      }
    }
  } else e.type === "TSEnumDeclaration" ? (n = e.members.every(
    (a) => !a.initializer || wr(a.initializer)
  ), t[e.id.name] = n ? "literal-const" : "setup-const") : (e.type === "FunctionDeclaration" || e.type === "ClassDeclaration") && (t[e.id.name] = "setup-const");
  return n;
}
function Ew(r, e, t, s = !1) {
  for (const i of r.properties)
    if (i.type === "ObjectProperty")
      if (i.key.type === "Identifier" && i.key === i.value) {
        const n = s ? "setup-const" : t ? "setup-maybe-ref" : "setup-let";
        Pn(e, i.key, n);
      } else
        ig(i.value, e, t, s);
    else {
      const n = t ? "setup-const" : "setup-let";
      Pn(e, i.argument, n);
    }
}
function Sw(r, e, t, s = !1) {
  for (const i of r.elements)
    i && ig(i, e, t, s);
}
function ig(r, e, t, s = !1) {
  if (r.type === "Identifier")
    Pn(e, r, s ? "setup-const" : t ? "setup-maybe-ref" : "setup-let");
  else if (r.type === "RestElement") {
    const i = t ? "setup-const" : "setup-let";
    Pn(e, r.argument, i);
  } else if (r.type === "ObjectPattern")
    Ew(r, e, t);
  else if (r.type === "ArrayPattern")
    Sw(r, e, t);
  else if (r.type === "AssignmentPattern")
    if (r.left.type === "Identifier") {
      const i = s ? "setup-const" : t ? "setup-maybe-ref" : "setup-let";
      Pn(e, r.left, i);
    } else
      ig(r.left, e, t);
}
function _w(r, e) {
  if (Wt(r, e))
    return !0;
  switch (r.type) {
    case "UnaryExpression":
    case "BinaryExpression":
    case "ArrayExpression":
    case "ObjectExpression":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "UpdateExpression":
    case "ClassExpression":
    case "TaggedTemplateExpression":
      return !0;
    case "SequenceExpression":
      return _w(
        r.expressions[r.expressions.length - 1],
        e
      );
    default:
      return !!f2(r);
  }
}
function wr(r) {
  switch (r = br(r), r.type) {
    case "UnaryExpression":
      return wr(r.argument);
    case "LogicalExpression":
    case "BinaryExpression":
      return wr(r.left) && wr(r.right);
    case "ConditionalExpression":
      return wr(r.test) && wr(r.consequent) && wr(r.alternate);
    case "SequenceExpression":
    case "TemplateLiteral":
      return r.expressions.every((e) => wr(e));
    case "ParenthesizedExpression":
      return wr(r.expression);
    case "StringLiteral":
    case "NumericLiteral":
    case "BooleanLiteral":
    case "NullLiteral":
    case "BigIntLiteral":
      return !0;
  }
  return !1;
}
var j9 = Object.defineProperty, db = Object.getOwnPropertySymbols, q9 = Object.prototype.hasOwnProperty, H9 = Object.prototype.propertyIsEnumerable, mb = (r, e, t) => e in r ? j9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, gb = (r, e) => {
  for (var t in e || (e = {}))
    q9.call(e, t) && mb(r, t, e[t]);
  if (db)
    for (var t of db(e))
      H9.call(e, t) && mb(r, t, e[t]);
  return r;
};
const W9 = "3.4.37", z9 = Kp, G9 = gb(gb({}, tm), Jm), K9 = Rc, X9 = () => !1, c$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MagicString: la,
  babelParse: $n,
  compileScript: U9,
  compileStyle: PR,
  compileStyleAsync: AR,
  compileTemplate: M_,
  errorMessages: G9,
  extractIdentifiers: mr,
  extractRuntimeEmits: vw,
  extractRuntimeProps: yw,
  generateCodeFrame: kn,
  inferRuntimeType: xt,
  invalidateTypeCache: m9,
  isInDestructureAssignment: jo,
  isStaticProperty: qo,
  parse: N2,
  parseCache: z9,
  registerTS: p9,
  resolveTypeElements: wt,
  rewriteDefault: WR,
  rewriteDefaultAST: J0,
  shouldTransformRef: X9,
  version: W9,
  walk: K9,
  walkIdentifiers: Uo
}, Symbol.toStringTag, { value: "Module" }));
/**
* @vue/server-renderer v3.4.37
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const J9 = /* @__PURE__ */ zt(
  ",key,ref,innerHTML,textContent,ref_key,ref_for"
);
function xw(r, e) {
  let t = "";
  for (const s in r) {
    if (J9(s) || Yi(s) || e === "textarea" && s === "value")
      continue;
    const i = r[s];
    s === "class" ? t += ` class="${Pw(i)}"` : s === "style" ? t += ` style="${Aw(i)}"` : t += ww(s, i, e);
  }
  return t;
}
function ww(r, e, t) {
  if (!id(e))
    return "";
  const s = t && (t.indexOf("-") > 0 || Pb(t)) ? r : mT[r] || r.toLowerCase();
  return ap(s) ? Ao(e) ? ` ${s}` : "" : dT(s) ? e === "" ? ` ${s}` : ` ${s}="${Wr(e)}"` : (console.warn(
    `[@vue/server-renderer] Skipped rendering unsafe attribute name: ${s}`
  ), "");
}
function Tw(r, e) {
  return id(e) ? ` ${r}="${Wr(e)}"` : "";
}
function Pw(r) {
  return Wr(en(r));
}
function Aw(r) {
  if (!r)
    return "";
  if (_e(r))
    return Wr(r);
  const e = Zi(r);
  return Wr(Tb(e));
}
function Y9(r, e = null, t = null, s = null, i) {
  return mf(
    He(r, e, t),
    s,
    i
  );
}
const { ensureValidVNode: Q9 } = Kn;
function Z9(r, e, t, s, i, n, a) {
  i("<!--[-->"), Cw(
    r,
    e,
    t,
    s,
    i,
    n,
    a
  ), i("<!--]-->");
}
function Cw(r, e, t, s, i, n, a, o) {
  const u = r[e];
  if (u) {
    const l = [], f = u(
      t,
      (p) => {
        l.push(p);
      },
      n,
      a ? " " + a : ""
    );
    if (se(f)) {
      const p = Q9(f);
      p ? gf(
        i,
        p,
        n,
        a
      ) : s && s();
    } else {
      let p = !0;
      if (o)
        p = !1;
      else
        for (let h = 0; h < l.length; h++)
          if (!r7(l[h])) {
            p = !1;
            break;
          }
      if (p)
        s && s();
      else {
        let h = 0, m = l.length;
        o && l[0] === "<!--[-->" && l[m - 1] === "<!--]-->" && (h++, m--);
        for (let d = h; d < m; d++)
          i(l[d]);
      }
    }
  } else s && s();
}
const e7 = /^<!--[\s\S]*-->$/, t7 = /<!--[^]*?-->/gm;
function r7(r) {
  return typeof r != "string" || !e7.test(r) ? !1 : r.length <= 8 ? !0 : !r.replace(t7, "").trim();
}
function Nw(r, e, t, s, i) {
  r("<!--teleport start-->");
  const n = i.appContext.provides[ko], a = n.__teleportBuffers || (n.__teleportBuffers = {}), o = a[t] || (a[t] = []), u = o.length;
  let l;
  if (s)
    e(r), l = "<!--teleport start anchor--><!--teleport anchor-->";
  else {
    const { getBuffer: c, push: f } = Fw();
    f("<!--teleport start anchor-->"), e(f), f("<!--teleport anchor-->"), l = c();
  }
  o.splice(u, 0, l), r("<!--teleport end-->");
}
function s7(r) {
  return Wr(nd(r));
}
let yb, Jl = !0;
const Ow = [];
function Iw() {
  Ow.push(Jl), Jl = !1;
}
function kw() {
  const r = Ow.pop();
  Jl = r === void 0 ? !0 : r;
}
function i7(r, e, t) {
  var s;
  e.get(r) !== r._trackId && (e.set(r, r._trackId), r.deps[r._depsLength] !== e ? r.deps[r._depsLength++] = e : r._depsLength++, process.env.NODE_ENV !== "production" && ((s = r.onTrack) == null || s.call(r, Be({ effect: r }, t))));
}
const n7 = (r, e) => {
  const t = /* @__PURE__ */ new Map();
  return t.cleanup = r, t.computed = e, t;
}, bb = /* @__PURE__ */ new WeakMap();
Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
function vb(r, e, t) {
  if (Jl && yb) {
    let s = bb.get(r);
    s || bb.set(r, s = /* @__PURE__ */ new Map());
    let i = s.get(t);
    i || s.set(t, i = n7(() => s.delete(t))), i7(
      yb,
      i,
      process.env.NODE_ENV !== "production" ? {
        target: r,
        type: e,
        key: t
      } : void 0
    );
  }
}
function ed(r) {
  const e = r && r.__v_raw;
  return e ? ed(e) : r;
}
function a7(r) {
  return !!(r && r.__v_isRef === !0);
}
const qi = [];
function o7(r) {
  qi.push(r);
}
function u7() {
  qi.pop();
}
let np = !1;
function Yl(r, ...e) {
  if (np) return;
  np = !0, Iw();
  const t = qi.length ? qi[qi.length - 1].component : null, s = t && t.appContext.config.warnHandler, i = l7();
  if (s)
    Mw(
      s,
      t,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        r + e.map((n) => {
          var a, o;
          return (o = (a = n.toString) == null ? void 0 : a.call(n)) != null ? o : JSON.stringify(n);
        }).join(""),
        t && t.proxy,
        i.map(
          ({ vnode: n }) => `at <${$w(t, n.type)}>`
        ).join(`
`),
        i
      ]
    );
  else {
    const n = [`[Vue warn]: ${r}`, ...e];
    i.length && n.push(`
`, ...c7(i)), console.warn(...n);
  }
  kw(), np = !1;
}
function l7() {
  let r = qi[qi.length - 1];
  if (!r)
    return [];
  const e = [];
  for (; r; ) {
    const t = e[0];
    t && t.vnode === r ? t.recurseCount++ : e.push({
      vnode: r,
      recurseCount: 0
    });
    const s = r.component && r.component.parent;
    r = s && s.vnode;
  }
  return e;
}
function c7(r) {
  const e = [];
  return r.forEach((t, s) => {
    e.push(...s === 0 ? [] : [`
`], ...f7(t));
  }), e;
}
function f7({ vnode: r, recurseCount: e }) {
  const t = e > 0 ? `... (${e} recursive calls)` : "", s = r.component ? r.component.parent == null : !1, i = ` at <${$w(
    r.component,
    r.type,
    s
  )}`, n = ">" + t;
  return r.props ? [i, ...p7(r.props), n] : [i + n];
}
function p7(r) {
  const e = [], t = Object.keys(r);
  return t.slice(0, 3).forEach((s) => {
    e.push(...Dw(s, r[s]));
  }), t.length > 3 && e.push(" ..."), e;
}
function Dw(r, e, t) {
  return _e(e) ? (e = JSON.stringify(e), t ? e : [`${r}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? t ? e : [`${r}=${e}`] : a7(e) ? (e = Dw(r, ed(e.value), !0), t ? e : [`${r}=Ref<`, e, ">"]) : fe(e) ? [`${r}=fn${e.name ? `<${e.name}>` : ""}`] : (e = ed(e), t ? e : [`${r}=`, e]);
}
const Lw = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update"
};
function Mw(r, e, t, s) {
  try {
    return s ? r(...s) : r();
  } catch (i) {
    h7(i, e, t);
  }
}
function h7(r, e, t, s = !0) {
  const i = e ? e.vnode : null;
  if (e) {
    let n = e.parent;
    const a = e.proxy, o = process.env.NODE_ENV !== "production" ? Lw[t] : `https://vuejs.org/error-reference/#runtime-${t}`;
    for (; n; ) {
      const l = n.ec;
      if (l) {
        for (let c = 0; c < l.length; c++)
          if (l[c](r, a, o) === !1)
            return;
      }
      n = n.parent;
    }
    const u = e.appContext.config.errorHandler;
    if (u) {
      Iw(), Mw(
        u,
        null,
        10,
        [r, a, o]
      ), kw();
      return;
    }
  }
  d7(r, t, i, s);
}
function d7(r, e, t, s = !0) {
  if (process.env.NODE_ENV !== "production") {
    const i = Lw[e];
    if (t && o7(t), Yl(`Unhandled error${i ? ` during execution of ${i}` : ""}`), t && u7(), s)
      throw r;
    console.error(r);
  } else
    console.error(r);
}
let pn, Au = [];
function Rw(r, e) {
  var t, s;
  pn = r, pn ? (pn.enabled = !0, Au.forEach(({ event: i, args: n }) => pn.emit(i, ...n)), Au = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((s = (t = window.navigator) == null ? void 0 : t.userAgent) != null && s.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((n) => {
    Rw(n, e);
  }), setTimeout(() => {
    pn || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Au = []);
  }, 3e3)) : Au = [];
}
{
  const r = Zl(), e = (t, s) => {
    let i;
    return (i = r[t]) || (i = r[t] = []), i.push(s), (n) => {
      i.length > 1 ? i.forEach((a) => a(n)) : i[0](n);
    };
  };
  e(
    "__VUE_INSTANCE_SETTERS__",
    (t) => t
  ), e(
    "__VUE_SSR_SETTERS__",
    (t) => t
  );
}
process.env.NODE_ENV;
const m7 = /(?:^|[-_])(\w)/g, g7 = (r) => r.replace(m7, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function y7(r, e = !0) {
  return fe(r) ? r.displayName || r.name : r.name || e && r.__name;
}
function $w(r, e, t = !1) {
  let s = y7(e);
  if (!s && e.__file) {
    const i = e.__file.match(/([^/\\]+)\.\w+$/);
    i && (s = i[1]);
  }
  if (!s && r && r.parent) {
    const i = (n) => {
      for (const a in n)
        if (n[a] === e)
          return a;
    };
    s = i(
      r.components || r.parent.type.components
    ) || i(r.appContext.components);
  }
  return s ? g7(s) : t ? "App" : "Anonymous";
}
const b7 = process.env.NODE_ENV !== "production" ? Yl : Ge;
process.env.NODE_ENV;
process.env.NODE_ENV;
function v7(r, e) {
  if (se(r) || _e(r))
    for (let t = 0, s = r.length; t < s; t++)
      e(r[t], t);
  else if (typeof r == "number") {
    if (process.env.NODE_ENV !== "production" && !Number.isInteger(r)) {
      b7(`The v-for range expect an integer value but got ${r}.`);
      return;
    }
    for (let t = 0; t < r; t++)
      e(t + 1, t);
  } else if (Ae(r))
    if (r[Symbol.iterator]) {
      const t = Array.from(r);
      for (let s = 0, i = t.length; s < i; s++)
        e(t[s], s);
    } else {
      const t = Object.keys(r);
      for (let s = 0, i = t.length; s < i; s++) {
        const n = t[s];
        e(r[n], n, s);
      }
    }
}
async function E7(r, { default: e }) {
  e ? e() : r("<!---->");
}
function S7(r, e, t, s, i = {}) {
  return typeof e != "function" && e.getSSRProps ? e.getSSRProps(
    {
      dir: e,
      instance: Kn.getComponentPublicInstance(r.$),
      value: t,
      oldValue: void 0,
      arg: s,
      modifiers: i
    },
    null
  ) || {} : {};
}
const _7 = Or;
function ng(r, e) {
  return Co(r, e) > -1;
}
function x7(r, e, t) {
  switch (r) {
    case "radio":
      return Or(e, t) ? " checked" : "";
    case "checkbox":
      return (se(e) ? ng(e, t) : e) ? " checked" : "";
    default:
      return Tw("value", e);
  }
}
function w7(r = {}, e) {
  const { type: t, value: s } = r;
  switch (t) {
    case "radio":
      return Or(e, s) ? { checked: !0 } : null;
    case "checkbox":
      return (se(e) ? ng(e, s) : e) ? { checked: !0 } : null;
    default:
      return { value: e };
  }
}
function T7(r, e) {
  throw new Error(
    "On-the-fly template compilation is not supported in the ESM build of @vue/server-renderer. All templates must be pre-compiled into render functions."
  );
}
const {
  createComponentInstance: P7,
  setCurrentRenderingInstance: Eb,
  setupComponent: A7,
  renderComponentRoot: Sb,
  normalizeVNode: C7
} = Kn;
function Fw() {
  let r = !1;
  const e = [];
  return {
    getBuffer() {
      return e;
    },
    push(t) {
      const s = _e(t);
      if (r && s) {
        e[e.length - 1] += t;
        return;
      }
      e.push(t), r = s, (es(t) || se(t) && t.hasAsync) && (e.hasAsync = !0);
    }
  };
}
function mf(r, e = null, t) {
  const s = P7(r, e, null), i = A7(
    s,
    !0
    /* isSSR */
  ), n = es(i), a = s.sp;
  if (n || a) {
    let o = n ? i : Promise.resolve();
    return a && (o = o.then(
      () => Promise.all(
        a.map((u) => u.call(s.proxy))
      )
    ).catch(Ge)), o.then(() => _b(s, t));
  } else
    return _b(s, t);
}
function _b(r, e) {
  const t = r.type, { getBuffer: s, push: i } = Fw();
  if (fe(t)) {
    let n = Sb(r);
    if (!t.props)
      for (const a in r.attrs)
        a.startsWith("data-v-") && ((n.props || (n.props = {}))[a] = "");
    Po(i, r.subTree = n, r, e);
  } else {
    (!r.render || r.render === Ge) && !r.ssrRender && !t.ssrRender && _e(t.template) && (t.ssrRender = T7(t.template));
    for (const a of r.scope.effects)
      a.computed && (a.computed._dirty = !0, a.computed._cacheable = !0);
    const n = r.ssrRender || t.ssrRender;
    if (n) {
      let a = r.inheritAttrs !== !1 ? r.attrs : void 0, o = !1, u = r;
      for (; ; ) {
        const c = u.vnode.scopeId;
        c && (o || (a = { ...a }, o = !0), a[c] = "");
        const f = u.parent;
        if (f && f.subTree && f.subTree === u.vnode)
          u = f;
        else
          break;
      }
      if (e) {
        o || (a = { ...a });
        const c = e.trim().split(" ");
        for (let f = 0; f < c.length; f++)
          a[c[f]] = "";
      }
      const l = Eb(r);
      try {
        n(
          r.proxy,
          i,
          r,
          a,
          // compiler-optimized bindings
          r.props,
          r.setupState,
          r.data,
          r.ctx
        );
      } finally {
        Eb(l);
      }
    } else if (r.render && r.render !== Ge)
      Po(
        i,
        r.subTree = Sb(r),
        r,
        e
      );
    else {
      const a = t.name || t.__file || "<Anonymous>";
      ot(`Component ${a} is missing template or render function.`), i("<!---->");
    }
  }
  return s();
}
function Po(r, e, t, s) {
  const { type: i, shapeFlag: n, children: a } = e;
  switch (i) {
    case Xr:
      r(Wr(a));
      break;
    case Je:
      r(
        a ? `<!--${ET(a)}-->` : "<!---->"
      );
      break;
    case Es:
      r(a);
      break;
    case ct:
      e.slotScopeIds && (s = (s ? s + " " : "") + e.slotScopeIds.join(" ")), r("<!--[-->"), gf(
        r,
        a,
        t,
        s
      ), r("<!--]-->");
      break;
    default:
      n & 1 ? N7(r, e, t, s) : n & 6 ? r(mf(e, t, s)) : n & 64 ? I7(r, e, t, s) : n & 128 ? Po(r, e.ssContent, t, s) : ot(
        "[@vue/server-renderer] Invalid VNode type:",
        i,
        `(${typeof i})`
      );
  }
}
function gf(r, e, t, s) {
  for (let i = 0; i < e.length; i++)
    Po(r, C7(e[i]), t, s);
}
function N7(r, e, t, s) {
  const i = e.type;
  let { props: n, children: a, shapeFlag: o, scopeId: u, dirs: l } = e, c = `<${i}`;
  l && (n = O7(e, n, l)), n && (c += xw(n, i)), u && (c += ` ${u}`);
  let f = t, p = e;
  for (; f && p === f.subTree; )
    p = f.vnode, p.scopeId && (c += ` ${p.scopeId}`), f = f.parent;
  if (s && (c += ` ${s}`), r(c + ">"), !fT(i)) {
    let h = !1;
    n && (n.innerHTML ? (h = !0, r(n.innerHTML)) : n.textContent ? (h = !0, r(Wr(n.textContent))) : i === "textarea" && n.value && (h = !0, r(Wr(n.value)))), h || (o & 8 ? r(Wr(a)) : o & 16 && gf(
      r,
      a,
      t,
      s
    )), r(`</${i}>`);
  }
}
function O7(r, e, t) {
  const s = [];
  for (let i = 0; i < t.length; i++) {
    const n = t[i], {
      dir: { getSSRProps: a }
    } = n;
    if (a) {
      const o = a(n, r);
      o && s.push(o);
    }
  }
  return Rd(e || {}, ...s);
}
function I7(r, e, t, s) {
  const i = e.props && e.props.to, n = e.props && e.props.disabled;
  if (!i)
    return n || ot("[@vue/server-renderer] Teleport is missing target prop."), [];
  if (!_e(i))
    return ot(
      "[@vue/server-renderer] Teleport target must be a query selector string."
    ), [];
  Nw(
    r,
    (a) => {
      gf(
        a,
        e.children,
        t,
        s
      );
    },
    i,
    n || n === "",
    t
  );
}
const { isVNode: k7 } = Kn;
function Ju(r, e, t) {
  if (!r.hasAsync)
    return e + Vw(r);
  let s = e;
  for (let i = t; i < r.length; i += 1) {
    const n = r[i];
    if (_e(n)) {
      s += n;
      continue;
    }
    if (es(n))
      return n.then((o) => (r[i] = o, Ju(r, s, i)));
    const a = Ju(n, s, 0);
    if (es(a))
      return a.then((o) => (r[i] = o, Ju(r, "", i)));
    s = a;
  }
  return s;
}
function Bw(r) {
  return Ju(r, "", 0);
}
function Vw(r) {
  let e = "";
  for (let t = 0; t < r.length; t++) {
    let s = r[t];
    _e(s) ? e += s : e += Vw(s);
  }
  return e;
}
async function Uw(r, e = {}) {
  if (k7(r))
    return Uw(jd({ render: () => r }), e);
  const t = He(r._component, r._props);
  t.appContext = r._context, r.provide(ko, e);
  const s = await mf(t), i = await Bw(s);
  if (await jw(e), e.__watcherHandles)
    for (const n of e.__watcherHandles)
      n();
  return i;
}
async function jw(r) {
  if (r.__teleportBuffers) {
    r.teleports = r.teleports || {};
    for (const e in r.__teleportBuffers)
      r.teleports[e] = await Bw(
        await Promise.all([r.__teleportBuffers[e]])
      );
  }
}
const { isVNode: D7 } = Kn;
async function qw(r, e) {
  if (r.hasAsync)
    for (let t = 0; t < r.length; t++) {
      let s = r[t];
      es(s) && (s = await s), _e(s) ? e.push(s) : await qw(s, e);
    }
  else
    Hw(r, e);
}
function Hw(r, e) {
  for (let t = 0; t < r.length; t++) {
    let s = r[t];
    _e(s) ? e.push(s) : Hw(s, e);
  }
}
function Xo(r, e, t) {
  if (D7(r))
    return Xo(
      jd({ render: () => r }),
      e,
      t
    );
  const s = He(r._component, r._props);
  return s.appContext = r._context, r.provide(ko, e), Promise.resolve(mf(s)).then((i) => qw(i, t)).then(() => jw(e)).then(() => {
    if (e.__watcherHandles)
      for (const i of e.__watcherHandles)
        i();
  }).then(() => t.push(null)).catch((i) => {
    t.destroy(i);
  }), t;
}
function L7(r, e = {}) {
  return console.warn(
    "[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead."
  ), Ww(r, e);
}
function Ww(r, e = {}) {
  throw new Error(
    "ESM build of renderToStream() does not support renderToNodeStream(). Use pipeToNodeWritable() with an existing Node.js Writable stream instance instead."
  );
}
function M7(r, e = {}, t) {
  Xo(r, e, {
    push(s) {
      s != null ? t.write(s) : t.end();
    },
    destroy(s) {
      t.destroy(s);
    }
  });
}
function R7(r, e = {}) {
  if (typeof ReadableStream != "function")
    throw new Error(
      "ReadableStream constructor is not available in the global scope. If the target environment does support web streams, consider using pipeToWebWritable() with an existing WritableStream instance instead."
    );
  const t = new TextEncoder();
  let s = !1;
  return new ReadableStream({
    start(i) {
      Xo(r, e, {
        push(n) {
          s || (n != null ? i.enqueue(t.encode(n)) : i.close());
        },
        destroy(n) {
          i.error(n);
        }
      });
    },
    cancel() {
      s = !0;
    }
  });
}
function $7(r, e = {}, t) {
  const s = t.getWriter(), i = new TextEncoder();
  let n = !1;
  try {
    n = es(s.ready);
  } catch {
  }
  Xo(r, e, {
    async push(a) {
      return n && await s.ready, a != null ? s.write(i.encode(a)) : s.close();
    },
    destroy(a) {
      console.log(a), s.close();
    }
  });
}
kE();
const f$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  pipeToNodeWritable: M7,
  pipeToWebWritable: $7,
  renderToNodeStream: Ww,
  renderToSimpleStream: Xo,
  renderToStream: L7,
  renderToString: Uw,
  renderToWebStream: R7,
  ssrGetDirectiveProps: S7,
  ssrGetDynamicModelProps: w7,
  ssrIncludeBooleanAttr: Ao,
  ssrInterpolate: s7,
  ssrLooseContain: ng,
  ssrLooseEqual: _7,
  ssrRenderAttr: Tw,
  ssrRenderAttrs: xw,
  ssrRenderClass: Pw,
  ssrRenderComponent: Y9,
  ssrRenderDynamicAttr: ww,
  ssrRenderDynamicModel: x7,
  ssrRenderList: v7,
  ssrRenderSlot: Z9,
  ssrRenderSlotInner: Cw,
  ssrRenderStyle: Aw,
  ssrRenderSuspense: E7,
  ssrRenderTeleport: Nw,
  ssrRenderVNode: Po
}, Symbol.toStringTag, { value: "Module" }));
export {
  iC as A,
  Zi as B,
  nd as C,
  YT as D,
  $n as E,
  ct as F,
  mr as G,
  Uo as H,
  qo as I,
  jo as J,
  K9 as K,
  VP as L,
  la as M,
  pl as N,
  aC as O,
  q3 as P,
  AP as Q,
  CP as R,
  f$ as S,
  Fd as T,
  oC as U,
  F7 as V,
  Uw as W,
  rc as a,
  tA as b,
  aE as c,
  xd as d,
  He as e,
  Io as f,
  Fa as g,
  fc as h,
  Ra as i,
  U3 as j,
  OP as k,
  Bd as l,
  Dd as m,
  en as n,
  dc as o,
  Ev as p,
  kd as q,
  Ii as r,
  KT as s,
  sP as t,
  hd as u,
  Np as v,
  Ed as w,
  nA as x,
  c$ as y,
  jP as z
};
