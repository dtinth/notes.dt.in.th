const Ut = {
  AElig: "Ã†",
  AMP: "&",
  Aacute: "Ã",
  Abreve: "Ä‚",
  Acirc: "Ã‚",
  Acy: "Ğ",
  Afr: "ğ”„",
  Agrave: "Ã€",
  Alpha: "Î‘",
  Amacr: "Ä€",
  And: "â©“",
  Aogon: "Ä„",
  Aopf: "ğ”¸",
  ApplyFunction: "â¡",
  Aring: "Ã…",
  Ascr: "ğ’œ",
  Assign: "â‰”",
  Atilde: "Ãƒ",
  Auml: "Ã„",
  Backslash: "âˆ–",
  Barv: "â«§",
  Barwed: "âŒ†",
  Bcy: "Ğ‘",
  Because: "âˆµ",
  Bernoullis: "â„¬",
  Beta: "Î’",
  Bfr: "ğ”…",
  Bopf: "ğ”¹",
  Breve: "Ë˜",
  Bscr: "â„¬",
  Bumpeq: "â‰",
  CHcy: "Ğ§",
  COPY: "Â©",
  Cacute: "Ä†",
  Cap: "â‹’",
  CapitalDifferentialD: "â……",
  Cayleys: "â„­",
  Ccaron: "ÄŒ",
  Ccedil: "Ã‡",
  Ccirc: "Äˆ",
  Cconint: "âˆ°",
  Cdot: "ÄŠ",
  Cedilla: "Â¸",
  CenterDot: "Â·",
  Cfr: "â„­",
  Chi: "Î§",
  CircleDot: "âŠ™",
  CircleMinus: "âŠ–",
  CirclePlus: "âŠ•",
  CircleTimes: "âŠ—",
  ClockwiseContourIntegral: "âˆ²",
  CloseCurlyDoubleQuote: "â€",
  CloseCurlyQuote: "â€™",
  Colon: "âˆ·",
  Colone: "â©´",
  Congruent: "â‰¡",
  Conint: "âˆ¯",
  ContourIntegral: "âˆ®",
  Copf: "â„‚",
  Coproduct: "âˆ",
  CounterClockwiseContourIntegral: "âˆ³",
  Cross: "â¨¯",
  Cscr: "ğ’",
  Cup: "â‹“",
  CupCap: "â‰",
  DD: "â……",
  DDotrahd: "â¤‘",
  DJcy: "Ğ‚",
  DScy: "Ğ…",
  DZcy: "Ğ",
  Dagger: "â€¡",
  Darr: "â†¡",
  Dashv: "â«¤",
  Dcaron: "Ä",
  Dcy: "Ğ”",
  Del: "âˆ‡",
  Delta: "Î”",
  Dfr: "ğ”‡",
  DiacriticalAcute: "Â´",
  DiacriticalDot: "Ë™",
  DiacriticalDoubleAcute: "Ë",
  DiacriticalGrave: "`",
  DiacriticalTilde: "Ëœ",
  Diamond: "â‹„",
  DifferentialD: "â…†",
  Dopf: "ğ”»",
  Dot: "Â¨",
  DotDot: "âƒœ",
  DotEqual: "â‰",
  DoubleContourIntegral: "âˆ¯",
  DoubleDot: "Â¨",
  DoubleDownArrow: "â‡“",
  DoubleLeftArrow: "â‡",
  DoubleLeftRightArrow: "â‡”",
  DoubleLeftTee: "â«¤",
  DoubleLongLeftArrow: "âŸ¸",
  DoubleLongLeftRightArrow: "âŸº",
  DoubleLongRightArrow: "âŸ¹",
  DoubleRightArrow: "â‡’",
  DoubleRightTee: "âŠ¨",
  DoubleUpArrow: "â‡‘",
  DoubleUpDownArrow: "â‡•",
  DoubleVerticalBar: "âˆ¥",
  DownArrow: "â†“",
  DownArrowBar: "â¤“",
  DownArrowUpArrow: "â‡µ",
  DownBreve: "Ì‘",
  DownLeftRightVector: "â¥",
  DownLeftTeeVector: "â¥",
  DownLeftVector: "â†½",
  DownLeftVectorBar: "â¥–",
  DownRightTeeVector: "â¥Ÿ",
  DownRightVector: "â‡",
  DownRightVectorBar: "â¥—",
  DownTee: "âŠ¤",
  DownTeeArrow: "â†§",
  Downarrow: "â‡“",
  Dscr: "ğ’Ÿ",
  Dstrok: "Ä",
  ENG: "ÅŠ",
  ETH: "Ã",
  Eacute: "Ã‰",
  Ecaron: "Äš",
  Ecirc: "ÃŠ",
  Ecy: "Ğ­",
  Edot: "Ä–",
  Efr: "ğ”ˆ",
  Egrave: "Ãˆ",
  Element: "âˆˆ",
  Emacr: "Ä’",
  EmptySmallSquare: "â—»",
  EmptyVerySmallSquare: "â–«",
  Eogon: "Ä˜",
  Eopf: "ğ”¼",
  Epsilon: "Î•",
  Equal: "â©µ",
  EqualTilde: "â‰‚",
  Equilibrium: "â‡Œ",
  Escr: "â„°",
  Esim: "â©³",
  Eta: "Î—",
  Euml: "Ã‹",
  Exists: "âˆƒ",
  ExponentialE: "â…‡",
  Fcy: "Ğ¤",
  Ffr: "ğ”‰",
  FilledSmallSquare: "â—¼",
  FilledVerySmallSquare: "â–ª",
  Fopf: "ğ”½",
  ForAll: "âˆ€",
  Fouriertrf: "â„±",
  Fscr: "â„±",
  GJcy: "Ğƒ",
  GT: ">",
  Gamma: "Î“",
  Gammad: "Ïœ",
  Gbreve: "Ä",
  Gcedil: "Ä¢",
  Gcirc: "Äœ",
  Gcy: "Ğ“",
  Gdot: "Ä ",
  Gfr: "ğ”Š",
  Gg: "â‹™",
  Gopf: "ğ”¾",
  GreaterEqual: "â‰¥",
  GreaterEqualLess: "â‹›",
  GreaterFullEqual: "â‰§",
  GreaterGreater: "âª¢",
  GreaterLess: "â‰·",
  GreaterSlantEqual: "â©¾",
  GreaterTilde: "â‰³",
  Gscr: "ğ’¢",
  Gt: "â‰«",
  HARDcy: "Ğª",
  Hacek: "Ë‡",
  Hat: "^",
  Hcirc: "Ä¤",
  Hfr: "â„Œ",
  HilbertSpace: "â„‹",
  Hopf: "â„",
  HorizontalLine: "â”€",
  Hscr: "â„‹",
  Hstrok: "Ä¦",
  HumpDownHump: "â‰",
  HumpEqual: "â‰",
  IEcy: "Ğ•",
  IJlig: "Ä²",
  IOcy: "Ğ",
  Iacute: "Ã",
  Icirc: "Ã",
  Icy: "Ğ˜",
  Idot: "Ä°",
  Ifr: "â„‘",
  Igrave: "ÃŒ",
  Im: "â„‘",
  Imacr: "Äª",
  ImaginaryI: "â…ˆ",
  Implies: "â‡’",
  Int: "âˆ¬",
  Integral: "âˆ«",
  Intersection: "â‹‚",
  InvisibleComma: "â£",
  InvisibleTimes: "â¢",
  Iogon: "Ä®",
  Iopf: "ğ•€",
  Iota: "Î™",
  Iscr: "â„",
  Itilde: "Ä¨",
  Iukcy: "Ğ†",
  Iuml: "Ã",
  Jcirc: "Ä´",
  Jcy: "Ğ™",
  Jfr: "ğ”",
  Jopf: "ğ•",
  Jscr: "ğ’¥",
  Jsercy: "Ğˆ",
  Jukcy: "Ğ„",
  KHcy: "Ğ¥",
  KJcy: "ĞŒ",
  Kappa: "Îš",
  Kcedil: "Ä¶",
  Kcy: "Ğš",
  Kfr: "ğ”",
  Kopf: "ğ•‚",
  Kscr: "ğ’¦",
  LJcy: "Ğ‰",
  LT: "<",
  Lacute: "Ä¹",
  Lambda: "Î›",
  Lang: "âŸª",
  Laplacetrf: "â„’",
  Larr: "â†",
  Lcaron: "Ä½",
  Lcedil: "Ä»",
  Lcy: "Ğ›",
  LeftAngleBracket: "âŸ¨",
  LeftArrow: "â†",
  LeftArrowBar: "â‡¤",
  LeftArrowRightArrow: "â‡†",
  LeftCeiling: "âŒˆ",
  LeftDoubleBracket: "âŸ¦",
  LeftDownTeeVector: "â¥¡",
  LeftDownVector: "â‡ƒ",
  LeftDownVectorBar: "â¥™",
  LeftFloor: "âŒŠ",
  LeftRightArrow: "â†”",
  LeftRightVector: "â¥",
  LeftTee: "âŠ£",
  LeftTeeArrow: "â†¤",
  LeftTeeVector: "â¥š",
  LeftTriangle: "âŠ²",
  LeftTriangleBar: "â§",
  LeftTriangleEqual: "âŠ´",
  LeftUpDownVector: "â¥‘",
  LeftUpTeeVector: "â¥ ",
  LeftUpVector: "â†¿",
  LeftUpVectorBar: "â¥˜",
  LeftVector: "â†¼",
  LeftVectorBar: "â¥’",
  Leftarrow: "â‡",
  Leftrightarrow: "â‡”",
  LessEqualGreater: "â‹š",
  LessFullEqual: "â‰¦",
  LessGreater: "â‰¶",
  LessLess: "âª¡",
  LessSlantEqual: "â©½",
  LessTilde: "â‰²",
  Lfr: "ğ”",
  Ll: "â‹˜",
  Lleftarrow: "â‡š",
  Lmidot: "Ä¿",
  LongLeftArrow: "âŸµ",
  LongLeftRightArrow: "âŸ·",
  LongRightArrow: "âŸ¶",
  Longleftarrow: "âŸ¸",
  Longleftrightarrow: "âŸº",
  Longrightarrow: "âŸ¹",
  Lopf: "ğ•ƒ",
  LowerLeftArrow: "â†™",
  LowerRightArrow: "â†˜",
  Lscr: "â„’",
  Lsh: "â†°",
  Lstrok: "Å",
  Lt: "â‰ª",
  Map: "â¤…",
  Mcy: "Ğœ",
  MediumSpace: "âŸ",
  Mellintrf: "â„³",
  Mfr: "ğ”",
  MinusPlus: "âˆ“",
  Mopf: "ğ•„",
  Mscr: "â„³",
  Mu: "Îœ",
  NJcy: "ĞŠ",
  Nacute: "Åƒ",
  Ncaron: "Å‡",
  Ncedil: "Å…",
  Ncy: "Ğ",
  NegativeMediumSpace: "â€‹",
  NegativeThickSpace: "â€‹",
  NegativeThinSpace: "â€‹",
  NegativeVeryThinSpace: "â€‹",
  NestedGreaterGreater: "â‰«",
  NestedLessLess: "â‰ª",
  NewLine: `
`,
  Nfr: "ğ”‘",
  NoBreak: "â ",
  NonBreakingSpace: "Â ",
  Nopf: "â„•",
  Not: "â«¬",
  NotCongruent: "â‰¢",
  NotCupCap: "â‰­",
  NotDoubleVerticalBar: "âˆ¦",
  NotElement: "âˆ‰",
  NotEqual: "â‰ ",
  NotEqualTilde: "â‰‚Ì¸",
  NotExists: "âˆ„",
  NotGreater: "â‰¯",
  NotGreaterEqual: "â‰±",
  NotGreaterFullEqual: "â‰§Ì¸",
  NotGreaterGreater: "â‰«Ì¸",
  NotGreaterLess: "â‰¹",
  NotGreaterSlantEqual: "â©¾Ì¸",
  NotGreaterTilde: "â‰µ",
  NotHumpDownHump: "â‰Ì¸",
  NotHumpEqual: "â‰Ì¸",
  NotLeftTriangle: "â‹ª",
  NotLeftTriangleBar: "â§Ì¸",
  NotLeftTriangleEqual: "â‹¬",
  NotLess: "â‰®",
  NotLessEqual: "â‰°",
  NotLessGreater: "â‰¸",
  NotLessLess: "â‰ªÌ¸",
  NotLessSlantEqual: "â©½Ì¸",
  NotLessTilde: "â‰´",
  NotNestedGreaterGreater: "âª¢Ì¸",
  NotNestedLessLess: "âª¡Ì¸",
  NotPrecedes: "âŠ€",
  NotPrecedesEqual: "âª¯Ì¸",
  NotPrecedesSlantEqual: "â‹ ",
  NotReverseElement: "âˆŒ",
  NotRightTriangle: "â‹«",
  NotRightTriangleBar: "â§Ì¸",
  NotRightTriangleEqual: "â‹­",
  NotSquareSubset: "âŠÌ¸",
  NotSquareSubsetEqual: "â‹¢",
  NotSquareSuperset: "âŠÌ¸",
  NotSquareSupersetEqual: "â‹£",
  NotSubset: "âŠ‚âƒ’",
  NotSubsetEqual: "âŠˆ",
  NotSucceeds: "âŠ",
  NotSucceedsEqual: "âª°Ì¸",
  NotSucceedsSlantEqual: "â‹¡",
  NotSucceedsTilde: "â‰¿Ì¸",
  NotSuperset: "âŠƒâƒ’",
  NotSupersetEqual: "âŠ‰",
  NotTilde: "â‰",
  NotTildeEqual: "â‰„",
  NotTildeFullEqual: "â‰‡",
  NotTildeTilde: "â‰‰",
  NotVerticalBar: "âˆ¤",
  Nscr: "ğ’©",
  Ntilde: "Ã‘",
  Nu: "Î",
  OElig: "Å’",
  Oacute: "Ã“",
  Ocirc: "Ã”",
  Ocy: "Ğ",
  Odblac: "Å",
  Ofr: "ğ”’",
  Ograve: "Ã’",
  Omacr: "ÅŒ",
  Omega: "Î©",
  Omicron: "ÎŸ",
  Oopf: "ğ•†",
  OpenCurlyDoubleQuote: "â€œ",
  OpenCurlyQuote: "â€˜",
  Or: "â©”",
  Oscr: "ğ’ª",
  Oslash: "Ã˜",
  Otilde: "Ã•",
  Otimes: "â¨·",
  Ouml: "Ã–",
  OverBar: "â€¾",
  OverBrace: "â",
  OverBracket: "â´",
  OverParenthesis: "âœ",
  PartialD: "âˆ‚",
  Pcy: "ĞŸ",
  Pfr: "ğ”“",
  Phi: "Î¦",
  Pi: "Î ",
  PlusMinus: "Â±",
  Poincareplane: "â„Œ",
  Popf: "â„™",
  Pr: "âª»",
  Precedes: "â‰º",
  PrecedesEqual: "âª¯",
  PrecedesSlantEqual: "â‰¼",
  PrecedesTilde: "â‰¾",
  Prime: "â€³",
  Product: "âˆ",
  Proportion: "âˆ·",
  Proportional: "âˆ",
  Pscr: "ğ’«",
  Psi: "Î¨",
  QUOT: '"',
  Qfr: "ğ””",
  Qopf: "â„š",
  Qscr: "ğ’¬",
  RBarr: "â¤",
  REG: "Â®",
  Racute: "Å”",
  Rang: "âŸ«",
  Rarr: "â† ",
  Rarrtl: "â¤–",
  Rcaron: "Å˜",
  Rcedil: "Å–",
  Rcy: "Ğ ",
  Re: "â„œ",
  ReverseElement: "âˆ‹",
  ReverseEquilibrium: "â‡‹",
  ReverseUpEquilibrium: "â¥¯",
  Rfr: "â„œ",
  Rho: "Î¡",
  RightAngleBracket: "âŸ©",
  RightArrow: "â†’",
  RightArrowBar: "â‡¥",
  RightArrowLeftArrow: "â‡„",
  RightCeiling: "âŒ‰",
  RightDoubleBracket: "âŸ§",
  RightDownTeeVector: "â¥",
  RightDownVector: "â‡‚",
  RightDownVectorBar: "â¥•",
  RightFloor: "âŒ‹",
  RightTee: "âŠ¢",
  RightTeeArrow: "â†¦",
  RightTeeVector: "â¥›",
  RightTriangle: "âŠ³",
  RightTriangleBar: "â§",
  RightTriangleEqual: "âŠµ",
  RightUpDownVector: "â¥",
  RightUpTeeVector: "â¥œ",
  RightUpVector: "â†¾",
  RightUpVectorBar: "â¥”",
  RightVector: "â‡€",
  RightVectorBar: "â¥“",
  Rightarrow: "â‡’",
  Ropf: "â„",
  RoundImplies: "â¥°",
  Rrightarrow: "â‡›",
  Rscr: "â„›",
  Rsh: "â†±",
  RuleDelayed: "â§´",
  SHCHcy: "Ğ©",
  SHcy: "Ğ¨",
  SOFTcy: "Ğ¬",
  Sacute: "Åš",
  Sc: "âª¼",
  Scaron: "Å ",
  Scedil: "Å",
  Scirc: "Åœ",
  Scy: "Ğ¡",
  Sfr: "ğ”–",
  ShortDownArrow: "â†“",
  ShortLeftArrow: "â†",
  ShortRightArrow: "â†’",
  ShortUpArrow: "â†‘",
  Sigma: "Î£",
  SmallCircle: "âˆ˜",
  Sopf: "ğ•Š",
  Sqrt: "âˆš",
  Square: "â–¡",
  SquareIntersection: "âŠ“",
  SquareSubset: "âŠ",
  SquareSubsetEqual: "âŠ‘",
  SquareSuperset: "âŠ",
  SquareSupersetEqual: "âŠ’",
  SquareUnion: "âŠ”",
  Sscr: "ğ’®",
  Star: "â‹†",
  Sub: "â‹",
  Subset: "â‹",
  SubsetEqual: "âŠ†",
  Succeeds: "â‰»",
  SucceedsEqual: "âª°",
  SucceedsSlantEqual: "â‰½",
  SucceedsTilde: "â‰¿",
  SuchThat: "âˆ‹",
  Sum: "âˆ‘",
  Sup: "â‹‘",
  Superset: "âŠƒ",
  SupersetEqual: "âŠ‡",
  Supset: "â‹‘",
  THORN: "Ã",
  TRADE: "â„¢",
  TSHcy: "Ğ‹",
  TScy: "Ğ¦",
  Tab: "	",
  Tau: "Î¤",
  Tcaron: "Å¤",
  Tcedil: "Å¢",
  Tcy: "Ğ¢",
  Tfr: "ğ”—",
  Therefore: "âˆ´",
  Theta: "Î˜",
  ThickSpace: "âŸâ€Š",
  ThinSpace: "â€‰",
  Tilde: "âˆ¼",
  TildeEqual: "â‰ƒ",
  TildeFullEqual: "â‰…",
  TildeTilde: "â‰ˆ",
  Topf: "ğ•‹",
  TripleDot: "âƒ›",
  Tscr: "ğ’¯",
  Tstrok: "Å¦",
  Uacute: "Ãš",
  Uarr: "â†Ÿ",
  Uarrocir: "â¥‰",
  Ubrcy: "Ğ",
  Ubreve: "Å¬",
  Ucirc: "Ã›",
  Ucy: "Ğ£",
  Udblac: "Å°",
  Ufr: "ğ”˜",
  Ugrave: "Ã™",
  Umacr: "Åª",
  UnderBar: "_",
  UnderBrace: "âŸ",
  UnderBracket: "âµ",
  UnderParenthesis: "â",
  Union: "â‹ƒ",
  UnionPlus: "âŠ",
  Uogon: "Å²",
  Uopf: "ğ•Œ",
  UpArrow: "â†‘",
  UpArrowBar: "â¤’",
  UpArrowDownArrow: "â‡…",
  UpDownArrow: "â†•",
  UpEquilibrium: "â¥®",
  UpTee: "âŠ¥",
  UpTeeArrow: "â†¥",
  Uparrow: "â‡‘",
  Updownarrow: "â‡•",
  UpperLeftArrow: "â†–",
  UpperRightArrow: "â†—",
  Upsi: "Ï’",
  Upsilon: "Î¥",
  Uring: "Å®",
  Uscr: "ğ’°",
  Utilde: "Å¨",
  Uuml: "Ãœ",
  VDash: "âŠ«",
  Vbar: "â««",
  Vcy: "Ğ’",
  Vdash: "âŠ©",
  Vdashl: "â«¦",
  Vee: "â‹",
  Verbar: "â€–",
  Vert: "â€–",
  VerticalBar: "âˆ£",
  VerticalLine: "|",
  VerticalSeparator: "â˜",
  VerticalTilde: "â‰€",
  VeryThinSpace: "â€Š",
  Vfr: "ğ”™",
  Vopf: "ğ•",
  Vscr: "ğ’±",
  Vvdash: "âŠª",
  Wcirc: "Å´",
  Wedge: "â‹€",
  Wfr: "ğ”š",
  Wopf: "ğ•",
  Wscr: "ğ’²",
  Xfr: "ğ”›",
  Xi: "Î",
  Xopf: "ğ•",
  Xscr: "ğ’³",
  YAcy: "Ğ¯",
  YIcy: "Ğ‡",
  YUcy: "Ğ®",
  Yacute: "Ã",
  Ycirc: "Å¶",
  Ycy: "Ğ«",
  Yfr: "ğ”œ",
  Yopf: "ğ•",
  Yscr: "ğ’´",
  Yuml: "Å¸",
  ZHcy: "Ğ–",
  Zacute: "Å¹",
  Zcaron: "Å½",
  Zcy: "Ğ—",
  Zdot: "Å»",
  ZeroWidthSpace: "â€‹",
  Zeta: "Î–",
  Zfr: "â„¨",
  Zopf: "â„¤",
  Zscr: "ğ’µ",
  aacute: "Ã¡",
  abreve: "Äƒ",
  ac: "âˆ¾",
  acE: "âˆ¾Ì³",
  acd: "âˆ¿",
  acirc: "Ã¢",
  acute: "Â´",
  acy: "Ğ°",
  aelig: "Ã¦",
  af: "â¡",
  afr: "ğ”",
  agrave: "Ã ",
  alefsym: "â„µ",
  aleph: "â„µ",
  alpha: "Î±",
  amacr: "Ä",
  amalg: "â¨¿",
  amp: "&",
  and: "âˆ§",
  andand: "â©•",
  andd: "â©œ",
  andslope: "â©˜",
  andv: "â©š",
  ang: "âˆ ",
  ange: "â¦¤",
  angle: "âˆ ",
  angmsd: "âˆ¡",
  angmsdaa: "â¦¨",
  angmsdab: "â¦©",
  angmsdac: "â¦ª",
  angmsdad: "â¦«",
  angmsdae: "â¦¬",
  angmsdaf: "â¦­",
  angmsdag: "â¦®",
  angmsdah: "â¦¯",
  angrt: "âˆŸ",
  angrtvb: "âŠ¾",
  angrtvbd: "â¦",
  angsph: "âˆ¢",
  angst: "Ã…",
  angzarr: "â¼",
  aogon: "Ä…",
  aopf: "ğ•’",
  ap: "â‰ˆ",
  apE: "â©°",
  apacir: "â©¯",
  ape: "â‰Š",
  apid: "â‰‹",
  apos: "'",
  approx: "â‰ˆ",
  approxeq: "â‰Š",
  aring: "Ã¥",
  ascr: "ğ’¶",
  ast: "*",
  asymp: "â‰ˆ",
  asympeq: "â‰",
  atilde: "Ã£",
  auml: "Ã¤",
  awconint: "âˆ³",
  awint: "â¨‘",
  bNot: "â«­",
  backcong: "â‰Œ",
  backepsilon: "Ï¶",
  backprime: "â€µ",
  backsim: "âˆ½",
  backsimeq: "â‹",
  barvee: "âŠ½",
  barwed: "âŒ…",
  barwedge: "âŒ…",
  bbrk: "âµ",
  bbrktbrk: "â¶",
  bcong: "â‰Œ",
  bcy: "Ğ±",
  bdquo: "â€",
  becaus: "âˆµ",
  because: "âˆµ",
  bemptyv: "â¦°",
  bepsi: "Ï¶",
  bernou: "â„¬",
  beta: "Î²",
  beth: "â„¶",
  between: "â‰¬",
  bfr: "ğ”Ÿ",
  bigcap: "â‹‚",
  bigcirc: "â—¯",
  bigcup: "â‹ƒ",
  bigodot: "â¨€",
  bigoplus: "â¨",
  bigotimes: "â¨‚",
  bigsqcup: "â¨†",
  bigstar: "â˜…",
  bigtriangledown: "â–½",
  bigtriangleup: "â–³",
  biguplus: "â¨„",
  bigvee: "â‹",
  bigwedge: "â‹€",
  bkarow: "â¤",
  blacklozenge: "â§«",
  blacksquare: "â–ª",
  blacktriangle: "â–´",
  blacktriangledown: "â–¾",
  blacktriangleleft: "â—‚",
  blacktriangleright: "â–¸",
  blank: "â£",
  blk12: "â–’",
  blk14: "â–‘",
  blk34: "â–“",
  block: "â–ˆ",
  bne: "=âƒ¥",
  bnequiv: "â‰¡âƒ¥",
  bnot: "âŒ",
  bopf: "ğ•“",
  bot: "âŠ¥",
  bottom: "âŠ¥",
  bowtie: "â‹ˆ",
  boxDL: "â•—",
  boxDR: "â•”",
  boxDl: "â•–",
  boxDr: "â•“",
  boxH: "â•",
  boxHD: "â•¦",
  boxHU: "â•©",
  boxHd: "â•¤",
  boxHu: "â•§",
  boxUL: "â•",
  boxUR: "â•š",
  boxUl: "â•œ",
  boxUr: "â•™",
  boxV: "â•‘",
  boxVH: "â•¬",
  boxVL: "â•£",
  boxVR: "â• ",
  boxVh: "â•«",
  boxVl: "â•¢",
  boxVr: "â•Ÿ",
  boxbox: "â§‰",
  boxdL: "â••",
  boxdR: "â•’",
  boxdl: "â”",
  boxdr: "â”Œ",
  boxh: "â”€",
  boxhD: "â•¥",
  boxhU: "â•¨",
  boxhd: "â”¬",
  boxhu: "â”´",
  boxminus: "âŠŸ",
  boxplus: "âŠ",
  boxtimes: "âŠ ",
  boxuL: "â•›",
  boxuR: "â•˜",
  boxul: "â”˜",
  boxur: "â””",
  boxv: "â”‚",
  boxvH: "â•ª",
  boxvL: "â•¡",
  boxvR: "â•",
  boxvh: "â”¼",
  boxvl: "â”¤",
  boxvr: "â”œ",
  bprime: "â€µ",
  breve: "Ë˜",
  brvbar: "Â¦",
  bscr: "ğ’·",
  bsemi: "â",
  bsim: "âˆ½",
  bsime: "â‹",
  bsol: "\\",
  bsolb: "â§…",
  bsolhsub: "âŸˆ",
  bull: "â€¢",
  bullet: "â€¢",
  bump: "â‰",
  bumpE: "âª®",
  bumpe: "â‰",
  bumpeq: "â‰",
  cacute: "Ä‡",
  cap: "âˆ©",
  capand: "â©„",
  capbrcup: "â©‰",
  capcap: "â©‹",
  capcup: "â©‡",
  capdot: "â©€",
  caps: "âˆ©ï¸€",
  caret: "â",
  caron: "Ë‡",
  ccaps: "â©",
  ccaron: "Ä",
  ccedil: "Ã§",
  ccirc: "Ä‰",
  ccups: "â©Œ",
  ccupssm: "â©",
  cdot: "Ä‹",
  cedil: "Â¸",
  cemptyv: "â¦²",
  cent: "Â¢",
  centerdot: "Â·",
  cfr: "ğ” ",
  chcy: "Ñ‡",
  check: "âœ“",
  checkmark: "âœ“",
  chi: "Ï‡",
  cir: "â—‹",
  cirE: "â§ƒ",
  circ: "Ë†",
  circeq: "â‰—",
  circlearrowleft: "â†º",
  circlearrowright: "â†»",
  circledR: "Â®",
  circledS: "â“ˆ",
  circledast: "âŠ›",
  circledcirc: "âŠš",
  circleddash: "âŠ",
  cire: "â‰—",
  cirfnint: "â¨",
  cirmid: "â«¯",
  cirscir: "â§‚",
  clubs: "â™£",
  clubsuit: "â™£",
  colon: ":",
  colone: "â‰”",
  coloneq: "â‰”",
  comma: ",",
  commat: "@",
  comp: "âˆ",
  compfn: "âˆ˜",
  complement: "âˆ",
  complexes: "â„‚",
  cong: "â‰…",
  congdot: "â©­",
  conint: "âˆ®",
  copf: "ğ•”",
  coprod: "âˆ",
  copy: "Â©",
  copysr: "â„—",
  crarr: "â†µ",
  cross: "âœ—",
  cscr: "ğ’¸",
  csub: "â«",
  csube: "â«‘",
  csup: "â«",
  csupe: "â«’",
  ctdot: "â‹¯",
  cudarrl: "â¤¸",
  cudarrr: "â¤µ",
  cuepr: "â‹",
  cuesc: "â‹Ÿ",
  cularr: "â†¶",
  cularrp: "â¤½",
  cup: "âˆª",
  cupbrcap: "â©ˆ",
  cupcap: "â©†",
  cupcup: "â©Š",
  cupdot: "âŠ",
  cupor: "â©…",
  cups: "âˆªï¸€",
  curarr: "â†·",
  curarrm: "â¤¼",
  curlyeqprec: "â‹",
  curlyeqsucc: "â‹Ÿ",
  curlyvee: "â‹",
  curlywedge: "â‹",
  curren: "Â¤",
  curvearrowleft: "â†¶",
  curvearrowright: "â†·",
  cuvee: "â‹",
  cuwed: "â‹",
  cwconint: "âˆ²",
  cwint: "âˆ±",
  cylcty: "âŒ­",
  dArr: "â‡“",
  dHar: "â¥¥",
  dagger: "â€ ",
  daleth: "â„¸",
  darr: "â†“",
  dash: "â€",
  dashv: "âŠ£",
  dbkarow: "â¤",
  dblac: "Ë",
  dcaron: "Ä",
  dcy: "Ğ´",
  dd: "â…†",
  ddagger: "â€¡",
  ddarr: "â‡Š",
  ddotseq: "â©·",
  deg: "Â°",
  delta: "Î´",
  demptyv: "â¦±",
  dfisht: "â¥¿",
  dfr: "ğ”¡",
  dharl: "â‡ƒ",
  dharr: "â‡‚",
  diam: "â‹„",
  diamond: "â‹„",
  diamondsuit: "â™¦",
  diams: "â™¦",
  die: "Â¨",
  digamma: "Ï",
  disin: "â‹²",
  div: "Ã·",
  divide: "Ã·",
  divideontimes: "â‹‡",
  divonx: "â‹‡",
  djcy: "Ñ’",
  dlcorn: "âŒ",
  dlcrop: "âŒ",
  dollar: "$",
  dopf: "ğ••",
  dot: "Ë™",
  doteq: "â‰",
  doteqdot: "â‰‘",
  dotminus: "âˆ¸",
  dotplus: "âˆ”",
  dotsquare: "âŠ¡",
  doublebarwedge: "âŒ†",
  downarrow: "â†“",
  downdownarrows: "â‡Š",
  downharpoonleft: "â‡ƒ",
  downharpoonright: "â‡‚",
  drbkarow: "â¤",
  drcorn: "âŒŸ",
  drcrop: "âŒŒ",
  dscr: "ğ’¹",
  dscy: "Ñ•",
  dsol: "â§¶",
  dstrok: "Ä‘",
  dtdot: "â‹±",
  dtri: "â–¿",
  dtrif: "â–¾",
  duarr: "â‡µ",
  duhar: "â¥¯",
  dwangle: "â¦¦",
  dzcy: "ÑŸ",
  dzigrarr: "âŸ¿",
  eDDot: "â©·",
  eDot: "â‰‘",
  eacute: "Ã©",
  easter: "â©®",
  ecaron: "Ä›",
  ecir: "â‰–",
  ecirc: "Ãª",
  ecolon: "â‰•",
  ecy: "Ñ",
  edot: "Ä—",
  ee: "â…‡",
  efDot: "â‰’",
  efr: "ğ”¢",
  eg: "âªš",
  egrave: "Ã¨",
  egs: "âª–",
  egsdot: "âª˜",
  el: "âª™",
  elinters: "â§",
  ell: "â„“",
  els: "âª•",
  elsdot: "âª—",
  emacr: "Ä“",
  empty: "âˆ…",
  emptyset: "âˆ…",
  emptyv: "âˆ…",
  emsp13: "â€„",
  emsp14: "â€…",
  emsp: "â€ƒ",
  eng: "Å‹",
  ensp: "â€‚",
  eogon: "Ä™",
  eopf: "ğ•–",
  epar: "â‹•",
  eparsl: "â§£",
  eplus: "â©±",
  epsi: "Îµ",
  epsilon: "Îµ",
  epsiv: "Ïµ",
  eqcirc: "â‰–",
  eqcolon: "â‰•",
  eqsim: "â‰‚",
  eqslantgtr: "âª–",
  eqslantless: "âª•",
  equals: "=",
  equest: "â‰Ÿ",
  equiv: "â‰¡",
  equivDD: "â©¸",
  eqvparsl: "â§¥",
  erDot: "â‰“",
  erarr: "â¥±",
  escr: "â„¯",
  esdot: "â‰",
  esim: "â‰‚",
  eta: "Î·",
  eth: "Ã°",
  euml: "Ã«",
  euro: "â‚¬",
  excl: "!",
  exist: "âˆƒ",
  expectation: "â„°",
  exponentiale: "â…‡",
  fallingdotseq: "â‰’",
  fcy: "Ñ„",
  female: "â™€",
  ffilig: "ï¬ƒ",
  fflig: "ï¬€",
  ffllig: "ï¬„",
  ffr: "ğ”£",
  filig: "ï¬",
  fjlig: "fj",
  flat: "â™­",
  fllig: "ï¬‚",
  fltns: "â–±",
  fnof: "Æ’",
  fopf: "ğ•—",
  forall: "âˆ€",
  fork: "â‹”",
  forkv: "â«™",
  fpartint: "â¨",
  frac12: "Â½",
  frac13: "â…“",
  frac14: "Â¼",
  frac15: "â…•",
  frac16: "â…™",
  frac18: "â…›",
  frac23: "â…”",
  frac25: "â…–",
  frac34: "Â¾",
  frac35: "â…—",
  frac38: "â…œ",
  frac45: "â…˜",
  frac56: "â…š",
  frac58: "â…",
  frac78: "â…",
  frasl: "â„",
  frown: "âŒ¢",
  fscr: "ğ’»",
  gE: "â‰§",
  gEl: "âªŒ",
  gacute: "Çµ",
  gamma: "Î³",
  gammad: "Ï",
  gap: "âª†",
  gbreve: "ÄŸ",
  gcirc: "Ä",
  gcy: "Ğ³",
  gdot: "Ä¡",
  ge: "â‰¥",
  gel: "â‹›",
  geq: "â‰¥",
  geqq: "â‰§",
  geqslant: "â©¾",
  ges: "â©¾",
  gescc: "âª©",
  gesdot: "âª€",
  gesdoto: "âª‚",
  gesdotol: "âª„",
  gesl: "â‹›ï¸€",
  gesles: "âª”",
  gfr: "ğ”¤",
  gg: "â‰«",
  ggg: "â‹™",
  gimel: "â„·",
  gjcy: "Ñ“",
  gl: "â‰·",
  glE: "âª’",
  gla: "âª¥",
  glj: "âª¤",
  gnE: "â‰©",
  gnap: "âªŠ",
  gnapprox: "âªŠ",
  gne: "âªˆ",
  gneq: "âªˆ",
  gneqq: "â‰©",
  gnsim: "â‹§",
  gopf: "ğ•˜",
  grave: "`",
  gscr: "â„Š",
  gsim: "â‰³",
  gsime: "âª",
  gsiml: "âª",
  gt: ">",
  gtcc: "âª§",
  gtcir: "â©º",
  gtdot: "â‹—",
  gtlPar: "â¦•",
  gtquest: "â©¼",
  gtrapprox: "âª†",
  gtrarr: "â¥¸",
  gtrdot: "â‹—",
  gtreqless: "â‹›",
  gtreqqless: "âªŒ",
  gtrless: "â‰·",
  gtrsim: "â‰³",
  gvertneqq: "â‰©ï¸€",
  gvnE: "â‰©ï¸€",
  hArr: "â‡”",
  hairsp: "â€Š",
  half: "Â½",
  hamilt: "â„‹",
  hardcy: "ÑŠ",
  harr: "â†”",
  harrcir: "â¥ˆ",
  harrw: "â†­",
  hbar: "â„",
  hcirc: "Ä¥",
  hearts: "â™¥",
  heartsuit: "â™¥",
  hellip: "â€¦",
  hercon: "âŠ¹",
  hfr: "ğ”¥",
  hksearow: "â¤¥",
  hkswarow: "â¤¦",
  hoarr: "â‡¿",
  homtht: "âˆ»",
  hookleftarrow: "â†©",
  hookrightarrow: "â†ª",
  hopf: "ğ•™",
  horbar: "â€•",
  hscr: "ğ’½",
  hslash: "â„",
  hstrok: "Ä§",
  hybull: "âƒ",
  hyphen: "â€",
  iacute: "Ã­",
  ic: "â£",
  icirc: "Ã®",
  icy: "Ğ¸",
  iecy: "Ğµ",
  iexcl: "Â¡",
  iff: "â‡”",
  ifr: "ğ”¦",
  igrave: "Ã¬",
  ii: "â…ˆ",
  iiiint: "â¨Œ",
  iiint: "âˆ­",
  iinfin: "â§œ",
  iiota: "â„©",
  ijlig: "Ä³",
  imacr: "Ä«",
  image: "â„‘",
  imagline: "â„",
  imagpart: "â„‘",
  imath: "Ä±",
  imof: "âŠ·",
  imped: "Æµ",
  in: "âˆˆ",
  incare: "â„…",
  infin: "âˆ",
  infintie: "â§",
  inodot: "Ä±",
  int: "âˆ«",
  intcal: "âŠº",
  integers: "â„¤",
  intercal: "âŠº",
  intlarhk: "â¨—",
  intprod: "â¨¼",
  iocy: "Ñ‘",
  iogon: "Ä¯",
  iopf: "ğ•š",
  iota: "Î¹",
  iprod: "â¨¼",
  iquest: "Â¿",
  iscr: "ğ’¾",
  isin: "âˆˆ",
  isinE: "â‹¹",
  isindot: "â‹µ",
  isins: "â‹´",
  isinsv: "â‹³",
  isinv: "âˆˆ",
  it: "â¢",
  itilde: "Ä©",
  iukcy: "Ñ–",
  iuml: "Ã¯",
  jcirc: "Äµ",
  jcy: "Ğ¹",
  jfr: "ğ”§",
  jmath: "È·",
  jopf: "ğ•›",
  jscr: "ğ’¿",
  jsercy: "Ñ˜",
  jukcy: "Ñ”",
  kappa: "Îº",
  kappav: "Ï°",
  kcedil: "Ä·",
  kcy: "Ğº",
  kfr: "ğ”¨",
  kgreen: "Ä¸",
  khcy: "Ñ…",
  kjcy: "Ñœ",
  kopf: "ğ•œ",
  kscr: "ğ“€",
  lAarr: "â‡š",
  lArr: "â‡",
  lAtail: "â¤›",
  lBarr: "â¤",
  lE: "â‰¦",
  lEg: "âª‹",
  lHar: "â¥¢",
  lacute: "Äº",
  laemptyv: "â¦´",
  lagran: "â„’",
  lambda: "Î»",
  lang: "âŸ¨",
  langd: "â¦‘",
  langle: "âŸ¨",
  lap: "âª…",
  laquo: "Â«",
  larr: "â†",
  larrb: "â‡¤",
  larrbfs: "â¤Ÿ",
  larrfs: "â¤",
  larrhk: "â†©",
  larrlp: "â†«",
  larrpl: "â¤¹",
  larrsim: "â¥³",
  larrtl: "â†¢",
  lat: "âª«",
  latail: "â¤™",
  late: "âª­",
  lates: "âª­ï¸€",
  lbarr: "â¤Œ",
  lbbrk: "â²",
  lbrace: "{",
  lbrack: "[",
  lbrke: "â¦‹",
  lbrksld: "â¦",
  lbrkslu: "â¦",
  lcaron: "Ä¾",
  lcedil: "Ä¼",
  lceil: "âŒˆ",
  lcub: "{",
  lcy: "Ğ»",
  ldca: "â¤¶",
  ldquo: "â€œ",
  ldquor: "â€",
  ldrdhar: "â¥§",
  ldrushar: "â¥‹",
  ldsh: "â†²",
  le: "â‰¤",
  leftarrow: "â†",
  leftarrowtail: "â†¢",
  leftharpoondown: "â†½",
  leftharpoonup: "â†¼",
  leftleftarrows: "â‡‡",
  leftrightarrow: "â†”",
  leftrightarrows: "â‡†",
  leftrightharpoons: "â‡‹",
  leftrightsquigarrow: "â†­",
  leftthreetimes: "â‹‹",
  leg: "â‹š",
  leq: "â‰¤",
  leqq: "â‰¦",
  leqslant: "â©½",
  les: "â©½",
  lescc: "âª¨",
  lesdot: "â©¿",
  lesdoto: "âª",
  lesdotor: "âªƒ",
  lesg: "â‹šï¸€",
  lesges: "âª“",
  lessapprox: "âª…",
  lessdot: "â‹–",
  lesseqgtr: "â‹š",
  lesseqqgtr: "âª‹",
  lessgtr: "â‰¶",
  lesssim: "â‰²",
  lfisht: "â¥¼",
  lfloor: "âŒŠ",
  lfr: "ğ”©",
  lg: "â‰¶",
  lgE: "âª‘",
  lhard: "â†½",
  lharu: "â†¼",
  lharul: "â¥ª",
  lhblk: "â–„",
  ljcy: "Ñ™",
  ll: "â‰ª",
  llarr: "â‡‡",
  llcorner: "âŒ",
  llhard: "â¥«",
  lltri: "â—º",
  lmidot: "Å€",
  lmoust: "â°",
  lmoustache: "â°",
  lnE: "â‰¨",
  lnap: "âª‰",
  lnapprox: "âª‰",
  lne: "âª‡",
  lneq: "âª‡",
  lneqq: "â‰¨",
  lnsim: "â‹¦",
  loang: "âŸ¬",
  loarr: "â‡½",
  lobrk: "âŸ¦",
  longleftarrow: "âŸµ",
  longleftrightarrow: "âŸ·",
  longmapsto: "âŸ¼",
  longrightarrow: "âŸ¶",
  looparrowleft: "â†«",
  looparrowright: "â†¬",
  lopar: "â¦…",
  lopf: "ğ•",
  loplus: "â¨­",
  lotimes: "â¨´",
  lowast: "âˆ—",
  lowbar: "_",
  loz: "â—Š",
  lozenge: "â—Š",
  lozf: "â§«",
  lpar: "(",
  lparlt: "â¦“",
  lrarr: "â‡†",
  lrcorner: "âŒŸ",
  lrhar: "â‡‹",
  lrhard: "â¥­",
  lrm: "â€",
  lrtri: "âŠ¿",
  lsaquo: "â€¹",
  lscr: "ğ“",
  lsh: "â†°",
  lsim: "â‰²",
  lsime: "âª",
  lsimg: "âª",
  lsqb: "[",
  lsquo: "â€˜",
  lsquor: "â€š",
  lstrok: "Å‚",
  lt: "<",
  ltcc: "âª¦",
  ltcir: "â©¹",
  ltdot: "â‹–",
  lthree: "â‹‹",
  ltimes: "â‹‰",
  ltlarr: "â¥¶",
  ltquest: "â©»",
  ltrPar: "â¦–",
  ltri: "â—ƒ",
  ltrie: "âŠ´",
  ltrif: "â—‚",
  lurdshar: "â¥Š",
  luruhar: "â¥¦",
  lvertneqq: "â‰¨ï¸€",
  lvnE: "â‰¨ï¸€",
  mDDot: "âˆº",
  macr: "Â¯",
  male: "â™‚",
  malt: "âœ ",
  maltese: "âœ ",
  map: "â†¦",
  mapsto: "â†¦",
  mapstodown: "â†§",
  mapstoleft: "â†¤",
  mapstoup: "â†¥",
  marker: "â–®",
  mcomma: "â¨©",
  mcy: "Ğ¼",
  mdash: "â€”",
  measuredangle: "âˆ¡",
  mfr: "ğ”ª",
  mho: "â„§",
  micro: "Âµ",
  mid: "âˆ£",
  midast: "*",
  midcir: "â«°",
  middot: "Â·",
  minus: "âˆ’",
  minusb: "âŠŸ",
  minusd: "âˆ¸",
  minusdu: "â¨ª",
  mlcp: "â«›",
  mldr: "â€¦",
  mnplus: "âˆ“",
  models: "âŠ§",
  mopf: "ğ•",
  mp: "âˆ“",
  mscr: "ğ“‚",
  mstpos: "âˆ¾",
  mu: "Î¼",
  multimap: "âŠ¸",
  mumap: "âŠ¸",
  nGg: "â‹™Ì¸",
  nGt: "â‰«âƒ’",
  nGtv: "â‰«Ì¸",
  nLeftarrow: "â‡",
  nLeftrightarrow: "â‡",
  nLl: "â‹˜Ì¸",
  nLt: "â‰ªâƒ’",
  nLtv: "â‰ªÌ¸",
  nRightarrow: "â‡",
  nVDash: "âŠ¯",
  nVdash: "âŠ®",
  nabla: "âˆ‡",
  nacute: "Å„",
  nang: "âˆ âƒ’",
  nap: "â‰‰",
  napE: "â©°Ì¸",
  napid: "â‰‹Ì¸",
  napos: "Å‰",
  napprox: "â‰‰",
  natur: "â™®",
  natural: "â™®",
  naturals: "â„•",
  nbsp: "Â ",
  nbump: "â‰Ì¸",
  nbumpe: "â‰Ì¸",
  ncap: "â©ƒ",
  ncaron: "Åˆ",
  ncedil: "Å†",
  ncong: "â‰‡",
  ncongdot: "â©­Ì¸",
  ncup: "â©‚",
  ncy: "Ğ½",
  ndash: "â€“",
  ne: "â‰ ",
  neArr: "â‡—",
  nearhk: "â¤¤",
  nearr: "â†—",
  nearrow: "â†—",
  nedot: "â‰Ì¸",
  nequiv: "â‰¢",
  nesear: "â¤¨",
  nesim: "â‰‚Ì¸",
  nexist: "âˆ„",
  nexists: "âˆ„",
  nfr: "ğ”«",
  ngE: "â‰§Ì¸",
  nge: "â‰±",
  ngeq: "â‰±",
  ngeqq: "â‰§Ì¸",
  ngeqslant: "â©¾Ì¸",
  nges: "â©¾Ì¸",
  ngsim: "â‰µ",
  ngt: "â‰¯",
  ngtr: "â‰¯",
  nhArr: "â‡",
  nharr: "â†®",
  nhpar: "â«²",
  ni: "âˆ‹",
  nis: "â‹¼",
  nisd: "â‹º",
  niv: "âˆ‹",
  njcy: "Ñš",
  nlArr: "â‡",
  nlE: "â‰¦Ì¸",
  nlarr: "â†š",
  nldr: "â€¥",
  nle: "â‰°",
  nleftarrow: "â†š",
  nleftrightarrow: "â†®",
  nleq: "â‰°",
  nleqq: "â‰¦Ì¸",
  nleqslant: "â©½Ì¸",
  nles: "â©½Ì¸",
  nless: "â‰®",
  nlsim: "â‰´",
  nlt: "â‰®",
  nltri: "â‹ª",
  nltrie: "â‹¬",
  nmid: "âˆ¤",
  nopf: "ğ•Ÿ",
  not: "Â¬",
  notin: "âˆ‰",
  notinE: "â‹¹Ì¸",
  notindot: "â‹µÌ¸",
  notinva: "âˆ‰",
  notinvb: "â‹·",
  notinvc: "â‹¶",
  notni: "âˆŒ",
  notniva: "âˆŒ",
  notnivb: "â‹¾",
  notnivc: "â‹½",
  npar: "âˆ¦",
  nparallel: "âˆ¦",
  nparsl: "â«½âƒ¥",
  npart: "âˆ‚Ì¸",
  npolint: "â¨”",
  npr: "âŠ€",
  nprcue: "â‹ ",
  npre: "âª¯Ì¸",
  nprec: "âŠ€",
  npreceq: "âª¯Ì¸",
  nrArr: "â‡",
  nrarr: "â†›",
  nrarrc: "â¤³Ì¸",
  nrarrw: "â†Ì¸",
  nrightarrow: "â†›",
  nrtri: "â‹«",
  nrtrie: "â‹­",
  nsc: "âŠ",
  nsccue: "â‹¡",
  nsce: "âª°Ì¸",
  nscr: "ğ“ƒ",
  nshortmid: "âˆ¤",
  nshortparallel: "âˆ¦",
  nsim: "â‰",
  nsime: "â‰„",
  nsimeq: "â‰„",
  nsmid: "âˆ¤",
  nspar: "âˆ¦",
  nsqsube: "â‹¢",
  nsqsupe: "â‹£",
  nsub: "âŠ„",
  nsubE: "â«…Ì¸",
  nsube: "âŠˆ",
  nsubset: "âŠ‚âƒ’",
  nsubseteq: "âŠˆ",
  nsubseteqq: "â«…Ì¸",
  nsucc: "âŠ",
  nsucceq: "âª°Ì¸",
  nsup: "âŠ…",
  nsupE: "â«†Ì¸",
  nsupe: "âŠ‰",
  nsupset: "âŠƒâƒ’",
  nsupseteq: "âŠ‰",
  nsupseteqq: "â«†Ì¸",
  ntgl: "â‰¹",
  ntilde: "Ã±",
  ntlg: "â‰¸",
  ntriangleleft: "â‹ª",
  ntrianglelefteq: "â‹¬",
  ntriangleright: "â‹«",
  ntrianglerighteq: "â‹­",
  nu: "Î½",
  num: "#",
  numero: "â„–",
  numsp: "â€‡",
  nvDash: "âŠ­",
  nvHarr: "â¤„",
  nvap: "â‰âƒ’",
  nvdash: "âŠ¬",
  nvge: "â‰¥âƒ’",
  nvgt: ">âƒ’",
  nvinfin: "â§",
  nvlArr: "â¤‚",
  nvle: "â‰¤âƒ’",
  nvlt: "<âƒ’",
  nvltrie: "âŠ´âƒ’",
  nvrArr: "â¤ƒ",
  nvrtrie: "âŠµâƒ’",
  nvsim: "âˆ¼âƒ’",
  nwArr: "â‡–",
  nwarhk: "â¤£",
  nwarr: "â†–",
  nwarrow: "â†–",
  nwnear: "â¤§",
  oS: "â“ˆ",
  oacute: "Ã³",
  oast: "âŠ›",
  ocir: "âŠš",
  ocirc: "Ã´",
  ocy: "Ğ¾",
  odash: "âŠ",
  odblac: "Å‘",
  odiv: "â¨¸",
  odot: "âŠ™",
  odsold: "â¦¼",
  oelig: "Å“",
  ofcir: "â¦¿",
  ofr: "ğ”¬",
  ogon: "Ë›",
  ograve: "Ã²",
  ogt: "â§",
  ohbar: "â¦µ",
  ohm: "Î©",
  oint: "âˆ®",
  olarr: "â†º",
  olcir: "â¦¾",
  olcross: "â¦»",
  oline: "â€¾",
  olt: "â§€",
  omacr: "Å",
  omega: "Ï‰",
  omicron: "Î¿",
  omid: "â¦¶",
  ominus: "âŠ–",
  oopf: "ğ• ",
  opar: "â¦·",
  operp: "â¦¹",
  oplus: "âŠ•",
  or: "âˆ¨",
  orarr: "â†»",
  ord: "â©",
  order: "â„´",
  orderof: "â„´",
  ordf: "Âª",
  ordm: "Âº",
  origof: "âŠ¶",
  oror: "â©–",
  orslope: "â©—",
  orv: "â©›",
  oscr: "â„´",
  oslash: "Ã¸",
  osol: "âŠ˜",
  otilde: "Ãµ",
  otimes: "âŠ—",
  otimesas: "â¨¶",
  ouml: "Ã¶",
  ovbar: "âŒ½",
  par: "âˆ¥",
  para: "Â¶",
  parallel: "âˆ¥",
  parsim: "â«³",
  parsl: "â«½",
  part: "âˆ‚",
  pcy: "Ğ¿",
  percnt: "%",
  period: ".",
  permil: "â€°",
  perp: "âŠ¥",
  pertenk: "â€±",
  pfr: "ğ”­",
  phi: "Ï†",
  phiv: "Ï•",
  phmmat: "â„³",
  phone: "â˜",
  pi: "Ï€",
  pitchfork: "â‹”",
  piv: "Ï–",
  planck: "â„",
  planckh: "â„",
  plankv: "â„",
  plus: "+",
  plusacir: "â¨£",
  plusb: "âŠ",
  pluscir: "â¨¢",
  plusdo: "âˆ”",
  plusdu: "â¨¥",
  pluse: "â©²",
  plusmn: "Â±",
  plussim: "â¨¦",
  plustwo: "â¨§",
  pm: "Â±",
  pointint: "â¨•",
  popf: "ğ•¡",
  pound: "Â£",
  pr: "â‰º",
  prE: "âª³",
  prap: "âª·",
  prcue: "â‰¼",
  pre: "âª¯",
  prec: "â‰º",
  precapprox: "âª·",
  preccurlyeq: "â‰¼",
  preceq: "âª¯",
  precnapprox: "âª¹",
  precneqq: "âªµ",
  precnsim: "â‹¨",
  precsim: "â‰¾",
  prime: "â€²",
  primes: "â„™",
  prnE: "âªµ",
  prnap: "âª¹",
  prnsim: "â‹¨",
  prod: "âˆ",
  profalar: "âŒ®",
  profline: "âŒ’",
  profsurf: "âŒ“",
  prop: "âˆ",
  propto: "âˆ",
  prsim: "â‰¾",
  prurel: "âŠ°",
  pscr: "ğ“…",
  psi: "Ïˆ",
  puncsp: "â€ˆ",
  qfr: "ğ”®",
  qint: "â¨Œ",
  qopf: "ğ•¢",
  qprime: "â—",
  qscr: "ğ“†",
  quaternions: "â„",
  quatint: "â¨–",
  quest: "?",
  questeq: "â‰Ÿ",
  quot: '"',
  rAarr: "â‡›",
  rArr: "â‡’",
  rAtail: "â¤œ",
  rBarr: "â¤",
  rHar: "â¥¤",
  race: "âˆ½Ì±",
  racute: "Å•",
  radic: "âˆš",
  raemptyv: "â¦³",
  rang: "âŸ©",
  rangd: "â¦’",
  range: "â¦¥",
  rangle: "âŸ©",
  raquo: "Â»",
  rarr: "â†’",
  rarrap: "â¥µ",
  rarrb: "â‡¥",
  rarrbfs: "â¤ ",
  rarrc: "â¤³",
  rarrfs: "â¤",
  rarrhk: "â†ª",
  rarrlp: "â†¬",
  rarrpl: "â¥…",
  rarrsim: "â¥´",
  rarrtl: "â†£",
  rarrw: "â†",
  ratail: "â¤š",
  ratio: "âˆ¶",
  rationals: "â„š",
  rbarr: "â¤",
  rbbrk: "â³",
  rbrace: "}",
  rbrack: "]",
  rbrke: "â¦Œ",
  rbrksld: "â¦",
  rbrkslu: "â¦",
  rcaron: "Å™",
  rcedil: "Å—",
  rceil: "âŒ‰",
  rcub: "}",
  rcy: "Ñ€",
  rdca: "â¤·",
  rdldhar: "â¥©",
  rdquo: "â€",
  rdquor: "â€",
  rdsh: "â†³",
  real: "â„œ",
  realine: "â„›",
  realpart: "â„œ",
  reals: "â„",
  rect: "â–­",
  reg: "Â®",
  rfisht: "â¥½",
  rfloor: "âŒ‹",
  rfr: "ğ”¯",
  rhard: "â‡",
  rharu: "â‡€",
  rharul: "â¥¬",
  rho: "Ï",
  rhov: "Ï±",
  rightarrow: "â†’",
  rightarrowtail: "â†£",
  rightharpoondown: "â‡",
  rightharpoonup: "â‡€",
  rightleftarrows: "â‡„",
  rightleftharpoons: "â‡Œ",
  rightrightarrows: "â‡‰",
  rightsquigarrow: "â†",
  rightthreetimes: "â‹Œ",
  ring: "Ëš",
  risingdotseq: "â‰“",
  rlarr: "â‡„",
  rlhar: "â‡Œ",
  rlm: "â€",
  rmoust: "â±",
  rmoustache: "â±",
  rnmid: "â«®",
  roang: "âŸ­",
  roarr: "â‡¾",
  robrk: "âŸ§",
  ropar: "â¦†",
  ropf: "ğ•£",
  roplus: "â¨®",
  rotimes: "â¨µ",
  rpar: ")",
  rpargt: "â¦”",
  rppolint: "â¨’",
  rrarr: "â‡‰",
  rsaquo: "â€º",
  rscr: "ğ“‡",
  rsh: "â†±",
  rsqb: "]",
  rsquo: "â€™",
  rsquor: "â€™",
  rthree: "â‹Œ",
  rtimes: "â‹Š",
  rtri: "â–¹",
  rtrie: "âŠµ",
  rtrif: "â–¸",
  rtriltri: "â§",
  ruluhar: "â¥¨",
  rx: "â„",
  sacute: "Å›",
  sbquo: "â€š",
  sc: "â‰»",
  scE: "âª´",
  scap: "âª¸",
  scaron: "Å¡",
  sccue: "â‰½",
  sce: "âª°",
  scedil: "ÅŸ",
  scirc: "Å",
  scnE: "âª¶",
  scnap: "âªº",
  scnsim: "â‹©",
  scpolint: "â¨“",
  scsim: "â‰¿",
  scy: "Ñ",
  sdot: "â‹…",
  sdotb: "âŠ¡",
  sdote: "â©¦",
  seArr: "â‡˜",
  searhk: "â¤¥",
  searr: "â†˜",
  searrow: "â†˜",
  sect: "Â§",
  semi: ";",
  seswar: "â¤©",
  setminus: "âˆ–",
  setmn: "âˆ–",
  sext: "âœ¶",
  sfr: "ğ”°",
  sfrown: "âŒ¢",
  sharp: "â™¯",
  shchcy: "Ñ‰",
  shcy: "Ñˆ",
  shortmid: "âˆ£",
  shortparallel: "âˆ¥",
  shy: "Â­",
  sigma: "Ïƒ",
  sigmaf: "Ï‚",
  sigmav: "Ï‚",
  sim: "âˆ¼",
  simdot: "â©ª",
  sime: "â‰ƒ",
  simeq: "â‰ƒ",
  simg: "âª",
  simgE: "âª ",
  siml: "âª",
  simlE: "âªŸ",
  simne: "â‰†",
  simplus: "â¨¤",
  simrarr: "â¥²",
  slarr: "â†",
  smallsetminus: "âˆ–",
  smashp: "â¨³",
  smeparsl: "â§¤",
  smid: "âˆ£",
  smile: "âŒ£",
  smt: "âªª",
  smte: "âª¬",
  smtes: "âª¬ï¸€",
  softcy: "ÑŒ",
  sol: "/",
  solb: "â§„",
  solbar: "âŒ¿",
  sopf: "ğ•¤",
  spades: "â™ ",
  spadesuit: "â™ ",
  spar: "âˆ¥",
  sqcap: "âŠ“",
  sqcaps: "âŠ“ï¸€",
  sqcup: "âŠ”",
  sqcups: "âŠ”ï¸€",
  sqsub: "âŠ",
  sqsube: "âŠ‘",
  sqsubset: "âŠ",
  sqsubseteq: "âŠ‘",
  sqsup: "âŠ",
  sqsupe: "âŠ’",
  sqsupset: "âŠ",
  sqsupseteq: "âŠ’",
  squ: "â–¡",
  square: "â–¡",
  squarf: "â–ª",
  squf: "â–ª",
  srarr: "â†’",
  sscr: "ğ“ˆ",
  ssetmn: "âˆ–",
  ssmile: "âŒ£",
  sstarf: "â‹†",
  star: "â˜†",
  starf: "â˜…",
  straightepsilon: "Ïµ",
  straightphi: "Ï•",
  strns: "Â¯",
  sub: "âŠ‚",
  subE: "â«…",
  subdot: "âª½",
  sube: "âŠ†",
  subedot: "â«ƒ",
  submult: "â«",
  subnE: "â«‹",
  subne: "âŠŠ",
  subplus: "âª¿",
  subrarr: "â¥¹",
  subset: "âŠ‚",
  subseteq: "âŠ†",
  subseteqq: "â«…",
  subsetneq: "âŠŠ",
  subsetneqq: "â«‹",
  subsim: "â«‡",
  subsub: "â«•",
  subsup: "â«“",
  succ: "â‰»",
  succapprox: "âª¸",
  succcurlyeq: "â‰½",
  succeq: "âª°",
  succnapprox: "âªº",
  succneqq: "âª¶",
  succnsim: "â‹©",
  succsim: "â‰¿",
  sum: "âˆ‘",
  sung: "â™ª",
  sup1: "Â¹",
  sup2: "Â²",
  sup3: "Â³",
  sup: "âŠƒ",
  supE: "â«†",
  supdot: "âª¾",
  supdsub: "â«˜",
  supe: "âŠ‡",
  supedot: "â«„",
  suphsol: "âŸ‰",
  suphsub: "â«—",
  suplarr: "â¥»",
  supmult: "â«‚",
  supnE: "â«Œ",
  supne: "âŠ‹",
  supplus: "â«€",
  supset: "âŠƒ",
  supseteq: "âŠ‡",
  supseteqq: "â«†",
  supsetneq: "âŠ‹",
  supsetneqq: "â«Œ",
  supsim: "â«ˆ",
  supsub: "â«”",
  supsup: "â«–",
  swArr: "â‡™",
  swarhk: "â¤¦",
  swarr: "â†™",
  swarrow: "â†™",
  swnwar: "â¤ª",
  szlig: "ÃŸ",
  target: "âŒ–",
  tau: "Ï„",
  tbrk: "â´",
  tcaron: "Å¥",
  tcedil: "Å£",
  tcy: "Ñ‚",
  tdot: "âƒ›",
  telrec: "âŒ•",
  tfr: "ğ”±",
  there4: "âˆ´",
  therefore: "âˆ´",
  theta: "Î¸",
  thetasym: "Ï‘",
  thetav: "Ï‘",
  thickapprox: "â‰ˆ",
  thicksim: "âˆ¼",
  thinsp: "â€‰",
  thkap: "â‰ˆ",
  thksim: "âˆ¼",
  thorn: "Ã¾",
  tilde: "Ëœ",
  times: "Ã—",
  timesb: "âŠ ",
  timesbar: "â¨±",
  timesd: "â¨°",
  tint: "âˆ­",
  toea: "â¤¨",
  top: "âŠ¤",
  topbot: "âŒ¶",
  topcir: "â«±",
  topf: "ğ•¥",
  topfork: "â«š",
  tosa: "â¤©",
  tprime: "â€´",
  trade: "â„¢",
  triangle: "â–µ",
  triangledown: "â–¿",
  triangleleft: "â—ƒ",
  trianglelefteq: "âŠ´",
  triangleq: "â‰œ",
  triangleright: "â–¹",
  trianglerighteq: "âŠµ",
  tridot: "â—¬",
  trie: "â‰œ",
  triminus: "â¨º",
  triplus: "â¨¹",
  trisb: "â§",
  tritime: "â¨»",
  trpezium: "â¢",
  tscr: "ğ“‰",
  tscy: "Ñ†",
  tshcy: "Ñ›",
  tstrok: "Å§",
  twixt: "â‰¬",
  twoheadleftarrow: "â†",
  twoheadrightarrow: "â† ",
  uArr: "â‡‘",
  uHar: "â¥£",
  uacute: "Ãº",
  uarr: "â†‘",
  ubrcy: "Ñ",
  ubreve: "Å­",
  ucirc: "Ã»",
  ucy: "Ñƒ",
  udarr: "â‡…",
  udblac: "Å±",
  udhar: "â¥®",
  ufisht: "â¥¾",
  ufr: "ğ”²",
  ugrave: "Ã¹",
  uharl: "â†¿",
  uharr: "â†¾",
  uhblk: "â–€",
  ulcorn: "âŒœ",
  ulcorner: "âŒœ",
  ulcrop: "âŒ",
  ultri: "â—¸",
  umacr: "Å«",
  uml: "Â¨",
  uogon: "Å³",
  uopf: "ğ•¦",
  uparrow: "â†‘",
  updownarrow: "â†•",
  upharpoonleft: "â†¿",
  upharpoonright: "â†¾",
  uplus: "âŠ",
  upsi: "Ï…",
  upsih: "Ï’",
  upsilon: "Ï…",
  upuparrows: "â‡ˆ",
  urcorn: "âŒ",
  urcorner: "âŒ",
  urcrop: "âŒ",
  uring: "Å¯",
  urtri: "â—¹",
  uscr: "ğ“Š",
  utdot: "â‹°",
  utilde: "Å©",
  utri: "â–µ",
  utrif: "â–´",
  uuarr: "â‡ˆ",
  uuml: "Ã¼",
  uwangle: "â¦§",
  vArr: "â‡•",
  vBar: "â«¨",
  vBarv: "â«©",
  vDash: "âŠ¨",
  vangrt: "â¦œ",
  varepsilon: "Ïµ",
  varkappa: "Ï°",
  varnothing: "âˆ…",
  varphi: "Ï•",
  varpi: "Ï–",
  varpropto: "âˆ",
  varr: "â†•",
  varrho: "Ï±",
  varsigma: "Ï‚",
  varsubsetneq: "âŠŠï¸€",
  varsubsetneqq: "â«‹ï¸€",
  varsupsetneq: "âŠ‹ï¸€",
  varsupsetneqq: "â«Œï¸€",
  vartheta: "Ï‘",
  vartriangleleft: "âŠ²",
  vartriangleright: "âŠ³",
  vcy: "Ğ²",
  vdash: "âŠ¢",
  vee: "âˆ¨",
  veebar: "âŠ»",
  veeeq: "â‰š",
  vellip: "â‹®",
  verbar: "|",
  vert: "|",
  vfr: "ğ”³",
  vltri: "âŠ²",
  vnsub: "âŠ‚âƒ’",
  vnsup: "âŠƒâƒ’",
  vopf: "ğ•§",
  vprop: "âˆ",
  vrtri: "âŠ³",
  vscr: "ğ“‹",
  vsubnE: "â«‹ï¸€",
  vsubne: "âŠŠï¸€",
  vsupnE: "â«Œï¸€",
  vsupne: "âŠ‹ï¸€",
  vzigzag: "â¦š",
  wcirc: "Åµ",
  wedbar: "â©Ÿ",
  wedge: "âˆ§",
  wedgeq: "â‰™",
  weierp: "â„˜",
  wfr: "ğ”´",
  wopf: "ğ•¨",
  wp: "â„˜",
  wr: "â‰€",
  wreath: "â‰€",
  wscr: "ğ“Œ",
  xcap: "â‹‚",
  xcirc: "â—¯",
  xcup: "â‹ƒ",
  xdtri: "â–½",
  xfr: "ğ”µ",
  xhArr: "âŸº",
  xharr: "âŸ·",
  xi: "Î¾",
  xlArr: "âŸ¸",
  xlarr: "âŸµ",
  xmap: "âŸ¼",
  xnis: "â‹»",
  xodot: "â¨€",
  xopf: "ğ•©",
  xoplus: "â¨",
  xotime: "â¨‚",
  xrArr: "âŸ¹",
  xrarr: "âŸ¶",
  xscr: "ğ“",
  xsqcup: "â¨†",
  xuplus: "â¨„",
  xutri: "â–³",
  xvee: "â‹",
  xwedge: "â‹€",
  yacute: "Ã½",
  yacy: "Ñ",
  ycirc: "Å·",
  ycy: "Ñ‹",
  yen: "Â¥",
  yfr: "ğ”¶",
  yicy: "Ñ—",
  yopf: "ğ•ª",
  yscr: "ğ“",
  yucy: "Ñ",
  yuml: "Ã¿",
  zacute: "Åº",
  zcaron: "Å¾",
  zcy: "Ğ·",
  zdot: "Å¼",
  zeetrf: "â„¨",
  zeta: "Î¶",
  zfr: "ğ”·",
  zhcy: "Ğ¶",
  zigrarr: "â‡",
  zopf: "ğ•«",
  zscr: "ğ“",
  zwj: "â€",
  zwnj: "â€Œ"
}, je = {}.hasOwnProperty;
function wt(t) {
  return je.call(Ut, t) ? Ut[t] : !1;
}
function $(t, n, e, r) {
  const u = t.length;
  let a = 0, i;
  if (n < 0 ? n = -n > u ? 0 : u + n : n = n > u ? u : n, e = e > 0 ? e : 0, r.length < 1e4)
    i = Array.from(r), i.unshift(n, e), t.splice(...i);
  else
    for (e && t.splice(n, e); a < r.length; )
      i = r.slice(a, a + 1e4), i.unshift(n, 0), t.splice(...i), a += 1e4, n += 1e4;
}
function j(t, n) {
  return t.length > 0 ? ($(t, t.length, 0, n), t) : n;
}
const Lt = {}.hasOwnProperty;
function Ue(t) {
  const n = {};
  let e = -1;
  for (; ++e < t.length; )
    Ge(n, t[e]);
  return n;
}
function Ge(t, n) {
  let e;
  for (e in n) {
    const u = (Lt.call(t, e) ? t[e] : void 0) || (t[e] = {}), a = n[e];
    let i;
    if (a)
      for (i in a) {
        Lt.call(u, i) || (u[i] = []);
        const l = a[i];
        Qe(
          // @ts-expect-error Looks like a list.
          u[i],
          Array.isArray(l) ? l : l ? [l] : []
        );
      }
  }
}
function Qe(t, n) {
  let e = -1;
  const r = [];
  for (; ++e < n.length; )
    (n[e].add === "after" ? t : r).push(n[e]);
  $(t, 0, 0, r);
}
function We(t) {
  const n = {};
  let e = -1;
  for (; ++e < t.length; )
    $e(n, t[e]);
  return n;
}
function $e(t, n) {
  let e;
  for (e in n) {
    const u = (Lt.call(t, e) ? t[e] : void 0) || (t[e] = {}), a = n[e];
    let i;
    if (a)
      for (i in a)
        u[i] = a[i];
  }
}
function Ye(t, n) {
  const e = Number.parseInt(t, n);
  return (
    // C0 except for HT, LF, FF, CR, space.
    e < 9 || e === 11 || e > 13 && e < 32 || // Control character (DEL) of C0, and C1 controls.
    e > 126 && e < 160 || // Lone high surrogates and low surrogates.
    e > 55295 && e < 57344 || // Noncharacters.
    e > 64975 && e < 65008 || /* eslint-disable no-bitwise */
    (e & 65535) === 65535 || (e & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    e > 1114111 ? "ï¿½" : String.fromCodePoint(e)
  );
}
const Ze = { '"': "quot", "&": "amp", "<": "lt", ">": "gt" };
function ae(t) {
  return t.replace(/["&<>]/g, n);
  function n(e) {
    return "&" + Ze[e] + ";";
  }
}
function et(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const W = lt(/[A-Za-z]/), U = lt(/[\dA-Za-z]/), Je = lt(/[#-'*+\--9=?A-Z^-~]/);
function vt(t) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    t !== null && (t < 32 || t === 127)
  );
}
const zt = lt(/\d/), Ke = lt(/[\dA-Fa-f]/), Xe = lt(/[!-/:-@[-`{-~]/);
function z(t) {
  return t !== null && t < -2;
}
function _(t) {
  return t !== null && (t < 0 || t === 32);
}
function R(t) {
  return t === -2 || t === -1 || t === 32;
}
const tn = lt(new RegExp("\\p{P}|\\p{S}", "u")), en = lt(/\s/);
function lt(t) {
  return n;
  function n(e) {
    return e !== null && e > -1 && t.test(String.fromCharCode(e));
  }
}
function gt(t, n) {
  const e = ae(nn(t || ""));
  if (!n)
    return e;
  const r = e.indexOf(":"), u = e.indexOf("?"), a = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, itâ€™s relative.
    r < 0 || // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.
    i > -1 && r > i || u > -1 && r > u || a > -1 && r > a || // It is a protocol, it should be allowed.
    n.test(e.slice(0, r)) ? e : ""
  );
}
function nn(t) {
  const n = [];
  let e = -1, r = 0, u = 0;
  for (; ++e < t.length; ) {
    const a = t.charCodeAt(e);
    let i = "";
    if (a === 37 && U(t.charCodeAt(e + 1)) && U(t.charCodeAt(e + 2)))
      u = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (i = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const l = t.charCodeAt(e + 1);
      a < 56320 && l > 56319 && l < 57344 ? (i = String.fromCharCode(a, l), u = 1) : i = "ï¿½";
    } else
      i = String.fromCharCode(a);
    i && (n.push(t.slice(r, e), encodeURIComponent(i)), r = e + u + 1, i = ""), u && (e += u, u = 0);
  }
  return n.join("") + t.slice(r);
}
const Gt = {}.hasOwnProperty, Qt = /^(https?|ircs?|mailto|xmpp)$/i, rn = /^https?$/i;
function an(t) {
  const n = t || {};
  let e = !0;
  const r = {}, u = [[]], a = [], i = [], c = (
    /** @type {NormalizedHtmlExtension} */
    We(
      [{
        enter: {
          blockQuote: d,
          codeFenced: nt,
          codeFencedFenceInfo: k,
          codeFencedFenceMeta: k,
          codeIndented: rt,
          codeText: Oe,
          content: Ce,
          definition: de,
          definitionDestinationString: ke,
          definitionLabelString: k,
          definitionTitleString: k,
          emphasis: Fe,
          htmlFlow: Te,
          htmlText: _t,
          image: J,
          label: k,
          link: ot,
          listItemMarker: L,
          listItemValue: x,
          listOrdered: F,
          listUnordered: P,
          paragraph: V,
          reference: k,
          resource: st,
          resourceDestinationString: ct,
          resourceTitleString: k,
          setextHeading: Ee,
          strong: Ne
        },
        exit: {
          atxHeading: qe,
          atxHeadingSequence: Ae,
          autolinkEmail: He,
          autolinkProtocol: Ve,
          blockQuote: M,
          characterEscapeValue: ft,
          characterReferenceMarkerHexadecimal: Mt,
          characterReferenceMarkerNumeric: Mt,
          characterReferenceValue: Me,
          codeFenced: m,
          codeFencedFence: Z,
          codeFencedFenceInfo: g,
          codeFencedFenceMeta: y,
          codeFlowValue: Ie,
          codeIndented: m,
          codeText: Re,
          codeTextData: ft,
          data: ft,
          definition: ye,
          definitionDestinationString: we,
          definitionLabelString: xe,
          definitionTitleString: Se,
          emphasis: Be,
          hardBreakEscape: Bt,
          hardBreakTrailing: Bt,
          htmlFlow: Pt,
          htmlFlowData: ft,
          htmlText: Pt,
          htmlTextData: ft,
          image: Rt,
          label: mt,
          labelText: H,
          lineEnding: ze,
          link: Rt,
          listOrdered: D,
          listUnordered: B,
          paragraph: Y,
          reference: y,
          referenceString: ut,
          resource: y,
          resourceDestinationString: Ct,
          resourceTitleString: be,
          setextHeading: ve,
          setextHeadingLineSequence: Le,
          setextHeadingText: De,
          strong: Pe,
          thematicBreak: _e
        }
      }].concat(n.htmlExtensions || [])
    )
  ), o = {
    tightStack: i,
    definitions: r
  }, p = {
    lineEndingIfNeeded: v,
    options: n,
    encode: S,
    raw: A,
    tag: E,
    buffer: k,
    resume: w,
    setData: b,
    getData: C
  };
  let h = n.defaultLineEnding;
  return f;
  function f(q) {
    let I = -1, G = 0;
    const K = [];
    let X = [], it = [];
    for (; ++I < q.length; )
      !h && (q[I][1].type === "lineEnding" || q[I][1].type === "lineEndingBlank") && (h = q[I][2].sliceSerialize(q[I][1])), (q[I][1].type === "listOrdered" || q[I][1].type === "listUnordered") && (q[I][0] === "enter" ? K.push(I) : s(q.slice(K.pop(), I))), q[I][1].type === "definition" && (q[I][0] === "enter" ? (it = j(it, q.slice(G, I)), G = I) : (X = j(X, q.slice(G, I + 1)), G = I + 1));
    X = j(X, it), X = j(X, q.slice(G)), I = -1;
    const tt = X;
    for (c.enter.null && c.enter.null.call(p); ++I < q.length; ) {
      const Vt = c[tt[I][0]], Ht = tt[I][1].type, jt = Vt[Ht];
      Gt.call(Vt, Ht) && jt && jt.call(
        Object.assign(
          {
            sliceSerialize: tt[I][2].sliceSerialize
          },
          p
        ),
        tt[I][1]
      );
    }
    return c.exit.null && c.exit.null.call(p), u[0].join("");
  }
  function s(q) {
    const I = q.length;
    let G = 0, K = 0, X = !1, it;
    for (; ++G < I; ) {
      const tt = q[G];
      if (tt[1]._container)
        it = void 0, tt[0] === "enter" ? K++ : K--;
      else
        switch (tt[1].type) {
          case "listItemPrefix": {
            tt[0] === "exit" && (it = !0);
            break;
          }
          case "linePrefix":
            break;
          case "lineEndingBlank": {
            tt[0] === "enter" && !K && (it ? it = void 0 : X = !0);
            break;
          }
          default:
            it = void 0;
        }
    }
    q[0][1]._loose = X;
  }
  function b(q, I) {
    o[q] = I;
  }
  function C(q) {
    return o[q];
  }
  function k() {
    u.push([]);
  }
  function w() {
    return u.pop().join("");
  }
  function E(q) {
    e && (b("lastWasTag", !0), u[u.length - 1].push(q));
  }
  function A(q) {
    b("lastWasTag"), u[u.length - 1].push(q);
  }
  function T() {
    A(h || `
`);
  }
  function v() {
    const q = u[u.length - 1], I = q[q.length - 1], G = I ? I.charCodeAt(I.length - 1) : null;
    G === 10 || G === 13 || G === null || T();
  }
  function S(q) {
    return C("ignoreEncode") ? q : ae(q);
  }
  function y() {
    w();
  }
  function F(q) {
    i.push(!q._loose), v(), E("<ol"), b("expectFirstItem", !0);
  }
  function P(q) {
    i.push(!q._loose), v(), E("<ul"), b("expectFirstItem", !0);
  }
  function x(q) {
    if (C("expectFirstItem")) {
      const I = Number.parseInt(this.sliceSerialize(q), 10);
      I !== 1 && E(' start="' + S(String(I)) + '"');
    }
  }
  function L() {
    C("expectFirstItem") ? E(">") : O(), v(), E("<li>"), b("expectFirstItem"), b("lastWasTag");
  }
  function D() {
    O(), i.pop(), T(), E("</ol>");
  }
  function B() {
    O(), i.pop(), T(), E("</ul>");
  }
  function O() {
    C("lastWasTag") && !C("slurpAllLineEndings") && v(), E("</li>"), b("slurpAllLineEndings");
  }
  function d() {
    i.push(!1), v(), E("<blockquote>");
  }
  function M() {
    i.pop(), v(), E("</blockquote>"), b("slurpAllLineEndings");
  }
  function V() {
    i[i.length - 1] || (v(), E("<p>")), b("slurpAllLineEndings");
  }
  function Y() {
    i[i.length - 1] ? b("slurpAllLineEndings", !0) : E("</p>");
  }
  function nt() {
    v(), E("<pre><code"), b("fencesCount", 0);
  }
  function g() {
    const q = w();
    E(' class="language-' + q + '"');
  }
  function Z() {
    const q = C("fencesCount") || 0;
    q || (E(">"), b("slurpOneLineEnding", !0)), b("fencesCount", q + 1);
  }
  function rt() {
    v(), E("<pre><code>");
  }
  function m() {
    const q = C("fencesCount");
    q !== void 0 && q < 2 && o.tightStack.length > 0 && !C("lastWasTag") && T(), C("flowCodeSeenData") && v(), E("</code></pre>"), q !== void 0 && q < 2 && v(), b("flowCodeSeenData"), b("fencesCount"), b("slurpOneLineEnding");
  }
  function J() {
    a.push({
      image: !0
    }), e = void 0;
  }
  function ot() {
    a.push({});
  }
  function H(q) {
    a[a.length - 1].labelId = this.sliceSerialize(q);
  }
  function mt() {
    a[a.length - 1].label = w();
  }
  function ut(q) {
    a[a.length - 1].referenceId = this.sliceSerialize(q);
  }
  function st() {
    k(), a[a.length - 1].destination = "";
  }
  function ct() {
    k(), b("ignoreEncode", !0);
  }
  function Ct() {
    a[a.length - 1].destination = w(), b("ignoreEncode");
  }
  function be() {
    a[a.length - 1].title = w();
  }
  function Rt() {
    let q = a.length - 1;
    const I = a[q], G = I.referenceId || I.labelId, K = I.destination === void 0 ? r[et(G)] : I;
    for (e = !0; q--; )
      if (a[q].image) {
        e = void 0;
        break;
      }
    I.image ? (E(
      '<img src="' + gt(
        K.destination,
        n.allowDangerousProtocol ? void 0 : rn
      ) + '" alt="'
    ), A(I.label), E('"')) : E(
      '<a href="' + gt(
        K.destination,
        n.allowDangerousProtocol ? void 0 : Qt
      ) + '"'
    ), E(K.title ? ' title="' + K.title + '"' : ""), I.image ? E(" />") : (E(">"), A(I.label), E("</a>")), a.pop();
  }
  function de() {
    k(), a.push({});
  }
  function xe(q) {
    w(), a[a.length - 1].labelId = this.sliceSerialize(q);
  }
  function ke() {
    k(), b("ignoreEncode", !0);
  }
  function we() {
    a[a.length - 1].destination = w(), b("ignoreEncode");
  }
  function Se() {
    a[a.length - 1].title = w();
  }
  function ye() {
    const q = a[a.length - 1], I = et(q.labelId);
    w(), Gt.call(r, I) || (r[I] = a[a.length - 1]), a.pop();
  }
  function Ce() {
    b("slurpAllLineEndings", !0);
  }
  function Ae(q) {
    C("headingRank") || (b("headingRank", this.sliceSerialize(q).length), v(), E("<h" + C("headingRank") + ">"));
  }
  function Ee() {
    k(), b("slurpAllLineEndings");
  }
  function De() {
    b("slurpAllLineEndings", !0);
  }
  function qe() {
    E("</h" + C("headingRank") + ">"), b("headingRank");
  }
  function Le(q) {
    b(
      "headingRank",
      this.sliceSerialize(q).charCodeAt(0) === 61 ? 1 : 2
    );
  }
  function ve() {
    const q = w();
    v(), E("<h" + C("headingRank") + ">"), A(q), E("</h" + C("headingRank") + ">"), b("slurpAllLineEndings"), b("headingRank");
  }
  function ft(q) {
    A(S(this.sliceSerialize(q)));
  }
  function ze(q) {
    if (!C("slurpAllLineEndings")) {
      if (C("slurpOneLineEnding")) {
        b("slurpOneLineEnding");
        return;
      }
      if (C("inCodeText")) {
        A(" ");
        return;
      }
      A(S(this.sliceSerialize(q)));
    }
  }
  function Ie(q) {
    A(S(this.sliceSerialize(q))), b("flowCodeSeenData", !0);
  }
  function Bt() {
    E("<br />");
  }
  function Te() {
    v(), _t();
  }
  function Pt() {
    b("ignoreEncode");
  }
  function _t() {
    n.allowDangerousHtml && b("ignoreEncode", !0);
  }
  function Fe() {
    E("<em>");
  }
  function Ne() {
    E("<strong>");
  }
  function Oe() {
    b("inCodeText", !0), E("<code>");
  }
  function Re() {
    b("inCodeText"), E("</code>");
  }
  function Be() {
    E("</em>");
  }
  function Pe() {
    E("</strong>");
  }
  function _e() {
    v(), E("<hr />");
  }
  function Mt(q) {
    b("characterReferenceType", q.type);
  }
  function Me(q) {
    let I = this.sliceSerialize(q);
    I = C("characterReferenceType") ? Ye(
      I,
      C("characterReferenceType") === "characterReferenceMarkerNumeric" ? 10 : 16
    ) : wt(I), A(S(I)), b("characterReferenceType");
  }
  function Ve(q) {
    const I = this.sliceSerialize(q);
    E(
      '<a href="' + gt(
        I,
        n.allowDangerousProtocol ? void 0 : Qt
      ) + '">'
    ), A(S(I)), E("</a>");
  }
  function He(q) {
    const I = this.sliceSerialize(q);
    E('<a href="' + gt("mailto:" + I) + '">'), A(S(I)), E("</a>");
  }
}
function N(t, n, e, r) {
  const u = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return i;
  function i(c) {
    return R(c) ? (t.enter(e), l(c)) : n(c);
  }
  function l(c) {
    return R(c) && a++ < u ? (t.consume(c), l) : (t.exit(e), n(c));
  }
}
const un = {
  tokenize: ln
};
function ln(t) {
  const n = t.attempt(
    this.parser.constructs.contentInitial,
    r,
    u
  );
  let e;
  return n;
  function r(l) {
    if (l === null) {
      t.consume(l);
      return;
    }
    return t.enter("lineEnding"), t.consume(l), t.exit("lineEnding"), N(t, n, "linePrefix");
  }
  function u(l) {
    return t.enter("paragraph"), a(l);
  }
  function a(l) {
    const c = t.enter("chunkText", {
      contentType: "text",
      previous: e
    });
    return e && (e.next = c), e = c, i(l);
  }
  function i(l) {
    if (l === null) {
      t.exit("chunkText"), t.exit("paragraph"), t.consume(l);
      return;
    }
    return z(l) ? (t.consume(l), t.exit("chunkText"), a) : (t.consume(l), i);
  }
}
const on = {
  tokenize: sn
}, Wt = {
  tokenize: cn
};
function sn(t) {
  const n = this, e = [];
  let r = 0, u, a, i;
  return l;
  function l(A) {
    if (r < e.length) {
      const T = e[r];
      return n.containerState = T[1], t.attempt(
        T[0].continuation,
        c,
        o
      )(A);
    }
    return o(A);
  }
  function c(A) {
    if (r++, n.containerState._closeFlow) {
      n.containerState._closeFlow = void 0, u && E();
      const T = n.events.length;
      let v = T, S;
      for (; v--; )
        if (n.events[v][0] === "exit" && n.events[v][1].type === "chunkFlow") {
          S = n.events[v][1].end;
          break;
        }
      w(r);
      let y = T;
      for (; y < n.events.length; )
        n.events[y][1].end = Object.assign({}, S), y++;
      return $(
        n.events,
        v + 1,
        0,
        n.events.slice(T)
      ), n.events.length = y, o(A);
    }
    return l(A);
  }
  function o(A) {
    if (r === e.length) {
      if (!u)
        return f(A);
      if (u.currentConstruct && u.currentConstruct.concrete)
        return b(A);
      n.interrupt = !!(u.currentConstruct && !u._gfmTableDynamicInterruptHack);
    }
    return n.containerState = {}, t.check(
      Wt,
      p,
      h
    )(A);
  }
  function p(A) {
    return u && E(), w(r), f(A);
  }
  function h(A) {
    return n.parser.lazy[n.now().line] = r !== e.length, i = n.now().offset, b(A);
  }
  function f(A) {
    return n.containerState = {}, t.attempt(
      Wt,
      s,
      b
    )(A);
  }
  function s(A) {
    return r++, e.push([n.currentConstruct, n.containerState]), f(A);
  }
  function b(A) {
    if (A === null) {
      u && E(), w(0), t.consume(A);
      return;
    }
    return u = u || n.parser.flow(n.now()), t.enter("chunkFlow", {
      contentType: "flow",
      previous: a,
      _tokenizer: u
    }), C(A);
  }
  function C(A) {
    if (A === null) {
      k(t.exit("chunkFlow"), !0), w(0), t.consume(A);
      return;
    }
    return z(A) ? (t.consume(A), k(t.exit("chunkFlow")), r = 0, n.interrupt = void 0, l) : (t.consume(A), C);
  }
  function k(A, T) {
    const v = n.sliceStream(A);
    if (T && v.push(null), A.previous = a, a && (a.next = A), a = A, u.defineSkip(A.start), u.write(v), n.parser.lazy[A.start.line]) {
      let S = u.events.length;
      for (; S--; )
        if (
          // The token starts before the line endingâ€¦
          u.events[S][1].start.offset < i && // â€¦and either is not ended yetâ€¦
          (!u.events[S][1].end || // â€¦or ends after it.
          u.events[S][1].end.offset > i)
        )
          return;
      const y = n.events.length;
      let F = y, P, x;
      for (; F--; )
        if (n.events[F][0] === "exit" && n.events[F][1].type === "chunkFlow") {
          if (P) {
            x = n.events[F][1].end;
            break;
          }
          P = !0;
        }
      for (w(r), S = y; S < n.events.length; )
        n.events[S][1].end = Object.assign({}, x), S++;
      $(
        n.events,
        F + 1,
        0,
        n.events.slice(y)
      ), n.events.length = S;
    }
  }
  function w(A) {
    let T = e.length;
    for (; T-- > A; ) {
      const v = e[T];
      n.containerState = v[1], v[0].exit.call(n, t);
    }
    e.length = A;
  }
  function E() {
    u.write([null]), a = void 0, u = void 0, n.containerState._closeFlow = void 0;
  }
}
function cn(t, n, e) {
  return N(
    t,
    t.attempt(this.parser.constructs.document, n, e),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function St(t) {
  if (t === null || _(t) || en(t))
    return 1;
  if (tn(t))
    return 2;
}
function yt(t, n, e) {
  const r = [];
  let u = -1;
  for (; ++u < t.length; ) {
    const a = t[u].resolveAll;
    a && !r.includes(a) && (n = a(n, e), r.push(a));
  }
  return n;
}
const It = {
  name: "attention",
  tokenize: pn,
  resolveAll: hn
};
function hn(t, n) {
  let e = -1, r, u, a, i, l, c, o, p;
  for (; ++e < t.length; )
    if (t[e][0] === "enter" && t[e][1].type === "attentionSequence" && t[e][1]._close) {
      for (r = e; r--; )
        if (t[r][0] === "exit" && t[r][1].type === "attentionSequence" && t[r][1]._open && // If the markers are the same:
        n.sliceSerialize(t[r][1]).charCodeAt(0) === n.sliceSerialize(t[e][1]).charCodeAt(0)) {
          if ((t[r][1]._close || t[e][1]._open) && (t[e][1].end.offset - t[e][1].start.offset) % 3 && !((t[r][1].end.offset - t[r][1].start.offset + t[e][1].end.offset - t[e][1].start.offset) % 3))
            continue;
          c = t[r][1].end.offset - t[r][1].start.offset > 1 && t[e][1].end.offset - t[e][1].start.offset > 1 ? 2 : 1;
          const h = Object.assign({}, t[r][1].end), f = Object.assign({}, t[e][1].start);
          $t(h, -c), $t(f, c), i = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: Object.assign({}, t[r][1].end)
          }, l = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, t[e][1].start),
            end: f
          }, a = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, t[r][1].end),
            end: Object.assign({}, t[e][1].start)
          }, u = {
            type: c > 1 ? "strong" : "emphasis",
            start: Object.assign({}, i.start),
            end: Object.assign({}, l.end)
          }, t[r][1].end = Object.assign({}, i.start), t[e][1].start = Object.assign({}, l.end), o = [], t[r][1].end.offset - t[r][1].start.offset && (o = j(o, [["enter", t[r][1], n], ["exit", t[r][1], n]])), o = j(o, [["enter", u, n], ["enter", i, n], ["exit", i, n], ["enter", a, n]]), o = j(o, yt(n.parser.constructs.insideSpan.null, t.slice(r + 1, e), n)), o = j(o, [["exit", a, n], ["enter", l, n], ["exit", l, n], ["exit", u, n]]), t[e][1].end.offset - t[e][1].start.offset ? (p = 2, o = j(o, [["enter", t[e][1], n], ["exit", t[e][1], n]])) : p = 0, $(t, r - 1, e - r + 3, o), e = r + o.length - p - 2;
          break;
        }
    }
  for (e = -1; ++e < t.length; )
    t[e][1].type === "attentionSequence" && (t[e][1].type = "data");
  return t;
}
function pn(t, n) {
  const e = this.parser.constructs.attentionMarkers.null, r = this.previous, u = St(r);
  let a;
  return i;
  function i(c) {
    return a = c, t.enter("attentionSequence"), l(c);
  }
  function l(c) {
    if (c === a)
      return t.consume(c), l;
    const o = t.exit("attentionSequence"), p = St(c), h = !p || p === 2 && u || e.includes(c), f = !u || u === 2 && p || e.includes(r);
    return o._open = !!(a === 42 ? h : h && (u || !f)), o._close = !!(a === 42 ? f : f && (p || !h)), n(c);
  }
}
function $t(t, n) {
  t.column += n, t.offset += n, t._bufferIndex += n;
}
const gn = {
  name: "autolink",
  tokenize: mn
};
function mn(t, n, e) {
  let r = 0;
  return u;
  function u(s) {
    return t.enter("autolink"), t.enter("autolinkMarker"), t.consume(s), t.exit("autolinkMarker"), t.enter("autolinkProtocol"), a;
  }
  function a(s) {
    return W(s) ? (t.consume(s), i) : s === 64 ? e(s) : o(s);
  }
  function i(s) {
    return s === 43 || s === 45 || s === 46 || U(s) ? (r = 1, l(s)) : o(s);
  }
  function l(s) {
    return s === 58 ? (t.consume(s), r = 0, c) : (s === 43 || s === 45 || s === 46 || U(s)) && r++ < 32 ? (t.consume(s), l) : (r = 0, o(s));
  }
  function c(s) {
    return s === 62 ? (t.exit("autolinkProtocol"), t.enter("autolinkMarker"), t.consume(s), t.exit("autolinkMarker"), t.exit("autolink"), n) : s === null || s === 32 || s === 60 || vt(s) ? e(s) : (t.consume(s), c);
  }
  function o(s) {
    return s === 64 ? (t.consume(s), p) : Je(s) ? (t.consume(s), o) : e(s);
  }
  function p(s) {
    return U(s) ? h(s) : e(s);
  }
  function h(s) {
    return s === 46 ? (t.consume(s), r = 0, p) : s === 62 ? (t.exit("autolinkProtocol").type = "autolinkEmail", t.enter("autolinkMarker"), t.consume(s), t.exit("autolinkMarker"), t.exit("autolink"), n) : f(s);
  }
  function f(s) {
    if ((s === 45 || U(s)) && r++ < 63) {
      const b = s === 45 ? f : h;
      return t.consume(s), b;
    }
    return e(s);
  }
}
const dt = {
  tokenize: fn,
  partial: !0
};
function fn(t, n, e) {
  return r;
  function r(a) {
    return R(a) ? N(t, u, "linePrefix")(a) : u(a);
  }
  function u(a) {
    return a === null || z(a) ? n(a) : e(a);
  }
}
const ue = {
  name: "blockQuote",
  tokenize: bn,
  continuation: {
    tokenize: dn
  },
  exit: xn
};
function bn(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    if (i === 62) {
      const l = r.containerState;
      return l.open || (t.enter("blockQuote", {
        _container: !0
      }), l.open = !0), t.enter("blockQuotePrefix"), t.enter("blockQuoteMarker"), t.consume(i), t.exit("blockQuoteMarker"), a;
    }
    return e(i);
  }
  function a(i) {
    return R(i) ? (t.enter("blockQuotePrefixWhitespace"), t.consume(i), t.exit("blockQuotePrefixWhitespace"), t.exit("blockQuotePrefix"), n) : (t.exit("blockQuotePrefix"), n(i));
  }
}
function dn(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return R(i) ? N(t, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(i) : a(i);
  }
  function a(i) {
    return t.attempt(ue, n, e)(i);
  }
}
function xn(t) {
  t.exit("blockQuote");
}
const le = {
  name: "characterEscape",
  tokenize: kn
};
function kn(t, n, e) {
  return r;
  function r(a) {
    return t.enter("characterEscape"), t.enter("escapeMarker"), t.consume(a), t.exit("escapeMarker"), u;
  }
  function u(a) {
    return Xe(a) ? (t.enter("characterEscapeValue"), t.consume(a), t.exit("characterEscapeValue"), t.exit("characterEscape"), n) : e(a);
  }
}
const oe = {
  name: "characterReference",
  tokenize: wn
};
function wn(t, n, e) {
  const r = this;
  let u = 0, a, i;
  return l;
  function l(h) {
    return t.enter("characterReference"), t.enter("characterReferenceMarker"), t.consume(h), t.exit("characterReferenceMarker"), c;
  }
  function c(h) {
    return h === 35 ? (t.enter("characterReferenceMarkerNumeric"), t.consume(h), t.exit("characterReferenceMarkerNumeric"), o) : (t.enter("characterReferenceValue"), a = 31, i = U, p(h));
  }
  function o(h) {
    return h === 88 || h === 120 ? (t.enter("characterReferenceMarkerHexadecimal"), t.consume(h), t.exit("characterReferenceMarkerHexadecimal"), t.enter("characterReferenceValue"), a = 6, i = Ke, p) : (t.enter("characterReferenceValue"), a = 7, i = zt, p(h));
  }
  function p(h) {
    if (h === 59 && u) {
      const f = t.exit("characterReferenceValue");
      return i === U && !wt(r.sliceSerialize(f)) ? e(h) : (t.enter("characterReferenceMarker"), t.consume(h), t.exit("characterReferenceMarker"), t.exit("characterReference"), n);
    }
    return i(h) && u++ < a ? (t.consume(h), p) : e(h);
  }
}
const Yt = {
  tokenize: yn,
  partial: !0
}, Zt = {
  name: "codeFenced",
  tokenize: Sn,
  concrete: !0
};
function Sn(t, n, e) {
  const r = this, u = {
    tokenize: v,
    partial: !0
  };
  let a = 0, i = 0, l;
  return c;
  function c(S) {
    return o(S);
  }
  function o(S) {
    const y = r.events[r.events.length - 1];
    return a = y && y[1].type === "linePrefix" ? y[2].sliceSerialize(y[1], !0).length : 0, l = S, t.enter("codeFenced"), t.enter("codeFencedFence"), t.enter("codeFencedFenceSequence"), p(S);
  }
  function p(S) {
    return S === l ? (i++, t.consume(S), p) : i < 3 ? e(S) : (t.exit("codeFencedFenceSequence"), R(S) ? N(t, h, "whitespace")(S) : h(S));
  }
  function h(S) {
    return S === null || z(S) ? (t.exit("codeFencedFence"), r.interrupt ? n(S) : t.check(Yt, C, T)(S)) : (t.enter("codeFencedFenceInfo"), t.enter("chunkString", {
      contentType: "string"
    }), f(S));
  }
  function f(S) {
    return S === null || z(S) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), h(S)) : R(S) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), N(t, s, "whitespace")(S)) : S === 96 && S === l ? e(S) : (t.consume(S), f);
  }
  function s(S) {
    return S === null || z(S) ? h(S) : (t.enter("codeFencedFenceMeta"), t.enter("chunkString", {
      contentType: "string"
    }), b(S));
  }
  function b(S) {
    return S === null || z(S) ? (t.exit("chunkString"), t.exit("codeFencedFenceMeta"), h(S)) : S === 96 && S === l ? e(S) : (t.consume(S), b);
  }
  function C(S) {
    return t.attempt(u, T, k)(S);
  }
  function k(S) {
    return t.enter("lineEnding"), t.consume(S), t.exit("lineEnding"), w;
  }
  function w(S) {
    return a > 0 && R(S) ? N(t, E, "linePrefix", a + 1)(S) : E(S);
  }
  function E(S) {
    return S === null || z(S) ? t.check(Yt, C, T)(S) : (t.enter("codeFlowValue"), A(S));
  }
  function A(S) {
    return S === null || z(S) ? (t.exit("codeFlowValue"), E(S)) : (t.consume(S), A);
  }
  function T(S) {
    return t.exit("codeFenced"), n(S);
  }
  function v(S, y, F) {
    let P = 0;
    return x;
    function x(d) {
      return S.enter("lineEnding"), S.consume(d), S.exit("lineEnding"), L;
    }
    function L(d) {
      return S.enter("codeFencedFence"), R(d) ? N(S, D, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(d) : D(d);
    }
    function D(d) {
      return d === l ? (S.enter("codeFencedFenceSequence"), B(d)) : F(d);
    }
    function B(d) {
      return d === l ? (P++, S.consume(d), B) : P >= i ? (S.exit("codeFencedFenceSequence"), R(d) ? N(S, O, "whitespace")(d) : O(d)) : F(d);
    }
    function O(d) {
      return d === null || z(d) ? (S.exit("codeFencedFence"), y(d)) : F(d);
    }
  }
}
function yn(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return i === null ? e(i) : (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), a);
  }
  function a(i) {
    return r.parser.lazy[r.now().line] ? e(i) : n(i);
  }
}
const At = {
  name: "codeIndented",
  tokenize: An
}, Cn = {
  tokenize: En,
  partial: !0
};
function An(t, n, e) {
  const r = this;
  return u;
  function u(o) {
    return t.enter("codeIndented"), N(t, a, "linePrefix", 5)(o);
  }
  function a(o) {
    const p = r.events[r.events.length - 1];
    return p && p[1].type === "linePrefix" && p[2].sliceSerialize(p[1], !0).length >= 4 ? i(o) : e(o);
  }
  function i(o) {
    return o === null ? c(o) : z(o) ? t.attempt(Cn, i, c)(o) : (t.enter("codeFlowValue"), l(o));
  }
  function l(o) {
    return o === null || z(o) ? (t.exit("codeFlowValue"), i(o)) : (t.consume(o), l);
  }
  function c(o) {
    return t.exit("codeIndented"), n(o);
  }
}
function En(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return r.parser.lazy[r.now().line] ? e(i) : z(i) ? (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), u) : N(t, a, "linePrefix", 5)(i);
  }
  function a(i) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? n(i) : z(i) ? u(i) : e(i);
  }
}
const Dn = {
  name: "codeText",
  tokenize: vn,
  resolve: qn,
  previous: Ln
};
function qn(t) {
  let n = t.length - 4, e = 3, r, u;
  if ((t[e][1].type === "lineEnding" || t[e][1].type === "space") && (t[n][1].type === "lineEnding" || t[n][1].type === "space")) {
    for (r = e; ++r < n; )
      if (t[r][1].type === "codeTextData") {
        t[e][1].type = "codeTextPadding", t[n][1].type = "codeTextPadding", e += 2, n -= 2;
        break;
      }
  }
  for (r = e - 1, n++; ++r <= n; )
    u === void 0 ? r !== n && t[r][1].type !== "lineEnding" && (u = r) : (r === n || t[r][1].type === "lineEnding") && (t[u][1].type = "codeTextData", r !== u + 2 && (t[u][1].end = t[r - 1][1].end, t.splice(u + 2, r - u - 2), n -= r - u - 2, r = u + 2), u = void 0);
  return t;
}
function Ln(t) {
  return t !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function vn(t, n, e) {
  let r = 0, u, a;
  return i;
  function i(h) {
    return t.enter("codeText"), t.enter("codeTextSequence"), l(h);
  }
  function l(h) {
    return h === 96 ? (t.consume(h), r++, l) : (t.exit("codeTextSequence"), c(h));
  }
  function c(h) {
    return h === null ? e(h) : h === 32 ? (t.enter("space"), t.consume(h), t.exit("space"), c) : h === 96 ? (a = t.enter("codeTextSequence"), u = 0, p(h)) : z(h) ? (t.enter("lineEnding"), t.consume(h), t.exit("lineEnding"), c) : (t.enter("codeTextData"), o(h));
  }
  function o(h) {
    return h === null || h === 32 || h === 96 || z(h) ? (t.exit("codeTextData"), c(h)) : (t.consume(h), o);
  }
  function p(h) {
    return h === 96 ? (t.consume(h), u++, p) : u === r ? (t.exit("codeTextSequence"), t.exit("codeText"), n(h)) : (a.type = "codeTextData", o(h));
  }
}
class zn {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(n) {
    this.left = n ? [...n] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(n) {
    if (n < 0 || n >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + n + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return n < this.left.length ? this.left[n] : this.right[this.right.length - n + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(n, e) {
    const r = e ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(n, r) : n > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - n + this.left.length).reverse() : this.left.slice(n).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(n, e, r) {
    const u = e || 0;
    this.setCursor(Math.trunc(n));
    const a = this.right.splice(this.right.length - u, Number.POSITIVE_INFINITY);
    return r && bt(this.left, r), a.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(n) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(n);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(n) {
    this.setCursor(Number.POSITIVE_INFINITY), bt(this.left, n);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(n) {
    this.setCursor(0), this.right.push(n);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(n) {
    this.setCursor(0), bt(this.right, n.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n) {
    if (!(n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0))
      if (n < this.left.length) {
        const e = this.left.splice(n, Number.POSITIVE_INFINITY);
        bt(this.right, e.reverse());
      } else {
        const e = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);
        bt(this.left, e.reverse());
      }
  }
}
function bt(t, n) {
  let e = 0;
  if (n.length < 1e4)
    t.push(...n);
  else
    for (; e < n.length; )
      t.push(...n.slice(e, e + 1e4)), e += 1e4;
}
function se(t) {
  const n = {};
  let e = -1, r, u, a, i, l, c, o;
  const p = new zn(t);
  for (; ++e < p.length; ) {
    for (; e in n; )
      e = n[e];
    if (r = p.get(e), e && r[1].type === "chunkFlow" && p.get(e - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, a = 0, a < c.length && c[a][1].type === "lineEndingBlank" && (a += 2), a < c.length && c[a][1].type === "content"))
      for (; ++a < c.length && c[a][1].type !== "content"; )
        c[a][1].type === "chunkText" && (c[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(n, In(p, e)), e = n[e], o = !0);
    else if (r[1]._container) {
      for (a = e, u = void 0; a-- && (i = p.get(a), i[1].type === "lineEnding" || i[1].type === "lineEndingBlank"); )
        i[0] === "enter" && (u && (p.get(u)[1].type = "lineEndingBlank"), i[1].type = "lineEnding", u = a);
      u && (r[1].end = Object.assign({}, p.get(u)[1].start), l = p.slice(u, e), l.unshift(r), p.splice(u, e - u + 1, l));
    }
  }
  return $(t, 0, Number.POSITIVE_INFINITY, p.slice(0)), !o;
}
function In(t, n) {
  const e = t.get(n)[1], r = t.get(n)[2];
  let u = n - 1;
  const a = [], i = e._tokenizer || r.parser[e.contentType](e.start), l = i.events, c = [], o = {};
  let p, h, f = -1, s = e, b = 0, C = 0;
  const k = [C];
  for (; s; ) {
    for (; t.get(++u)[1] !== s; )
      ;
    a.push(u), s._tokenizer || (p = r.sliceStream(s), s.next || p.push(null), h && i.defineSkip(s.start), s._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = !0), i.write(p), s._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = void 0)), h = s, s = s.next;
  }
  for (s = e; ++f < l.length; )
    // Find a void token that includes a break.
    l[f][0] === "exit" && l[f - 1][0] === "enter" && l[f][1].type === l[f - 1][1].type && l[f][1].start.line !== l[f][1].end.line && (C = f + 1, k.push(C), s._tokenizer = void 0, s.previous = void 0, s = s.next);
  for (i.events = [], s ? (s._tokenizer = void 0, s.previous = void 0) : k.pop(), f = k.length; f--; ) {
    const w = l.slice(k[f], k[f + 1]), E = a.pop();
    c.push([E, E + w.length - 1]), t.splice(E, 2, w);
  }
  for (c.reverse(), f = -1; ++f < c.length; )
    o[b + c[f][0]] = b + c[f][1], b += c[f][1] - c[f][0] - 1;
  return o;
}
const Tn = {
  tokenize: On,
  resolve: Nn
}, Fn = {
  tokenize: Rn,
  partial: !0
};
function Nn(t) {
  return se(t), t;
}
function On(t, n) {
  let e;
  return r;
  function r(l) {
    return t.enter("content"), e = t.enter("chunkContent", {
      contentType: "content"
    }), u(l);
  }
  function u(l) {
    return l === null ? a(l) : z(l) ? t.check(Fn, i, a)(l) : (t.consume(l), u);
  }
  function a(l) {
    return t.exit("chunkContent"), t.exit("content"), n(l);
  }
  function i(l) {
    return t.consume(l), t.exit("chunkContent"), e.next = t.enter("chunkContent", {
      contentType: "content",
      previous: e
    }), e = e.next, u;
  }
}
function Rn(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return t.exit("chunkContent"), t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), N(t, a, "linePrefix");
  }
  function a(i) {
    if (i === null || z(i))
      return e(i);
    const l = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? n(i) : t.interrupt(r.parser.constructs.flow, e, n)(i);
  }
}
function ce(t, n, e, r, u, a, i, l, c) {
  const o = c || Number.POSITIVE_INFINITY;
  let p = 0;
  return h;
  function h(w) {
    return w === 60 ? (t.enter(r), t.enter(u), t.enter(a), t.consume(w), t.exit(a), f) : w === null || w === 32 || w === 41 || vt(w) ? e(w) : (t.enter(r), t.enter(i), t.enter(l), t.enter("chunkString", {
      contentType: "string"
    }), C(w));
  }
  function f(w) {
    return w === 62 ? (t.enter(a), t.consume(w), t.exit(a), t.exit(u), t.exit(r), n) : (t.enter(l), t.enter("chunkString", {
      contentType: "string"
    }), s(w));
  }
  function s(w) {
    return w === 62 ? (t.exit("chunkString"), t.exit(l), f(w)) : w === null || w === 60 || z(w) ? e(w) : (t.consume(w), w === 92 ? b : s);
  }
  function b(w) {
    return w === 60 || w === 62 || w === 92 ? (t.consume(w), s) : s(w);
  }
  function C(w) {
    return !p && (w === null || w === 41 || _(w)) ? (t.exit("chunkString"), t.exit(l), t.exit(i), t.exit(r), n(w)) : p < o && w === 40 ? (t.consume(w), p++, C) : w === 41 ? (t.consume(w), p--, C) : w === null || w === 32 || w === 40 || vt(w) ? e(w) : (t.consume(w), w === 92 ? k : C);
  }
  function k(w) {
    return w === 40 || w === 41 || w === 92 ? (t.consume(w), C) : C(w);
  }
}
function he(t, n, e, r, u, a) {
  const i = this;
  let l = 0, c;
  return o;
  function o(s) {
    return t.enter(r), t.enter(u), t.consume(s), t.exit(u), t.enter(a), p;
  }
  function p(s) {
    return l > 999 || s === null || s === 91 || s === 93 && !c || // To do: remove in the future once weâ€™ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnâ€™t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    s === 94 && !l && "_hiddenFootnoteSupport" in i.parser.constructs ? e(s) : s === 93 ? (t.exit(a), t.enter(u), t.consume(s), t.exit(u), t.exit(r), n) : z(s) ? (t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), p) : (t.enter("chunkString", {
      contentType: "string"
    }), h(s));
  }
  function h(s) {
    return s === null || s === 91 || s === 93 || z(s) || l++ > 999 ? (t.exit("chunkString"), p(s)) : (t.consume(s), c || (c = !R(s)), s === 92 ? f : h);
  }
  function f(s) {
    return s === 91 || s === 92 || s === 93 ? (t.consume(s), l++, h) : h(s);
  }
}
function pe(t, n, e, r, u, a) {
  let i;
  return l;
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? (t.enter(r), t.enter(u), t.consume(f), t.exit(u), i = f === 40 ? 41 : f, c) : e(f);
  }
  function c(f) {
    return f === i ? (t.enter(u), t.consume(f), t.exit(u), t.exit(r), n) : (t.enter(a), o(f));
  }
  function o(f) {
    return f === i ? (t.exit(a), c(i)) : f === null ? e(f) : z(f) ? (t.enter("lineEnding"), t.consume(f), t.exit("lineEnding"), N(t, o, "linePrefix")) : (t.enter("chunkString", {
      contentType: "string"
    }), p(f));
  }
  function p(f) {
    return f === i || f === null || z(f) ? (t.exit("chunkString"), o(f)) : (t.consume(f), f === 92 ? h : p);
  }
  function h(f) {
    return f === i || f === 92 ? (t.consume(f), p) : p(f);
  }
}
function at(t, n) {
  let e;
  return r;
  function r(u) {
    return z(u) ? (t.enter("lineEnding"), t.consume(u), t.exit("lineEnding"), e = !0, r) : R(u) ? N(
      t,
      r,
      e ? "linePrefix" : "lineSuffix"
    )(u) : n(u);
  }
}
const Bn = {
  name: "definition",
  tokenize: _n
}, Pn = {
  tokenize: Mn,
  partial: !0
};
function _n(t, n, e) {
  const r = this;
  let u;
  return a;
  function a(s) {
    return t.enter("definition"), i(s);
  }
  function i(s) {
    return he.call(
      r,
      t,
      l,
      // Note: we donâ€™t need to reset the way `markdown-rs` does.
      e,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(s);
  }
  function l(s) {
    return u = et(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), s === 58 ? (t.enter("definitionMarker"), t.consume(s), t.exit("definitionMarker"), c) : e(s);
  }
  function c(s) {
    return _(s) ? at(t, o)(s) : o(s);
  }
  function o(s) {
    return ce(
      t,
      p,
      // Note: we donâ€™t need to reset the way `markdown-rs` does.
      e,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(s);
  }
  function p(s) {
    return t.attempt(Pn, h, h)(s);
  }
  function h(s) {
    return R(s) ? N(t, f, "whitespace")(s) : f(s);
  }
  function f(s) {
    return s === null || z(s) ? (t.exit("definition"), r.parser.defined.push(u), n(s)) : e(s);
  }
}
function Mn(t, n, e) {
  return r;
  function r(l) {
    return _(l) ? at(t, u)(l) : e(l);
  }
  function u(l) {
    return pe(t, a, e, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(l);
  }
  function a(l) {
    return R(l) ? N(t, i, "whitespace")(l) : i(l);
  }
  function i(l) {
    return l === null || z(l) ? n(l) : e(l);
  }
}
const Vn = {
  name: "hardBreakEscape",
  tokenize: Hn
};
function Hn(t, n, e) {
  return r;
  function r(a) {
    return t.enter("hardBreakEscape"), t.consume(a), u;
  }
  function u(a) {
    return z(a) ? (t.exit("hardBreakEscape"), n(a)) : e(a);
  }
}
const jn = {
  name: "headingAtx",
  tokenize: Gn,
  resolve: Un
};
function Un(t, n) {
  let e = t.length - 2, r = 3, u, a;
  return t[r][1].type === "whitespace" && (r += 2), e - 2 > r && t[e][1].type === "whitespace" && (e -= 2), t[e][1].type === "atxHeadingSequence" && (r === e - 1 || e - 4 > r && t[e - 2][1].type === "whitespace") && (e -= r + 1 === e ? 2 : 4), e > r && (u = {
    type: "atxHeadingText",
    start: t[r][1].start,
    end: t[e][1].end
  }, a = {
    type: "chunkText",
    start: t[r][1].start,
    end: t[e][1].end,
    contentType: "text"
  }, $(t, r, e - r + 1, [["enter", u, n], ["enter", a, n], ["exit", a, n], ["exit", u, n]])), t;
}
function Gn(t, n, e) {
  let r = 0;
  return u;
  function u(p) {
    return t.enter("atxHeading"), a(p);
  }
  function a(p) {
    return t.enter("atxHeadingSequence"), i(p);
  }
  function i(p) {
    return p === 35 && r++ < 6 ? (t.consume(p), i) : p === null || _(p) ? (t.exit("atxHeadingSequence"), l(p)) : e(p);
  }
  function l(p) {
    return p === 35 ? (t.enter("atxHeadingSequence"), c(p)) : p === null || z(p) ? (t.exit("atxHeading"), n(p)) : R(p) ? N(t, l, "whitespace")(p) : (t.enter("atxHeadingText"), o(p));
  }
  function c(p) {
    return p === 35 ? (t.consume(p), c) : (t.exit("atxHeadingSequence"), l(p));
  }
  function o(p) {
    return p === null || p === 35 || _(p) ? (t.exit("atxHeadingText"), l(p)) : (t.consume(p), o);
  }
}
const Qn = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Jt = ["pre", "script", "style", "textarea"], Wn = {
  name: "htmlFlow",
  tokenize: Jn,
  resolveTo: Zn,
  concrete: !0
}, $n = {
  tokenize: Xn,
  partial: !0
}, Yn = {
  tokenize: Kn,
  partial: !0
};
function Zn(t) {
  let n = t.length;
  for (; n-- && !(t[n][0] === "enter" && t[n][1].type === "htmlFlow"); )
    ;
  return n > 1 && t[n - 2][1].type === "linePrefix" && (t[n][1].start = t[n - 2][1].start, t[n + 1][1].start = t[n - 2][1].start, t.splice(n - 2, 2)), t;
}
function Jn(t, n, e) {
  const r = this;
  let u, a, i, l, c;
  return o;
  function o(m) {
    return p(m);
  }
  function p(m) {
    return t.enter("htmlFlow"), t.enter("htmlFlowData"), t.consume(m), h;
  }
  function h(m) {
    return m === 33 ? (t.consume(m), f) : m === 47 ? (t.consume(m), a = !0, C) : m === 63 ? (t.consume(m), u = 3, r.interrupt ? n : g) : W(m) ? (t.consume(m), i = String.fromCharCode(m), k) : e(m);
  }
  function f(m) {
    return m === 45 ? (t.consume(m), u = 2, s) : m === 91 ? (t.consume(m), u = 5, l = 0, b) : W(m) ? (t.consume(m), u = 4, r.interrupt ? n : g) : e(m);
  }
  function s(m) {
    return m === 45 ? (t.consume(m), r.interrupt ? n : g) : e(m);
  }
  function b(m) {
    const J = "CDATA[";
    return m === J.charCodeAt(l++) ? (t.consume(m), l === J.length ? r.interrupt ? n : D : b) : e(m);
  }
  function C(m) {
    return W(m) ? (t.consume(m), i = String.fromCharCode(m), k) : e(m);
  }
  function k(m) {
    if (m === null || m === 47 || m === 62 || _(m)) {
      const J = m === 47, ot = i.toLowerCase();
      return !J && !a && Jt.includes(ot) ? (u = 1, r.interrupt ? n(m) : D(m)) : Qn.includes(i.toLowerCase()) ? (u = 6, J ? (t.consume(m), w) : r.interrupt ? n(m) : D(m)) : (u = 7, r.interrupt && !r.parser.lazy[r.now().line] ? e(m) : a ? E(m) : A(m));
    }
    return m === 45 || U(m) ? (t.consume(m), i += String.fromCharCode(m), k) : e(m);
  }
  function w(m) {
    return m === 62 ? (t.consume(m), r.interrupt ? n : D) : e(m);
  }
  function E(m) {
    return R(m) ? (t.consume(m), E) : x(m);
  }
  function A(m) {
    return m === 47 ? (t.consume(m), x) : m === 58 || m === 95 || W(m) ? (t.consume(m), T) : R(m) ? (t.consume(m), A) : x(m);
  }
  function T(m) {
    return m === 45 || m === 46 || m === 58 || m === 95 || U(m) ? (t.consume(m), T) : v(m);
  }
  function v(m) {
    return m === 61 ? (t.consume(m), S) : R(m) ? (t.consume(m), v) : A(m);
  }
  function S(m) {
    return m === null || m === 60 || m === 61 || m === 62 || m === 96 ? e(m) : m === 34 || m === 39 ? (t.consume(m), c = m, y) : R(m) ? (t.consume(m), S) : F(m);
  }
  function y(m) {
    return m === c ? (t.consume(m), c = null, P) : m === null || z(m) ? e(m) : (t.consume(m), y);
  }
  function F(m) {
    return m === null || m === 34 || m === 39 || m === 47 || m === 60 || m === 61 || m === 62 || m === 96 || _(m) ? v(m) : (t.consume(m), F);
  }
  function P(m) {
    return m === 47 || m === 62 || R(m) ? A(m) : e(m);
  }
  function x(m) {
    return m === 62 ? (t.consume(m), L) : e(m);
  }
  function L(m) {
    return m === null || z(m) ? D(m) : R(m) ? (t.consume(m), L) : e(m);
  }
  function D(m) {
    return m === 45 && u === 2 ? (t.consume(m), M) : m === 60 && u === 1 ? (t.consume(m), V) : m === 62 && u === 4 ? (t.consume(m), Z) : m === 63 && u === 3 ? (t.consume(m), g) : m === 93 && u === 5 ? (t.consume(m), nt) : z(m) && (u === 6 || u === 7) ? (t.exit("htmlFlowData"), t.check($n, rt, B)(m)) : m === null || z(m) ? (t.exit("htmlFlowData"), B(m)) : (t.consume(m), D);
  }
  function B(m) {
    return t.check(Yn, O, rt)(m);
  }
  function O(m) {
    return t.enter("lineEnding"), t.consume(m), t.exit("lineEnding"), d;
  }
  function d(m) {
    return m === null || z(m) ? B(m) : (t.enter("htmlFlowData"), D(m));
  }
  function M(m) {
    return m === 45 ? (t.consume(m), g) : D(m);
  }
  function V(m) {
    return m === 47 ? (t.consume(m), i = "", Y) : D(m);
  }
  function Y(m) {
    if (m === 62) {
      const J = i.toLowerCase();
      return Jt.includes(J) ? (t.consume(m), Z) : D(m);
    }
    return W(m) && i.length < 8 ? (t.consume(m), i += String.fromCharCode(m), Y) : D(m);
  }
  function nt(m) {
    return m === 93 ? (t.consume(m), g) : D(m);
  }
  function g(m) {
    return m === 62 ? (t.consume(m), Z) : m === 45 && u === 2 ? (t.consume(m), g) : D(m);
  }
  function Z(m) {
    return m === null || z(m) ? (t.exit("htmlFlowData"), rt(m)) : (t.consume(m), Z);
  }
  function rt(m) {
    return t.exit("htmlFlow"), n(m);
  }
}
function Kn(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return z(i) ? (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), a) : e(i);
  }
  function a(i) {
    return r.parser.lazy[r.now().line] ? e(i) : n(i);
  }
}
function Xn(t, n, e) {
  return r;
  function r(u) {
    return t.enter("lineEnding"), t.consume(u), t.exit("lineEnding"), t.attempt(dt, n, e);
  }
}
const tr = {
  name: "htmlText",
  tokenize: er
};
function er(t, n, e) {
  const r = this;
  let u, a, i;
  return l;
  function l(g) {
    return t.enter("htmlText"), t.enter("htmlTextData"), t.consume(g), c;
  }
  function c(g) {
    return g === 33 ? (t.consume(g), o) : g === 47 ? (t.consume(g), v) : g === 63 ? (t.consume(g), A) : W(g) ? (t.consume(g), F) : e(g);
  }
  function o(g) {
    return g === 45 ? (t.consume(g), p) : g === 91 ? (t.consume(g), a = 0, b) : W(g) ? (t.consume(g), E) : e(g);
  }
  function p(g) {
    return g === 45 ? (t.consume(g), s) : e(g);
  }
  function h(g) {
    return g === null ? e(g) : g === 45 ? (t.consume(g), f) : z(g) ? (i = h, V(g)) : (t.consume(g), h);
  }
  function f(g) {
    return g === 45 ? (t.consume(g), s) : h(g);
  }
  function s(g) {
    return g === 62 ? M(g) : g === 45 ? f(g) : h(g);
  }
  function b(g) {
    const Z = "CDATA[";
    return g === Z.charCodeAt(a++) ? (t.consume(g), a === Z.length ? C : b) : e(g);
  }
  function C(g) {
    return g === null ? e(g) : g === 93 ? (t.consume(g), k) : z(g) ? (i = C, V(g)) : (t.consume(g), C);
  }
  function k(g) {
    return g === 93 ? (t.consume(g), w) : C(g);
  }
  function w(g) {
    return g === 62 ? M(g) : g === 93 ? (t.consume(g), w) : C(g);
  }
  function E(g) {
    return g === null || g === 62 ? M(g) : z(g) ? (i = E, V(g)) : (t.consume(g), E);
  }
  function A(g) {
    return g === null ? e(g) : g === 63 ? (t.consume(g), T) : z(g) ? (i = A, V(g)) : (t.consume(g), A);
  }
  function T(g) {
    return g === 62 ? M(g) : A(g);
  }
  function v(g) {
    return W(g) ? (t.consume(g), S) : e(g);
  }
  function S(g) {
    return g === 45 || U(g) ? (t.consume(g), S) : y(g);
  }
  function y(g) {
    return z(g) ? (i = y, V(g)) : R(g) ? (t.consume(g), y) : M(g);
  }
  function F(g) {
    return g === 45 || U(g) ? (t.consume(g), F) : g === 47 || g === 62 || _(g) ? P(g) : e(g);
  }
  function P(g) {
    return g === 47 ? (t.consume(g), M) : g === 58 || g === 95 || W(g) ? (t.consume(g), x) : z(g) ? (i = P, V(g)) : R(g) ? (t.consume(g), P) : M(g);
  }
  function x(g) {
    return g === 45 || g === 46 || g === 58 || g === 95 || U(g) ? (t.consume(g), x) : L(g);
  }
  function L(g) {
    return g === 61 ? (t.consume(g), D) : z(g) ? (i = L, V(g)) : R(g) ? (t.consume(g), L) : P(g);
  }
  function D(g) {
    return g === null || g === 60 || g === 61 || g === 62 || g === 96 ? e(g) : g === 34 || g === 39 ? (t.consume(g), u = g, B) : z(g) ? (i = D, V(g)) : R(g) ? (t.consume(g), D) : (t.consume(g), O);
  }
  function B(g) {
    return g === u ? (t.consume(g), u = void 0, d) : g === null ? e(g) : z(g) ? (i = B, V(g)) : (t.consume(g), B);
  }
  function O(g) {
    return g === null || g === 34 || g === 39 || g === 60 || g === 61 || g === 96 ? e(g) : g === 47 || g === 62 || _(g) ? P(g) : (t.consume(g), O);
  }
  function d(g) {
    return g === 47 || g === 62 || _(g) ? P(g) : e(g);
  }
  function M(g) {
    return g === 62 ? (t.consume(g), t.exit("htmlTextData"), t.exit("htmlText"), n) : e(g);
  }
  function V(g) {
    return t.exit("htmlTextData"), t.enter("lineEnding"), t.consume(g), t.exit("lineEnding"), Y;
  }
  function Y(g) {
    return R(g) ? N(t, nt, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(g) : nt(g);
  }
  function nt(g) {
    return t.enter("htmlTextData"), i(g);
  }
}
const Tt = {
  name: "labelEnd",
  tokenize: lr,
  resolveTo: ur,
  resolveAll: ar
}, nr = {
  tokenize: or
}, rr = {
  tokenize: sr
}, ir = {
  tokenize: cr
};
function ar(t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const e = t[n][1];
    (e.type === "labelImage" || e.type === "labelLink" || e.type === "labelEnd") && (t.splice(n + 1, e.type === "labelImage" ? 4 : 2), e.type = "data", n++);
  }
  return t;
}
function ur(t, n) {
  let e = t.length, r = 0, u, a, i, l;
  for (; e--; )
    if (u = t[e][1], a) {
      if (u.type === "link" || u.type === "labelLink" && u._inactive)
        break;
      t[e][0] === "enter" && u.type === "labelLink" && (u._inactive = !0);
    } else if (i) {
      if (t[e][0] === "enter" && (u.type === "labelImage" || u.type === "labelLink") && !u._balanced && (a = e, u.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else u.type === "labelEnd" && (i = e);
  const c = {
    type: t[a][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, t[a][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  }, o = {
    type: "label",
    start: Object.assign({}, t[a][1].start),
    end: Object.assign({}, t[i][1].end)
  }, p = {
    type: "labelText",
    start: Object.assign({}, t[a + r + 2][1].end),
    end: Object.assign({}, t[i - 2][1].start)
  };
  return l = [["enter", c, n], ["enter", o, n]], l = j(l, t.slice(a + 1, a + r + 3)), l = j(l, [["enter", p, n]]), l = j(l, yt(n.parser.constructs.insideSpan.null, t.slice(a + r + 4, i - 3), n)), l = j(l, [["exit", p, n], t[i - 2], t[i - 1], ["exit", o, n]]), l = j(l, t.slice(i + 1)), l = j(l, [["exit", c, n]]), $(t, a, t.length, l), t;
}
function lr(t, n, e) {
  const r = this;
  let u = r.events.length, a, i;
  for (; u--; )
    if ((r.events[u][1].type === "labelImage" || r.events[u][1].type === "labelLink") && !r.events[u][1]._balanced) {
      a = r.events[u][1];
      break;
    }
  return l;
  function l(f) {
    return a ? a._inactive ? h(f) : (i = r.parser.defined.includes(et(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }))), t.enter("labelEnd"), t.enter("labelMarker"), t.consume(f), t.exit("labelMarker"), t.exit("labelEnd"), c) : e(f);
  }
  function c(f) {
    return f === 40 ? t.attempt(nr, p, i ? p : h)(f) : f === 91 ? t.attempt(rr, p, i ? o : h)(f) : i ? p(f) : h(f);
  }
  function o(f) {
    return t.attempt(ir, p, h)(f);
  }
  function p(f) {
    return n(f);
  }
  function h(f) {
    return a._balanced = !0, e(f);
  }
}
function or(t, n, e) {
  return r;
  function r(h) {
    return t.enter("resource"), t.enter("resourceMarker"), t.consume(h), t.exit("resourceMarker"), u;
  }
  function u(h) {
    return _(h) ? at(t, a)(h) : a(h);
  }
  function a(h) {
    return h === 41 ? p(h) : ce(t, i, l, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function i(h) {
    return _(h) ? at(t, c)(h) : p(h);
  }
  function l(h) {
    return e(h);
  }
  function c(h) {
    return h === 34 || h === 39 || h === 40 ? pe(t, o, e, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : p(h);
  }
  function o(h) {
    return _(h) ? at(t, p)(h) : p(h);
  }
  function p(h) {
    return h === 41 ? (t.enter("resourceMarker"), t.consume(h), t.exit("resourceMarker"), t.exit("resource"), n) : e(h);
  }
}
function sr(t, n, e) {
  const r = this;
  return u;
  function u(l) {
    return he.call(r, t, a, i, "reference", "referenceMarker", "referenceString")(l);
  }
  function a(l) {
    return r.parser.defined.includes(et(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? n(l) : e(l);
  }
  function i(l) {
    return e(l);
  }
}
function cr(t, n, e) {
  return r;
  function r(a) {
    return t.enter("reference"), t.enter("referenceMarker"), t.consume(a), t.exit("referenceMarker"), u;
  }
  function u(a) {
    return a === 93 ? (t.enter("referenceMarker"), t.consume(a), t.exit("referenceMarker"), t.exit("reference"), n) : e(a);
  }
}
const hr = {
  name: "labelStartImage",
  tokenize: pr,
  resolveAll: Tt.resolveAll
};
function pr(t, n, e) {
  const r = this;
  return u;
  function u(l) {
    return t.enter("labelImage"), t.enter("labelImageMarker"), t.consume(l), t.exit("labelImageMarker"), a;
  }
  function a(l) {
    return l === 91 ? (t.enter("labelMarker"), t.consume(l), t.exit("labelMarker"), t.exit("labelImage"), i) : e(l);
  }
  function i(l) {
    return l === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? e(l) : n(l);
  }
}
const gr = {
  name: "labelStartLink",
  tokenize: mr,
  resolveAll: Tt.resolveAll
};
function mr(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return t.enter("labelLink"), t.enter("labelMarker"), t.consume(i), t.exit("labelMarker"), t.exit("labelLink"), a;
  }
  function a(i) {
    return i === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? e(i) : n(i);
  }
}
const Et = {
  name: "lineEnding",
  tokenize: fr
};
function fr(t, n) {
  return e;
  function e(r) {
    return t.enter("lineEnding"), t.consume(r), t.exit("lineEnding"), N(t, n, "linePrefix");
  }
}
const kt = {
  name: "thematicBreak",
  tokenize: br
};
function br(t, n, e) {
  let r = 0, u;
  return a;
  function a(o) {
    return t.enter("thematicBreak"), i(o);
  }
  function i(o) {
    return u = o, l(o);
  }
  function l(o) {
    return o === u ? (t.enter("thematicBreakSequence"), c(o)) : r >= 3 && (o === null || z(o)) ? (t.exit("thematicBreak"), n(o)) : e(o);
  }
  function c(o) {
    return o === u ? (t.consume(o), r++, c) : (t.exit("thematicBreakSequence"), R(o) ? N(t, l, "whitespace")(o) : l(o));
  }
}
const Q = {
  name: "list",
  tokenize: kr,
  continuation: {
    tokenize: wr
  },
  exit: yr
}, dr = {
  tokenize: Cr,
  partial: !0
}, xr = {
  tokenize: Sr,
  partial: !0
};
function kr(t, n, e) {
  const r = this, u = r.events[r.events.length - 1];
  let a = u && u[1].type === "linePrefix" ? u[2].sliceSerialize(u[1], !0).length : 0, i = 0;
  return l;
  function l(s) {
    const b = r.containerState.type || (s === 42 || s === 43 || s === 45 ? "listUnordered" : "listOrdered");
    if (b === "listUnordered" ? !r.containerState.marker || s === r.containerState.marker : zt(s)) {
      if (r.containerState.type || (r.containerState.type = b, t.enter(b, {
        _container: !0
      })), b === "listUnordered")
        return t.enter("listItemPrefix"), s === 42 || s === 45 ? t.check(kt, e, o)(s) : o(s);
      if (!r.interrupt || s === 49)
        return t.enter("listItemPrefix"), t.enter("listItemValue"), c(s);
    }
    return e(s);
  }
  function c(s) {
    return zt(s) && ++i < 10 ? (t.consume(s), c) : (!r.interrupt || i < 2) && (r.containerState.marker ? s === r.containerState.marker : s === 41 || s === 46) ? (t.exit("listItemValue"), o(s)) : e(s);
  }
  function o(s) {
    return t.enter("listItemMarker"), t.consume(s), t.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || s, t.check(
      dt,
      // Canâ€™t be empty when interrupting.
      r.interrupt ? e : p,
      t.attempt(dr, f, h)
    );
  }
  function p(s) {
    return r.containerState.initialBlankLine = !0, a++, f(s);
  }
  function h(s) {
    return R(s) ? (t.enter("listItemPrefixWhitespace"), t.consume(s), t.exit("listItemPrefixWhitespace"), f) : e(s);
  }
  function f(s) {
    return r.containerState.size = a + r.sliceSerialize(t.exit("listItemPrefix"), !0).length, n(s);
  }
}
function wr(t, n, e) {
  const r = this;
  return r.containerState._closeFlow = void 0, t.check(dt, u, a);
  function u(l) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, N(t, n, "listItemIndent", r.containerState.size + 1)(l);
  }
  function a(l) {
    return r.containerState.furtherBlankLines || !R(l) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, i(l)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, t.attempt(xr, n, i)(l));
  }
  function i(l) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, N(t, t.attempt(Q, n, e), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l);
  }
}
function Sr(t, n, e) {
  const r = this;
  return N(t, u, "listItemIndent", r.containerState.size + 1);
  function u(a) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "listItemIndent" && i[2].sliceSerialize(i[1], !0).length === r.containerState.size ? n(a) : e(a);
  }
}
function yr(t) {
  t.exit(this.containerState.type);
}
function Cr(t, n, e) {
  const r = this;
  return N(t, u, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function u(a) {
    const i = r.events[r.events.length - 1];
    return !R(a) && i && i[1].type === "listItemPrefixWhitespace" ? n(a) : e(a);
  }
}
const Kt = {
  name: "setextUnderline",
  tokenize: Er,
  resolveTo: Ar
};
function Ar(t, n) {
  let e = t.length, r, u, a;
  for (; e--; )
    if (t[e][0] === "enter") {
      if (t[e][1].type === "content") {
        r = e;
        break;
      }
      t[e][1].type === "paragraph" && (u = e);
    } else
      t[e][1].type === "content" && t.splice(e, 1), !a && t[e][1].type === "definition" && (a = e);
  const i = {
    type: "setextHeading",
    start: Object.assign({}, t[u][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  };
  return t[u][1].type = "setextHeadingText", a ? (t.splice(u, 0, ["enter", i, n]), t.splice(a + 1, 0, ["exit", t[r][1], n]), t[r][1].end = Object.assign({}, t[a][1].end)) : t[r][1] = i, t.push(["exit", i, n]), t;
}
function Er(t, n, e) {
  const r = this;
  let u;
  return a;
  function a(o) {
    let p = r.events.length, h;
    for (; p--; )
      if (r.events[p][1].type !== "lineEnding" && r.events[p][1].type !== "linePrefix" && r.events[p][1].type !== "content") {
        h = r.events[p][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (t.enter("setextHeadingLine"), u = o, i(o)) : e(o);
  }
  function i(o) {
    return t.enter("setextHeadingLineSequence"), l(o);
  }
  function l(o) {
    return o === u ? (t.consume(o), l) : (t.exit("setextHeadingLineSequence"), R(o) ? N(t, c, "lineSuffix")(o) : c(o));
  }
  function c(o) {
    return o === null || z(o) ? (t.exit("setextHeadingLine"), n(o)) : e(o);
  }
}
const Dr = {
  tokenize: qr
};
function qr(t) {
  const n = this, e = t.attempt(
    // Try to parse a blank line.
    dt,
    r,
    // Try to parse initial flow (essentially, only code).
    t.attempt(
      this.parser.constructs.flowInitial,
      u,
      N(
        t,
        t.attempt(
          this.parser.constructs.flow,
          u,
          t.attempt(Tn, u)
        ),
        "linePrefix"
      )
    )
  );
  return e;
  function r(a) {
    if (a === null) {
      t.consume(a);
      return;
    }
    return t.enter("lineEndingBlank"), t.consume(a), t.exit("lineEndingBlank"), n.currentConstruct = void 0, e;
  }
  function u(a) {
    if (a === null) {
      t.consume(a);
      return;
    }
    return t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), n.currentConstruct = void 0, e;
  }
}
const Lr = {
  resolveAll: me()
}, vr = ge("string"), zr = ge("text");
function ge(t) {
  return {
    tokenize: n,
    resolveAll: me(
      t === "text" ? Ir : void 0
    )
  };
  function n(e) {
    const r = this, u = this.parser.constructs[t], a = e.attempt(u, i, l);
    return i;
    function i(p) {
      return o(p) ? a(p) : l(p);
    }
    function l(p) {
      if (p === null) {
        e.consume(p);
        return;
      }
      return e.enter("data"), e.consume(p), c;
    }
    function c(p) {
      return o(p) ? (e.exit("data"), a(p)) : (e.consume(p), c);
    }
    function o(p) {
      if (p === null)
        return !0;
      const h = u[p];
      let f = -1;
      if (h)
        for (; ++f < h.length; ) {
          const s = h[f];
          if (!s.previous || s.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function me(t) {
  return n;
  function n(e, r) {
    let u = -1, a;
    for (; ++u <= e.length; )
      a === void 0 ? e[u] && e[u][1].type === "data" && (a = u, u++) : (!e[u] || e[u][1].type !== "data") && (u !== a + 2 && (e[a][1].end = e[u - 1][1].end, e.splice(a + 2, u - a - 2), u = a + 2), a = void 0);
    return t ? t(e, r) : e;
  }
}
function Ir(t, n) {
  let e = 0;
  for (; ++e <= t.length; )
    if ((e === t.length || t[e][1].type === "lineEnding") && t[e - 1][1].type === "data") {
      const r = t[e - 1][1], u = n.sliceStream(r);
      let a = u.length, i = -1, l = 0, c;
      for (; a--; ) {
        const o = u[a];
        if (typeof o == "string") {
          for (i = o.length; o.charCodeAt(i - 1) === 32; )
            l++, i--;
          if (i) break;
          i = -1;
        } else if (o === -2)
          c = !0, l++;
        else if (o !== -1) {
          a++;
          break;
        }
      }
      if (l) {
        const o = {
          type: e === t.length || c || l < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - l,
            offset: r.end.offset - l,
            _index: r.start._index + a,
            _bufferIndex: a ? i : r.start._bufferIndex + i
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, o.start), r.start.offset === r.end.offset ? Object.assign(r, o) : (t.splice(
          e,
          0,
          ["enter", o, n],
          ["exit", o, n]
        ), e += 2);
      }
      e++;
    }
  return t;
}
function Tr(t, n, e) {
  let r = Object.assign(
    e ? Object.assign({}, e) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const u = {}, a = [];
  let i = [], l = [];
  const c = {
    consume: E,
    enter: A,
    exit: T,
    attempt: y(v),
    check: y(S),
    interrupt: y(S, {
      interrupt: !0
    })
  }, o = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: t,
    sliceStream: s,
    sliceSerialize: f,
    now: b,
    defineSkip: C,
    write: h
  };
  let p = n.tokenize.call(o, c);
  return n.resolveAll && a.push(n), o;
  function h(L) {
    return i = j(i, L), k(), i[i.length - 1] !== null ? [] : (F(n, 0), o.events = yt(a, o.events, o), o.events);
  }
  function f(L, D) {
    return Nr(s(L), D);
  }
  function s(L) {
    return Fr(i, L);
  }
  function b() {
    const { line: L, column: D, offset: B, _index: O, _bufferIndex: d } = r;
    return {
      line: L,
      column: D,
      offset: B,
      _index: O,
      _bufferIndex: d
    };
  }
  function C(L) {
    u[L.line] = L.column, x();
  }
  function k() {
    let L;
    for (; r._index < i.length; ) {
      const D = i[r._index];
      if (typeof D == "string")
        for (L = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === L && r._bufferIndex < D.length; )
          w(D.charCodeAt(r._bufferIndex));
      else
        w(D);
    }
  }
  function w(L) {
    p = p(L);
  }
  function E(L) {
    z(L) ? (r.line++, r.column = 1, r.offset += L === -3 ? 2 : 1, x()) : L !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === i[r._index].length && (r._bufferIndex = -1, r._index++)), o.previous = L;
  }
  function A(L, D) {
    const B = D || {};
    return B.type = L, B.start = b(), o.events.push(["enter", B, o]), l.push(B), B;
  }
  function T(L) {
    const D = l.pop();
    return D.end = b(), o.events.push(["exit", D, o]), D;
  }
  function v(L, D) {
    F(L, D.from);
  }
  function S(L, D) {
    D.restore();
  }
  function y(L, D) {
    return B;
    function B(O, d, M) {
      let V, Y, nt, g;
      return Array.isArray(O) ? rt(O) : "tokenize" in O ? (
        // @ts-expect-error Looks like a construct.
        rt([O])
      ) : Z(O);
      function Z(H) {
        return mt;
        function mt(ut) {
          const st = ut !== null && H[ut], ct = ut !== null && H.null, Ct = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(st) ? st : st ? [st] : [],
            ...Array.isArray(ct) ? ct : ct ? [ct] : []
          ];
          return rt(Ct)(ut);
        }
      }
      function rt(H) {
        return V = H, Y = 0, H.length === 0 ? M : m(H[Y]);
      }
      function m(H) {
        return mt;
        function mt(ut) {
          return g = P(), nt = H, H.partial || (o.currentConstruct = H), H.name && o.parser.constructs.disable.null.includes(H.name) ? ot() : H.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a â€œlive bindingâ€, which is needed for `interrupt`.
            D ? Object.assign(Object.create(o), D) : o,
            c,
            J,
            ot
          )(ut);
        }
      }
      function J(H) {
        return L(nt, g), d;
      }
      function ot(H) {
        return g.restore(), ++Y < V.length ? m(V[Y]) : M;
      }
    }
  }
  function F(L, D) {
    L.resolveAll && !a.includes(L) && a.push(L), L.resolve && $(
      o.events,
      D,
      o.events.length - D,
      L.resolve(o.events.slice(D), o)
    ), L.resolveTo && (o.events = L.resolveTo(o.events, o));
  }
  function P() {
    const L = b(), D = o.previous, B = o.currentConstruct, O = o.events.length, d = Array.from(l);
    return {
      restore: M,
      from: O
    };
    function M() {
      r = L, o.previous = D, o.currentConstruct = B, o.events.length = O, l = d, x();
    }
  }
  function x() {
    r.line in u && r.column < 2 && (r.column = u[r.line], r.offset += u[r.line] - 1);
  }
}
function Fr(t, n) {
  const e = n.start._index, r = n.start._bufferIndex, u = n.end._index, a = n.end._bufferIndex;
  let i;
  if (e === u)
    i = [t[e].slice(r, a)];
  else {
    if (i = t.slice(e, u), r > -1) {
      const l = i[0];
      typeof l == "string" ? i[0] = l.slice(r) : i.shift();
    }
    a > 0 && i.push(t[u].slice(0, a));
  }
  return i;
}
function Nr(t, n) {
  let e = -1;
  const r = [];
  let u;
  for (; ++e < t.length; ) {
    const a = t[e];
    let i;
    if (typeof a == "string")
      i = a;
    else
      switch (a) {
        case -5: {
          i = "\r";
          break;
        }
        case -4: {
          i = `
`;
          break;
        }
        case -3: {
          i = `\r
`;
          break;
        }
        case -2: {
          i = n ? " " : "	";
          break;
        }
        case -1: {
          if (!n && u) continue;
          i = " ";
          break;
        }
        default:
          i = String.fromCharCode(a);
      }
    u = a === -2, r.push(i);
  }
  return r.join("");
}
const Or = {
  42: Q,
  43: Q,
  45: Q,
  48: Q,
  49: Q,
  50: Q,
  51: Q,
  52: Q,
  53: Q,
  54: Q,
  55: Q,
  56: Q,
  57: Q,
  62: ue
}, Rr = {
  91: Bn
}, Br = {
  [-2]: At,
  [-1]: At,
  32: At
}, Pr = {
  35: jn,
  42: kt,
  45: [Kt, kt],
  60: Wn,
  61: Kt,
  95: kt,
  96: Zt,
  126: Zt
}, _r = {
  38: oe,
  92: le
}, Mr = {
  [-5]: Et,
  [-4]: Et,
  [-3]: Et,
  33: hr,
  38: oe,
  42: It,
  60: [gn, tr],
  91: gr,
  92: [Vn, le],
  93: Tt,
  95: It,
  96: Dn
}, Vr = {
  null: [It, Lr]
}, Hr = {
  null: [42, 95]
}, jr = {
  null: []
}, Ur = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Hr,
  contentInitial: Rr,
  disable: jr,
  document: Or,
  flow: Pr,
  flowInitial: Br,
  insideSpan: Vr,
  string: _r,
  text: Mr
}, Symbol.toStringTag, { value: "Module" }));
function Gr(t) {
  const e = (
    /** @type {FullNormalizedExtension} */
    Ue([Ur, ...(t || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: e,
    content: u(un),
    document: u(on),
    flow: u(Dr),
    string: u(vr),
    text: u(zr)
  };
  return r;
  function u(a) {
    return i;
    function i(l) {
      return Tr(r, a, l);
    }
  }
}
function Qr(t) {
  for (; !se(t); )
    ;
  return t;
}
const Xt = /[\0\t\n\r]/g;
function Wr() {
  let t = 1, n = "", e = !0, r;
  return u;
  function u(a, i, l) {
    const c = [];
    let o, p, h, f, s;
    for (a = n + (typeof a == "string" ? a.toString() : new TextDecoder(i || void 0).decode(a)), h = 0, n = "", e && (a.charCodeAt(0) === 65279 && h++, e = void 0); h < a.length; ) {
      if (Xt.lastIndex = h, o = Xt.exec(a), f = o && o.index !== void 0 ? o.index : a.length, s = a.charCodeAt(f), !o) {
        n = a.slice(h);
        break;
      }
      if (s === 10 && h === f && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), h < f && (c.push(a.slice(h, f)), t += f - h), s) {
          case 0: {
            c.push(65533), t++;
            break;
          }
          case 9: {
            for (p = Math.ceil(t / 4) * 4, c.push(-2); t++ < p; ) c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), t = 1;
            break;
          }
          default:
            r = !0, t = 1;
        }
      h = f + 1;
    }
    return l && (r && c.push(-5), n && c.push(n), c.push(null)), c;
  }
}
function Bi(t, n, e) {
  return typeof n != "string" && (e = n, n = void 0), an(e)(
    Qr(
      Gr(e).document().write(Wr()(t, n, !0))
    )
  );
}
function Ft(t, n, e, r, u, a, i, l, c, o, p, h, f, s, b) {
  let C, k;
  return w;
  function w(d) {
    return t.enter(r), t.enter(u), t.consume(d), t.exit(u), E;
  }
  function E(d) {
    return d === 35 ? (C = i, A(d)) : d === 46 ? (C = l, A(d)) : d === 58 || d === 95 || W(d) ? (t.enter(a), t.enter(c), t.consume(d), S) : b && R(d) ? N(t, E, "whitespace")(d) : !b && _(d) ? at(t, E)(d) : O(d);
  }
  function A(d) {
    const M = (
      /** @type {TokenType} */
      C + "Marker"
    );
    return t.enter(a), t.enter(C), t.enter(M), t.consume(d), t.exit(M), T;
  }
  function T(d) {
    if (d === null || d === 34 || d === 35 || d === 39 || d === 46 || d === 60 || d === 61 || d === 62 || d === 96 || d === 125 || _(d))
      return e(d);
    const M = (
      /** @type {TokenType} */
      C + "Value"
    );
    return t.enter(M), t.consume(d), v;
  }
  function v(d) {
    if (d === null || d === 34 || d === 39 || d === 60 || d === 61 || d === 62 || d === 96)
      return e(d);
    if (d === 35 || d === 46 || d === 125 || _(d)) {
      const M = (
        /** @type {TokenType} */
        C + "Value"
      );
      return t.exit(M), t.exit(C), t.exit(a), E(d);
    }
    return t.consume(d), v;
  }
  function S(d) {
    return d === 45 || d === 46 || d === 58 || d === 95 || U(d) ? (t.consume(d), S) : (t.exit(c), b && R(d) ? N(t, y, "whitespace")(d) : !b && _(d) ? at(t, y)(d) : y(d));
  }
  function y(d) {
    return d === 61 ? (t.enter(o), t.consume(d), t.exit(o), F) : (t.exit(a), E(d));
  }
  function F(d) {
    return d === null || d === 60 || d === 61 || d === 62 || d === 96 || d === 125 || b && z(d) ? e(d) : d === 34 || d === 39 ? (t.enter(p), t.enter(f), t.consume(d), t.exit(f), k = d, x) : b && R(d) ? N(t, F, "whitespace")(d) : !b && _(d) ? at(t, F)(d) : (t.enter(h), t.enter(s), t.consume(d), k = void 0, P);
  }
  function P(d) {
    return d === null || d === 34 || d === 39 || d === 60 || d === 61 || d === 62 || d === 96 ? e(d) : d === 125 || _(d) ? (t.exit(s), t.exit(h), t.exit(a), E(d)) : (t.consume(d), P);
  }
  function x(d) {
    return d === k ? (t.enter(f), t.consume(d), t.exit(f), t.exit(p), t.exit(a), B) : (t.enter(h), L(d));
  }
  function L(d) {
    return d === k ? (t.exit(h), x(d)) : d === null ? e(d) : z(d) ? b ? e(d) : at(t, L)(d) : (t.enter(s), t.consume(d), D);
  }
  function D(d) {
    return d === k || d === null || z(d) ? (t.exit(s), L(d)) : (t.consume(d), D);
  }
  function B(d) {
    return d === 125 || _(d) ? E(d) : O(d);
  }
  function O(d) {
    return d === 125 ? (t.enter(u), t.consume(d), t.exit(u), t.exit(r), n) : e(d);
  }
}
function Nt(t, n, e, r, u, a, i) {
  let l = 0, c = 0, o;
  return p;
  function p(k) {
    return t.enter(r), t.enter(u), t.consume(k), t.exit(u), h;
  }
  function h(k) {
    return k === 93 ? (t.enter(u), t.consume(k), t.exit(u), t.exit(r), n) : (t.enter(a), f(k));
  }
  function f(k) {
    if (k === 93 && !c)
      return C(k);
    const w = t.enter("chunkText", {
      contentType: "text",
      previous: o
    });
    return o && (o.next = w), o = w, s(k);
  }
  function s(k) {
    return k === null || l > 999 || k === 91 && ++c > 32 ? e(k) : k === 93 && !c-- ? (t.exit("chunkText"), C(k)) : z(k) ? i ? e(k) : (t.consume(k), t.exit("chunkText"), f) : (t.consume(k), k === 92 ? b : s);
  }
  function b(k) {
    return k === 91 || k === 92 || k === 93 ? (t.consume(k), l++, s) : s(k);
  }
  function C(k) {
    return t.exit(a), t.enter(u), t.consume(k), t.exit(u), t.exit(r), n;
  }
}
function Ot(t, n, e, r) {
  const u = this;
  return a;
  function a(l) {
    return W(l) ? (t.enter(r), t.consume(l), i) : e(l);
  }
  function i(l) {
    return l === 45 || l === 95 || U(l) ? (t.consume(l), i) : (t.exit(r), u.previous === 45 || u.previous === 95 ? e(l) : n(l));
  }
}
const $r = {
  tokenize: Jr,
  concrete: !0
}, Yr = {
  tokenize: Kr,
  partial: !0
}, Zr = {
  tokenize: Xr,
  partial: !0
}, te = {
  tokenize: ti,
  partial: !0
};
function Jr(t, n, e) {
  const r = this, u = r.events[r.events.length - 1], a = u && u[1].type === "linePrefix" ? u[2].sliceSerialize(u[1], !0).length : 0;
  let i = 0, l;
  return c;
  function c(y) {
    return t.enter("directiveContainer"), t.enter("directiveContainerFence"), t.enter("directiveContainerSequence"), o(y);
  }
  function o(y) {
    return y === 58 ? (t.consume(y), i++, o) : i < 3 ? e(y) : (t.exit("directiveContainerSequence"), Ot.call(r, t, p, e, "directiveContainerName")(y));
  }
  function p(y) {
    return y === 91 ? t.attempt(Yr, h, h)(y) : h(y);
  }
  function h(y) {
    return y === 123 ? t.attempt(Zr, f, f)(y) : f(y);
  }
  function f(y) {
    return N(t, s, "whitespace")(y);
  }
  function s(y) {
    return t.exit("directiveContainerFence"), y === null ? b(y) : z(y) ? r.interrupt ? n(y) : t.attempt(te, C, b)(y) : e(y);
  }
  function b(y) {
    return t.exit("directiveContainer"), n(y);
  }
  function C(y) {
    return y === null ? (t.exit("directiveContainer"), n(y)) : (t.enter("directiveContainerContent"), k(y));
  }
  function k(y) {
    return y === null ? v(y) : t.attempt({
      tokenize: S,
      partial: !0
    }, v, a ? N(t, w, "linePrefix", a + 1) : w)(y);
  }
  function w(y) {
    if (y === null)
      return v(y);
    const F = t.enter("chunkDocument", {
      contentType: "document",
      previous: l
    });
    return l && (l.next = F), l = F, E(y);
  }
  function E(y) {
    if (y === null) {
      const F = t.exit("chunkDocument");
      return r.parser.lazy[F.start.line] = !1, v(y);
    }
    return z(y) ? t.check(te, A, T)(y) : (t.consume(y), E);
  }
  function A(y) {
    t.consume(y);
    const F = t.exit("chunkDocument");
    return r.parser.lazy[F.start.line] = !1, k;
  }
  function T(y) {
    const F = t.exit("chunkDocument");
    return r.parser.lazy[F.start.line] = !1, v(y);
  }
  function v(y) {
    return t.exit("directiveContainerContent"), t.exit("directiveContainer"), n(y);
  }
  function S(y, F, P) {
    let x = 0;
    return N(y, L, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function L(O) {
      return y.enter("directiveContainerFence"), y.enter("directiveContainerSequence"), D(O);
    }
    function D(O) {
      return O === 58 ? (y.consume(O), x++, D) : x < i ? P(O) : (y.exit("directiveContainerSequence"), N(y, B, "whitespace")(O));
    }
    function B(O) {
      return O === null || z(O) ? (y.exit("directiveContainerFence"), F(O)) : P(O);
    }
  }
}
function Kr(t, n, e) {
  return Nt(t, n, e, "directiveContainerLabel", "directiveContainerLabelMarker", "directiveContainerLabelString", !0);
}
function Xr(t, n, e) {
  return Ft(t, n, e, "directiveContainerAttributes", "directiveContainerAttributesMarker", "directiveContainerAttribute", "directiveContainerAttributeId", "directiveContainerAttributeClass", "directiveContainerAttributeName", "directiveContainerAttributeInitializerMarker", "directiveContainerAttributeValueLiteral", "directiveContainerAttributeValue", "directiveContainerAttributeValueMarker", "directiveContainerAttributeValueData", !0);
}
function ti(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), a;
  }
  function a(i) {
    return r.parser.lazy[r.now().line] ? e(i) : n(i);
  }
}
const ei = {
  tokenize: ii
}, ni = {
  tokenize: ai,
  partial: !0
}, ri = {
  tokenize: ui,
  partial: !0
};
function ii(t, n, e) {
  const r = this;
  return u;
  function u(p) {
    return t.enter("directiveLeaf"), t.enter("directiveLeafSequence"), t.consume(p), a;
  }
  function a(p) {
    return p === 58 ? (t.consume(p), t.exit("directiveLeafSequence"), Ot.call(r, t, i, e, "directiveLeafName")) : e(p);
  }
  function i(p) {
    return p === 91 ? t.attempt(ni, l, l)(p) : l(p);
  }
  function l(p) {
    return p === 123 ? t.attempt(ri, c, c)(p) : c(p);
  }
  function c(p) {
    return N(t, o, "whitespace")(p);
  }
  function o(p) {
    return p === null || z(p) ? (t.exit("directiveLeaf"), n(p)) : e(p);
  }
}
function ai(t, n, e) {
  return Nt(t, n, e, "directiveLeafLabel", "directiveLeafLabelMarker", "directiveLeafLabelString", !0);
}
function ui(t, n, e) {
  return Ft(t, n, e, "directiveLeafAttributes", "directiveLeafAttributesMarker", "directiveLeafAttribute", "directiveLeafAttributeId", "directiveLeafAttributeClass", "directiveLeafAttributeName", "directiveLeafAttributeInitializerMarker", "directiveLeafAttributeValueLiteral", "directiveLeafAttributeValue", "directiveLeafAttributeValueMarker", "directiveLeafAttributeValueData", !0);
}
const li = {
  tokenize: hi,
  previous: ci
}, oi = {
  tokenize: pi,
  partial: !0
}, si = {
  tokenize: gi,
  partial: !0
};
function ci(t) {
  return t !== 58 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function hi(t, n, e) {
  const r = this;
  return u;
  function u(c) {
    return t.enter("directiveText"), t.enter("directiveTextMarker"), t.consume(c), t.exit("directiveTextMarker"), Ot.call(r, t, a, e, "directiveTextName");
  }
  function a(c) {
    return c === 58 ? e(c) : c === 91 ? t.attempt(oi, i, i)(c) : i(c);
  }
  function i(c) {
    return c === 123 ? t.attempt(si, l, l)(c) : l(c);
  }
  function l(c) {
    return t.exit("directiveText"), n(c);
  }
}
function pi(t, n, e) {
  return Nt(t, n, e, "directiveTextLabel", "directiveTextLabelMarker", "directiveTextLabelString");
}
function gi(t, n, e) {
  return Ft(t, n, e, "directiveTextAttributes", "directiveTextAttributesMarker", "directiveTextAttribute", "directiveTextAttributeId", "directiveTextAttributeClass", "directiveTextAttributeName", "directiveTextAttributeInitializerMarker", "directiveTextAttributeValueLiteral", "directiveTextAttributeValue", "directiveTextAttributeValueMarker", "directiveTextAttributeValueData");
}
function Pi() {
  return {
    text: {
      58: li
    },
    flow: {
      58: [$r, ei]
    }
  };
}
const mi = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], ee = {
  0: "ï¿½",
  128: "â‚¬",
  130: "â€š",
  131: "Æ’",
  132: "â€",
  133: "â€¦",
  134: "â€ ",
  135: "â€¡",
  136: "Ë†",
  137: "â€°",
  138: "Å ",
  139: "â€¹",
  140: "Å’",
  142: "Å½",
  145: "â€˜",
  146: "â€™",
  147: "â€œ",
  148: "â€",
  149: "â€¢",
  150: "â€“",
  151: "â€”",
  152: "Ëœ",
  153: "â„¢",
  154: "Å¡",
  155: "â€º",
  156: "Å“",
  158: "Å¾",
  159: "Å¸"
};
function fe(t) {
  const n = typeof t == "string" ? t.charCodeAt(0) : t;
  return n >= 48 && n <= 57;
}
function fi(t) {
  const n = typeof t == "string" ? t.charCodeAt(0) : t;
  return n >= 97 && n <= 102 || n >= 65 && n <= 70 || n >= 48 && n <= 57;
}
function bi(t) {
  const n = typeof t == "string" ? t.charCodeAt(0) : t;
  return n >= 97 && n <= 122 || n >= 65 && n <= 90;
}
function ne(t) {
  return bi(t) || fe(t);
}
const ht = String.fromCharCode, di = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function Dt(t, n = {}) {
  const e = typeof n.additional == "string" ? n.additional.charCodeAt(0) : n.additional, r = [];
  let u = 0, a = -1, i = "", l, c;
  n.position && ("start" in n.position || "indent" in n.position ? (c = n.position.indent, l = n.position.start) : l = n.position);
  let o = (l ? l.line : 0) || 1, p = (l ? l.column : 0) || 1, h = s(), f;
  for (u--; ++u <= t.length; )
    if (f === 10 && (p = (c ? c[a] : 0) || 1), f = t.charCodeAt(u), f === 38) {
      const k = t.charCodeAt(u + 1);
      if (k === 9 || k === 10 || k === 12 || k === 32 || k === 38 || k === 60 || Number.isNaN(k) || e && k === e) {
        i += ht(f), p++;
        continue;
      }
      const w = u + 1;
      let E = w, A = w, T;
      if (k === 35) {
        A = ++E;
        const D = t.charCodeAt(A);
        D === 88 || D === 120 ? (T = "hexadecimal", A = ++E) : T = "decimal";
      } else
        T = "named";
      let v = "", S = "", y = "";
      const F = T === "named" ? ne : T === "decimal" ? fe : fi;
      for (A--; ++A <= t.length; ) {
        const D = t.charCodeAt(A);
        if (!F(D))
          break;
        y += ht(D), T === "named" && mi.includes(y) && (v = y, S = wt(y));
      }
      let P = t.charCodeAt(A) === 59;
      if (P) {
        A++;
        const D = T === "named" ? wt(y) : !1;
        D && (v = y, S = D);
      }
      let x = 1 + A - w, L = "";
      if (!(!P && n.nonTerminated === !1)) if (!y)
        T !== "named" && b(4, x);
      else if (T === "named") {
        if (P && !S)
          b(5, 1);
        else if (v !== y && (A = E + v.length, x = 1 + A - E, P = !1), !P) {
          const D = v ? 1 : 3;
          if (n.attribute) {
            const B = t.charCodeAt(A);
            B === 61 ? (b(D, x), S = "") : ne(B) ? S = "" : b(D, x);
          } else
            b(D, x);
        }
        L = S;
      } else {
        P || b(2, x);
        let D = Number.parseInt(
          y,
          T === "hexadecimal" ? 16 : 10
        );
        if (xi(D))
          b(7, x), L = ht(
            65533
            /* `ï¿½` */
          );
        else if (D in ee)
          b(6, x), L = ee[D];
        else {
          let B = "";
          ki(D) && b(6, x), D > 65535 && (D -= 65536, B += ht(D >>> 10 | 55296), D = 56320 | D & 1023), L = B + ht(D);
        }
      }
      if (L) {
        C(), h = s(), u = A - 1, p += A - w + 1, r.push(L);
        const D = s();
        D.offset++, n.reference && n.reference.call(
          n.referenceContext,
          L,
          { start: h, end: D },
          t.slice(w - 1, A)
        ), h = D;
      } else
        y = t.slice(w - 1, A), i += y, p += y.length, u = A - 1;
    } else
      f === 10 && (o++, a++, p = 0), Number.isNaN(f) ? C() : (i += ht(f), p++);
  return r.join("");
  function s() {
    return {
      line: o,
      column: p,
      offset: u + ((l ? l.offset : 0) || 0)
    };
  }
  function b(k, w) {
    let E;
    n.warning && (E = s(), E.column += w, E.offset += w, n.warning.call(
      n.warningContext,
      di[k],
      E,
      k
    ));
  }
  function C() {
    i && (r.push(i), n.text && n.text.call(n.textContext, i, {
      start: h,
      end: s()
    }), i = "");
  }
}
function xi(t) {
  return t >= 55296 && t <= 57343 || t > 1114111;
}
function ki(t) {
  return t >= 1 && t <= 8 || t === 11 || t >= 13 && t <= 31 || t >= 127 && t <= 159 || t >= 64976 && t <= 65007 || (t & 65535) === 65535 || (t & 65535) === 65534;
}
const re = {}.hasOwnProperty;
function _i(t) {
  const n = t || {};
  return {
    enter: {
      directiveContainer() {
        e.call(this, "containerDirective");
      },
      directiveContainerAttributes: i,
      directiveContainerLabel: u,
      directiveContainerContent() {
        this.buffer();
      },
      directiveLeaf() {
        e.call(this, "leafDirective");
      },
      directiveLeafAttributes: i,
      directiveLeafLabel: u,
      directiveText() {
        e.call(this, "textDirective");
      },
      directiveTextAttributes: i,
      directiveTextLabel: u
    },
    exit: {
      directiveContainer: b,
      directiveContainerAttributeClassValue: c,
      directiveContainerAttributeIdValue: l,
      directiveContainerAttributeName: o,
      directiveContainerAttributeValue: p,
      directiveContainerAttributes: h,
      directiveContainerContent: f,
      directiveContainerFence: s,
      directiveContainerLabel: a,
      directiveContainerName: r,
      directiveLeaf: b,
      directiveLeafAttributeClassValue: c,
      directiveLeafAttributeIdValue: l,
      directiveLeafAttributeName: o,
      directiveLeafAttributeValue: p,
      directiveLeafAttributes: h,
      directiveLeafLabel: a,
      directiveLeafName: r,
      directiveText: b,
      directiveTextAttributeClassValue: c,
      directiveTextAttributeIdValue: l,
      directiveTextAttributeName: o,
      directiveTextAttributeValue: p,
      directiveTextAttributes: h,
      directiveTextLabel: a,
      directiveTextName: r
    }
  };
  function e(C) {
    let k = this.getData("directiveStack");
    k || this.setData("directiveStack", k = []), k.push({
      type: C,
      name: ""
    });
  }
  function r(C) {
    const k = this.getData("directiveStack");
    k[k.length - 1].name = this.sliceSerialize(C);
  }
  function u() {
    this.buffer();
  }
  function a() {
    const C = this.resume(), k = this.getData("directiveStack");
    k[k.length - 1].label = C;
  }
  function i() {
    this.buffer(), this.setData("directiveAttributes", []);
  }
  function l(C) {
    this.getData("directiveAttributes").push(["id", Dt(this.sliceSerialize(C), {
      attribute: !0
    })]);
  }
  function c(C) {
    this.getData("directiveAttributes").push(["class", Dt(this.sliceSerialize(C), {
      attribute: !0
    })]);
  }
  function o(C) {
    this.getData("directiveAttributes").push([this.sliceSerialize(C), ""]);
  }
  function p(C) {
    const k = this.getData("directiveAttributes");
    k[k.length - 1][1] = Dt(this.sliceSerialize(C), {
      attribute: !0
    });
  }
  function h() {
    const C = this.getData("directiveStack"), k = this.getData("directiveAttributes"), w = {};
    let E = -1;
    for (; ++E < k.length; ) {
      const A = k[E];
      A[0] === "class" && w.class ? w.class += " " + A[1] : w[A[0]] = A[1];
    }
    this.resume(), this.setData("directiveAttributes"), C[C.length - 1].attributes = w;
  }
  function f() {
    const C = this.resume(), k = this.getData("directiveStack");
    k[k.length - 1].content = C;
  }
  function s() {
    const C = this.getData("directiveStack"), k = C[C.length - 1];
    k._fenceCount || (k._fenceCount = 0), k._fenceCount++, k._fenceCount === 1 && this.setData("slurpOneLineEnding", !0);
  }
  function b() {
    const k = this.getData("directiveStack").pop();
    let w, E;
    re.call(n, k.name) && (E = n[k.name].call(this, k), w = E !== !1), !w && re.call(n, "*") && (E = n["*"].call(this, k), w = E !== !1), !w && k.type !== "textDirective" && this.setData("slurpOneLineEnding", !0);
  }
}
const wi = {
  tokenize: qi,
  partial: !0
};
function Mi() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: Ai,
        continuation: {
          tokenize: Ei
        },
        exit: Di
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: Ci
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: Si,
        resolveTo: yi
      }
    }
  };
}
function Si(t, n, e) {
  const r = this;
  let u = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i;
  for (; u--; ) {
    const c = r.events[u][1];
    if (c.type === "labelImage") {
      i = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return l;
  function l(c) {
    if (!i || !i._balanced)
      return e(c);
    const o = et(r.sliceSerialize({
      start: i.end,
      end: r.now()
    }));
    return o.codePointAt(0) !== 94 || !a.includes(o.slice(1)) ? e(c) : (t.enter("gfmFootnoteCallLabelMarker"), t.consume(c), t.exit("gfmFootnoteCallLabelMarker"), n(c));
  }
}
function yi(t, n) {
  let e = t.length;
  for (; e--; )
    if (t[e][1].type === "labelImage" && t[e][0] === "enter") {
      t[e][1];
      break;
    }
  t[e + 1][1].type = "data", t[e + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, t[e + 3][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  }, u = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, t[e + 3][1].end),
    end: Object.assign({}, t[e + 3][1].end)
  };
  u.end.column++, u.end.offset++, u.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, u.end),
    end: Object.assign({}, t[t.length - 1][1].start)
  }, i = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, l = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    t[e + 1],
    t[e + 2],
    ["enter", r, n],
    // The `[`
    t[e + 3],
    t[e + 4],
    // The `^`.
    ["enter", u, n],
    ["exit", u, n],
    // Everything in between.
    ["enter", a, n],
    ["enter", i, n],
    ["exit", i, n],
    ["exit", a, n],
    // The ending (`]`, properly parsed and labelled).
    t[t.length - 2],
    t[t.length - 1],
    ["exit", r, n]
  ];
  return t.splice(e, t.length - e + 1, ...l), t;
}
function Ci(t, n, e) {
  const r = this, u = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, i;
  return l;
  function l(h) {
    return t.enter("gfmFootnoteCall"), t.enter("gfmFootnoteCallLabelMarker"), t.consume(h), t.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(h) {
    return h !== 94 ? e(h) : (t.enter("gfmFootnoteCallMarker"), t.consume(h), t.exit("gfmFootnoteCallMarker"), t.enter("gfmFootnoteCallString"), t.enter("chunkString").contentType = "string", o);
  }
  function o(h) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      h === 93 && !i || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || _(h)
    )
      return e(h);
    if (h === 93) {
      t.exit("chunkString");
      const f = t.exit("gfmFootnoteCallString");
      return u.includes(et(r.sliceSerialize(f))) ? (t.enter("gfmFootnoteCallLabelMarker"), t.consume(h), t.exit("gfmFootnoteCallLabelMarker"), t.exit("gfmFootnoteCall"), n) : e(h);
    }
    return _(h) || (i = !0), a++, t.consume(h), h === 92 ? p : o;
  }
  function p(h) {
    return h === 91 || h === 92 || h === 93 ? (t.consume(h), a++, o) : o(h);
  }
}
function Ai(t, n, e) {
  const r = this, u = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, i = 0, l;
  return c;
  function c(b) {
    return t.enter("gfmFootnoteDefinition")._container = !0, t.enter("gfmFootnoteDefinitionLabel"), t.enter("gfmFootnoteDefinitionLabelMarker"), t.consume(b), t.exit("gfmFootnoteDefinitionLabelMarker"), o;
  }
  function o(b) {
    return b === 94 ? (t.enter("gfmFootnoteDefinitionMarker"), t.consume(b), t.exit("gfmFootnoteDefinitionMarker"), t.enter("gfmFootnoteDefinitionLabelString"), t.enter("chunkString").contentType = "string", p) : e(b);
  }
  function p(b) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      b === 93 && !l || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      b === null || b === 91 || _(b)
    )
      return e(b);
    if (b === 93) {
      t.exit("chunkString");
      const C = t.exit("gfmFootnoteDefinitionLabelString");
      return a = et(r.sliceSerialize(C)), t.enter("gfmFootnoteDefinitionLabelMarker"), t.consume(b), t.exit("gfmFootnoteDefinitionLabelMarker"), t.exit("gfmFootnoteDefinitionLabel"), f;
    }
    return _(b) || (l = !0), i++, t.consume(b), b === 92 ? h : p;
  }
  function h(b) {
    return b === 91 || b === 92 || b === 93 ? (t.consume(b), i++, p) : p(b);
  }
  function f(b) {
    return b === 58 ? (t.enter("definitionMarker"), t.consume(b), t.exit("definitionMarker"), u.includes(a) || u.push(a), N(t, s, "gfmFootnoteDefinitionWhitespace")) : e(b);
  }
  function s(b) {
    return n(b);
  }
}
function Ei(t, n, e) {
  return t.check(dt, n, t.attempt(wi, n, e));
}
function Di(t) {
  t.exit("gfmFootnoteDefinition");
}
function qi(t, n, e) {
  const r = this;
  return N(t, u, "gfmFootnoteDefinitionIndent", 5);
  function u(a) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "gfmFootnoteDefinitionIndent" && i[2].sliceSerialize(i[1], !0).length === 4 ? n(a) : e(a);
  }
}
const Li = {}.hasOwnProperty, vi = {};
function zi(t, n) {
  return "Back to reference " + (t + 1) + (n > 1 ? "-" + n : "");
}
function Vi(t) {
  const n = vi, e = n.label || "Footnotes", r = n.labelTagName || "h2", u = n.labelAttributes === null || n.labelAttributes === void 0 ? 'class="sr-only"' : n.labelAttributes, a = n.backLabel || zi, i = n.clobberPrefix === null || n.clobberPrefix === void 0 ? "user-content-" : n.clobberPrefix;
  return {
    enter: {
      gfmFootnoteDefinition() {
        this.getData("tightStack").push(!1);
      },
      gfmFootnoteDefinitionLabelString() {
        this.buffer();
      },
      gfmFootnoteCallString() {
        this.buffer();
      }
    },
    exit: {
      gfmFootnoteDefinition() {
        let l = this.getData("gfmFootnoteDefinitions");
        const c = this.getData("gfmFootnoteDefinitionStack"), o = this.getData("tightStack"), p = c.pop(), h = this.resume();
        l || this.setData("gfmFootnoteDefinitions", l = {}), Li.call(l, p) || (l[p] = h), o.pop(), this.setData("slurpOneLineEnding", !0), this.setData("lastWasTag");
      },
      gfmFootnoteDefinitionLabelString(l) {
        let c = this.getData("gfmFootnoteDefinitionStack");
        c || this.setData("gfmFootnoteDefinitionStack", c = []), c.push(et(this.sliceSerialize(l))), this.resume(), this.buffer();
      },
      gfmFootnoteCallString(l) {
        let c = this.getData("gfmFootnoteCallOrder"), o = this.getData("gfmFootnoteCallCounts");
        const p = et(this.sliceSerialize(l));
        let h;
        this.resume(), c || this.setData("gfmFootnoteCallOrder", c = []), o || this.setData("gfmFootnoteCallCounts", o = {});
        const f = c.indexOf(p), s = gt(p.toLowerCase());
        f === -1 ? (c.push(p), o[p] = 1, h = c.length) : (o[p]++, h = f + 1);
        const b = o[p];
        this.tag('<sup><a href="#' + i + "fn-" + s + '" id="' + i + "fnref-" + s + (b > 1 ? "-" + b : "") + '" data-footnote-ref="" aria-describedby="footnote-label">' + String(h) + "</a></sup>");
      },
      null() {
        const l = this.getData("gfmFootnoteCallOrder") || [], c = this.getData("gfmFootnoteCallCounts") || {}, o = this.getData("gfmFootnoteDefinitions") || {};
        let p = -1;
        for (l.length > 0 && (this.lineEndingIfNeeded(), this.tag('<section data-footnotes="" class="footnotes"><' + r + ' id="footnote-label"' + (u ? " " + u : "") + ">"), this.raw(this.encode(e)), this.tag("</" + r + ">"), this.lineEndingIfNeeded(), this.tag("<ol>")); ++p < l.length; ) {
          const h = l[p], f = gt(h.toLowerCase());
          let s = 0;
          const b = [];
          for (; ++s <= c[h]; )
            b.push('<a href="#' + i + "fnref-" + f + (s > 1 ? "-" + s : "") + '" data-footnote-backref="" aria-label="' + this.encode(typeof a == "string" ? a : a(p, s)) + '" class="data-footnote-backref">â†©' + (s > 1 ? "<sup>" + s + "</sup>" : "") + "</a>");
          const C = b.join(" ");
          let k = !1;
          this.lineEndingIfNeeded(), this.tag('<li id="' + i + "fn-" + f + '">'), this.lineEndingIfNeeded(), this.tag(o[h].replace(/<\/p>(?:\r?\n|\r)?$/, function(w) {
            return k = !0, " " + C + w;
          })), k || (this.lineEndingIfNeeded(), this.tag(C)), this.lineEndingIfNeeded(), this.tag("</li>");
        }
        l.length > 0 && (this.lineEndingIfNeeded(), this.tag("</ol>"), this.lineEndingIfNeeded(), this.tag("</section>"));
      }
    }
  };
}
function Hi() {
  return {
    enter: {
      strikethrough() {
        this.tag("<del>");
      }
    },
    exit: {
      strikethrough() {
        this.tag("</del>");
      }
    }
  };
}
function ji(t) {
  let e = (t || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: u
  };
  return e == null && (e = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function u(i, l) {
    let c = -1;
    for (; ++c < i.length; )
      if (i[c][0] === "enter" && i[c][1].type === "strikethroughSequenceTemporary" && i[c][1]._close) {
        let o = c;
        for (; o--; )
          if (i[o][0] === "exit" && i[o][1].type === "strikethroughSequenceTemporary" && i[o][1]._open && // If the sizes are the same:
          i[c][1].end.offset - i[c][1].start.offset === i[o][1].end.offset - i[o][1].start.offset) {
            i[c][1].type = "strikethroughSequence", i[o][1].type = "strikethroughSequence";
            const p = {
              type: "strikethrough",
              start: Object.assign({}, i[o][1].start),
              end: Object.assign({}, i[c][1].end)
            }, h = {
              type: "strikethroughText",
              start: Object.assign({}, i[o][1].end),
              end: Object.assign({}, i[c][1].start)
            }, f = [["enter", p, l], ["enter", i[o][1], l], ["exit", i[o][1], l], ["enter", h, l]], s = l.parser.constructs.insideSpan.null;
            s && $(f, f.length, 0, yt(s, i.slice(o + 1, c), l)), $(f, f.length, 0, [["exit", h, l], ["enter", i[c][1], l], ["exit", i[c][1], l], ["exit", p, l]]), $(i, o - 1, c - o + 3, f), c = o + f.length - 2;
            break;
          }
      }
    for (c = -1; ++c < i.length; )
      i[c][1].type === "strikethroughSequenceTemporary" && (i[c][1].type = "data");
    return i;
  }
  function a(i, l, c) {
    const o = this.previous, p = this.events;
    let h = 0;
    return f;
    function f(b) {
      return o === 126 && p[p.length - 1][1].type !== "characterEscape" ? c(b) : (i.enter("strikethroughSequenceTemporary"), s(b));
    }
    function s(b) {
      const C = St(o);
      if (b === 126)
        return h > 1 ? c(b) : (i.consume(b), h++, s);
      if (h < 2 && !e) return c(b);
      const k = i.exit("strikethroughSequenceTemporary"), w = St(b);
      return k._open = !w || w === 2 && !!C, k._close = !C || C === 2 && !!w, l(b);
    }
  }
}
const qt = {
  none: "",
  left: ' align="left"',
  right: ' align="right"',
  center: ' align="center"'
};
function Ui() {
  return {
    enter: {
      table(t) {
        const n = t._align;
        this.lineEndingIfNeeded(), this.tag("<table>"), this.setData("tableAlign", n);
      },
      tableBody() {
        this.tag("<tbody>");
      },
      tableData() {
        const t = this.getData("tableAlign"), n = this.getData("tableColumn"), e = qt[t[n]];
        e === void 0 ? this.buffer() : (this.lineEndingIfNeeded(), this.tag("<td" + e + ">"));
      },
      tableHead() {
        this.lineEndingIfNeeded(), this.tag("<thead>");
      },
      tableHeader() {
        const t = this.getData("tableAlign"), n = this.getData("tableColumn"), e = qt[t[n]];
        this.lineEndingIfNeeded(), this.tag("<th" + e + ">");
      },
      tableRow() {
        this.setData("tableColumn", 0), this.lineEndingIfNeeded(), this.tag("<tr>");
      }
    },
    exit: {
      // Overwrite the default code text data handler to unescape escaped pipes when
      // they are in tables.
      codeTextData(t) {
        let n = this.sliceSerialize(t);
        this.getData("tableAlign") && (n = n.replace(/\\([\\|])/g, Ii)), this.raw(this.encode(n));
      },
      table() {
        this.setData("tableAlign"), this.setData("slurpAllLineEndings"), this.lineEndingIfNeeded(), this.tag("</table>");
      },
      tableBody() {
        this.lineEndingIfNeeded(), this.tag("</tbody>");
      },
      tableData() {
        const t = this.getData("tableAlign"), n = this.getData("tableColumn");
        n in t ? (this.tag("</td>"), this.setData("tableColumn", n + 1)) : this.resume();
      },
      tableHead() {
        this.lineEndingIfNeeded(), this.tag("</thead>");
      },
      tableHeader() {
        const t = this.getData("tableColumn");
        this.tag("</th>"), this.setData("tableColumn", t + 1);
      },
      tableRow() {
        const t = this.getData("tableAlign");
        let n = this.getData("tableColumn");
        for (; n < t.length; )
          this.lineEndingIfNeeded(), this.tag("<td" + qt[t[n]] + "></td>"), n++;
        this.setData("tableColumn", n), this.lineEndingIfNeeded(), this.tag("</tr>");
      }
    }
  };
}
function Ii(t, n) {
  return n === "|" ? n : t;
}
class Ti {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(n, e, r) {
    Fi(this, n, e, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(n) {
    if (this.map.sort(function(a, i) {
      return a[0] - i[0];
    }), this.map.length === 0)
      return;
    let e = this.map.length;
    const r = [];
    for (; e > 0; )
      e -= 1, r.push(n.slice(this.map[e][0] + this.map[e][1]), this.map[e][2]), n.length = this.map[e][0];
    r.push([...n]), n.length = 0;
    let u = r.pop();
    for (; u; )
      n.push(...u), u = r.pop();
    this.map.length = 0;
  }
}
function Fi(t, n, e, r) {
  let u = 0;
  if (!(e === 0 && r.length === 0)) {
    for (; u < t.map.length; ) {
      if (t.map[u][0] === n) {
        t.map[u][1] += e, t.map[u][2].push(...r);
        return;
      }
      u += 1;
    }
    t.map.push([n, e, r]);
  }
}
function Ni(t, n) {
  let e = !1;
  const r = [];
  for (; n < t.length; ) {
    const u = t[n];
    if (e) {
      if (u[0] === "enter")
        u[1].type === "tableContent" && r.push(t[n + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (u[1].type === "tableContent") {
        if (t[n - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (u[1].type === "tableDelimiterRow")
        break;
    } else u[0] === "enter" && u[1].type === "tableDelimiterRow" && (e = !0);
    n += 1;
  }
  return r;
}
function Gi() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: Oi,
        resolveAll: Ri
      }
    }
  };
}
function Oi(t, n, e) {
  const r = this;
  let u = 0, a = 0, i;
  return l;
  function l(x) {
    let L = r.events.length - 1;
    for (; L > -1; ) {
      const O = r.events[L][1].type;
      if (O === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      O === "linePrefix") L--;
      else break;
    }
    const D = L > -1 ? r.events[L][1].type : null, B = D === "tableHead" || D === "tableRow" ? S : c;
    return B === S && r.parser.lazy[r.now().line] ? e(x) : B(x);
  }
  function c(x) {
    return t.enter("tableHead"), t.enter("tableRow"), o(x);
  }
  function o(x) {
    return x === 124 || (i = !0, a += 1), p(x);
  }
  function p(x) {
    return x === null ? e(x) : z(x) ? a > 1 ? (a = 0, r.interrupt = !0, t.exit("tableRow"), t.enter("lineEnding"), t.consume(x), t.exit("lineEnding"), s) : e(x) : R(x) ? N(t, p, "whitespace")(x) : (a += 1, i && (i = !1, u += 1), x === 124 ? (t.enter("tableCellDivider"), t.consume(x), t.exit("tableCellDivider"), i = !0, p) : (t.enter("data"), h(x)));
  }
  function h(x) {
    return x === null || x === 124 || _(x) ? (t.exit("data"), p(x)) : (t.consume(x), x === 92 ? f : h);
  }
  function f(x) {
    return x === 92 || x === 124 ? (t.consume(x), h) : h(x);
  }
  function s(x) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? e(x) : (t.enter("tableDelimiterRow"), i = !1, R(x) ? N(t, b, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(x) : b(x));
  }
  function b(x) {
    return x === 45 || x === 58 ? k(x) : x === 124 ? (i = !0, t.enter("tableCellDivider"), t.consume(x), t.exit("tableCellDivider"), C) : v(x);
  }
  function C(x) {
    return R(x) ? N(t, k, "whitespace")(x) : k(x);
  }
  function k(x) {
    return x === 58 ? (a += 1, i = !0, t.enter("tableDelimiterMarker"), t.consume(x), t.exit("tableDelimiterMarker"), w) : x === 45 ? (a += 1, w(x)) : x === null || z(x) ? T(x) : v(x);
  }
  function w(x) {
    return x === 45 ? (t.enter("tableDelimiterFiller"), E(x)) : v(x);
  }
  function E(x) {
    return x === 45 ? (t.consume(x), E) : x === 58 ? (i = !0, t.exit("tableDelimiterFiller"), t.enter("tableDelimiterMarker"), t.consume(x), t.exit("tableDelimiterMarker"), A) : (t.exit("tableDelimiterFiller"), A(x));
  }
  function A(x) {
    return R(x) ? N(t, T, "whitespace")(x) : T(x);
  }
  function T(x) {
    return x === 124 ? b(x) : x === null || z(x) ? !i || u !== a ? v(x) : (t.exit("tableDelimiterRow"), t.exit("tableHead"), n(x)) : v(x);
  }
  function v(x) {
    return e(x);
  }
  function S(x) {
    return t.enter("tableRow"), y(x);
  }
  function y(x) {
    return x === 124 ? (t.enter("tableCellDivider"), t.consume(x), t.exit("tableCellDivider"), y) : x === null || z(x) ? (t.exit("tableRow"), n(x)) : R(x) ? N(t, y, "whitespace")(x) : (t.enter("data"), F(x));
  }
  function F(x) {
    return x === null || x === 124 || _(x) ? (t.exit("data"), y(x)) : (t.consume(x), x === 92 ? P : F);
  }
  function P(x) {
    return x === 92 || x === 124 ? (t.consume(x), F) : F(x);
  }
}
function Ri(t, n) {
  let e = -1, r = !0, u = 0, a = [0, 0, 0, 0], i = [0, 0, 0, 0], l = !1, c = 0, o, p, h;
  const f = new Ti();
  for (; ++e < t.length; ) {
    const s = t[e], b = s[1];
    s[0] === "enter" ? b.type === "tableHead" ? (l = !1, c !== 0 && (ie(f, n, c, o, p), p = void 0, c = 0), o = {
      type: "table",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, f.add(e, 0, [["enter", o, n]])) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (r = !0, h = void 0, a = [0, 0, 0, 0], i = [0, e + 1, 0, 0], l && (l = !1, p = {
      type: "tableBody",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, f.add(e, 0, [["enter", p, n]])), u = b.type === "tableDelimiterRow" ? 2 : p ? 3 : 1) : u && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") ? (r = !1, i[2] === 0 && (a[1] !== 0 && (i[0] = i[1], h = xt(f, n, a, u, void 0, h), a = [0, 0, 0, 0]), i[2] = e)) : b.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (i[0] = i[1], h = xt(f, n, a, u, void 0, h)), a = i, i = [a[1], e, 0, 0])) : b.type === "tableHead" ? (l = !0, c = e) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (c = e, a[1] !== 0 ? (i[0] = i[1], h = xt(f, n, a, u, e, h)) : i[1] !== 0 && (h = xt(f, n, i, u, e, h)), u = 0) : u && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") && (i[3] = e);
  }
  for (c !== 0 && ie(f, n, c, o, p), f.consume(n.events), e = -1; ++e < n.events.length; ) {
    const s = n.events[e];
    s[0] === "enter" && s[1].type === "table" && (s[1]._align = Ni(n.events, e));
  }
  return t;
}
function xt(t, n, e, r, u, a) {
  const i = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", l = "tableContent";
  e[0] !== 0 && (a.end = Object.assign({}, pt(n.events, e[0])), t.add(e[0], 0, [["exit", a, n]]));
  const c = pt(n.events, e[1]);
  if (a = {
    type: i,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, t.add(e[1], 0, [["enter", a, n]]), e[2] !== 0) {
    const o = pt(n.events, e[2]), p = pt(n.events, e[3]), h = {
      type: l,
      start: Object.assign({}, o),
      end: Object.assign({}, p)
    };
    if (t.add(e[2], 0, [["enter", h, n]]), r !== 2) {
      const f = n.events[e[2]], s = n.events[e[3]];
      if (f[1].end = Object.assign({}, s[1].end), f[1].type = "chunkText", f[1].contentType = "text", e[3] > e[2] + 1) {
        const b = e[2] + 1, C = e[3] - e[2] - 1;
        t.add(b, C, []);
      }
    }
    t.add(e[3] + 1, 0, [["exit", h, n]]);
  }
  return u !== void 0 && (a.end = Object.assign({}, pt(n.events, u)), t.add(u, 0, [["exit", a, n]]), a = void 0), a;
}
function ie(t, n, e, r, u) {
  const a = [], i = pt(n.events, e);
  u && (u.end = Object.assign({}, i), a.push(["exit", u, n])), r.end = Object.assign({}, i), a.push(["exit", r, n]), t.add(e + 1, 0, a);
}
function pt(t, n) {
  const e = t[n], r = e[0] === "enter" ? "start" : "end";
  return e[1][r];
}
export {
  ji as a,
  Gi as b,
  mi as c,
  Pi as d,
  Vi as e,
  Hi as f,
  Mi as g,
  Ui as h,
  _i as i,
  Bi as m
};
