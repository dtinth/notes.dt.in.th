const Ut = {
  AElig: "Æ",
  AMP: "&",
  Aacute: "Á",
  Abreve: "Ă",
  Acirc: "Â",
  Acy: "А",
  Afr: "𝔄",
  Agrave: "À",
  Alpha: "Α",
  Amacr: "Ā",
  And: "⩓",
  Aogon: "Ą",
  Aopf: "𝔸",
  ApplyFunction: "⁡",
  Aring: "Å",
  Ascr: "𝒜",
  Assign: "≔",
  Atilde: "Ã",
  Auml: "Ä",
  Backslash: "∖",
  Barv: "⫧",
  Barwed: "⌆",
  Bcy: "Б",
  Because: "∵",
  Bernoullis: "ℬ",
  Beta: "Β",
  Bfr: "𝔅",
  Bopf: "𝔹",
  Breve: "˘",
  Bscr: "ℬ",
  Bumpeq: "≎",
  CHcy: "Ч",
  COPY: "©",
  Cacute: "Ć",
  Cap: "⋒",
  CapitalDifferentialD: "ⅅ",
  Cayleys: "ℭ",
  Ccaron: "Č",
  Ccedil: "Ç",
  Ccirc: "Ĉ",
  Cconint: "∰",
  Cdot: "Ċ",
  Cedilla: "¸",
  CenterDot: "·",
  Cfr: "ℭ",
  Chi: "Χ",
  CircleDot: "⊙",
  CircleMinus: "⊖",
  CirclePlus: "⊕",
  CircleTimes: "⊗",
  ClockwiseContourIntegral: "∲",
  CloseCurlyDoubleQuote: "”",
  CloseCurlyQuote: "’",
  Colon: "∷",
  Colone: "⩴",
  Congruent: "≡",
  Conint: "∯",
  ContourIntegral: "∮",
  Copf: "ℂ",
  Coproduct: "∐",
  CounterClockwiseContourIntegral: "∳",
  Cross: "⨯",
  Cscr: "𝒞",
  Cup: "⋓",
  CupCap: "≍",
  DD: "ⅅ",
  DDotrahd: "⤑",
  DJcy: "Ђ",
  DScy: "Ѕ",
  DZcy: "Џ",
  Dagger: "‡",
  Darr: "↡",
  Dashv: "⫤",
  Dcaron: "Ď",
  Dcy: "Д",
  Del: "∇",
  Delta: "Δ",
  Dfr: "𝔇",
  DiacriticalAcute: "´",
  DiacriticalDot: "˙",
  DiacriticalDoubleAcute: "˝",
  DiacriticalGrave: "`",
  DiacriticalTilde: "˜",
  Diamond: "⋄",
  DifferentialD: "ⅆ",
  Dopf: "𝔻",
  Dot: "¨",
  DotDot: "⃜",
  DotEqual: "≐",
  DoubleContourIntegral: "∯",
  DoubleDot: "¨",
  DoubleDownArrow: "⇓",
  DoubleLeftArrow: "⇐",
  DoubleLeftRightArrow: "⇔",
  DoubleLeftTee: "⫤",
  DoubleLongLeftArrow: "⟸",
  DoubleLongLeftRightArrow: "⟺",
  DoubleLongRightArrow: "⟹",
  DoubleRightArrow: "⇒",
  DoubleRightTee: "⊨",
  DoubleUpArrow: "⇑",
  DoubleUpDownArrow: "⇕",
  DoubleVerticalBar: "∥",
  DownArrow: "↓",
  DownArrowBar: "⤓",
  DownArrowUpArrow: "⇵",
  DownBreve: "̑",
  DownLeftRightVector: "⥐",
  DownLeftTeeVector: "⥞",
  DownLeftVector: "↽",
  DownLeftVectorBar: "⥖",
  DownRightTeeVector: "⥟",
  DownRightVector: "⇁",
  DownRightVectorBar: "⥗",
  DownTee: "⊤",
  DownTeeArrow: "↧",
  Downarrow: "⇓",
  Dscr: "𝒟",
  Dstrok: "Đ",
  ENG: "Ŋ",
  ETH: "Ð",
  Eacute: "É",
  Ecaron: "Ě",
  Ecirc: "Ê",
  Ecy: "Э",
  Edot: "Ė",
  Efr: "𝔈",
  Egrave: "È",
  Element: "∈",
  Emacr: "Ē",
  EmptySmallSquare: "◻",
  EmptyVerySmallSquare: "▫",
  Eogon: "Ę",
  Eopf: "𝔼",
  Epsilon: "Ε",
  Equal: "⩵",
  EqualTilde: "≂",
  Equilibrium: "⇌",
  Escr: "ℰ",
  Esim: "⩳",
  Eta: "Η",
  Euml: "Ë",
  Exists: "∃",
  ExponentialE: "ⅇ",
  Fcy: "Ф",
  Ffr: "𝔉",
  FilledSmallSquare: "◼",
  FilledVerySmallSquare: "▪",
  Fopf: "𝔽",
  ForAll: "∀",
  Fouriertrf: "ℱ",
  Fscr: "ℱ",
  GJcy: "Ѓ",
  GT: ">",
  Gamma: "Γ",
  Gammad: "Ϝ",
  Gbreve: "Ğ",
  Gcedil: "Ģ",
  Gcirc: "Ĝ",
  Gcy: "Г",
  Gdot: "Ġ",
  Gfr: "𝔊",
  Gg: "⋙",
  Gopf: "𝔾",
  GreaterEqual: "≥",
  GreaterEqualLess: "⋛",
  GreaterFullEqual: "≧",
  GreaterGreater: "⪢",
  GreaterLess: "≷",
  GreaterSlantEqual: "⩾",
  GreaterTilde: "≳",
  Gscr: "𝒢",
  Gt: "≫",
  HARDcy: "Ъ",
  Hacek: "ˇ",
  Hat: "^",
  Hcirc: "Ĥ",
  Hfr: "ℌ",
  HilbertSpace: "ℋ",
  Hopf: "ℍ",
  HorizontalLine: "─",
  Hscr: "ℋ",
  Hstrok: "Ħ",
  HumpDownHump: "≎",
  HumpEqual: "≏",
  IEcy: "Е",
  IJlig: "Ĳ",
  IOcy: "Ё",
  Iacute: "Í",
  Icirc: "Î",
  Icy: "И",
  Idot: "İ",
  Ifr: "ℑ",
  Igrave: "Ì",
  Im: "ℑ",
  Imacr: "Ī",
  ImaginaryI: "ⅈ",
  Implies: "⇒",
  Int: "∬",
  Integral: "∫",
  Intersection: "⋂",
  InvisibleComma: "⁣",
  InvisibleTimes: "⁢",
  Iogon: "Į",
  Iopf: "𝕀",
  Iota: "Ι",
  Iscr: "ℐ",
  Itilde: "Ĩ",
  Iukcy: "І",
  Iuml: "Ï",
  Jcirc: "Ĵ",
  Jcy: "Й",
  Jfr: "𝔍",
  Jopf: "𝕁",
  Jscr: "𝒥",
  Jsercy: "Ј",
  Jukcy: "Є",
  KHcy: "Х",
  KJcy: "Ќ",
  Kappa: "Κ",
  Kcedil: "Ķ",
  Kcy: "К",
  Kfr: "𝔎",
  Kopf: "𝕂",
  Kscr: "𝒦",
  LJcy: "Љ",
  LT: "<",
  Lacute: "Ĺ",
  Lambda: "Λ",
  Lang: "⟪",
  Laplacetrf: "ℒ",
  Larr: "↞",
  Lcaron: "Ľ",
  Lcedil: "Ļ",
  Lcy: "Л",
  LeftAngleBracket: "⟨",
  LeftArrow: "←",
  LeftArrowBar: "⇤",
  LeftArrowRightArrow: "⇆",
  LeftCeiling: "⌈",
  LeftDoubleBracket: "⟦",
  LeftDownTeeVector: "⥡",
  LeftDownVector: "⇃",
  LeftDownVectorBar: "⥙",
  LeftFloor: "⌊",
  LeftRightArrow: "↔",
  LeftRightVector: "⥎",
  LeftTee: "⊣",
  LeftTeeArrow: "↤",
  LeftTeeVector: "⥚",
  LeftTriangle: "⊲",
  LeftTriangleBar: "⧏",
  LeftTriangleEqual: "⊴",
  LeftUpDownVector: "⥑",
  LeftUpTeeVector: "⥠",
  LeftUpVector: "↿",
  LeftUpVectorBar: "⥘",
  LeftVector: "↼",
  LeftVectorBar: "⥒",
  Leftarrow: "⇐",
  Leftrightarrow: "⇔",
  LessEqualGreater: "⋚",
  LessFullEqual: "≦",
  LessGreater: "≶",
  LessLess: "⪡",
  LessSlantEqual: "⩽",
  LessTilde: "≲",
  Lfr: "𝔏",
  Ll: "⋘",
  Lleftarrow: "⇚",
  Lmidot: "Ŀ",
  LongLeftArrow: "⟵",
  LongLeftRightArrow: "⟷",
  LongRightArrow: "⟶",
  Longleftarrow: "⟸",
  Longleftrightarrow: "⟺",
  Longrightarrow: "⟹",
  Lopf: "𝕃",
  LowerLeftArrow: "↙",
  LowerRightArrow: "↘",
  Lscr: "ℒ",
  Lsh: "↰",
  Lstrok: "Ł",
  Lt: "≪",
  Map: "⤅",
  Mcy: "М",
  MediumSpace: " ",
  Mellintrf: "ℳ",
  Mfr: "𝔐",
  MinusPlus: "∓",
  Mopf: "𝕄",
  Mscr: "ℳ",
  Mu: "Μ",
  NJcy: "Њ",
  Nacute: "Ń",
  Ncaron: "Ň",
  Ncedil: "Ņ",
  Ncy: "Н",
  NegativeMediumSpace: "​",
  NegativeThickSpace: "​",
  NegativeThinSpace: "​",
  NegativeVeryThinSpace: "​",
  NestedGreaterGreater: "≫",
  NestedLessLess: "≪",
  NewLine: `
`,
  Nfr: "𝔑",
  NoBreak: "⁠",
  NonBreakingSpace: " ",
  Nopf: "ℕ",
  Not: "⫬",
  NotCongruent: "≢",
  NotCupCap: "≭",
  NotDoubleVerticalBar: "∦",
  NotElement: "∉",
  NotEqual: "≠",
  NotEqualTilde: "≂̸",
  NotExists: "∄",
  NotGreater: "≯",
  NotGreaterEqual: "≱",
  NotGreaterFullEqual: "≧̸",
  NotGreaterGreater: "≫̸",
  NotGreaterLess: "≹",
  NotGreaterSlantEqual: "⩾̸",
  NotGreaterTilde: "≵",
  NotHumpDownHump: "≎̸",
  NotHumpEqual: "≏̸",
  NotLeftTriangle: "⋪",
  NotLeftTriangleBar: "⧏̸",
  NotLeftTriangleEqual: "⋬",
  NotLess: "≮",
  NotLessEqual: "≰",
  NotLessGreater: "≸",
  NotLessLess: "≪̸",
  NotLessSlantEqual: "⩽̸",
  NotLessTilde: "≴",
  NotNestedGreaterGreater: "⪢̸",
  NotNestedLessLess: "⪡̸",
  NotPrecedes: "⊀",
  NotPrecedesEqual: "⪯̸",
  NotPrecedesSlantEqual: "⋠",
  NotReverseElement: "∌",
  NotRightTriangle: "⋫",
  NotRightTriangleBar: "⧐̸",
  NotRightTriangleEqual: "⋭",
  NotSquareSubset: "⊏̸",
  NotSquareSubsetEqual: "⋢",
  NotSquareSuperset: "⊐̸",
  NotSquareSupersetEqual: "⋣",
  NotSubset: "⊂⃒",
  NotSubsetEqual: "⊈",
  NotSucceeds: "⊁",
  NotSucceedsEqual: "⪰̸",
  NotSucceedsSlantEqual: "⋡",
  NotSucceedsTilde: "≿̸",
  NotSuperset: "⊃⃒",
  NotSupersetEqual: "⊉",
  NotTilde: "≁",
  NotTildeEqual: "≄",
  NotTildeFullEqual: "≇",
  NotTildeTilde: "≉",
  NotVerticalBar: "∤",
  Nscr: "𝒩",
  Ntilde: "Ñ",
  Nu: "Ν",
  OElig: "Œ",
  Oacute: "Ó",
  Ocirc: "Ô",
  Ocy: "О",
  Odblac: "Ő",
  Ofr: "𝔒",
  Ograve: "Ò",
  Omacr: "Ō",
  Omega: "Ω",
  Omicron: "Ο",
  Oopf: "𝕆",
  OpenCurlyDoubleQuote: "“",
  OpenCurlyQuote: "‘",
  Or: "⩔",
  Oscr: "𝒪",
  Oslash: "Ø",
  Otilde: "Õ",
  Otimes: "⨷",
  Ouml: "Ö",
  OverBar: "‾",
  OverBrace: "⏞",
  OverBracket: "⎴",
  OverParenthesis: "⏜",
  PartialD: "∂",
  Pcy: "П",
  Pfr: "𝔓",
  Phi: "Φ",
  Pi: "Π",
  PlusMinus: "±",
  Poincareplane: "ℌ",
  Popf: "ℙ",
  Pr: "⪻",
  Precedes: "≺",
  PrecedesEqual: "⪯",
  PrecedesSlantEqual: "≼",
  PrecedesTilde: "≾",
  Prime: "″",
  Product: "∏",
  Proportion: "∷",
  Proportional: "∝",
  Pscr: "𝒫",
  Psi: "Ψ",
  QUOT: '"',
  Qfr: "𝔔",
  Qopf: "ℚ",
  Qscr: "𝒬",
  RBarr: "⤐",
  REG: "®",
  Racute: "Ŕ",
  Rang: "⟫",
  Rarr: "↠",
  Rarrtl: "⤖",
  Rcaron: "Ř",
  Rcedil: "Ŗ",
  Rcy: "Р",
  Re: "ℜ",
  ReverseElement: "∋",
  ReverseEquilibrium: "⇋",
  ReverseUpEquilibrium: "⥯",
  Rfr: "ℜ",
  Rho: "Ρ",
  RightAngleBracket: "⟩",
  RightArrow: "→",
  RightArrowBar: "⇥",
  RightArrowLeftArrow: "⇄",
  RightCeiling: "⌉",
  RightDoubleBracket: "⟧",
  RightDownTeeVector: "⥝",
  RightDownVector: "⇂",
  RightDownVectorBar: "⥕",
  RightFloor: "⌋",
  RightTee: "⊢",
  RightTeeArrow: "↦",
  RightTeeVector: "⥛",
  RightTriangle: "⊳",
  RightTriangleBar: "⧐",
  RightTriangleEqual: "⊵",
  RightUpDownVector: "⥏",
  RightUpTeeVector: "⥜",
  RightUpVector: "↾",
  RightUpVectorBar: "⥔",
  RightVector: "⇀",
  RightVectorBar: "⥓",
  Rightarrow: "⇒",
  Ropf: "ℝ",
  RoundImplies: "⥰",
  Rrightarrow: "⇛",
  Rscr: "ℛ",
  Rsh: "↱",
  RuleDelayed: "⧴",
  SHCHcy: "Щ",
  SHcy: "Ш",
  SOFTcy: "Ь",
  Sacute: "Ś",
  Sc: "⪼",
  Scaron: "Š",
  Scedil: "Ş",
  Scirc: "Ŝ",
  Scy: "С",
  Sfr: "𝔖",
  ShortDownArrow: "↓",
  ShortLeftArrow: "←",
  ShortRightArrow: "→",
  ShortUpArrow: "↑",
  Sigma: "Σ",
  SmallCircle: "∘",
  Sopf: "𝕊",
  Sqrt: "√",
  Square: "□",
  SquareIntersection: "⊓",
  SquareSubset: "⊏",
  SquareSubsetEqual: "⊑",
  SquareSuperset: "⊐",
  SquareSupersetEqual: "⊒",
  SquareUnion: "⊔",
  Sscr: "𝒮",
  Star: "⋆",
  Sub: "⋐",
  Subset: "⋐",
  SubsetEqual: "⊆",
  Succeeds: "≻",
  SucceedsEqual: "⪰",
  SucceedsSlantEqual: "≽",
  SucceedsTilde: "≿",
  SuchThat: "∋",
  Sum: "∑",
  Sup: "⋑",
  Superset: "⊃",
  SupersetEqual: "⊇",
  Supset: "⋑",
  THORN: "Þ",
  TRADE: "™",
  TSHcy: "Ћ",
  TScy: "Ц",
  Tab: "	",
  Tau: "Τ",
  Tcaron: "Ť",
  Tcedil: "Ţ",
  Tcy: "Т",
  Tfr: "𝔗",
  Therefore: "∴",
  Theta: "Θ",
  ThickSpace: "  ",
  ThinSpace: " ",
  Tilde: "∼",
  TildeEqual: "≃",
  TildeFullEqual: "≅",
  TildeTilde: "≈",
  Topf: "𝕋",
  TripleDot: "⃛",
  Tscr: "𝒯",
  Tstrok: "Ŧ",
  Uacute: "Ú",
  Uarr: "↟",
  Uarrocir: "⥉",
  Ubrcy: "Ў",
  Ubreve: "Ŭ",
  Ucirc: "Û",
  Ucy: "У",
  Udblac: "Ű",
  Ufr: "𝔘",
  Ugrave: "Ù",
  Umacr: "Ū",
  UnderBar: "_",
  UnderBrace: "⏟",
  UnderBracket: "⎵",
  UnderParenthesis: "⏝",
  Union: "⋃",
  UnionPlus: "⊎",
  Uogon: "Ų",
  Uopf: "𝕌",
  UpArrow: "↑",
  UpArrowBar: "⤒",
  UpArrowDownArrow: "⇅",
  UpDownArrow: "↕",
  UpEquilibrium: "⥮",
  UpTee: "⊥",
  UpTeeArrow: "↥",
  Uparrow: "⇑",
  Updownarrow: "⇕",
  UpperLeftArrow: "↖",
  UpperRightArrow: "↗",
  Upsi: "ϒ",
  Upsilon: "Υ",
  Uring: "Ů",
  Uscr: "𝒰",
  Utilde: "Ũ",
  Uuml: "Ü",
  VDash: "⊫",
  Vbar: "⫫",
  Vcy: "В",
  Vdash: "⊩",
  Vdashl: "⫦",
  Vee: "⋁",
  Verbar: "‖",
  Vert: "‖",
  VerticalBar: "∣",
  VerticalLine: "|",
  VerticalSeparator: "❘",
  VerticalTilde: "≀",
  VeryThinSpace: " ",
  Vfr: "𝔙",
  Vopf: "𝕍",
  Vscr: "𝒱",
  Vvdash: "⊪",
  Wcirc: "Ŵ",
  Wedge: "⋀",
  Wfr: "𝔚",
  Wopf: "𝕎",
  Wscr: "𝒲",
  Xfr: "𝔛",
  Xi: "Ξ",
  Xopf: "𝕏",
  Xscr: "𝒳",
  YAcy: "Я",
  YIcy: "Ї",
  YUcy: "Ю",
  Yacute: "Ý",
  Ycirc: "Ŷ",
  Ycy: "Ы",
  Yfr: "𝔜",
  Yopf: "𝕐",
  Yscr: "𝒴",
  Yuml: "Ÿ",
  ZHcy: "Ж",
  Zacute: "Ź",
  Zcaron: "Ž",
  Zcy: "З",
  Zdot: "Ż",
  ZeroWidthSpace: "​",
  Zeta: "Ζ",
  Zfr: "ℨ",
  Zopf: "ℤ",
  Zscr: "𝒵",
  aacute: "á",
  abreve: "ă",
  ac: "∾",
  acE: "∾̳",
  acd: "∿",
  acirc: "â",
  acute: "´",
  acy: "а",
  aelig: "æ",
  af: "⁡",
  afr: "𝔞",
  agrave: "à",
  alefsym: "ℵ",
  aleph: "ℵ",
  alpha: "α",
  amacr: "ā",
  amalg: "⨿",
  amp: "&",
  and: "∧",
  andand: "⩕",
  andd: "⩜",
  andslope: "⩘",
  andv: "⩚",
  ang: "∠",
  ange: "⦤",
  angle: "∠",
  angmsd: "∡",
  angmsdaa: "⦨",
  angmsdab: "⦩",
  angmsdac: "⦪",
  angmsdad: "⦫",
  angmsdae: "⦬",
  angmsdaf: "⦭",
  angmsdag: "⦮",
  angmsdah: "⦯",
  angrt: "∟",
  angrtvb: "⊾",
  angrtvbd: "⦝",
  angsph: "∢",
  angst: "Å",
  angzarr: "⍼",
  aogon: "ą",
  aopf: "𝕒",
  ap: "≈",
  apE: "⩰",
  apacir: "⩯",
  ape: "≊",
  apid: "≋",
  apos: "'",
  approx: "≈",
  approxeq: "≊",
  aring: "å",
  ascr: "𝒶",
  ast: "*",
  asymp: "≈",
  asympeq: "≍",
  atilde: "ã",
  auml: "ä",
  awconint: "∳",
  awint: "⨑",
  bNot: "⫭",
  backcong: "≌",
  backepsilon: "϶",
  backprime: "‵",
  backsim: "∽",
  backsimeq: "⋍",
  barvee: "⊽",
  barwed: "⌅",
  barwedge: "⌅",
  bbrk: "⎵",
  bbrktbrk: "⎶",
  bcong: "≌",
  bcy: "б",
  bdquo: "„",
  becaus: "∵",
  because: "∵",
  bemptyv: "⦰",
  bepsi: "϶",
  bernou: "ℬ",
  beta: "β",
  beth: "ℶ",
  between: "≬",
  bfr: "𝔟",
  bigcap: "⋂",
  bigcirc: "◯",
  bigcup: "⋃",
  bigodot: "⨀",
  bigoplus: "⨁",
  bigotimes: "⨂",
  bigsqcup: "⨆",
  bigstar: "★",
  bigtriangledown: "▽",
  bigtriangleup: "△",
  biguplus: "⨄",
  bigvee: "⋁",
  bigwedge: "⋀",
  bkarow: "⤍",
  blacklozenge: "⧫",
  blacksquare: "▪",
  blacktriangle: "▴",
  blacktriangledown: "▾",
  blacktriangleleft: "◂",
  blacktriangleright: "▸",
  blank: "␣",
  blk12: "▒",
  blk14: "░",
  blk34: "▓",
  block: "█",
  bne: "=⃥",
  bnequiv: "≡⃥",
  bnot: "⌐",
  bopf: "𝕓",
  bot: "⊥",
  bottom: "⊥",
  bowtie: "⋈",
  boxDL: "╗",
  boxDR: "╔",
  boxDl: "╖",
  boxDr: "╓",
  boxH: "═",
  boxHD: "╦",
  boxHU: "╩",
  boxHd: "╤",
  boxHu: "╧",
  boxUL: "╝",
  boxUR: "╚",
  boxUl: "╜",
  boxUr: "╙",
  boxV: "║",
  boxVH: "╬",
  boxVL: "╣",
  boxVR: "╠",
  boxVh: "╫",
  boxVl: "╢",
  boxVr: "╟",
  boxbox: "⧉",
  boxdL: "╕",
  boxdR: "╒",
  boxdl: "┐",
  boxdr: "┌",
  boxh: "─",
  boxhD: "╥",
  boxhU: "╨",
  boxhd: "┬",
  boxhu: "┴",
  boxminus: "⊟",
  boxplus: "⊞",
  boxtimes: "⊠",
  boxuL: "╛",
  boxuR: "╘",
  boxul: "┘",
  boxur: "└",
  boxv: "│",
  boxvH: "╪",
  boxvL: "╡",
  boxvR: "╞",
  boxvh: "┼",
  boxvl: "┤",
  boxvr: "├",
  bprime: "‵",
  breve: "˘",
  brvbar: "¦",
  bscr: "𝒷",
  bsemi: "⁏",
  bsim: "∽",
  bsime: "⋍",
  bsol: "\\",
  bsolb: "⧅",
  bsolhsub: "⟈",
  bull: "•",
  bullet: "•",
  bump: "≎",
  bumpE: "⪮",
  bumpe: "≏",
  bumpeq: "≏",
  cacute: "ć",
  cap: "∩",
  capand: "⩄",
  capbrcup: "⩉",
  capcap: "⩋",
  capcup: "⩇",
  capdot: "⩀",
  caps: "∩︀",
  caret: "⁁",
  caron: "ˇ",
  ccaps: "⩍",
  ccaron: "č",
  ccedil: "ç",
  ccirc: "ĉ",
  ccups: "⩌",
  ccupssm: "⩐",
  cdot: "ċ",
  cedil: "¸",
  cemptyv: "⦲",
  cent: "¢",
  centerdot: "·",
  cfr: "𝔠",
  chcy: "ч",
  check: "✓",
  checkmark: "✓",
  chi: "χ",
  cir: "○",
  cirE: "⧃",
  circ: "ˆ",
  circeq: "≗",
  circlearrowleft: "↺",
  circlearrowright: "↻",
  circledR: "®",
  circledS: "Ⓢ",
  circledast: "⊛",
  circledcirc: "⊚",
  circleddash: "⊝",
  cire: "≗",
  cirfnint: "⨐",
  cirmid: "⫯",
  cirscir: "⧂",
  clubs: "♣",
  clubsuit: "♣",
  colon: ":",
  colone: "≔",
  coloneq: "≔",
  comma: ",",
  commat: "@",
  comp: "∁",
  compfn: "∘",
  complement: "∁",
  complexes: "ℂ",
  cong: "≅",
  congdot: "⩭",
  conint: "∮",
  copf: "𝕔",
  coprod: "∐",
  copy: "©",
  copysr: "℗",
  crarr: "↵",
  cross: "✗",
  cscr: "𝒸",
  csub: "⫏",
  csube: "⫑",
  csup: "⫐",
  csupe: "⫒",
  ctdot: "⋯",
  cudarrl: "⤸",
  cudarrr: "⤵",
  cuepr: "⋞",
  cuesc: "⋟",
  cularr: "↶",
  cularrp: "⤽",
  cup: "∪",
  cupbrcap: "⩈",
  cupcap: "⩆",
  cupcup: "⩊",
  cupdot: "⊍",
  cupor: "⩅",
  cups: "∪︀",
  curarr: "↷",
  curarrm: "⤼",
  curlyeqprec: "⋞",
  curlyeqsucc: "⋟",
  curlyvee: "⋎",
  curlywedge: "⋏",
  curren: "¤",
  curvearrowleft: "↶",
  curvearrowright: "↷",
  cuvee: "⋎",
  cuwed: "⋏",
  cwconint: "∲",
  cwint: "∱",
  cylcty: "⌭",
  dArr: "⇓",
  dHar: "⥥",
  dagger: "†",
  daleth: "ℸ",
  darr: "↓",
  dash: "‐",
  dashv: "⊣",
  dbkarow: "⤏",
  dblac: "˝",
  dcaron: "ď",
  dcy: "д",
  dd: "ⅆ",
  ddagger: "‡",
  ddarr: "⇊",
  ddotseq: "⩷",
  deg: "°",
  delta: "δ",
  demptyv: "⦱",
  dfisht: "⥿",
  dfr: "𝔡",
  dharl: "⇃",
  dharr: "⇂",
  diam: "⋄",
  diamond: "⋄",
  diamondsuit: "♦",
  diams: "♦",
  die: "¨",
  digamma: "ϝ",
  disin: "⋲",
  div: "÷",
  divide: "÷",
  divideontimes: "⋇",
  divonx: "⋇",
  djcy: "ђ",
  dlcorn: "⌞",
  dlcrop: "⌍",
  dollar: "$",
  dopf: "𝕕",
  dot: "˙",
  doteq: "≐",
  doteqdot: "≑",
  dotminus: "∸",
  dotplus: "∔",
  dotsquare: "⊡",
  doublebarwedge: "⌆",
  downarrow: "↓",
  downdownarrows: "⇊",
  downharpoonleft: "⇃",
  downharpoonright: "⇂",
  drbkarow: "⤐",
  drcorn: "⌟",
  drcrop: "⌌",
  dscr: "𝒹",
  dscy: "ѕ",
  dsol: "⧶",
  dstrok: "đ",
  dtdot: "⋱",
  dtri: "▿",
  dtrif: "▾",
  duarr: "⇵",
  duhar: "⥯",
  dwangle: "⦦",
  dzcy: "џ",
  dzigrarr: "⟿",
  eDDot: "⩷",
  eDot: "≑",
  eacute: "é",
  easter: "⩮",
  ecaron: "ě",
  ecir: "≖",
  ecirc: "ê",
  ecolon: "≕",
  ecy: "э",
  edot: "ė",
  ee: "ⅇ",
  efDot: "≒",
  efr: "𝔢",
  eg: "⪚",
  egrave: "è",
  egs: "⪖",
  egsdot: "⪘",
  el: "⪙",
  elinters: "⏧",
  ell: "ℓ",
  els: "⪕",
  elsdot: "⪗",
  emacr: "ē",
  empty: "∅",
  emptyset: "∅",
  emptyv: "∅",
  emsp13: " ",
  emsp14: " ",
  emsp: " ",
  eng: "ŋ",
  ensp: " ",
  eogon: "ę",
  eopf: "𝕖",
  epar: "⋕",
  eparsl: "⧣",
  eplus: "⩱",
  epsi: "ε",
  epsilon: "ε",
  epsiv: "ϵ",
  eqcirc: "≖",
  eqcolon: "≕",
  eqsim: "≂",
  eqslantgtr: "⪖",
  eqslantless: "⪕",
  equals: "=",
  equest: "≟",
  equiv: "≡",
  equivDD: "⩸",
  eqvparsl: "⧥",
  erDot: "≓",
  erarr: "⥱",
  escr: "ℯ",
  esdot: "≐",
  esim: "≂",
  eta: "η",
  eth: "ð",
  euml: "ë",
  euro: "€",
  excl: "!",
  exist: "∃",
  expectation: "ℰ",
  exponentiale: "ⅇ",
  fallingdotseq: "≒",
  fcy: "ф",
  female: "♀",
  ffilig: "ﬃ",
  fflig: "ﬀ",
  ffllig: "ﬄ",
  ffr: "𝔣",
  filig: "ﬁ",
  fjlig: "fj",
  flat: "♭",
  fllig: "ﬂ",
  fltns: "▱",
  fnof: "ƒ",
  fopf: "𝕗",
  forall: "∀",
  fork: "⋔",
  forkv: "⫙",
  fpartint: "⨍",
  frac12: "½",
  frac13: "⅓",
  frac14: "¼",
  frac15: "⅕",
  frac16: "⅙",
  frac18: "⅛",
  frac23: "⅔",
  frac25: "⅖",
  frac34: "¾",
  frac35: "⅗",
  frac38: "⅜",
  frac45: "⅘",
  frac56: "⅚",
  frac58: "⅝",
  frac78: "⅞",
  frasl: "⁄",
  frown: "⌢",
  fscr: "𝒻",
  gE: "≧",
  gEl: "⪌",
  gacute: "ǵ",
  gamma: "γ",
  gammad: "ϝ",
  gap: "⪆",
  gbreve: "ğ",
  gcirc: "ĝ",
  gcy: "г",
  gdot: "ġ",
  ge: "≥",
  gel: "⋛",
  geq: "≥",
  geqq: "≧",
  geqslant: "⩾",
  ges: "⩾",
  gescc: "⪩",
  gesdot: "⪀",
  gesdoto: "⪂",
  gesdotol: "⪄",
  gesl: "⋛︀",
  gesles: "⪔",
  gfr: "𝔤",
  gg: "≫",
  ggg: "⋙",
  gimel: "ℷ",
  gjcy: "ѓ",
  gl: "≷",
  glE: "⪒",
  gla: "⪥",
  glj: "⪤",
  gnE: "≩",
  gnap: "⪊",
  gnapprox: "⪊",
  gne: "⪈",
  gneq: "⪈",
  gneqq: "≩",
  gnsim: "⋧",
  gopf: "𝕘",
  grave: "`",
  gscr: "ℊ",
  gsim: "≳",
  gsime: "⪎",
  gsiml: "⪐",
  gt: ">",
  gtcc: "⪧",
  gtcir: "⩺",
  gtdot: "⋗",
  gtlPar: "⦕",
  gtquest: "⩼",
  gtrapprox: "⪆",
  gtrarr: "⥸",
  gtrdot: "⋗",
  gtreqless: "⋛",
  gtreqqless: "⪌",
  gtrless: "≷",
  gtrsim: "≳",
  gvertneqq: "≩︀",
  gvnE: "≩︀",
  hArr: "⇔",
  hairsp: " ",
  half: "½",
  hamilt: "ℋ",
  hardcy: "ъ",
  harr: "↔",
  harrcir: "⥈",
  harrw: "↭",
  hbar: "ℏ",
  hcirc: "ĥ",
  hearts: "♥",
  heartsuit: "♥",
  hellip: "…",
  hercon: "⊹",
  hfr: "𝔥",
  hksearow: "⤥",
  hkswarow: "⤦",
  hoarr: "⇿",
  homtht: "∻",
  hookleftarrow: "↩",
  hookrightarrow: "↪",
  hopf: "𝕙",
  horbar: "―",
  hscr: "𝒽",
  hslash: "ℏ",
  hstrok: "ħ",
  hybull: "⁃",
  hyphen: "‐",
  iacute: "í",
  ic: "⁣",
  icirc: "î",
  icy: "и",
  iecy: "е",
  iexcl: "¡",
  iff: "⇔",
  ifr: "𝔦",
  igrave: "ì",
  ii: "ⅈ",
  iiiint: "⨌",
  iiint: "∭",
  iinfin: "⧜",
  iiota: "℩",
  ijlig: "ĳ",
  imacr: "ī",
  image: "ℑ",
  imagline: "ℐ",
  imagpart: "ℑ",
  imath: "ı",
  imof: "⊷",
  imped: "Ƶ",
  in: "∈",
  incare: "℅",
  infin: "∞",
  infintie: "⧝",
  inodot: "ı",
  int: "∫",
  intcal: "⊺",
  integers: "ℤ",
  intercal: "⊺",
  intlarhk: "⨗",
  intprod: "⨼",
  iocy: "ё",
  iogon: "į",
  iopf: "𝕚",
  iota: "ι",
  iprod: "⨼",
  iquest: "¿",
  iscr: "𝒾",
  isin: "∈",
  isinE: "⋹",
  isindot: "⋵",
  isins: "⋴",
  isinsv: "⋳",
  isinv: "∈",
  it: "⁢",
  itilde: "ĩ",
  iukcy: "і",
  iuml: "ï",
  jcirc: "ĵ",
  jcy: "й",
  jfr: "𝔧",
  jmath: "ȷ",
  jopf: "𝕛",
  jscr: "𝒿",
  jsercy: "ј",
  jukcy: "є",
  kappa: "κ",
  kappav: "ϰ",
  kcedil: "ķ",
  kcy: "к",
  kfr: "𝔨",
  kgreen: "ĸ",
  khcy: "х",
  kjcy: "ќ",
  kopf: "𝕜",
  kscr: "𝓀",
  lAarr: "⇚",
  lArr: "⇐",
  lAtail: "⤛",
  lBarr: "⤎",
  lE: "≦",
  lEg: "⪋",
  lHar: "⥢",
  lacute: "ĺ",
  laemptyv: "⦴",
  lagran: "ℒ",
  lambda: "λ",
  lang: "⟨",
  langd: "⦑",
  langle: "⟨",
  lap: "⪅",
  laquo: "«",
  larr: "←",
  larrb: "⇤",
  larrbfs: "⤟",
  larrfs: "⤝",
  larrhk: "↩",
  larrlp: "↫",
  larrpl: "⤹",
  larrsim: "⥳",
  larrtl: "↢",
  lat: "⪫",
  latail: "⤙",
  late: "⪭",
  lates: "⪭︀",
  lbarr: "⤌",
  lbbrk: "❲",
  lbrace: "{",
  lbrack: "[",
  lbrke: "⦋",
  lbrksld: "⦏",
  lbrkslu: "⦍",
  lcaron: "ľ",
  lcedil: "ļ",
  lceil: "⌈",
  lcub: "{",
  lcy: "л",
  ldca: "⤶",
  ldquo: "“",
  ldquor: "„",
  ldrdhar: "⥧",
  ldrushar: "⥋",
  ldsh: "↲",
  le: "≤",
  leftarrow: "←",
  leftarrowtail: "↢",
  leftharpoondown: "↽",
  leftharpoonup: "↼",
  leftleftarrows: "⇇",
  leftrightarrow: "↔",
  leftrightarrows: "⇆",
  leftrightharpoons: "⇋",
  leftrightsquigarrow: "↭",
  leftthreetimes: "⋋",
  leg: "⋚",
  leq: "≤",
  leqq: "≦",
  leqslant: "⩽",
  les: "⩽",
  lescc: "⪨",
  lesdot: "⩿",
  lesdoto: "⪁",
  lesdotor: "⪃",
  lesg: "⋚︀",
  lesges: "⪓",
  lessapprox: "⪅",
  lessdot: "⋖",
  lesseqgtr: "⋚",
  lesseqqgtr: "⪋",
  lessgtr: "≶",
  lesssim: "≲",
  lfisht: "⥼",
  lfloor: "⌊",
  lfr: "𝔩",
  lg: "≶",
  lgE: "⪑",
  lhard: "↽",
  lharu: "↼",
  lharul: "⥪",
  lhblk: "▄",
  ljcy: "љ",
  ll: "≪",
  llarr: "⇇",
  llcorner: "⌞",
  llhard: "⥫",
  lltri: "◺",
  lmidot: "ŀ",
  lmoust: "⎰",
  lmoustache: "⎰",
  lnE: "≨",
  lnap: "⪉",
  lnapprox: "⪉",
  lne: "⪇",
  lneq: "⪇",
  lneqq: "≨",
  lnsim: "⋦",
  loang: "⟬",
  loarr: "⇽",
  lobrk: "⟦",
  longleftarrow: "⟵",
  longleftrightarrow: "⟷",
  longmapsto: "⟼",
  longrightarrow: "⟶",
  looparrowleft: "↫",
  looparrowright: "↬",
  lopar: "⦅",
  lopf: "𝕝",
  loplus: "⨭",
  lotimes: "⨴",
  lowast: "∗",
  lowbar: "_",
  loz: "◊",
  lozenge: "◊",
  lozf: "⧫",
  lpar: "(",
  lparlt: "⦓",
  lrarr: "⇆",
  lrcorner: "⌟",
  lrhar: "⇋",
  lrhard: "⥭",
  lrm: "‎",
  lrtri: "⊿",
  lsaquo: "‹",
  lscr: "𝓁",
  lsh: "↰",
  lsim: "≲",
  lsime: "⪍",
  lsimg: "⪏",
  lsqb: "[",
  lsquo: "‘",
  lsquor: "‚",
  lstrok: "ł",
  lt: "<",
  ltcc: "⪦",
  ltcir: "⩹",
  ltdot: "⋖",
  lthree: "⋋",
  ltimes: "⋉",
  ltlarr: "⥶",
  ltquest: "⩻",
  ltrPar: "⦖",
  ltri: "◃",
  ltrie: "⊴",
  ltrif: "◂",
  lurdshar: "⥊",
  luruhar: "⥦",
  lvertneqq: "≨︀",
  lvnE: "≨︀",
  mDDot: "∺",
  macr: "¯",
  male: "♂",
  malt: "✠",
  maltese: "✠",
  map: "↦",
  mapsto: "↦",
  mapstodown: "↧",
  mapstoleft: "↤",
  mapstoup: "↥",
  marker: "▮",
  mcomma: "⨩",
  mcy: "м",
  mdash: "—",
  measuredangle: "∡",
  mfr: "𝔪",
  mho: "℧",
  micro: "µ",
  mid: "∣",
  midast: "*",
  midcir: "⫰",
  middot: "·",
  minus: "−",
  minusb: "⊟",
  minusd: "∸",
  minusdu: "⨪",
  mlcp: "⫛",
  mldr: "…",
  mnplus: "∓",
  models: "⊧",
  mopf: "𝕞",
  mp: "∓",
  mscr: "𝓂",
  mstpos: "∾",
  mu: "μ",
  multimap: "⊸",
  mumap: "⊸",
  nGg: "⋙̸",
  nGt: "≫⃒",
  nGtv: "≫̸",
  nLeftarrow: "⇍",
  nLeftrightarrow: "⇎",
  nLl: "⋘̸",
  nLt: "≪⃒",
  nLtv: "≪̸",
  nRightarrow: "⇏",
  nVDash: "⊯",
  nVdash: "⊮",
  nabla: "∇",
  nacute: "ń",
  nang: "∠⃒",
  nap: "≉",
  napE: "⩰̸",
  napid: "≋̸",
  napos: "ŉ",
  napprox: "≉",
  natur: "♮",
  natural: "♮",
  naturals: "ℕ",
  nbsp: " ",
  nbump: "≎̸",
  nbumpe: "≏̸",
  ncap: "⩃",
  ncaron: "ň",
  ncedil: "ņ",
  ncong: "≇",
  ncongdot: "⩭̸",
  ncup: "⩂",
  ncy: "н",
  ndash: "–",
  ne: "≠",
  neArr: "⇗",
  nearhk: "⤤",
  nearr: "↗",
  nearrow: "↗",
  nedot: "≐̸",
  nequiv: "≢",
  nesear: "⤨",
  nesim: "≂̸",
  nexist: "∄",
  nexists: "∄",
  nfr: "𝔫",
  ngE: "≧̸",
  nge: "≱",
  ngeq: "≱",
  ngeqq: "≧̸",
  ngeqslant: "⩾̸",
  nges: "⩾̸",
  ngsim: "≵",
  ngt: "≯",
  ngtr: "≯",
  nhArr: "⇎",
  nharr: "↮",
  nhpar: "⫲",
  ni: "∋",
  nis: "⋼",
  nisd: "⋺",
  niv: "∋",
  njcy: "њ",
  nlArr: "⇍",
  nlE: "≦̸",
  nlarr: "↚",
  nldr: "‥",
  nle: "≰",
  nleftarrow: "↚",
  nleftrightarrow: "↮",
  nleq: "≰",
  nleqq: "≦̸",
  nleqslant: "⩽̸",
  nles: "⩽̸",
  nless: "≮",
  nlsim: "≴",
  nlt: "≮",
  nltri: "⋪",
  nltrie: "⋬",
  nmid: "∤",
  nopf: "𝕟",
  not: "¬",
  notin: "∉",
  notinE: "⋹̸",
  notindot: "⋵̸",
  notinva: "∉",
  notinvb: "⋷",
  notinvc: "⋶",
  notni: "∌",
  notniva: "∌",
  notnivb: "⋾",
  notnivc: "⋽",
  npar: "∦",
  nparallel: "∦",
  nparsl: "⫽⃥",
  npart: "∂̸",
  npolint: "⨔",
  npr: "⊀",
  nprcue: "⋠",
  npre: "⪯̸",
  nprec: "⊀",
  npreceq: "⪯̸",
  nrArr: "⇏",
  nrarr: "↛",
  nrarrc: "⤳̸",
  nrarrw: "↝̸",
  nrightarrow: "↛",
  nrtri: "⋫",
  nrtrie: "⋭",
  nsc: "⊁",
  nsccue: "⋡",
  nsce: "⪰̸",
  nscr: "𝓃",
  nshortmid: "∤",
  nshortparallel: "∦",
  nsim: "≁",
  nsime: "≄",
  nsimeq: "≄",
  nsmid: "∤",
  nspar: "∦",
  nsqsube: "⋢",
  nsqsupe: "⋣",
  nsub: "⊄",
  nsubE: "⫅̸",
  nsube: "⊈",
  nsubset: "⊂⃒",
  nsubseteq: "⊈",
  nsubseteqq: "⫅̸",
  nsucc: "⊁",
  nsucceq: "⪰̸",
  nsup: "⊅",
  nsupE: "⫆̸",
  nsupe: "⊉",
  nsupset: "⊃⃒",
  nsupseteq: "⊉",
  nsupseteqq: "⫆̸",
  ntgl: "≹",
  ntilde: "ñ",
  ntlg: "≸",
  ntriangleleft: "⋪",
  ntrianglelefteq: "⋬",
  ntriangleright: "⋫",
  ntrianglerighteq: "⋭",
  nu: "ν",
  num: "#",
  numero: "№",
  numsp: " ",
  nvDash: "⊭",
  nvHarr: "⤄",
  nvap: "≍⃒",
  nvdash: "⊬",
  nvge: "≥⃒",
  nvgt: ">⃒",
  nvinfin: "⧞",
  nvlArr: "⤂",
  nvle: "≤⃒",
  nvlt: "<⃒",
  nvltrie: "⊴⃒",
  nvrArr: "⤃",
  nvrtrie: "⊵⃒",
  nvsim: "∼⃒",
  nwArr: "⇖",
  nwarhk: "⤣",
  nwarr: "↖",
  nwarrow: "↖",
  nwnear: "⤧",
  oS: "Ⓢ",
  oacute: "ó",
  oast: "⊛",
  ocir: "⊚",
  ocirc: "ô",
  ocy: "о",
  odash: "⊝",
  odblac: "ő",
  odiv: "⨸",
  odot: "⊙",
  odsold: "⦼",
  oelig: "œ",
  ofcir: "⦿",
  ofr: "𝔬",
  ogon: "˛",
  ograve: "ò",
  ogt: "⧁",
  ohbar: "⦵",
  ohm: "Ω",
  oint: "∮",
  olarr: "↺",
  olcir: "⦾",
  olcross: "⦻",
  oline: "‾",
  olt: "⧀",
  omacr: "ō",
  omega: "ω",
  omicron: "ο",
  omid: "⦶",
  ominus: "⊖",
  oopf: "𝕠",
  opar: "⦷",
  operp: "⦹",
  oplus: "⊕",
  or: "∨",
  orarr: "↻",
  ord: "⩝",
  order: "ℴ",
  orderof: "ℴ",
  ordf: "ª",
  ordm: "º",
  origof: "⊶",
  oror: "⩖",
  orslope: "⩗",
  orv: "⩛",
  oscr: "ℴ",
  oslash: "ø",
  osol: "⊘",
  otilde: "õ",
  otimes: "⊗",
  otimesas: "⨶",
  ouml: "ö",
  ovbar: "⌽",
  par: "∥",
  para: "¶",
  parallel: "∥",
  parsim: "⫳",
  parsl: "⫽",
  part: "∂",
  pcy: "п",
  percnt: "%",
  period: ".",
  permil: "‰",
  perp: "⊥",
  pertenk: "‱",
  pfr: "𝔭",
  phi: "φ",
  phiv: "ϕ",
  phmmat: "ℳ",
  phone: "☎",
  pi: "π",
  pitchfork: "⋔",
  piv: "ϖ",
  planck: "ℏ",
  planckh: "ℎ",
  plankv: "ℏ",
  plus: "+",
  plusacir: "⨣",
  plusb: "⊞",
  pluscir: "⨢",
  plusdo: "∔",
  plusdu: "⨥",
  pluse: "⩲",
  plusmn: "±",
  plussim: "⨦",
  plustwo: "⨧",
  pm: "±",
  pointint: "⨕",
  popf: "𝕡",
  pound: "£",
  pr: "≺",
  prE: "⪳",
  prap: "⪷",
  prcue: "≼",
  pre: "⪯",
  prec: "≺",
  precapprox: "⪷",
  preccurlyeq: "≼",
  preceq: "⪯",
  precnapprox: "⪹",
  precneqq: "⪵",
  precnsim: "⋨",
  precsim: "≾",
  prime: "′",
  primes: "ℙ",
  prnE: "⪵",
  prnap: "⪹",
  prnsim: "⋨",
  prod: "∏",
  profalar: "⌮",
  profline: "⌒",
  profsurf: "⌓",
  prop: "∝",
  propto: "∝",
  prsim: "≾",
  prurel: "⊰",
  pscr: "𝓅",
  psi: "ψ",
  puncsp: " ",
  qfr: "𝔮",
  qint: "⨌",
  qopf: "𝕢",
  qprime: "⁗",
  qscr: "𝓆",
  quaternions: "ℍ",
  quatint: "⨖",
  quest: "?",
  questeq: "≟",
  quot: '"',
  rAarr: "⇛",
  rArr: "⇒",
  rAtail: "⤜",
  rBarr: "⤏",
  rHar: "⥤",
  race: "∽̱",
  racute: "ŕ",
  radic: "√",
  raemptyv: "⦳",
  rang: "⟩",
  rangd: "⦒",
  range: "⦥",
  rangle: "⟩",
  raquo: "»",
  rarr: "→",
  rarrap: "⥵",
  rarrb: "⇥",
  rarrbfs: "⤠",
  rarrc: "⤳",
  rarrfs: "⤞",
  rarrhk: "↪",
  rarrlp: "↬",
  rarrpl: "⥅",
  rarrsim: "⥴",
  rarrtl: "↣",
  rarrw: "↝",
  ratail: "⤚",
  ratio: "∶",
  rationals: "ℚ",
  rbarr: "⤍",
  rbbrk: "❳",
  rbrace: "}",
  rbrack: "]",
  rbrke: "⦌",
  rbrksld: "⦎",
  rbrkslu: "⦐",
  rcaron: "ř",
  rcedil: "ŗ",
  rceil: "⌉",
  rcub: "}",
  rcy: "р",
  rdca: "⤷",
  rdldhar: "⥩",
  rdquo: "”",
  rdquor: "”",
  rdsh: "↳",
  real: "ℜ",
  realine: "ℛ",
  realpart: "ℜ",
  reals: "ℝ",
  rect: "▭",
  reg: "®",
  rfisht: "⥽",
  rfloor: "⌋",
  rfr: "𝔯",
  rhard: "⇁",
  rharu: "⇀",
  rharul: "⥬",
  rho: "ρ",
  rhov: "ϱ",
  rightarrow: "→",
  rightarrowtail: "↣",
  rightharpoondown: "⇁",
  rightharpoonup: "⇀",
  rightleftarrows: "⇄",
  rightleftharpoons: "⇌",
  rightrightarrows: "⇉",
  rightsquigarrow: "↝",
  rightthreetimes: "⋌",
  ring: "˚",
  risingdotseq: "≓",
  rlarr: "⇄",
  rlhar: "⇌",
  rlm: "‏",
  rmoust: "⎱",
  rmoustache: "⎱",
  rnmid: "⫮",
  roang: "⟭",
  roarr: "⇾",
  robrk: "⟧",
  ropar: "⦆",
  ropf: "𝕣",
  roplus: "⨮",
  rotimes: "⨵",
  rpar: ")",
  rpargt: "⦔",
  rppolint: "⨒",
  rrarr: "⇉",
  rsaquo: "›",
  rscr: "𝓇",
  rsh: "↱",
  rsqb: "]",
  rsquo: "’",
  rsquor: "’",
  rthree: "⋌",
  rtimes: "⋊",
  rtri: "▹",
  rtrie: "⊵",
  rtrif: "▸",
  rtriltri: "⧎",
  ruluhar: "⥨",
  rx: "℞",
  sacute: "ś",
  sbquo: "‚",
  sc: "≻",
  scE: "⪴",
  scap: "⪸",
  scaron: "š",
  sccue: "≽",
  sce: "⪰",
  scedil: "ş",
  scirc: "ŝ",
  scnE: "⪶",
  scnap: "⪺",
  scnsim: "⋩",
  scpolint: "⨓",
  scsim: "≿",
  scy: "с",
  sdot: "⋅",
  sdotb: "⊡",
  sdote: "⩦",
  seArr: "⇘",
  searhk: "⤥",
  searr: "↘",
  searrow: "↘",
  sect: "§",
  semi: ";",
  seswar: "⤩",
  setminus: "∖",
  setmn: "∖",
  sext: "✶",
  sfr: "𝔰",
  sfrown: "⌢",
  sharp: "♯",
  shchcy: "щ",
  shcy: "ш",
  shortmid: "∣",
  shortparallel: "∥",
  shy: "­",
  sigma: "σ",
  sigmaf: "ς",
  sigmav: "ς",
  sim: "∼",
  simdot: "⩪",
  sime: "≃",
  simeq: "≃",
  simg: "⪞",
  simgE: "⪠",
  siml: "⪝",
  simlE: "⪟",
  simne: "≆",
  simplus: "⨤",
  simrarr: "⥲",
  slarr: "←",
  smallsetminus: "∖",
  smashp: "⨳",
  smeparsl: "⧤",
  smid: "∣",
  smile: "⌣",
  smt: "⪪",
  smte: "⪬",
  smtes: "⪬︀",
  softcy: "ь",
  sol: "/",
  solb: "⧄",
  solbar: "⌿",
  sopf: "𝕤",
  spades: "♠",
  spadesuit: "♠",
  spar: "∥",
  sqcap: "⊓",
  sqcaps: "⊓︀",
  sqcup: "⊔",
  sqcups: "⊔︀",
  sqsub: "⊏",
  sqsube: "⊑",
  sqsubset: "⊏",
  sqsubseteq: "⊑",
  sqsup: "⊐",
  sqsupe: "⊒",
  sqsupset: "⊐",
  sqsupseteq: "⊒",
  squ: "□",
  square: "□",
  squarf: "▪",
  squf: "▪",
  srarr: "→",
  sscr: "𝓈",
  ssetmn: "∖",
  ssmile: "⌣",
  sstarf: "⋆",
  star: "☆",
  starf: "★",
  straightepsilon: "ϵ",
  straightphi: "ϕ",
  strns: "¯",
  sub: "⊂",
  subE: "⫅",
  subdot: "⪽",
  sube: "⊆",
  subedot: "⫃",
  submult: "⫁",
  subnE: "⫋",
  subne: "⊊",
  subplus: "⪿",
  subrarr: "⥹",
  subset: "⊂",
  subseteq: "⊆",
  subseteqq: "⫅",
  subsetneq: "⊊",
  subsetneqq: "⫋",
  subsim: "⫇",
  subsub: "⫕",
  subsup: "⫓",
  succ: "≻",
  succapprox: "⪸",
  succcurlyeq: "≽",
  succeq: "⪰",
  succnapprox: "⪺",
  succneqq: "⪶",
  succnsim: "⋩",
  succsim: "≿",
  sum: "∑",
  sung: "♪",
  sup1: "¹",
  sup2: "²",
  sup3: "³",
  sup: "⊃",
  supE: "⫆",
  supdot: "⪾",
  supdsub: "⫘",
  supe: "⊇",
  supedot: "⫄",
  suphsol: "⟉",
  suphsub: "⫗",
  suplarr: "⥻",
  supmult: "⫂",
  supnE: "⫌",
  supne: "⊋",
  supplus: "⫀",
  supset: "⊃",
  supseteq: "⊇",
  supseteqq: "⫆",
  supsetneq: "⊋",
  supsetneqq: "⫌",
  supsim: "⫈",
  supsub: "⫔",
  supsup: "⫖",
  swArr: "⇙",
  swarhk: "⤦",
  swarr: "↙",
  swarrow: "↙",
  swnwar: "⤪",
  szlig: "ß",
  target: "⌖",
  tau: "τ",
  tbrk: "⎴",
  tcaron: "ť",
  tcedil: "ţ",
  tcy: "т",
  tdot: "⃛",
  telrec: "⌕",
  tfr: "𝔱",
  there4: "∴",
  therefore: "∴",
  theta: "θ",
  thetasym: "ϑ",
  thetav: "ϑ",
  thickapprox: "≈",
  thicksim: "∼",
  thinsp: " ",
  thkap: "≈",
  thksim: "∼",
  thorn: "þ",
  tilde: "˜",
  times: "×",
  timesb: "⊠",
  timesbar: "⨱",
  timesd: "⨰",
  tint: "∭",
  toea: "⤨",
  top: "⊤",
  topbot: "⌶",
  topcir: "⫱",
  topf: "𝕥",
  topfork: "⫚",
  tosa: "⤩",
  tprime: "‴",
  trade: "™",
  triangle: "▵",
  triangledown: "▿",
  triangleleft: "◃",
  trianglelefteq: "⊴",
  triangleq: "≜",
  triangleright: "▹",
  trianglerighteq: "⊵",
  tridot: "◬",
  trie: "≜",
  triminus: "⨺",
  triplus: "⨹",
  trisb: "⧍",
  tritime: "⨻",
  trpezium: "⏢",
  tscr: "𝓉",
  tscy: "ц",
  tshcy: "ћ",
  tstrok: "ŧ",
  twixt: "≬",
  twoheadleftarrow: "↞",
  twoheadrightarrow: "↠",
  uArr: "⇑",
  uHar: "⥣",
  uacute: "ú",
  uarr: "↑",
  ubrcy: "ў",
  ubreve: "ŭ",
  ucirc: "û",
  ucy: "у",
  udarr: "⇅",
  udblac: "ű",
  udhar: "⥮",
  ufisht: "⥾",
  ufr: "𝔲",
  ugrave: "ù",
  uharl: "↿",
  uharr: "↾",
  uhblk: "▀",
  ulcorn: "⌜",
  ulcorner: "⌜",
  ulcrop: "⌏",
  ultri: "◸",
  umacr: "ū",
  uml: "¨",
  uogon: "ų",
  uopf: "𝕦",
  uparrow: "↑",
  updownarrow: "↕",
  upharpoonleft: "↿",
  upharpoonright: "↾",
  uplus: "⊎",
  upsi: "υ",
  upsih: "ϒ",
  upsilon: "υ",
  upuparrows: "⇈",
  urcorn: "⌝",
  urcorner: "⌝",
  urcrop: "⌎",
  uring: "ů",
  urtri: "◹",
  uscr: "𝓊",
  utdot: "⋰",
  utilde: "ũ",
  utri: "▵",
  utrif: "▴",
  uuarr: "⇈",
  uuml: "ü",
  uwangle: "⦧",
  vArr: "⇕",
  vBar: "⫨",
  vBarv: "⫩",
  vDash: "⊨",
  vangrt: "⦜",
  varepsilon: "ϵ",
  varkappa: "ϰ",
  varnothing: "∅",
  varphi: "ϕ",
  varpi: "ϖ",
  varpropto: "∝",
  varr: "↕",
  varrho: "ϱ",
  varsigma: "ς",
  varsubsetneq: "⊊︀",
  varsubsetneqq: "⫋︀",
  varsupsetneq: "⊋︀",
  varsupsetneqq: "⫌︀",
  vartheta: "ϑ",
  vartriangleleft: "⊲",
  vartriangleright: "⊳",
  vcy: "в",
  vdash: "⊢",
  vee: "∨",
  veebar: "⊻",
  veeeq: "≚",
  vellip: "⋮",
  verbar: "|",
  vert: "|",
  vfr: "𝔳",
  vltri: "⊲",
  vnsub: "⊂⃒",
  vnsup: "⊃⃒",
  vopf: "𝕧",
  vprop: "∝",
  vrtri: "⊳",
  vscr: "𝓋",
  vsubnE: "⫋︀",
  vsubne: "⊊︀",
  vsupnE: "⫌︀",
  vsupne: "⊋︀",
  vzigzag: "⦚",
  wcirc: "ŵ",
  wedbar: "⩟",
  wedge: "∧",
  wedgeq: "≙",
  weierp: "℘",
  wfr: "𝔴",
  wopf: "𝕨",
  wp: "℘",
  wr: "≀",
  wreath: "≀",
  wscr: "𝓌",
  xcap: "⋂",
  xcirc: "◯",
  xcup: "⋃",
  xdtri: "▽",
  xfr: "𝔵",
  xhArr: "⟺",
  xharr: "⟷",
  xi: "ξ",
  xlArr: "⟸",
  xlarr: "⟵",
  xmap: "⟼",
  xnis: "⋻",
  xodot: "⨀",
  xopf: "𝕩",
  xoplus: "⨁",
  xotime: "⨂",
  xrArr: "⟹",
  xrarr: "⟶",
  xscr: "𝓍",
  xsqcup: "⨆",
  xuplus: "⨄",
  xutri: "△",
  xvee: "⋁",
  xwedge: "⋀",
  yacute: "ý",
  yacy: "я",
  ycirc: "ŷ",
  ycy: "ы",
  yen: "¥",
  yfr: "𝔶",
  yicy: "ї",
  yopf: "𝕪",
  yscr: "𝓎",
  yucy: "ю",
  yuml: "ÿ",
  zacute: "ź",
  zcaron: "ž",
  zcy: "з",
  zdot: "ż",
  zeetrf: "ℨ",
  zeta: "ζ",
  zfr: "𝔷",
  zhcy: "ж",
  zigrarr: "⇝",
  zopf: "𝕫",
  zscr: "𝓏",
  zwj: "‍",
  zwnj: "‌"
}, je = {}.hasOwnProperty;
function wt(t) {
  return je.call(Ut, t) ? Ut[t] : !1;
}
function $(t, n, e, r) {
  const u = t.length;
  let a = 0, i;
  if (n < 0 ? n = -n > u ? 0 : u + n : n = n > u ? u : n, e = e > 0 ? e : 0, r.length < 1e4)
    i = Array.from(r), i.unshift(n, e), t.splice(...i);
  else
    for (e && t.splice(n, e); a < r.length; )
      i = r.slice(a, a + 1e4), i.unshift(n, 0), t.splice(...i), a += 1e4, n += 1e4;
}
function j(t, n) {
  return t.length > 0 ? ($(t, t.length, 0, n), t) : n;
}
const Lt = {}.hasOwnProperty;
function Ue(t) {
  const n = {};
  let e = -1;
  for (; ++e < t.length; )
    Ge(n, t[e]);
  return n;
}
function Ge(t, n) {
  let e;
  for (e in n) {
    const u = (Lt.call(t, e) ? t[e] : void 0) || (t[e] = {}), a = n[e];
    let i;
    if (a)
      for (i in a) {
        Lt.call(u, i) || (u[i] = []);
        const l = a[i];
        Qe(
          // @ts-expect-error Looks like a list.
          u[i],
          Array.isArray(l) ? l : l ? [l] : []
        );
      }
  }
}
function Qe(t, n) {
  let e = -1;
  const r = [];
  for (; ++e < n.length; )
    (n[e].add === "after" ? t : r).push(n[e]);
  $(t, 0, 0, r);
}
function We(t) {
  const n = {};
  let e = -1;
  for (; ++e < t.length; )
    $e(n, t[e]);
  return n;
}
function $e(t, n) {
  let e;
  for (e in n) {
    const u = (Lt.call(t, e) ? t[e] : void 0) || (t[e] = {}), a = n[e];
    let i;
    if (a)
      for (i in a)
        u[i] = a[i];
  }
}
function Ye(t, n) {
  const e = Number.parseInt(t, n);
  return (
    // C0 except for HT, LF, FF, CR, space.
    e < 9 || e === 11 || e > 13 && e < 32 || // Control character (DEL) of C0, and C1 controls.
    e > 126 && e < 160 || // Lone high surrogates and low surrogates.
    e > 55295 && e < 57344 || // Noncharacters.
    e > 64975 && e < 65008 || /* eslint-disable no-bitwise */
    (e & 65535) === 65535 || (e & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    e > 1114111 ? "�" : String.fromCodePoint(e)
  );
}
const Ze = { '"': "quot", "&": "amp", "<": "lt", ">": "gt" };
function ae(t) {
  return t.replace(/["&<>]/g, n);
  function n(e) {
    return "&" + Ze[e] + ";";
  }
}
function et(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const W = lt(/[A-Za-z]/), U = lt(/[\dA-Za-z]/), Je = lt(/[#-'*+\--9=?A-Z^-~]/);
function vt(t) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    t !== null && (t < 32 || t === 127)
  );
}
const zt = lt(/\d/), Ke = lt(/[\dA-Fa-f]/), Xe = lt(/[!-/:-@[-`{-~]/);
function z(t) {
  return t !== null && t < -2;
}
function _(t) {
  return t !== null && (t < 0 || t === 32);
}
function R(t) {
  return t === -2 || t === -1 || t === 32;
}
const tn = lt(new RegExp("\\p{P}|\\p{S}", "u")), en = lt(/\s/);
function lt(t) {
  return n;
  function n(e) {
    return e !== null && e > -1 && t.test(String.fromCharCode(e));
  }
}
function gt(t, n) {
  const e = ae(nn(t || ""));
  if (!n)
    return e;
  const r = e.indexOf(":"), u = e.indexOf("?"), a = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, it’s relative.
    r < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    i > -1 && r > i || u > -1 && r > u || a > -1 && r > a || // It is a protocol, it should be allowed.
    n.test(e.slice(0, r)) ? e : ""
  );
}
function nn(t) {
  const n = [];
  let e = -1, r = 0, u = 0;
  for (; ++e < t.length; ) {
    const a = t.charCodeAt(e);
    let i = "";
    if (a === 37 && U(t.charCodeAt(e + 1)) && U(t.charCodeAt(e + 2)))
      u = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (i = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const l = t.charCodeAt(e + 1);
      a < 56320 && l > 56319 && l < 57344 ? (i = String.fromCharCode(a, l), u = 1) : i = "�";
    } else
      i = String.fromCharCode(a);
    i && (n.push(t.slice(r, e), encodeURIComponent(i)), r = e + u + 1, i = ""), u && (e += u, u = 0);
  }
  return n.join("") + t.slice(r);
}
const Gt = {}.hasOwnProperty, Qt = /^(https?|ircs?|mailto|xmpp)$/i, rn = /^https?$/i;
function an(t) {
  const n = t || {};
  let e = !0;
  const r = {}, u = [[]], a = [], i = [], c = (
    /** @type {NormalizedHtmlExtension} */
    We(
      [{
        enter: {
          blockQuote: d,
          codeFenced: nt,
          codeFencedFenceInfo: k,
          codeFencedFenceMeta: k,
          codeIndented: rt,
          codeText: Oe,
          content: Ce,
          definition: de,
          definitionDestinationString: ke,
          definitionLabelString: k,
          definitionTitleString: k,
          emphasis: Fe,
          htmlFlow: Te,
          htmlText: _t,
          image: J,
          label: k,
          link: ot,
          listItemMarker: L,
          listItemValue: x,
          listOrdered: F,
          listUnordered: P,
          paragraph: V,
          reference: k,
          resource: st,
          resourceDestinationString: ct,
          resourceTitleString: k,
          setextHeading: Ee,
          strong: Ne
        },
        exit: {
          atxHeading: qe,
          atxHeadingSequence: Ae,
          autolinkEmail: He,
          autolinkProtocol: Ve,
          blockQuote: M,
          characterEscapeValue: ft,
          characterReferenceMarkerHexadecimal: Mt,
          characterReferenceMarkerNumeric: Mt,
          characterReferenceValue: Me,
          codeFenced: m,
          codeFencedFence: Z,
          codeFencedFenceInfo: g,
          codeFencedFenceMeta: y,
          codeFlowValue: Ie,
          codeIndented: m,
          codeText: Re,
          codeTextData: ft,
          data: ft,
          definition: ye,
          definitionDestinationString: we,
          definitionLabelString: xe,
          definitionTitleString: Se,
          emphasis: Be,
          hardBreakEscape: Bt,
          hardBreakTrailing: Bt,
          htmlFlow: Pt,
          htmlFlowData: ft,
          htmlText: Pt,
          htmlTextData: ft,
          image: Rt,
          label: mt,
          labelText: H,
          lineEnding: ze,
          link: Rt,
          listOrdered: D,
          listUnordered: B,
          paragraph: Y,
          reference: y,
          referenceString: ut,
          resource: y,
          resourceDestinationString: Ct,
          resourceTitleString: be,
          setextHeading: ve,
          setextHeadingLineSequence: Le,
          setextHeadingText: De,
          strong: Pe,
          thematicBreak: _e
        }
      }].concat(n.htmlExtensions || [])
    )
  ), o = {
    tightStack: i,
    definitions: r
  }, p = {
    lineEndingIfNeeded: v,
    options: n,
    encode: S,
    raw: A,
    tag: E,
    buffer: k,
    resume: w,
    setData: b,
    getData: C
  };
  let h = n.defaultLineEnding;
  return f;
  function f(q) {
    let I = -1, G = 0;
    const K = [];
    let X = [], it = [];
    for (; ++I < q.length; )
      !h && (q[I][1].type === "lineEnding" || q[I][1].type === "lineEndingBlank") && (h = q[I][2].sliceSerialize(q[I][1])), (q[I][1].type === "listOrdered" || q[I][1].type === "listUnordered") && (q[I][0] === "enter" ? K.push(I) : s(q.slice(K.pop(), I))), q[I][1].type === "definition" && (q[I][0] === "enter" ? (it = j(it, q.slice(G, I)), G = I) : (X = j(X, q.slice(G, I + 1)), G = I + 1));
    X = j(X, it), X = j(X, q.slice(G)), I = -1;
    const tt = X;
    for (c.enter.null && c.enter.null.call(p); ++I < q.length; ) {
      const Vt = c[tt[I][0]], Ht = tt[I][1].type, jt = Vt[Ht];
      Gt.call(Vt, Ht) && jt && jt.call(
        Object.assign(
          {
            sliceSerialize: tt[I][2].sliceSerialize
          },
          p
        ),
        tt[I][1]
      );
    }
    return c.exit.null && c.exit.null.call(p), u[0].join("");
  }
  function s(q) {
    const I = q.length;
    let G = 0, K = 0, X = !1, it;
    for (; ++G < I; ) {
      const tt = q[G];
      if (tt[1]._container)
        it = void 0, tt[0] === "enter" ? K++ : K--;
      else
        switch (tt[1].type) {
          case "listItemPrefix": {
            tt[0] === "exit" && (it = !0);
            break;
          }
          case "linePrefix":
            break;
          case "lineEndingBlank": {
            tt[0] === "enter" && !K && (it ? it = void 0 : X = !0);
            break;
          }
          default:
            it = void 0;
        }
    }
    q[0][1]._loose = X;
  }
  function b(q, I) {
    o[q] = I;
  }
  function C(q) {
    return o[q];
  }
  function k() {
    u.push([]);
  }
  function w() {
    return u.pop().join("");
  }
  function E(q) {
    e && (b("lastWasTag", !0), u[u.length - 1].push(q));
  }
  function A(q) {
    b("lastWasTag"), u[u.length - 1].push(q);
  }
  function T() {
    A(h || `
`);
  }
  function v() {
    const q = u[u.length - 1], I = q[q.length - 1], G = I ? I.charCodeAt(I.length - 1) : null;
    G === 10 || G === 13 || G === null || T();
  }
  function S(q) {
    return C("ignoreEncode") ? q : ae(q);
  }
  function y() {
    w();
  }
  function F(q) {
    i.push(!q._loose), v(), E("<ol"), b("expectFirstItem", !0);
  }
  function P(q) {
    i.push(!q._loose), v(), E("<ul"), b("expectFirstItem", !0);
  }
  function x(q) {
    if (C("expectFirstItem")) {
      const I = Number.parseInt(this.sliceSerialize(q), 10);
      I !== 1 && E(' start="' + S(String(I)) + '"');
    }
  }
  function L() {
    C("expectFirstItem") ? E(">") : O(), v(), E("<li>"), b("expectFirstItem"), b("lastWasTag");
  }
  function D() {
    O(), i.pop(), T(), E("</ol>");
  }
  function B() {
    O(), i.pop(), T(), E("</ul>");
  }
  function O() {
    C("lastWasTag") && !C("slurpAllLineEndings") && v(), E("</li>"), b("slurpAllLineEndings");
  }
  function d() {
    i.push(!1), v(), E("<blockquote>");
  }
  function M() {
    i.pop(), v(), E("</blockquote>"), b("slurpAllLineEndings");
  }
  function V() {
    i[i.length - 1] || (v(), E("<p>")), b("slurpAllLineEndings");
  }
  function Y() {
    i[i.length - 1] ? b("slurpAllLineEndings", !0) : E("</p>");
  }
  function nt() {
    v(), E("<pre><code"), b("fencesCount", 0);
  }
  function g() {
    const q = w();
    E(' class="language-' + q + '"');
  }
  function Z() {
    const q = C("fencesCount") || 0;
    q || (E(">"), b("slurpOneLineEnding", !0)), b("fencesCount", q + 1);
  }
  function rt() {
    v(), E("<pre><code>");
  }
  function m() {
    const q = C("fencesCount");
    q !== void 0 && q < 2 && o.tightStack.length > 0 && !C("lastWasTag") && T(), C("flowCodeSeenData") && v(), E("</code></pre>"), q !== void 0 && q < 2 && v(), b("flowCodeSeenData"), b("fencesCount"), b("slurpOneLineEnding");
  }
  function J() {
    a.push({
      image: !0
    }), e = void 0;
  }
  function ot() {
    a.push({});
  }
  function H(q) {
    a[a.length - 1].labelId = this.sliceSerialize(q);
  }
  function mt() {
    a[a.length - 1].label = w();
  }
  function ut(q) {
    a[a.length - 1].referenceId = this.sliceSerialize(q);
  }
  function st() {
    k(), a[a.length - 1].destination = "";
  }
  function ct() {
    k(), b("ignoreEncode", !0);
  }
  function Ct() {
    a[a.length - 1].destination = w(), b("ignoreEncode");
  }
  function be() {
    a[a.length - 1].title = w();
  }
  function Rt() {
    let q = a.length - 1;
    const I = a[q], G = I.referenceId || I.labelId, K = I.destination === void 0 ? r[et(G)] : I;
    for (e = !0; q--; )
      if (a[q].image) {
        e = void 0;
        break;
      }
    I.image ? (E(
      '<img src="' + gt(
        K.destination,
        n.allowDangerousProtocol ? void 0 : rn
      ) + '" alt="'
    ), A(I.label), E('"')) : E(
      '<a href="' + gt(
        K.destination,
        n.allowDangerousProtocol ? void 0 : Qt
      ) + '"'
    ), E(K.title ? ' title="' + K.title + '"' : ""), I.image ? E(" />") : (E(">"), A(I.label), E("</a>")), a.pop();
  }
  function de() {
    k(), a.push({});
  }
  function xe(q) {
    w(), a[a.length - 1].labelId = this.sliceSerialize(q);
  }
  function ke() {
    k(), b("ignoreEncode", !0);
  }
  function we() {
    a[a.length - 1].destination = w(), b("ignoreEncode");
  }
  function Se() {
    a[a.length - 1].title = w();
  }
  function ye() {
    const q = a[a.length - 1], I = et(q.labelId);
    w(), Gt.call(r, I) || (r[I] = a[a.length - 1]), a.pop();
  }
  function Ce() {
    b("slurpAllLineEndings", !0);
  }
  function Ae(q) {
    C("headingRank") || (b("headingRank", this.sliceSerialize(q).length), v(), E("<h" + C("headingRank") + ">"));
  }
  function Ee() {
    k(), b("slurpAllLineEndings");
  }
  function De() {
    b("slurpAllLineEndings", !0);
  }
  function qe() {
    E("</h" + C("headingRank") + ">"), b("headingRank");
  }
  function Le(q) {
    b(
      "headingRank",
      this.sliceSerialize(q).charCodeAt(0) === 61 ? 1 : 2
    );
  }
  function ve() {
    const q = w();
    v(), E("<h" + C("headingRank") + ">"), A(q), E("</h" + C("headingRank") + ">"), b("slurpAllLineEndings"), b("headingRank");
  }
  function ft(q) {
    A(S(this.sliceSerialize(q)));
  }
  function ze(q) {
    if (!C("slurpAllLineEndings")) {
      if (C("slurpOneLineEnding")) {
        b("slurpOneLineEnding");
        return;
      }
      if (C("inCodeText")) {
        A(" ");
        return;
      }
      A(S(this.sliceSerialize(q)));
    }
  }
  function Ie(q) {
    A(S(this.sliceSerialize(q))), b("flowCodeSeenData", !0);
  }
  function Bt() {
    E("<br />");
  }
  function Te() {
    v(), _t();
  }
  function Pt() {
    b("ignoreEncode");
  }
  function _t() {
    n.allowDangerousHtml && b("ignoreEncode", !0);
  }
  function Fe() {
    E("<em>");
  }
  function Ne() {
    E("<strong>");
  }
  function Oe() {
    b("inCodeText", !0), E("<code>");
  }
  function Re() {
    b("inCodeText"), E("</code>");
  }
  function Be() {
    E("</em>");
  }
  function Pe() {
    E("</strong>");
  }
  function _e() {
    v(), E("<hr />");
  }
  function Mt(q) {
    b("characterReferenceType", q.type);
  }
  function Me(q) {
    let I = this.sliceSerialize(q);
    I = C("characterReferenceType") ? Ye(
      I,
      C("characterReferenceType") === "characterReferenceMarkerNumeric" ? 10 : 16
    ) : wt(I), A(S(I)), b("characterReferenceType");
  }
  function Ve(q) {
    const I = this.sliceSerialize(q);
    E(
      '<a href="' + gt(
        I,
        n.allowDangerousProtocol ? void 0 : Qt
      ) + '">'
    ), A(S(I)), E("</a>");
  }
  function He(q) {
    const I = this.sliceSerialize(q);
    E('<a href="' + gt("mailto:" + I) + '">'), A(S(I)), E("</a>");
  }
}
function N(t, n, e, r) {
  const u = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return i;
  function i(c) {
    return R(c) ? (t.enter(e), l(c)) : n(c);
  }
  function l(c) {
    return R(c) && a++ < u ? (t.consume(c), l) : (t.exit(e), n(c));
  }
}
const un = {
  tokenize: ln
};
function ln(t) {
  const n = t.attempt(
    this.parser.constructs.contentInitial,
    r,
    u
  );
  let e;
  return n;
  function r(l) {
    if (l === null) {
      t.consume(l);
      return;
    }
    return t.enter("lineEnding"), t.consume(l), t.exit("lineEnding"), N(t, n, "linePrefix");
  }
  function u(l) {
    return t.enter("paragraph"), a(l);
  }
  function a(l) {
    const c = t.enter("chunkText", {
      contentType: "text",
      previous: e
    });
    return e && (e.next = c), e = c, i(l);
  }
  function i(l) {
    if (l === null) {
      t.exit("chunkText"), t.exit("paragraph"), t.consume(l);
      return;
    }
    return z(l) ? (t.consume(l), t.exit("chunkText"), a) : (t.consume(l), i);
  }
}
const on = {
  tokenize: sn
}, Wt = {
  tokenize: cn
};
function sn(t) {
  const n = this, e = [];
  let r = 0, u, a, i;
  return l;
  function l(A) {
    if (r < e.length) {
      const T = e[r];
      return n.containerState = T[1], t.attempt(
        T[0].continuation,
        c,
        o
      )(A);
    }
    return o(A);
  }
  function c(A) {
    if (r++, n.containerState._closeFlow) {
      n.containerState._closeFlow = void 0, u && E();
      const T = n.events.length;
      let v = T, S;
      for (; v--; )
        if (n.events[v][0] === "exit" && n.events[v][1].type === "chunkFlow") {
          S = n.events[v][1].end;
          break;
        }
      w(r);
      let y = T;
      for (; y < n.events.length; )
        n.events[y][1].end = Object.assign({}, S), y++;
      return $(
        n.events,
        v + 1,
        0,
        n.events.slice(T)
      ), n.events.length = y, o(A);
    }
    return l(A);
  }
  function o(A) {
    if (r === e.length) {
      if (!u)
        return f(A);
      if (u.currentConstruct && u.currentConstruct.concrete)
        return b(A);
      n.interrupt = !!(u.currentConstruct && !u._gfmTableDynamicInterruptHack);
    }
    return n.containerState = {}, t.check(
      Wt,
      p,
      h
    )(A);
  }
  function p(A) {
    return u && E(), w(r), f(A);
  }
  function h(A) {
    return n.parser.lazy[n.now().line] = r !== e.length, i = n.now().offset, b(A);
  }
  function f(A) {
    return n.containerState = {}, t.attempt(
      Wt,
      s,
      b
    )(A);
  }
  function s(A) {
    return r++, e.push([n.currentConstruct, n.containerState]), f(A);
  }
  function b(A) {
    if (A === null) {
      u && E(), w(0), t.consume(A);
      return;
    }
    return u = u || n.parser.flow(n.now()), t.enter("chunkFlow", {
      contentType: "flow",
      previous: a,
      _tokenizer: u
    }), C(A);
  }
  function C(A) {
    if (A === null) {
      k(t.exit("chunkFlow"), !0), w(0), t.consume(A);
      return;
    }
    return z(A) ? (t.consume(A), k(t.exit("chunkFlow")), r = 0, n.interrupt = void 0, l) : (t.consume(A), C);
  }
  function k(A, T) {
    const v = n.sliceStream(A);
    if (T && v.push(null), A.previous = a, a && (a.next = A), a = A, u.defineSkip(A.start), u.write(v), n.parser.lazy[A.start.line]) {
      let S = u.events.length;
      for (; S--; )
        if (
          // The token starts before the line ending…
          u.events[S][1].start.offset < i && // …and either is not ended yet…
          (!u.events[S][1].end || // …or ends after it.
          u.events[S][1].end.offset > i)
        )
          return;
      const y = n.events.length;
      let F = y, P, x;
      for (; F--; )
        if (n.events[F][0] === "exit" && n.events[F][1].type === "chunkFlow") {
          if (P) {
            x = n.events[F][1].end;
            break;
          }
          P = !0;
        }
      for (w(r), S = y; S < n.events.length; )
        n.events[S][1].end = Object.assign({}, x), S++;
      $(
        n.events,
        F + 1,
        0,
        n.events.slice(y)
      ), n.events.length = S;
    }
  }
  function w(A) {
    let T = e.length;
    for (; T-- > A; ) {
      const v = e[T];
      n.containerState = v[1], v[0].exit.call(n, t);
    }
    e.length = A;
  }
  function E() {
    u.write([null]), a = void 0, u = void 0, n.containerState._closeFlow = void 0;
  }
}
function cn(t, n, e) {
  return N(
    t,
    t.attempt(this.parser.constructs.document, n, e),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function St(t) {
  if (t === null || _(t) || en(t))
    return 1;
  if (tn(t))
    return 2;
}
function yt(t, n, e) {
  const r = [];
  let u = -1;
  for (; ++u < t.length; ) {
    const a = t[u].resolveAll;
    a && !r.includes(a) && (n = a(n, e), r.push(a));
  }
  return n;
}
const It = {
  name: "attention",
  tokenize: pn,
  resolveAll: hn
};
function hn(t, n) {
  let e = -1, r, u, a, i, l, c, o, p;
  for (; ++e < t.length; )
    if (t[e][0] === "enter" && t[e][1].type === "attentionSequence" && t[e][1]._close) {
      for (r = e; r--; )
        if (t[r][0] === "exit" && t[r][1].type === "attentionSequence" && t[r][1]._open && // If the markers are the same:
        n.sliceSerialize(t[r][1]).charCodeAt(0) === n.sliceSerialize(t[e][1]).charCodeAt(0)) {
          if ((t[r][1]._close || t[e][1]._open) && (t[e][1].end.offset - t[e][1].start.offset) % 3 && !((t[r][1].end.offset - t[r][1].start.offset + t[e][1].end.offset - t[e][1].start.offset) % 3))
            continue;
          c = t[r][1].end.offset - t[r][1].start.offset > 1 && t[e][1].end.offset - t[e][1].start.offset > 1 ? 2 : 1;
          const h = Object.assign({}, t[r][1].end), f = Object.assign({}, t[e][1].start);
          $t(h, -c), $t(f, c), i = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: Object.assign({}, t[r][1].end)
          }, l = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, t[e][1].start),
            end: f
          }, a = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, t[r][1].end),
            end: Object.assign({}, t[e][1].start)
          }, u = {
            type: c > 1 ? "strong" : "emphasis",
            start: Object.assign({}, i.start),
            end: Object.assign({}, l.end)
          }, t[r][1].end = Object.assign({}, i.start), t[e][1].start = Object.assign({}, l.end), o = [], t[r][1].end.offset - t[r][1].start.offset && (o = j(o, [["enter", t[r][1], n], ["exit", t[r][1], n]])), o = j(o, [["enter", u, n], ["enter", i, n], ["exit", i, n], ["enter", a, n]]), o = j(o, yt(n.parser.constructs.insideSpan.null, t.slice(r + 1, e), n)), o = j(o, [["exit", a, n], ["enter", l, n], ["exit", l, n], ["exit", u, n]]), t[e][1].end.offset - t[e][1].start.offset ? (p = 2, o = j(o, [["enter", t[e][1], n], ["exit", t[e][1], n]])) : p = 0, $(t, r - 1, e - r + 3, o), e = r + o.length - p - 2;
          break;
        }
    }
  for (e = -1; ++e < t.length; )
    t[e][1].type === "attentionSequence" && (t[e][1].type = "data");
  return t;
}
function pn(t, n) {
  const e = this.parser.constructs.attentionMarkers.null, r = this.previous, u = St(r);
  let a;
  return i;
  function i(c) {
    return a = c, t.enter("attentionSequence"), l(c);
  }
  function l(c) {
    if (c === a)
      return t.consume(c), l;
    const o = t.exit("attentionSequence"), p = St(c), h = !p || p === 2 && u || e.includes(c), f = !u || u === 2 && p || e.includes(r);
    return o._open = !!(a === 42 ? h : h && (u || !f)), o._close = !!(a === 42 ? f : f && (p || !h)), n(c);
  }
}
function $t(t, n) {
  t.column += n, t.offset += n, t._bufferIndex += n;
}
const gn = {
  name: "autolink",
  tokenize: mn
};
function mn(t, n, e) {
  let r = 0;
  return u;
  function u(s) {
    return t.enter("autolink"), t.enter("autolinkMarker"), t.consume(s), t.exit("autolinkMarker"), t.enter("autolinkProtocol"), a;
  }
  function a(s) {
    return W(s) ? (t.consume(s), i) : s === 64 ? e(s) : o(s);
  }
  function i(s) {
    return s === 43 || s === 45 || s === 46 || U(s) ? (r = 1, l(s)) : o(s);
  }
  function l(s) {
    return s === 58 ? (t.consume(s), r = 0, c) : (s === 43 || s === 45 || s === 46 || U(s)) && r++ < 32 ? (t.consume(s), l) : (r = 0, o(s));
  }
  function c(s) {
    return s === 62 ? (t.exit("autolinkProtocol"), t.enter("autolinkMarker"), t.consume(s), t.exit("autolinkMarker"), t.exit("autolink"), n) : s === null || s === 32 || s === 60 || vt(s) ? e(s) : (t.consume(s), c);
  }
  function o(s) {
    return s === 64 ? (t.consume(s), p) : Je(s) ? (t.consume(s), o) : e(s);
  }
  function p(s) {
    return U(s) ? h(s) : e(s);
  }
  function h(s) {
    return s === 46 ? (t.consume(s), r = 0, p) : s === 62 ? (t.exit("autolinkProtocol").type = "autolinkEmail", t.enter("autolinkMarker"), t.consume(s), t.exit("autolinkMarker"), t.exit("autolink"), n) : f(s);
  }
  function f(s) {
    if ((s === 45 || U(s)) && r++ < 63) {
      const b = s === 45 ? f : h;
      return t.consume(s), b;
    }
    return e(s);
  }
}
const dt = {
  tokenize: fn,
  partial: !0
};
function fn(t, n, e) {
  return r;
  function r(a) {
    return R(a) ? N(t, u, "linePrefix")(a) : u(a);
  }
  function u(a) {
    return a === null || z(a) ? n(a) : e(a);
  }
}
const ue = {
  name: "blockQuote",
  tokenize: bn,
  continuation: {
    tokenize: dn
  },
  exit: xn
};
function bn(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    if (i === 62) {
      const l = r.containerState;
      return l.open || (t.enter("blockQuote", {
        _container: !0
      }), l.open = !0), t.enter("blockQuotePrefix"), t.enter("blockQuoteMarker"), t.consume(i), t.exit("blockQuoteMarker"), a;
    }
    return e(i);
  }
  function a(i) {
    return R(i) ? (t.enter("blockQuotePrefixWhitespace"), t.consume(i), t.exit("blockQuotePrefixWhitespace"), t.exit("blockQuotePrefix"), n) : (t.exit("blockQuotePrefix"), n(i));
  }
}
function dn(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return R(i) ? N(t, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(i) : a(i);
  }
  function a(i) {
    return t.attempt(ue, n, e)(i);
  }
}
function xn(t) {
  t.exit("blockQuote");
}
const le = {
  name: "characterEscape",
  tokenize: kn
};
function kn(t, n, e) {
  return r;
  function r(a) {
    return t.enter("characterEscape"), t.enter("escapeMarker"), t.consume(a), t.exit("escapeMarker"), u;
  }
  function u(a) {
    return Xe(a) ? (t.enter("characterEscapeValue"), t.consume(a), t.exit("characterEscapeValue"), t.exit("characterEscape"), n) : e(a);
  }
}
const oe = {
  name: "characterReference",
  tokenize: wn
};
function wn(t, n, e) {
  const r = this;
  let u = 0, a, i;
  return l;
  function l(h) {
    return t.enter("characterReference"), t.enter("characterReferenceMarker"), t.consume(h), t.exit("characterReferenceMarker"), c;
  }
  function c(h) {
    return h === 35 ? (t.enter("characterReferenceMarkerNumeric"), t.consume(h), t.exit("characterReferenceMarkerNumeric"), o) : (t.enter("characterReferenceValue"), a = 31, i = U, p(h));
  }
  function o(h) {
    return h === 88 || h === 120 ? (t.enter("characterReferenceMarkerHexadecimal"), t.consume(h), t.exit("characterReferenceMarkerHexadecimal"), t.enter("characterReferenceValue"), a = 6, i = Ke, p) : (t.enter("characterReferenceValue"), a = 7, i = zt, p(h));
  }
  function p(h) {
    if (h === 59 && u) {
      const f = t.exit("characterReferenceValue");
      return i === U && !wt(r.sliceSerialize(f)) ? e(h) : (t.enter("characterReferenceMarker"), t.consume(h), t.exit("characterReferenceMarker"), t.exit("characterReference"), n);
    }
    return i(h) && u++ < a ? (t.consume(h), p) : e(h);
  }
}
const Yt = {
  tokenize: yn,
  partial: !0
}, Zt = {
  name: "codeFenced",
  tokenize: Sn,
  concrete: !0
};
function Sn(t, n, e) {
  const r = this, u = {
    tokenize: v,
    partial: !0
  };
  let a = 0, i = 0, l;
  return c;
  function c(S) {
    return o(S);
  }
  function o(S) {
    const y = r.events[r.events.length - 1];
    return a = y && y[1].type === "linePrefix" ? y[2].sliceSerialize(y[1], !0).length : 0, l = S, t.enter("codeFenced"), t.enter("codeFencedFence"), t.enter("codeFencedFenceSequence"), p(S);
  }
  function p(S) {
    return S === l ? (i++, t.consume(S), p) : i < 3 ? e(S) : (t.exit("codeFencedFenceSequence"), R(S) ? N(t, h, "whitespace")(S) : h(S));
  }
  function h(S) {
    return S === null || z(S) ? (t.exit("codeFencedFence"), r.interrupt ? n(S) : t.check(Yt, C, T)(S)) : (t.enter("codeFencedFenceInfo"), t.enter("chunkString", {
      contentType: "string"
    }), f(S));
  }
  function f(S) {
    return S === null || z(S) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), h(S)) : R(S) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), N(t, s, "whitespace")(S)) : S === 96 && S === l ? e(S) : (t.consume(S), f);
  }
  function s(S) {
    return S === null || z(S) ? h(S) : (t.enter("codeFencedFenceMeta"), t.enter("chunkString", {
      contentType: "string"
    }), b(S));
  }
  function b(S) {
    return S === null || z(S) ? (t.exit("chunkString"), t.exit("codeFencedFenceMeta"), h(S)) : S === 96 && S === l ? e(S) : (t.consume(S), b);
  }
  function C(S) {
    return t.attempt(u, T, k)(S);
  }
  function k(S) {
    return t.enter("lineEnding"), t.consume(S), t.exit("lineEnding"), w;
  }
  function w(S) {
    return a > 0 && R(S) ? N(t, E, "linePrefix", a + 1)(S) : E(S);
  }
  function E(S) {
    return S === null || z(S) ? t.check(Yt, C, T)(S) : (t.enter("codeFlowValue"), A(S));
  }
  function A(S) {
    return S === null || z(S) ? (t.exit("codeFlowValue"), E(S)) : (t.consume(S), A);
  }
  function T(S) {
    return t.exit("codeFenced"), n(S);
  }
  function v(S, y, F) {
    let P = 0;
    return x;
    function x(d) {
      return S.enter("lineEnding"), S.consume(d), S.exit("lineEnding"), L;
    }
    function L(d) {
      return S.enter("codeFencedFence"), R(d) ? N(S, D, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(d) : D(d);
    }
    function D(d) {
      return d === l ? (S.enter("codeFencedFenceSequence"), B(d)) : F(d);
    }
    function B(d) {
      return d === l ? (P++, S.consume(d), B) : P >= i ? (S.exit("codeFencedFenceSequence"), R(d) ? N(S, O, "whitespace")(d) : O(d)) : F(d);
    }
    function O(d) {
      return d === null || z(d) ? (S.exit("codeFencedFence"), y(d)) : F(d);
    }
  }
}
function yn(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return i === null ? e(i) : (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), a);
  }
  function a(i) {
    return r.parser.lazy[r.now().line] ? e(i) : n(i);
  }
}
const At = {
  name: "codeIndented",
  tokenize: An
}, Cn = {
  tokenize: En,
  partial: !0
};
function An(t, n, e) {
  const r = this;
  return u;
  function u(o) {
    return t.enter("codeIndented"), N(t, a, "linePrefix", 5)(o);
  }
  function a(o) {
    const p = r.events[r.events.length - 1];
    return p && p[1].type === "linePrefix" && p[2].sliceSerialize(p[1], !0).length >= 4 ? i(o) : e(o);
  }
  function i(o) {
    return o === null ? c(o) : z(o) ? t.attempt(Cn, i, c)(o) : (t.enter("codeFlowValue"), l(o));
  }
  function l(o) {
    return o === null || z(o) ? (t.exit("codeFlowValue"), i(o)) : (t.consume(o), l);
  }
  function c(o) {
    return t.exit("codeIndented"), n(o);
  }
}
function En(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return r.parser.lazy[r.now().line] ? e(i) : z(i) ? (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), u) : N(t, a, "linePrefix", 5)(i);
  }
  function a(i) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? n(i) : z(i) ? u(i) : e(i);
  }
}
const Dn = {
  name: "codeText",
  tokenize: vn,
  resolve: qn,
  previous: Ln
};
function qn(t) {
  let n = t.length - 4, e = 3, r, u;
  if ((t[e][1].type === "lineEnding" || t[e][1].type === "space") && (t[n][1].type === "lineEnding" || t[n][1].type === "space")) {
    for (r = e; ++r < n; )
      if (t[r][1].type === "codeTextData") {
        t[e][1].type = "codeTextPadding", t[n][1].type = "codeTextPadding", e += 2, n -= 2;
        break;
      }
  }
  for (r = e - 1, n++; ++r <= n; )
    u === void 0 ? r !== n && t[r][1].type !== "lineEnding" && (u = r) : (r === n || t[r][1].type === "lineEnding") && (t[u][1].type = "codeTextData", r !== u + 2 && (t[u][1].end = t[r - 1][1].end, t.splice(u + 2, r - u - 2), n -= r - u - 2, r = u + 2), u = void 0);
  return t;
}
function Ln(t) {
  return t !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function vn(t, n, e) {
  let r = 0, u, a;
  return i;
  function i(h) {
    return t.enter("codeText"), t.enter("codeTextSequence"), l(h);
  }
  function l(h) {
    return h === 96 ? (t.consume(h), r++, l) : (t.exit("codeTextSequence"), c(h));
  }
  function c(h) {
    return h === null ? e(h) : h === 32 ? (t.enter("space"), t.consume(h), t.exit("space"), c) : h === 96 ? (a = t.enter("codeTextSequence"), u = 0, p(h)) : z(h) ? (t.enter("lineEnding"), t.consume(h), t.exit("lineEnding"), c) : (t.enter("codeTextData"), o(h));
  }
  function o(h) {
    return h === null || h === 32 || h === 96 || z(h) ? (t.exit("codeTextData"), c(h)) : (t.consume(h), o);
  }
  function p(h) {
    return h === 96 ? (t.consume(h), u++, p) : u === r ? (t.exit("codeTextSequence"), t.exit("codeText"), n(h)) : (a.type = "codeTextData", o(h));
  }
}
class zn {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(n) {
    this.left = n ? [...n] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(n) {
    if (n < 0 || n >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + n + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return n < this.left.length ? this.left[n] : this.right[this.right.length - n + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(n, e) {
    const r = e ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(n, r) : n > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - n + this.left.length).reverse() : this.left.slice(n).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(n, e, r) {
    const u = e || 0;
    this.setCursor(Math.trunc(n));
    const a = this.right.splice(this.right.length - u, Number.POSITIVE_INFINITY);
    return r && bt(this.left, r), a.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(n) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(n);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(n) {
    this.setCursor(Number.POSITIVE_INFINITY), bt(this.left, n);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(n) {
    this.setCursor(0), this.right.push(n);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(n) {
    this.setCursor(0), bt(this.right, n.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n) {
    if (!(n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0))
      if (n < this.left.length) {
        const e = this.left.splice(n, Number.POSITIVE_INFINITY);
        bt(this.right, e.reverse());
      } else {
        const e = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);
        bt(this.left, e.reverse());
      }
  }
}
function bt(t, n) {
  let e = 0;
  if (n.length < 1e4)
    t.push(...n);
  else
    for (; e < n.length; )
      t.push(...n.slice(e, e + 1e4)), e += 1e4;
}
function se(t) {
  const n = {};
  let e = -1, r, u, a, i, l, c, o;
  const p = new zn(t);
  for (; ++e < p.length; ) {
    for (; e in n; )
      e = n[e];
    if (r = p.get(e), e && r[1].type === "chunkFlow" && p.get(e - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, a = 0, a < c.length && c[a][1].type === "lineEndingBlank" && (a += 2), a < c.length && c[a][1].type === "content"))
      for (; ++a < c.length && c[a][1].type !== "content"; )
        c[a][1].type === "chunkText" && (c[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(n, In(p, e)), e = n[e], o = !0);
    else if (r[1]._container) {
      for (a = e, u = void 0; a-- && (i = p.get(a), i[1].type === "lineEnding" || i[1].type === "lineEndingBlank"); )
        i[0] === "enter" && (u && (p.get(u)[1].type = "lineEndingBlank"), i[1].type = "lineEnding", u = a);
      u && (r[1].end = Object.assign({}, p.get(u)[1].start), l = p.slice(u, e), l.unshift(r), p.splice(u, e - u + 1, l));
    }
  }
  return $(t, 0, Number.POSITIVE_INFINITY, p.slice(0)), !o;
}
function In(t, n) {
  const e = t.get(n)[1], r = t.get(n)[2];
  let u = n - 1;
  const a = [], i = e._tokenizer || r.parser[e.contentType](e.start), l = i.events, c = [], o = {};
  let p, h, f = -1, s = e, b = 0, C = 0;
  const k = [C];
  for (; s; ) {
    for (; t.get(++u)[1] !== s; )
      ;
    a.push(u), s._tokenizer || (p = r.sliceStream(s), s.next || p.push(null), h && i.defineSkip(s.start), s._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = !0), i.write(p), s._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = void 0)), h = s, s = s.next;
  }
  for (s = e; ++f < l.length; )
    // Find a void token that includes a break.
    l[f][0] === "exit" && l[f - 1][0] === "enter" && l[f][1].type === l[f - 1][1].type && l[f][1].start.line !== l[f][1].end.line && (C = f + 1, k.push(C), s._tokenizer = void 0, s.previous = void 0, s = s.next);
  for (i.events = [], s ? (s._tokenizer = void 0, s.previous = void 0) : k.pop(), f = k.length; f--; ) {
    const w = l.slice(k[f], k[f + 1]), E = a.pop();
    c.push([E, E + w.length - 1]), t.splice(E, 2, w);
  }
  for (c.reverse(), f = -1; ++f < c.length; )
    o[b + c[f][0]] = b + c[f][1], b += c[f][1] - c[f][0] - 1;
  return o;
}
const Tn = {
  tokenize: On,
  resolve: Nn
}, Fn = {
  tokenize: Rn,
  partial: !0
};
function Nn(t) {
  return se(t), t;
}
function On(t, n) {
  let e;
  return r;
  function r(l) {
    return t.enter("content"), e = t.enter("chunkContent", {
      contentType: "content"
    }), u(l);
  }
  function u(l) {
    return l === null ? a(l) : z(l) ? t.check(Fn, i, a)(l) : (t.consume(l), u);
  }
  function a(l) {
    return t.exit("chunkContent"), t.exit("content"), n(l);
  }
  function i(l) {
    return t.consume(l), t.exit("chunkContent"), e.next = t.enter("chunkContent", {
      contentType: "content",
      previous: e
    }), e = e.next, u;
  }
}
function Rn(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return t.exit("chunkContent"), t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), N(t, a, "linePrefix");
  }
  function a(i) {
    if (i === null || z(i))
      return e(i);
    const l = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? n(i) : t.interrupt(r.parser.constructs.flow, e, n)(i);
  }
}
function ce(t, n, e, r, u, a, i, l, c) {
  const o = c || Number.POSITIVE_INFINITY;
  let p = 0;
  return h;
  function h(w) {
    return w === 60 ? (t.enter(r), t.enter(u), t.enter(a), t.consume(w), t.exit(a), f) : w === null || w === 32 || w === 41 || vt(w) ? e(w) : (t.enter(r), t.enter(i), t.enter(l), t.enter("chunkString", {
      contentType: "string"
    }), C(w));
  }
  function f(w) {
    return w === 62 ? (t.enter(a), t.consume(w), t.exit(a), t.exit(u), t.exit(r), n) : (t.enter(l), t.enter("chunkString", {
      contentType: "string"
    }), s(w));
  }
  function s(w) {
    return w === 62 ? (t.exit("chunkString"), t.exit(l), f(w)) : w === null || w === 60 || z(w) ? e(w) : (t.consume(w), w === 92 ? b : s);
  }
  function b(w) {
    return w === 60 || w === 62 || w === 92 ? (t.consume(w), s) : s(w);
  }
  function C(w) {
    return !p && (w === null || w === 41 || _(w)) ? (t.exit("chunkString"), t.exit(l), t.exit(i), t.exit(r), n(w)) : p < o && w === 40 ? (t.consume(w), p++, C) : w === 41 ? (t.consume(w), p--, C) : w === null || w === 32 || w === 40 || vt(w) ? e(w) : (t.consume(w), w === 92 ? k : C);
  }
  function k(w) {
    return w === 40 || w === 41 || w === 92 ? (t.consume(w), C) : C(w);
  }
}
function he(t, n, e, r, u, a) {
  const i = this;
  let l = 0, c;
  return o;
  function o(s) {
    return t.enter(r), t.enter(u), t.consume(s), t.exit(u), t.enter(a), p;
  }
  function p(s) {
    return l > 999 || s === null || s === 91 || s === 93 && !c || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    s === 94 && !l && "_hiddenFootnoteSupport" in i.parser.constructs ? e(s) : s === 93 ? (t.exit(a), t.enter(u), t.consume(s), t.exit(u), t.exit(r), n) : z(s) ? (t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), p) : (t.enter("chunkString", {
      contentType: "string"
    }), h(s));
  }
  function h(s) {
    return s === null || s === 91 || s === 93 || z(s) || l++ > 999 ? (t.exit("chunkString"), p(s)) : (t.consume(s), c || (c = !R(s)), s === 92 ? f : h);
  }
  function f(s) {
    return s === 91 || s === 92 || s === 93 ? (t.consume(s), l++, h) : h(s);
  }
}
function pe(t, n, e, r, u, a) {
  let i;
  return l;
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? (t.enter(r), t.enter(u), t.consume(f), t.exit(u), i = f === 40 ? 41 : f, c) : e(f);
  }
  function c(f) {
    return f === i ? (t.enter(u), t.consume(f), t.exit(u), t.exit(r), n) : (t.enter(a), o(f));
  }
  function o(f) {
    return f === i ? (t.exit(a), c(i)) : f === null ? e(f) : z(f) ? (t.enter("lineEnding"), t.consume(f), t.exit("lineEnding"), N(t, o, "linePrefix")) : (t.enter("chunkString", {
      contentType: "string"
    }), p(f));
  }
  function p(f) {
    return f === i || f === null || z(f) ? (t.exit("chunkString"), o(f)) : (t.consume(f), f === 92 ? h : p);
  }
  function h(f) {
    return f === i || f === 92 ? (t.consume(f), p) : p(f);
  }
}
function at(t, n) {
  let e;
  return r;
  function r(u) {
    return z(u) ? (t.enter("lineEnding"), t.consume(u), t.exit("lineEnding"), e = !0, r) : R(u) ? N(
      t,
      r,
      e ? "linePrefix" : "lineSuffix"
    )(u) : n(u);
  }
}
const Bn = {
  name: "definition",
  tokenize: _n
}, Pn = {
  tokenize: Mn,
  partial: !0
};
function _n(t, n, e) {
  const r = this;
  let u;
  return a;
  function a(s) {
    return t.enter("definition"), i(s);
  }
  function i(s) {
    return he.call(
      r,
      t,
      l,
      // Note: we don’t need to reset the way `markdown-rs` does.
      e,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(s);
  }
  function l(s) {
    return u = et(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), s === 58 ? (t.enter("definitionMarker"), t.consume(s), t.exit("definitionMarker"), c) : e(s);
  }
  function c(s) {
    return _(s) ? at(t, o)(s) : o(s);
  }
  function o(s) {
    return ce(
      t,
      p,
      // Note: we don’t need to reset the way `markdown-rs` does.
      e,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(s);
  }
  function p(s) {
    return t.attempt(Pn, h, h)(s);
  }
  function h(s) {
    return R(s) ? N(t, f, "whitespace")(s) : f(s);
  }
  function f(s) {
    return s === null || z(s) ? (t.exit("definition"), r.parser.defined.push(u), n(s)) : e(s);
  }
}
function Mn(t, n, e) {
  return r;
  function r(l) {
    return _(l) ? at(t, u)(l) : e(l);
  }
  function u(l) {
    return pe(t, a, e, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(l);
  }
  function a(l) {
    return R(l) ? N(t, i, "whitespace")(l) : i(l);
  }
  function i(l) {
    return l === null || z(l) ? n(l) : e(l);
  }
}
const Vn = {
  name: "hardBreakEscape",
  tokenize: Hn
};
function Hn(t, n, e) {
  return r;
  function r(a) {
    return t.enter("hardBreakEscape"), t.consume(a), u;
  }
  function u(a) {
    return z(a) ? (t.exit("hardBreakEscape"), n(a)) : e(a);
  }
}
const jn = {
  name: "headingAtx",
  tokenize: Gn,
  resolve: Un
};
function Un(t, n) {
  let e = t.length - 2, r = 3, u, a;
  return t[r][1].type === "whitespace" && (r += 2), e - 2 > r && t[e][1].type === "whitespace" && (e -= 2), t[e][1].type === "atxHeadingSequence" && (r === e - 1 || e - 4 > r && t[e - 2][1].type === "whitespace") && (e -= r + 1 === e ? 2 : 4), e > r && (u = {
    type: "atxHeadingText",
    start: t[r][1].start,
    end: t[e][1].end
  }, a = {
    type: "chunkText",
    start: t[r][1].start,
    end: t[e][1].end,
    contentType: "text"
  }, $(t, r, e - r + 1, [["enter", u, n], ["enter", a, n], ["exit", a, n], ["exit", u, n]])), t;
}
function Gn(t, n, e) {
  let r = 0;
  return u;
  function u(p) {
    return t.enter("atxHeading"), a(p);
  }
  function a(p) {
    return t.enter("atxHeadingSequence"), i(p);
  }
  function i(p) {
    return p === 35 && r++ < 6 ? (t.consume(p), i) : p === null || _(p) ? (t.exit("atxHeadingSequence"), l(p)) : e(p);
  }
  function l(p) {
    return p === 35 ? (t.enter("atxHeadingSequence"), c(p)) : p === null || z(p) ? (t.exit("atxHeading"), n(p)) : R(p) ? N(t, l, "whitespace")(p) : (t.enter("atxHeadingText"), o(p));
  }
  function c(p) {
    return p === 35 ? (t.consume(p), c) : (t.exit("atxHeadingSequence"), l(p));
  }
  function o(p) {
    return p === null || p === 35 || _(p) ? (t.exit("atxHeadingText"), l(p)) : (t.consume(p), o);
  }
}
const Qn = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Jt = ["pre", "script", "style", "textarea"], Wn = {
  name: "htmlFlow",
  tokenize: Jn,
  resolveTo: Zn,
  concrete: !0
}, $n = {
  tokenize: Xn,
  partial: !0
}, Yn = {
  tokenize: Kn,
  partial: !0
};
function Zn(t) {
  let n = t.length;
  for (; n-- && !(t[n][0] === "enter" && t[n][1].type === "htmlFlow"); )
    ;
  return n > 1 && t[n - 2][1].type === "linePrefix" && (t[n][1].start = t[n - 2][1].start, t[n + 1][1].start = t[n - 2][1].start, t.splice(n - 2, 2)), t;
}
function Jn(t, n, e) {
  const r = this;
  let u, a, i, l, c;
  return o;
  function o(m) {
    return p(m);
  }
  function p(m) {
    return t.enter("htmlFlow"), t.enter("htmlFlowData"), t.consume(m), h;
  }
  function h(m) {
    return m === 33 ? (t.consume(m), f) : m === 47 ? (t.consume(m), a = !0, C) : m === 63 ? (t.consume(m), u = 3, r.interrupt ? n : g) : W(m) ? (t.consume(m), i = String.fromCharCode(m), k) : e(m);
  }
  function f(m) {
    return m === 45 ? (t.consume(m), u = 2, s) : m === 91 ? (t.consume(m), u = 5, l = 0, b) : W(m) ? (t.consume(m), u = 4, r.interrupt ? n : g) : e(m);
  }
  function s(m) {
    return m === 45 ? (t.consume(m), r.interrupt ? n : g) : e(m);
  }
  function b(m) {
    const J = "CDATA[";
    return m === J.charCodeAt(l++) ? (t.consume(m), l === J.length ? r.interrupt ? n : D : b) : e(m);
  }
  function C(m) {
    return W(m) ? (t.consume(m), i = String.fromCharCode(m), k) : e(m);
  }
  function k(m) {
    if (m === null || m === 47 || m === 62 || _(m)) {
      const J = m === 47, ot = i.toLowerCase();
      return !J && !a && Jt.includes(ot) ? (u = 1, r.interrupt ? n(m) : D(m)) : Qn.includes(i.toLowerCase()) ? (u = 6, J ? (t.consume(m), w) : r.interrupt ? n(m) : D(m)) : (u = 7, r.interrupt && !r.parser.lazy[r.now().line] ? e(m) : a ? E(m) : A(m));
    }
    return m === 45 || U(m) ? (t.consume(m), i += String.fromCharCode(m), k) : e(m);
  }
  function w(m) {
    return m === 62 ? (t.consume(m), r.interrupt ? n : D) : e(m);
  }
  function E(m) {
    return R(m) ? (t.consume(m), E) : x(m);
  }
  function A(m) {
    return m === 47 ? (t.consume(m), x) : m === 58 || m === 95 || W(m) ? (t.consume(m), T) : R(m) ? (t.consume(m), A) : x(m);
  }
  function T(m) {
    return m === 45 || m === 46 || m === 58 || m === 95 || U(m) ? (t.consume(m), T) : v(m);
  }
  function v(m) {
    return m === 61 ? (t.consume(m), S) : R(m) ? (t.consume(m), v) : A(m);
  }
  function S(m) {
    return m === null || m === 60 || m === 61 || m === 62 || m === 96 ? e(m) : m === 34 || m === 39 ? (t.consume(m), c = m, y) : R(m) ? (t.consume(m), S) : F(m);
  }
  function y(m) {
    return m === c ? (t.consume(m), c = null, P) : m === null || z(m) ? e(m) : (t.consume(m), y);
  }
  function F(m) {
    return m === null || m === 34 || m === 39 || m === 47 || m === 60 || m === 61 || m === 62 || m === 96 || _(m) ? v(m) : (t.consume(m), F);
  }
  function P(m) {
    return m === 47 || m === 62 || R(m) ? A(m) : e(m);
  }
  function x(m) {
    return m === 62 ? (t.consume(m), L) : e(m);
  }
  function L(m) {
    return m === null || z(m) ? D(m) : R(m) ? (t.consume(m), L) : e(m);
  }
  function D(m) {
    return m === 45 && u === 2 ? (t.consume(m), M) : m === 60 && u === 1 ? (t.consume(m), V) : m === 62 && u === 4 ? (t.consume(m), Z) : m === 63 && u === 3 ? (t.consume(m), g) : m === 93 && u === 5 ? (t.consume(m), nt) : z(m) && (u === 6 || u === 7) ? (t.exit("htmlFlowData"), t.check($n, rt, B)(m)) : m === null || z(m) ? (t.exit("htmlFlowData"), B(m)) : (t.consume(m), D);
  }
  function B(m) {
    return t.check(Yn, O, rt)(m);
  }
  function O(m) {
    return t.enter("lineEnding"), t.consume(m), t.exit("lineEnding"), d;
  }
  function d(m) {
    return m === null || z(m) ? B(m) : (t.enter("htmlFlowData"), D(m));
  }
  function M(m) {
    return m === 45 ? (t.consume(m), g) : D(m);
  }
  function V(m) {
    return m === 47 ? (t.consume(m), i = "", Y) : D(m);
  }
  function Y(m) {
    if (m === 62) {
      const J = i.toLowerCase();
      return Jt.includes(J) ? (t.consume(m), Z) : D(m);
    }
    return W(m) && i.length < 8 ? (t.consume(m), i += String.fromCharCode(m), Y) : D(m);
  }
  function nt(m) {
    return m === 93 ? (t.consume(m), g) : D(m);
  }
  function g(m) {
    return m === 62 ? (t.consume(m), Z) : m === 45 && u === 2 ? (t.consume(m), g) : D(m);
  }
  function Z(m) {
    return m === null || z(m) ? (t.exit("htmlFlowData"), rt(m)) : (t.consume(m), Z);
  }
  function rt(m) {
    return t.exit("htmlFlow"), n(m);
  }
}
function Kn(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return z(i) ? (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), a) : e(i);
  }
  function a(i) {
    return r.parser.lazy[r.now().line] ? e(i) : n(i);
  }
}
function Xn(t, n, e) {
  return r;
  function r(u) {
    return t.enter("lineEnding"), t.consume(u), t.exit("lineEnding"), t.attempt(dt, n, e);
  }
}
const tr = {
  name: "htmlText",
  tokenize: er
};
function er(t, n, e) {
  const r = this;
  let u, a, i;
  return l;
  function l(g) {
    return t.enter("htmlText"), t.enter("htmlTextData"), t.consume(g), c;
  }
  function c(g) {
    return g === 33 ? (t.consume(g), o) : g === 47 ? (t.consume(g), v) : g === 63 ? (t.consume(g), A) : W(g) ? (t.consume(g), F) : e(g);
  }
  function o(g) {
    return g === 45 ? (t.consume(g), p) : g === 91 ? (t.consume(g), a = 0, b) : W(g) ? (t.consume(g), E) : e(g);
  }
  function p(g) {
    return g === 45 ? (t.consume(g), s) : e(g);
  }
  function h(g) {
    return g === null ? e(g) : g === 45 ? (t.consume(g), f) : z(g) ? (i = h, V(g)) : (t.consume(g), h);
  }
  function f(g) {
    return g === 45 ? (t.consume(g), s) : h(g);
  }
  function s(g) {
    return g === 62 ? M(g) : g === 45 ? f(g) : h(g);
  }
  function b(g) {
    const Z = "CDATA[";
    return g === Z.charCodeAt(a++) ? (t.consume(g), a === Z.length ? C : b) : e(g);
  }
  function C(g) {
    return g === null ? e(g) : g === 93 ? (t.consume(g), k) : z(g) ? (i = C, V(g)) : (t.consume(g), C);
  }
  function k(g) {
    return g === 93 ? (t.consume(g), w) : C(g);
  }
  function w(g) {
    return g === 62 ? M(g) : g === 93 ? (t.consume(g), w) : C(g);
  }
  function E(g) {
    return g === null || g === 62 ? M(g) : z(g) ? (i = E, V(g)) : (t.consume(g), E);
  }
  function A(g) {
    return g === null ? e(g) : g === 63 ? (t.consume(g), T) : z(g) ? (i = A, V(g)) : (t.consume(g), A);
  }
  function T(g) {
    return g === 62 ? M(g) : A(g);
  }
  function v(g) {
    return W(g) ? (t.consume(g), S) : e(g);
  }
  function S(g) {
    return g === 45 || U(g) ? (t.consume(g), S) : y(g);
  }
  function y(g) {
    return z(g) ? (i = y, V(g)) : R(g) ? (t.consume(g), y) : M(g);
  }
  function F(g) {
    return g === 45 || U(g) ? (t.consume(g), F) : g === 47 || g === 62 || _(g) ? P(g) : e(g);
  }
  function P(g) {
    return g === 47 ? (t.consume(g), M) : g === 58 || g === 95 || W(g) ? (t.consume(g), x) : z(g) ? (i = P, V(g)) : R(g) ? (t.consume(g), P) : M(g);
  }
  function x(g) {
    return g === 45 || g === 46 || g === 58 || g === 95 || U(g) ? (t.consume(g), x) : L(g);
  }
  function L(g) {
    return g === 61 ? (t.consume(g), D) : z(g) ? (i = L, V(g)) : R(g) ? (t.consume(g), L) : P(g);
  }
  function D(g) {
    return g === null || g === 60 || g === 61 || g === 62 || g === 96 ? e(g) : g === 34 || g === 39 ? (t.consume(g), u = g, B) : z(g) ? (i = D, V(g)) : R(g) ? (t.consume(g), D) : (t.consume(g), O);
  }
  function B(g) {
    return g === u ? (t.consume(g), u = void 0, d) : g === null ? e(g) : z(g) ? (i = B, V(g)) : (t.consume(g), B);
  }
  function O(g) {
    return g === null || g === 34 || g === 39 || g === 60 || g === 61 || g === 96 ? e(g) : g === 47 || g === 62 || _(g) ? P(g) : (t.consume(g), O);
  }
  function d(g) {
    return g === 47 || g === 62 || _(g) ? P(g) : e(g);
  }
  function M(g) {
    return g === 62 ? (t.consume(g), t.exit("htmlTextData"), t.exit("htmlText"), n) : e(g);
  }
  function V(g) {
    return t.exit("htmlTextData"), t.enter("lineEnding"), t.consume(g), t.exit("lineEnding"), Y;
  }
  function Y(g) {
    return R(g) ? N(t, nt, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(g) : nt(g);
  }
  function nt(g) {
    return t.enter("htmlTextData"), i(g);
  }
}
const Tt = {
  name: "labelEnd",
  tokenize: lr,
  resolveTo: ur,
  resolveAll: ar
}, nr = {
  tokenize: or
}, rr = {
  tokenize: sr
}, ir = {
  tokenize: cr
};
function ar(t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const e = t[n][1];
    (e.type === "labelImage" || e.type === "labelLink" || e.type === "labelEnd") && (t.splice(n + 1, e.type === "labelImage" ? 4 : 2), e.type = "data", n++);
  }
  return t;
}
function ur(t, n) {
  let e = t.length, r = 0, u, a, i, l;
  for (; e--; )
    if (u = t[e][1], a) {
      if (u.type === "link" || u.type === "labelLink" && u._inactive)
        break;
      t[e][0] === "enter" && u.type === "labelLink" && (u._inactive = !0);
    } else if (i) {
      if (t[e][0] === "enter" && (u.type === "labelImage" || u.type === "labelLink") && !u._balanced && (a = e, u.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else u.type === "labelEnd" && (i = e);
  const c = {
    type: t[a][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, t[a][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  }, o = {
    type: "label",
    start: Object.assign({}, t[a][1].start),
    end: Object.assign({}, t[i][1].end)
  }, p = {
    type: "labelText",
    start: Object.assign({}, t[a + r + 2][1].end),
    end: Object.assign({}, t[i - 2][1].start)
  };
  return l = [["enter", c, n], ["enter", o, n]], l = j(l, t.slice(a + 1, a + r + 3)), l = j(l, [["enter", p, n]]), l = j(l, yt(n.parser.constructs.insideSpan.null, t.slice(a + r + 4, i - 3), n)), l = j(l, [["exit", p, n], t[i - 2], t[i - 1], ["exit", o, n]]), l = j(l, t.slice(i + 1)), l = j(l, [["exit", c, n]]), $(t, a, t.length, l), t;
}
function lr(t, n, e) {
  const r = this;
  let u = r.events.length, a, i;
  for (; u--; )
    if ((r.events[u][1].type === "labelImage" || r.events[u][1].type === "labelLink") && !r.events[u][1]._balanced) {
      a = r.events[u][1];
      break;
    }
  return l;
  function l(f) {
    return a ? a._inactive ? h(f) : (i = r.parser.defined.includes(et(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }))), t.enter("labelEnd"), t.enter("labelMarker"), t.consume(f), t.exit("labelMarker"), t.exit("labelEnd"), c) : e(f);
  }
  function c(f) {
    return f === 40 ? t.attempt(nr, p, i ? p : h)(f) : f === 91 ? t.attempt(rr, p, i ? o : h)(f) : i ? p(f) : h(f);
  }
  function o(f) {
    return t.attempt(ir, p, h)(f);
  }
  function p(f) {
    return n(f);
  }
  function h(f) {
    return a._balanced = !0, e(f);
  }
}
function or(t, n, e) {
  return r;
  function r(h) {
    return t.enter("resource"), t.enter("resourceMarker"), t.consume(h), t.exit("resourceMarker"), u;
  }
  function u(h) {
    return _(h) ? at(t, a)(h) : a(h);
  }
  function a(h) {
    return h === 41 ? p(h) : ce(t, i, l, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function i(h) {
    return _(h) ? at(t, c)(h) : p(h);
  }
  function l(h) {
    return e(h);
  }
  function c(h) {
    return h === 34 || h === 39 || h === 40 ? pe(t, o, e, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : p(h);
  }
  function o(h) {
    return _(h) ? at(t, p)(h) : p(h);
  }
  function p(h) {
    return h === 41 ? (t.enter("resourceMarker"), t.consume(h), t.exit("resourceMarker"), t.exit("resource"), n) : e(h);
  }
}
function sr(t, n, e) {
  const r = this;
  return u;
  function u(l) {
    return he.call(r, t, a, i, "reference", "referenceMarker", "referenceString")(l);
  }
  function a(l) {
    return r.parser.defined.includes(et(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? n(l) : e(l);
  }
  function i(l) {
    return e(l);
  }
}
function cr(t, n, e) {
  return r;
  function r(a) {
    return t.enter("reference"), t.enter("referenceMarker"), t.consume(a), t.exit("referenceMarker"), u;
  }
  function u(a) {
    return a === 93 ? (t.enter("referenceMarker"), t.consume(a), t.exit("referenceMarker"), t.exit("reference"), n) : e(a);
  }
}
const hr = {
  name: "labelStartImage",
  tokenize: pr,
  resolveAll: Tt.resolveAll
};
function pr(t, n, e) {
  const r = this;
  return u;
  function u(l) {
    return t.enter("labelImage"), t.enter("labelImageMarker"), t.consume(l), t.exit("labelImageMarker"), a;
  }
  function a(l) {
    return l === 91 ? (t.enter("labelMarker"), t.consume(l), t.exit("labelMarker"), t.exit("labelImage"), i) : e(l);
  }
  function i(l) {
    return l === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? e(l) : n(l);
  }
}
const gr = {
  name: "labelStartLink",
  tokenize: mr,
  resolveAll: Tt.resolveAll
};
function mr(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return t.enter("labelLink"), t.enter("labelMarker"), t.consume(i), t.exit("labelMarker"), t.exit("labelLink"), a;
  }
  function a(i) {
    return i === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? e(i) : n(i);
  }
}
const Et = {
  name: "lineEnding",
  tokenize: fr
};
function fr(t, n) {
  return e;
  function e(r) {
    return t.enter("lineEnding"), t.consume(r), t.exit("lineEnding"), N(t, n, "linePrefix");
  }
}
const kt = {
  name: "thematicBreak",
  tokenize: br
};
function br(t, n, e) {
  let r = 0, u;
  return a;
  function a(o) {
    return t.enter("thematicBreak"), i(o);
  }
  function i(o) {
    return u = o, l(o);
  }
  function l(o) {
    return o === u ? (t.enter("thematicBreakSequence"), c(o)) : r >= 3 && (o === null || z(o)) ? (t.exit("thematicBreak"), n(o)) : e(o);
  }
  function c(o) {
    return o === u ? (t.consume(o), r++, c) : (t.exit("thematicBreakSequence"), R(o) ? N(t, l, "whitespace")(o) : l(o));
  }
}
const Q = {
  name: "list",
  tokenize: kr,
  continuation: {
    tokenize: wr
  },
  exit: yr
}, dr = {
  tokenize: Cr,
  partial: !0
}, xr = {
  tokenize: Sr,
  partial: !0
};
function kr(t, n, e) {
  const r = this, u = r.events[r.events.length - 1];
  let a = u && u[1].type === "linePrefix" ? u[2].sliceSerialize(u[1], !0).length : 0, i = 0;
  return l;
  function l(s) {
    const b = r.containerState.type || (s === 42 || s === 43 || s === 45 ? "listUnordered" : "listOrdered");
    if (b === "listUnordered" ? !r.containerState.marker || s === r.containerState.marker : zt(s)) {
      if (r.containerState.type || (r.containerState.type = b, t.enter(b, {
        _container: !0
      })), b === "listUnordered")
        return t.enter("listItemPrefix"), s === 42 || s === 45 ? t.check(kt, e, o)(s) : o(s);
      if (!r.interrupt || s === 49)
        return t.enter("listItemPrefix"), t.enter("listItemValue"), c(s);
    }
    return e(s);
  }
  function c(s) {
    return zt(s) && ++i < 10 ? (t.consume(s), c) : (!r.interrupt || i < 2) && (r.containerState.marker ? s === r.containerState.marker : s === 41 || s === 46) ? (t.exit("listItemValue"), o(s)) : e(s);
  }
  function o(s) {
    return t.enter("listItemMarker"), t.consume(s), t.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || s, t.check(
      dt,
      // Can’t be empty when interrupting.
      r.interrupt ? e : p,
      t.attempt(dr, f, h)
    );
  }
  function p(s) {
    return r.containerState.initialBlankLine = !0, a++, f(s);
  }
  function h(s) {
    return R(s) ? (t.enter("listItemPrefixWhitespace"), t.consume(s), t.exit("listItemPrefixWhitespace"), f) : e(s);
  }
  function f(s) {
    return r.containerState.size = a + r.sliceSerialize(t.exit("listItemPrefix"), !0).length, n(s);
  }
}
function wr(t, n, e) {
  const r = this;
  return r.containerState._closeFlow = void 0, t.check(dt, u, a);
  function u(l) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, N(t, n, "listItemIndent", r.containerState.size + 1)(l);
  }
  function a(l) {
    return r.containerState.furtherBlankLines || !R(l) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, i(l)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, t.attempt(xr, n, i)(l));
  }
  function i(l) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, N(t, t.attempt(Q, n, e), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l);
  }
}
function Sr(t, n, e) {
  const r = this;
  return N(t, u, "listItemIndent", r.containerState.size + 1);
  function u(a) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "listItemIndent" && i[2].sliceSerialize(i[1], !0).length === r.containerState.size ? n(a) : e(a);
  }
}
function yr(t) {
  t.exit(this.containerState.type);
}
function Cr(t, n, e) {
  const r = this;
  return N(t, u, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function u(a) {
    const i = r.events[r.events.length - 1];
    return !R(a) && i && i[1].type === "listItemPrefixWhitespace" ? n(a) : e(a);
  }
}
const Kt = {
  name: "setextUnderline",
  tokenize: Er,
  resolveTo: Ar
};
function Ar(t, n) {
  let e = t.length, r, u, a;
  for (; e--; )
    if (t[e][0] === "enter") {
      if (t[e][1].type === "content") {
        r = e;
        break;
      }
      t[e][1].type === "paragraph" && (u = e);
    } else
      t[e][1].type === "content" && t.splice(e, 1), !a && t[e][1].type === "definition" && (a = e);
  const i = {
    type: "setextHeading",
    start: Object.assign({}, t[u][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  };
  return t[u][1].type = "setextHeadingText", a ? (t.splice(u, 0, ["enter", i, n]), t.splice(a + 1, 0, ["exit", t[r][1], n]), t[r][1].end = Object.assign({}, t[a][1].end)) : t[r][1] = i, t.push(["exit", i, n]), t;
}
function Er(t, n, e) {
  const r = this;
  let u;
  return a;
  function a(o) {
    let p = r.events.length, h;
    for (; p--; )
      if (r.events[p][1].type !== "lineEnding" && r.events[p][1].type !== "linePrefix" && r.events[p][1].type !== "content") {
        h = r.events[p][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (t.enter("setextHeadingLine"), u = o, i(o)) : e(o);
  }
  function i(o) {
    return t.enter("setextHeadingLineSequence"), l(o);
  }
  function l(o) {
    return o === u ? (t.consume(o), l) : (t.exit("setextHeadingLineSequence"), R(o) ? N(t, c, "lineSuffix")(o) : c(o));
  }
  function c(o) {
    return o === null || z(o) ? (t.exit("setextHeadingLine"), n(o)) : e(o);
  }
}
const Dr = {
  tokenize: qr
};
function qr(t) {
  const n = this, e = t.attempt(
    // Try to parse a blank line.
    dt,
    r,
    // Try to parse initial flow (essentially, only code).
    t.attempt(
      this.parser.constructs.flowInitial,
      u,
      N(
        t,
        t.attempt(
          this.parser.constructs.flow,
          u,
          t.attempt(Tn, u)
        ),
        "linePrefix"
      )
    )
  );
  return e;
  function r(a) {
    if (a === null) {
      t.consume(a);
      return;
    }
    return t.enter("lineEndingBlank"), t.consume(a), t.exit("lineEndingBlank"), n.currentConstruct = void 0, e;
  }
  function u(a) {
    if (a === null) {
      t.consume(a);
      return;
    }
    return t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), n.currentConstruct = void 0, e;
  }
}
const Lr = {
  resolveAll: me()
}, vr = ge("string"), zr = ge("text");
function ge(t) {
  return {
    tokenize: n,
    resolveAll: me(
      t === "text" ? Ir : void 0
    )
  };
  function n(e) {
    const r = this, u = this.parser.constructs[t], a = e.attempt(u, i, l);
    return i;
    function i(p) {
      return o(p) ? a(p) : l(p);
    }
    function l(p) {
      if (p === null) {
        e.consume(p);
        return;
      }
      return e.enter("data"), e.consume(p), c;
    }
    function c(p) {
      return o(p) ? (e.exit("data"), a(p)) : (e.consume(p), c);
    }
    function o(p) {
      if (p === null)
        return !0;
      const h = u[p];
      let f = -1;
      if (h)
        for (; ++f < h.length; ) {
          const s = h[f];
          if (!s.previous || s.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function me(t) {
  return n;
  function n(e, r) {
    let u = -1, a;
    for (; ++u <= e.length; )
      a === void 0 ? e[u] && e[u][1].type === "data" && (a = u, u++) : (!e[u] || e[u][1].type !== "data") && (u !== a + 2 && (e[a][1].end = e[u - 1][1].end, e.splice(a + 2, u - a - 2), u = a + 2), a = void 0);
    return t ? t(e, r) : e;
  }
}
function Ir(t, n) {
  let e = 0;
  for (; ++e <= t.length; )
    if ((e === t.length || t[e][1].type === "lineEnding") && t[e - 1][1].type === "data") {
      const r = t[e - 1][1], u = n.sliceStream(r);
      let a = u.length, i = -1, l = 0, c;
      for (; a--; ) {
        const o = u[a];
        if (typeof o == "string") {
          for (i = o.length; o.charCodeAt(i - 1) === 32; )
            l++, i--;
          if (i) break;
          i = -1;
        } else if (o === -2)
          c = !0, l++;
        else if (o !== -1) {
          a++;
          break;
        }
      }
      if (l) {
        const o = {
          type: e === t.length || c || l < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - l,
            offset: r.end.offset - l,
            _index: r.start._index + a,
            _bufferIndex: a ? i : r.start._bufferIndex + i
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, o.start), r.start.offset === r.end.offset ? Object.assign(r, o) : (t.splice(
          e,
          0,
          ["enter", o, n],
          ["exit", o, n]
        ), e += 2);
      }
      e++;
    }
  return t;
}
function Tr(t, n, e) {
  let r = Object.assign(
    e ? Object.assign({}, e) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const u = {}, a = [];
  let i = [], l = [];
  const c = {
    consume: E,
    enter: A,
    exit: T,
    attempt: y(v),
    check: y(S),
    interrupt: y(S, {
      interrupt: !0
    })
  }, o = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: t,
    sliceStream: s,
    sliceSerialize: f,
    now: b,
    defineSkip: C,
    write: h
  };
  let p = n.tokenize.call(o, c);
  return n.resolveAll && a.push(n), o;
  function h(L) {
    return i = j(i, L), k(), i[i.length - 1] !== null ? [] : (F(n, 0), o.events = yt(a, o.events, o), o.events);
  }
  function f(L, D) {
    return Nr(s(L), D);
  }
  function s(L) {
    return Fr(i, L);
  }
  function b() {
    const { line: L, column: D, offset: B, _index: O, _bufferIndex: d } = r;
    return {
      line: L,
      column: D,
      offset: B,
      _index: O,
      _bufferIndex: d
    };
  }
  function C(L) {
    u[L.line] = L.column, x();
  }
  function k() {
    let L;
    for (; r._index < i.length; ) {
      const D = i[r._index];
      if (typeof D == "string")
        for (L = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === L && r._bufferIndex < D.length; )
          w(D.charCodeAt(r._bufferIndex));
      else
        w(D);
    }
  }
  function w(L) {
    p = p(L);
  }
  function E(L) {
    z(L) ? (r.line++, r.column = 1, r.offset += L === -3 ? 2 : 1, x()) : L !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === i[r._index].length && (r._bufferIndex = -1, r._index++)), o.previous = L;
  }
  function A(L, D) {
    const B = D || {};
    return B.type = L, B.start = b(), o.events.push(["enter", B, o]), l.push(B), B;
  }
  function T(L) {
    const D = l.pop();
    return D.end = b(), o.events.push(["exit", D, o]), D;
  }
  function v(L, D) {
    F(L, D.from);
  }
  function S(L, D) {
    D.restore();
  }
  function y(L, D) {
    return B;
    function B(O, d, M) {
      let V, Y, nt, g;
      return Array.isArray(O) ? rt(O) : "tokenize" in O ? (
        // @ts-expect-error Looks like a construct.
        rt([O])
      ) : Z(O);
      function Z(H) {
        return mt;
        function mt(ut) {
          const st = ut !== null && H[ut], ct = ut !== null && H.null, Ct = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(st) ? st : st ? [st] : [],
            ...Array.isArray(ct) ? ct : ct ? [ct] : []
          ];
          return rt(Ct)(ut);
        }
      }
      function rt(H) {
        return V = H, Y = 0, H.length === 0 ? M : m(H[Y]);
      }
      function m(H) {
        return mt;
        function mt(ut) {
          return g = P(), nt = H, H.partial || (o.currentConstruct = H), H.name && o.parser.constructs.disable.null.includes(H.name) ? ot() : H.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            D ? Object.assign(Object.create(o), D) : o,
            c,
            J,
            ot
          )(ut);
        }
      }
      function J(H) {
        return L(nt, g), d;
      }
      function ot(H) {
        return g.restore(), ++Y < V.length ? m(V[Y]) : M;
      }
    }
  }
  function F(L, D) {
    L.resolveAll && !a.includes(L) && a.push(L), L.resolve && $(
      o.events,
      D,
      o.events.length - D,
      L.resolve(o.events.slice(D), o)
    ), L.resolveTo && (o.events = L.resolveTo(o.events, o));
  }
  function P() {
    const L = b(), D = o.previous, B = o.currentConstruct, O = o.events.length, d = Array.from(l);
    return {
      restore: M,
      from: O
    };
    function M() {
      r = L, o.previous = D, o.currentConstruct = B, o.events.length = O, l = d, x();
    }
  }
  function x() {
    r.line in u && r.column < 2 && (r.column = u[r.line], r.offset += u[r.line] - 1);
  }
}
function Fr(t, n) {
  const e = n.start._index, r = n.start._bufferIndex, u = n.end._index, a = n.end._bufferIndex;
  let i;
  if (e === u)
    i = [t[e].slice(r, a)];
  else {
    if (i = t.slice(e, u), r > -1) {
      const l = i[0];
      typeof l == "string" ? i[0] = l.slice(r) : i.shift();
    }
    a > 0 && i.push(t[u].slice(0, a));
  }
  return i;
}
function Nr(t, n) {
  let e = -1;
  const r = [];
  let u;
  for (; ++e < t.length; ) {
    const a = t[e];
    let i;
    if (typeof a == "string")
      i = a;
    else
      switch (a) {
        case -5: {
          i = "\r";
          break;
        }
        case -4: {
          i = `
`;
          break;
        }
        case -3: {
          i = `\r
`;
          break;
        }
        case -2: {
          i = n ? " " : "	";
          break;
        }
        case -1: {
          if (!n && u) continue;
          i = " ";
          break;
        }
        default:
          i = String.fromCharCode(a);
      }
    u = a === -2, r.push(i);
  }
  return r.join("");
}
const Or = {
  42: Q,
  43: Q,
  45: Q,
  48: Q,
  49: Q,
  50: Q,
  51: Q,
  52: Q,
  53: Q,
  54: Q,
  55: Q,
  56: Q,
  57: Q,
  62: ue
}, Rr = {
  91: Bn
}, Br = {
  [-2]: At,
  [-1]: At,
  32: At
}, Pr = {
  35: jn,
  42: kt,
  45: [Kt, kt],
  60: Wn,
  61: Kt,
  95: kt,
  96: Zt,
  126: Zt
}, _r = {
  38: oe,
  92: le
}, Mr = {
  [-5]: Et,
  [-4]: Et,
  [-3]: Et,
  33: hr,
  38: oe,
  42: It,
  60: [gn, tr],
  91: gr,
  92: [Vn, le],
  93: Tt,
  95: It,
  96: Dn
}, Vr = {
  null: [It, Lr]
}, Hr = {
  null: [42, 95]
}, jr = {
  null: []
}, Ur = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Hr,
  contentInitial: Rr,
  disable: jr,
  document: Or,
  flow: Pr,
  flowInitial: Br,
  insideSpan: Vr,
  string: _r,
  text: Mr
}, Symbol.toStringTag, { value: "Module" }));
function Gr(t) {
  const e = (
    /** @type {FullNormalizedExtension} */
    Ue([Ur, ...(t || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: e,
    content: u(un),
    document: u(on),
    flow: u(Dr),
    string: u(vr),
    text: u(zr)
  };
  return r;
  function u(a) {
    return i;
    function i(l) {
      return Tr(r, a, l);
    }
  }
}
function Qr(t) {
  for (; !se(t); )
    ;
  return t;
}
const Xt = /[\0\t\n\r]/g;
function Wr() {
  let t = 1, n = "", e = !0, r;
  return u;
  function u(a, i, l) {
    const c = [];
    let o, p, h, f, s;
    for (a = n + (typeof a == "string" ? a.toString() : new TextDecoder(i || void 0).decode(a)), h = 0, n = "", e && (a.charCodeAt(0) === 65279 && h++, e = void 0); h < a.length; ) {
      if (Xt.lastIndex = h, o = Xt.exec(a), f = o && o.index !== void 0 ? o.index : a.length, s = a.charCodeAt(f), !o) {
        n = a.slice(h);
        break;
      }
      if (s === 10 && h === f && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), h < f && (c.push(a.slice(h, f)), t += f - h), s) {
          case 0: {
            c.push(65533), t++;
            break;
          }
          case 9: {
            for (p = Math.ceil(t / 4) * 4, c.push(-2); t++ < p; ) c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), t = 1;
            break;
          }
          default:
            r = !0, t = 1;
        }
      h = f + 1;
    }
    return l && (r && c.push(-5), n && c.push(n), c.push(null)), c;
  }
}
function Bi(t, n, e) {
  return typeof n != "string" && (e = n, n = void 0), an(e)(
    Qr(
      Gr(e).document().write(Wr()(t, n, !0))
    )
  );
}
function Ft(t, n, e, r, u, a, i, l, c, o, p, h, f, s, b) {
  let C, k;
  return w;
  function w(d) {
    return t.enter(r), t.enter(u), t.consume(d), t.exit(u), E;
  }
  function E(d) {
    return d === 35 ? (C = i, A(d)) : d === 46 ? (C = l, A(d)) : d === 58 || d === 95 || W(d) ? (t.enter(a), t.enter(c), t.consume(d), S) : b && R(d) ? N(t, E, "whitespace")(d) : !b && _(d) ? at(t, E)(d) : O(d);
  }
  function A(d) {
    const M = (
      /** @type {TokenType} */
      C + "Marker"
    );
    return t.enter(a), t.enter(C), t.enter(M), t.consume(d), t.exit(M), T;
  }
  function T(d) {
    if (d === null || d === 34 || d === 35 || d === 39 || d === 46 || d === 60 || d === 61 || d === 62 || d === 96 || d === 125 || _(d))
      return e(d);
    const M = (
      /** @type {TokenType} */
      C + "Value"
    );
    return t.enter(M), t.consume(d), v;
  }
  function v(d) {
    if (d === null || d === 34 || d === 39 || d === 60 || d === 61 || d === 62 || d === 96)
      return e(d);
    if (d === 35 || d === 46 || d === 125 || _(d)) {
      const M = (
        /** @type {TokenType} */
        C + "Value"
      );
      return t.exit(M), t.exit(C), t.exit(a), E(d);
    }
    return t.consume(d), v;
  }
  function S(d) {
    return d === 45 || d === 46 || d === 58 || d === 95 || U(d) ? (t.consume(d), S) : (t.exit(c), b && R(d) ? N(t, y, "whitespace")(d) : !b && _(d) ? at(t, y)(d) : y(d));
  }
  function y(d) {
    return d === 61 ? (t.enter(o), t.consume(d), t.exit(o), F) : (t.exit(a), E(d));
  }
  function F(d) {
    return d === null || d === 60 || d === 61 || d === 62 || d === 96 || d === 125 || b && z(d) ? e(d) : d === 34 || d === 39 ? (t.enter(p), t.enter(f), t.consume(d), t.exit(f), k = d, x) : b && R(d) ? N(t, F, "whitespace")(d) : !b && _(d) ? at(t, F)(d) : (t.enter(h), t.enter(s), t.consume(d), k = void 0, P);
  }
  function P(d) {
    return d === null || d === 34 || d === 39 || d === 60 || d === 61 || d === 62 || d === 96 ? e(d) : d === 125 || _(d) ? (t.exit(s), t.exit(h), t.exit(a), E(d)) : (t.consume(d), P);
  }
  function x(d) {
    return d === k ? (t.enter(f), t.consume(d), t.exit(f), t.exit(p), t.exit(a), B) : (t.enter(h), L(d));
  }
  function L(d) {
    return d === k ? (t.exit(h), x(d)) : d === null ? e(d) : z(d) ? b ? e(d) : at(t, L)(d) : (t.enter(s), t.consume(d), D);
  }
  function D(d) {
    return d === k || d === null || z(d) ? (t.exit(s), L(d)) : (t.consume(d), D);
  }
  function B(d) {
    return d === 125 || _(d) ? E(d) : O(d);
  }
  function O(d) {
    return d === 125 ? (t.enter(u), t.consume(d), t.exit(u), t.exit(r), n) : e(d);
  }
}
function Nt(t, n, e, r, u, a, i) {
  let l = 0, c = 0, o;
  return p;
  function p(k) {
    return t.enter(r), t.enter(u), t.consume(k), t.exit(u), h;
  }
  function h(k) {
    return k === 93 ? (t.enter(u), t.consume(k), t.exit(u), t.exit(r), n) : (t.enter(a), f(k));
  }
  function f(k) {
    if (k === 93 && !c)
      return C(k);
    const w = t.enter("chunkText", {
      contentType: "text",
      previous: o
    });
    return o && (o.next = w), o = w, s(k);
  }
  function s(k) {
    return k === null || l > 999 || k === 91 && ++c > 32 ? e(k) : k === 93 && !c-- ? (t.exit("chunkText"), C(k)) : z(k) ? i ? e(k) : (t.consume(k), t.exit("chunkText"), f) : (t.consume(k), k === 92 ? b : s);
  }
  function b(k) {
    return k === 91 || k === 92 || k === 93 ? (t.consume(k), l++, s) : s(k);
  }
  function C(k) {
    return t.exit(a), t.enter(u), t.consume(k), t.exit(u), t.exit(r), n;
  }
}
function Ot(t, n, e, r) {
  const u = this;
  return a;
  function a(l) {
    return W(l) ? (t.enter(r), t.consume(l), i) : e(l);
  }
  function i(l) {
    return l === 45 || l === 95 || U(l) ? (t.consume(l), i) : (t.exit(r), u.previous === 45 || u.previous === 95 ? e(l) : n(l));
  }
}
const $r = {
  tokenize: Jr,
  concrete: !0
}, Yr = {
  tokenize: Kr,
  partial: !0
}, Zr = {
  tokenize: Xr,
  partial: !0
}, te = {
  tokenize: ti,
  partial: !0
};
function Jr(t, n, e) {
  const r = this, u = r.events[r.events.length - 1], a = u && u[1].type === "linePrefix" ? u[2].sliceSerialize(u[1], !0).length : 0;
  let i = 0, l;
  return c;
  function c(y) {
    return t.enter("directiveContainer"), t.enter("directiveContainerFence"), t.enter("directiveContainerSequence"), o(y);
  }
  function o(y) {
    return y === 58 ? (t.consume(y), i++, o) : i < 3 ? e(y) : (t.exit("directiveContainerSequence"), Ot.call(r, t, p, e, "directiveContainerName")(y));
  }
  function p(y) {
    return y === 91 ? t.attempt(Yr, h, h)(y) : h(y);
  }
  function h(y) {
    return y === 123 ? t.attempt(Zr, f, f)(y) : f(y);
  }
  function f(y) {
    return N(t, s, "whitespace")(y);
  }
  function s(y) {
    return t.exit("directiveContainerFence"), y === null ? b(y) : z(y) ? r.interrupt ? n(y) : t.attempt(te, C, b)(y) : e(y);
  }
  function b(y) {
    return t.exit("directiveContainer"), n(y);
  }
  function C(y) {
    return y === null ? (t.exit("directiveContainer"), n(y)) : (t.enter("directiveContainerContent"), k(y));
  }
  function k(y) {
    return y === null ? v(y) : t.attempt({
      tokenize: S,
      partial: !0
    }, v, a ? N(t, w, "linePrefix", a + 1) : w)(y);
  }
  function w(y) {
    if (y === null)
      return v(y);
    const F = t.enter("chunkDocument", {
      contentType: "document",
      previous: l
    });
    return l && (l.next = F), l = F, E(y);
  }
  function E(y) {
    if (y === null) {
      const F = t.exit("chunkDocument");
      return r.parser.lazy[F.start.line] = !1, v(y);
    }
    return z(y) ? t.check(te, A, T)(y) : (t.consume(y), E);
  }
  function A(y) {
    t.consume(y);
    const F = t.exit("chunkDocument");
    return r.parser.lazy[F.start.line] = !1, k;
  }
  function T(y) {
    const F = t.exit("chunkDocument");
    return r.parser.lazy[F.start.line] = !1, v(y);
  }
  function v(y) {
    return t.exit("directiveContainerContent"), t.exit("directiveContainer"), n(y);
  }
  function S(y, F, P) {
    let x = 0;
    return N(y, L, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function L(O) {
      return y.enter("directiveContainerFence"), y.enter("directiveContainerSequence"), D(O);
    }
    function D(O) {
      return O === 58 ? (y.consume(O), x++, D) : x < i ? P(O) : (y.exit("directiveContainerSequence"), N(y, B, "whitespace")(O));
    }
    function B(O) {
      return O === null || z(O) ? (y.exit("directiveContainerFence"), F(O)) : P(O);
    }
  }
}
function Kr(t, n, e) {
  return Nt(t, n, e, "directiveContainerLabel", "directiveContainerLabelMarker", "directiveContainerLabelString", !0);
}
function Xr(t, n, e) {
  return Ft(t, n, e, "directiveContainerAttributes", "directiveContainerAttributesMarker", "directiveContainerAttribute", "directiveContainerAttributeId", "directiveContainerAttributeClass", "directiveContainerAttributeName", "directiveContainerAttributeInitializerMarker", "directiveContainerAttributeValueLiteral", "directiveContainerAttributeValue", "directiveContainerAttributeValueMarker", "directiveContainerAttributeValueData", !0);
}
function ti(t, n, e) {
  const r = this;
  return u;
  function u(i) {
    return t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), a;
  }
  function a(i) {
    return r.parser.lazy[r.now().line] ? e(i) : n(i);
  }
}
const ei = {
  tokenize: ii
}, ni = {
  tokenize: ai,
  partial: !0
}, ri = {
  tokenize: ui,
  partial: !0
};
function ii(t, n, e) {
  const r = this;
  return u;
  function u(p) {
    return t.enter("directiveLeaf"), t.enter("directiveLeafSequence"), t.consume(p), a;
  }
  function a(p) {
    return p === 58 ? (t.consume(p), t.exit("directiveLeafSequence"), Ot.call(r, t, i, e, "directiveLeafName")) : e(p);
  }
  function i(p) {
    return p === 91 ? t.attempt(ni, l, l)(p) : l(p);
  }
  function l(p) {
    return p === 123 ? t.attempt(ri, c, c)(p) : c(p);
  }
  function c(p) {
    return N(t, o, "whitespace")(p);
  }
  function o(p) {
    return p === null || z(p) ? (t.exit("directiveLeaf"), n(p)) : e(p);
  }
}
function ai(t, n, e) {
  return Nt(t, n, e, "directiveLeafLabel", "directiveLeafLabelMarker", "directiveLeafLabelString", !0);
}
function ui(t, n, e) {
  return Ft(t, n, e, "directiveLeafAttributes", "directiveLeafAttributesMarker", "directiveLeafAttribute", "directiveLeafAttributeId", "directiveLeafAttributeClass", "directiveLeafAttributeName", "directiveLeafAttributeInitializerMarker", "directiveLeafAttributeValueLiteral", "directiveLeafAttributeValue", "directiveLeafAttributeValueMarker", "directiveLeafAttributeValueData", !0);
}
const li = {
  tokenize: hi,
  previous: ci
}, oi = {
  tokenize: pi,
  partial: !0
}, si = {
  tokenize: gi,
  partial: !0
};
function ci(t) {
  return t !== 58 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function hi(t, n, e) {
  const r = this;
  return u;
  function u(c) {
    return t.enter("directiveText"), t.enter("directiveTextMarker"), t.consume(c), t.exit("directiveTextMarker"), Ot.call(r, t, a, e, "directiveTextName");
  }
  function a(c) {
    return c === 58 ? e(c) : c === 91 ? t.attempt(oi, i, i)(c) : i(c);
  }
  function i(c) {
    return c === 123 ? t.attempt(si, l, l)(c) : l(c);
  }
  function l(c) {
    return t.exit("directiveText"), n(c);
  }
}
function pi(t, n, e) {
  return Nt(t, n, e, "directiveTextLabel", "directiveTextLabelMarker", "directiveTextLabelString");
}
function gi(t, n, e) {
  return Ft(t, n, e, "directiveTextAttributes", "directiveTextAttributesMarker", "directiveTextAttribute", "directiveTextAttributeId", "directiveTextAttributeClass", "directiveTextAttributeName", "directiveTextAttributeInitializerMarker", "directiveTextAttributeValueLiteral", "directiveTextAttributeValue", "directiveTextAttributeValueMarker", "directiveTextAttributeValueData");
}
function Pi() {
  return {
    text: {
      58: li
    },
    flow: {
      58: [$r, ei]
    }
  };
}
const mi = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], ee = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};
function fe(t) {
  const n = typeof t == "string" ? t.charCodeAt(0) : t;
  return n >= 48 && n <= 57;
}
function fi(t) {
  const n = typeof t == "string" ? t.charCodeAt(0) : t;
  return n >= 97 && n <= 102 || n >= 65 && n <= 70 || n >= 48 && n <= 57;
}
function bi(t) {
  const n = typeof t == "string" ? t.charCodeAt(0) : t;
  return n >= 97 && n <= 122 || n >= 65 && n <= 90;
}
function ne(t) {
  return bi(t) || fe(t);
}
const ht = String.fromCharCode, di = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function Dt(t, n = {}) {
  const e = typeof n.additional == "string" ? n.additional.charCodeAt(0) : n.additional, r = [];
  let u = 0, a = -1, i = "", l, c;
  n.position && ("start" in n.position || "indent" in n.position ? (c = n.position.indent, l = n.position.start) : l = n.position);
  let o = (l ? l.line : 0) || 1, p = (l ? l.column : 0) || 1, h = s(), f;
  for (u--; ++u <= t.length; )
    if (f === 10 && (p = (c ? c[a] : 0) || 1), f = t.charCodeAt(u), f === 38) {
      const k = t.charCodeAt(u + 1);
      if (k === 9 || k === 10 || k === 12 || k === 32 || k === 38 || k === 60 || Number.isNaN(k) || e && k === e) {
        i += ht(f), p++;
        continue;
      }
      const w = u + 1;
      let E = w, A = w, T;
      if (k === 35) {
        A = ++E;
        const D = t.charCodeAt(A);
        D === 88 || D === 120 ? (T = "hexadecimal", A = ++E) : T = "decimal";
      } else
        T = "named";
      let v = "", S = "", y = "";
      const F = T === "named" ? ne : T === "decimal" ? fe : fi;
      for (A--; ++A <= t.length; ) {
        const D = t.charCodeAt(A);
        if (!F(D))
          break;
        y += ht(D), T === "named" && mi.includes(y) && (v = y, S = wt(y));
      }
      let P = t.charCodeAt(A) === 59;
      if (P) {
        A++;
        const D = T === "named" ? wt(y) : !1;
        D && (v = y, S = D);
      }
      let x = 1 + A - w, L = "";
      if (!(!P && n.nonTerminated === !1)) if (!y)
        T !== "named" && b(4, x);
      else if (T === "named") {
        if (P && !S)
          b(5, 1);
        else if (v !== y && (A = E + v.length, x = 1 + A - E, P = !1), !P) {
          const D = v ? 1 : 3;
          if (n.attribute) {
            const B = t.charCodeAt(A);
            B === 61 ? (b(D, x), S = "") : ne(B) ? S = "" : b(D, x);
          } else
            b(D, x);
        }
        L = S;
      } else {
        P || b(2, x);
        let D = Number.parseInt(
          y,
          T === "hexadecimal" ? 16 : 10
        );
        if (xi(D))
          b(7, x), L = ht(
            65533
            /* `�` */
          );
        else if (D in ee)
          b(6, x), L = ee[D];
        else {
          let B = "";
          ki(D) && b(6, x), D > 65535 && (D -= 65536, B += ht(D >>> 10 | 55296), D = 56320 | D & 1023), L = B + ht(D);
        }
      }
      if (L) {
        C(), h = s(), u = A - 1, p += A - w + 1, r.push(L);
        const D = s();
        D.offset++, n.reference && n.reference.call(
          n.referenceContext,
          L,
          { start: h, end: D },
          t.slice(w - 1, A)
        ), h = D;
      } else
        y = t.slice(w - 1, A), i += y, p += y.length, u = A - 1;
    } else
      f === 10 && (o++, a++, p = 0), Number.isNaN(f) ? C() : (i += ht(f), p++);
  return r.join("");
  function s() {
    return {
      line: o,
      column: p,
      offset: u + ((l ? l.offset : 0) || 0)
    };
  }
  function b(k, w) {
    let E;
    n.warning && (E = s(), E.column += w, E.offset += w, n.warning.call(
      n.warningContext,
      di[k],
      E,
      k
    ));
  }
  function C() {
    i && (r.push(i), n.text && n.text.call(n.textContext, i, {
      start: h,
      end: s()
    }), i = "");
  }
}
function xi(t) {
  return t >= 55296 && t <= 57343 || t > 1114111;
}
function ki(t) {
  return t >= 1 && t <= 8 || t === 11 || t >= 13 && t <= 31 || t >= 127 && t <= 159 || t >= 64976 && t <= 65007 || (t & 65535) === 65535 || (t & 65535) === 65534;
}
const re = {}.hasOwnProperty;
function _i(t) {
  const n = t || {};
  return {
    enter: {
      directiveContainer() {
        e.call(this, "containerDirective");
      },
      directiveContainerAttributes: i,
      directiveContainerLabel: u,
      directiveContainerContent() {
        this.buffer();
      },
      directiveLeaf() {
        e.call(this, "leafDirective");
      },
      directiveLeafAttributes: i,
      directiveLeafLabel: u,
      directiveText() {
        e.call(this, "textDirective");
      },
      directiveTextAttributes: i,
      directiveTextLabel: u
    },
    exit: {
      directiveContainer: b,
      directiveContainerAttributeClassValue: c,
      directiveContainerAttributeIdValue: l,
      directiveContainerAttributeName: o,
      directiveContainerAttributeValue: p,
      directiveContainerAttributes: h,
      directiveContainerContent: f,
      directiveContainerFence: s,
      directiveContainerLabel: a,
      directiveContainerName: r,
      directiveLeaf: b,
      directiveLeafAttributeClassValue: c,
      directiveLeafAttributeIdValue: l,
      directiveLeafAttributeName: o,
      directiveLeafAttributeValue: p,
      directiveLeafAttributes: h,
      directiveLeafLabel: a,
      directiveLeafName: r,
      directiveText: b,
      directiveTextAttributeClassValue: c,
      directiveTextAttributeIdValue: l,
      directiveTextAttributeName: o,
      directiveTextAttributeValue: p,
      directiveTextAttributes: h,
      directiveTextLabel: a,
      directiveTextName: r
    }
  };
  function e(C) {
    let k = this.getData("directiveStack");
    k || this.setData("directiveStack", k = []), k.push({
      type: C,
      name: ""
    });
  }
  function r(C) {
    const k = this.getData("directiveStack");
    k[k.length - 1].name = this.sliceSerialize(C);
  }
  function u() {
    this.buffer();
  }
  function a() {
    const C = this.resume(), k = this.getData("directiveStack");
    k[k.length - 1].label = C;
  }
  function i() {
    this.buffer(), this.setData("directiveAttributes", []);
  }
  function l(C) {
    this.getData("directiveAttributes").push(["id", Dt(this.sliceSerialize(C), {
      attribute: !0
    })]);
  }
  function c(C) {
    this.getData("directiveAttributes").push(["class", Dt(this.sliceSerialize(C), {
      attribute: !0
    })]);
  }
  function o(C) {
    this.getData("directiveAttributes").push([this.sliceSerialize(C), ""]);
  }
  function p(C) {
    const k = this.getData("directiveAttributes");
    k[k.length - 1][1] = Dt(this.sliceSerialize(C), {
      attribute: !0
    });
  }
  function h() {
    const C = this.getData("directiveStack"), k = this.getData("directiveAttributes"), w = {};
    let E = -1;
    for (; ++E < k.length; ) {
      const A = k[E];
      A[0] === "class" && w.class ? w.class += " " + A[1] : w[A[0]] = A[1];
    }
    this.resume(), this.setData("directiveAttributes"), C[C.length - 1].attributes = w;
  }
  function f() {
    const C = this.resume(), k = this.getData("directiveStack");
    k[k.length - 1].content = C;
  }
  function s() {
    const C = this.getData("directiveStack"), k = C[C.length - 1];
    k._fenceCount || (k._fenceCount = 0), k._fenceCount++, k._fenceCount === 1 && this.setData("slurpOneLineEnding", !0);
  }
  function b() {
    const k = this.getData("directiveStack").pop();
    let w, E;
    re.call(n, k.name) && (E = n[k.name].call(this, k), w = E !== !1), !w && re.call(n, "*") && (E = n["*"].call(this, k), w = E !== !1), !w && k.type !== "textDirective" && this.setData("slurpOneLineEnding", !0);
  }
}
const wi = {
  tokenize: qi,
  partial: !0
};
function Mi() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: Ai,
        continuation: {
          tokenize: Ei
        },
        exit: Di
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: Ci
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: Si,
        resolveTo: yi
      }
    }
  };
}
function Si(t, n, e) {
  const r = this;
  let u = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i;
  for (; u--; ) {
    const c = r.events[u][1];
    if (c.type === "labelImage") {
      i = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return l;
  function l(c) {
    if (!i || !i._balanced)
      return e(c);
    const o = et(r.sliceSerialize({
      start: i.end,
      end: r.now()
    }));
    return o.codePointAt(0) !== 94 || !a.includes(o.slice(1)) ? e(c) : (t.enter("gfmFootnoteCallLabelMarker"), t.consume(c), t.exit("gfmFootnoteCallLabelMarker"), n(c));
  }
}
function yi(t, n) {
  let e = t.length;
  for (; e--; )
    if (t[e][1].type === "labelImage" && t[e][0] === "enter") {
      t[e][1];
      break;
    }
  t[e + 1][1].type = "data", t[e + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, t[e + 3][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  }, u = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, t[e + 3][1].end),
    end: Object.assign({}, t[e + 3][1].end)
  };
  u.end.column++, u.end.offset++, u.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, u.end),
    end: Object.assign({}, t[t.length - 1][1].start)
  }, i = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, l = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    t[e + 1],
    t[e + 2],
    ["enter", r, n],
    // The `[`
    t[e + 3],
    t[e + 4],
    // The `^`.
    ["enter", u, n],
    ["exit", u, n],
    // Everything in between.
    ["enter", a, n],
    ["enter", i, n],
    ["exit", i, n],
    ["exit", a, n],
    // The ending (`]`, properly parsed and labelled).
    t[t.length - 2],
    t[t.length - 1],
    ["exit", r, n]
  ];
  return t.splice(e, t.length - e + 1, ...l), t;
}
function Ci(t, n, e) {
  const r = this, u = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, i;
  return l;
  function l(h) {
    return t.enter("gfmFootnoteCall"), t.enter("gfmFootnoteCallLabelMarker"), t.consume(h), t.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(h) {
    return h !== 94 ? e(h) : (t.enter("gfmFootnoteCallMarker"), t.consume(h), t.exit("gfmFootnoteCallMarker"), t.enter("gfmFootnoteCallString"), t.enter("chunkString").contentType = "string", o);
  }
  function o(h) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      h === 93 && !i || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || _(h)
    )
      return e(h);
    if (h === 93) {
      t.exit("chunkString");
      const f = t.exit("gfmFootnoteCallString");
      return u.includes(et(r.sliceSerialize(f))) ? (t.enter("gfmFootnoteCallLabelMarker"), t.consume(h), t.exit("gfmFootnoteCallLabelMarker"), t.exit("gfmFootnoteCall"), n) : e(h);
    }
    return _(h) || (i = !0), a++, t.consume(h), h === 92 ? p : o;
  }
  function p(h) {
    return h === 91 || h === 92 || h === 93 ? (t.consume(h), a++, o) : o(h);
  }
}
function Ai(t, n, e) {
  const r = this, u = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, i = 0, l;
  return c;
  function c(b) {
    return t.enter("gfmFootnoteDefinition")._container = !0, t.enter("gfmFootnoteDefinitionLabel"), t.enter("gfmFootnoteDefinitionLabelMarker"), t.consume(b), t.exit("gfmFootnoteDefinitionLabelMarker"), o;
  }
  function o(b) {
    return b === 94 ? (t.enter("gfmFootnoteDefinitionMarker"), t.consume(b), t.exit("gfmFootnoteDefinitionMarker"), t.enter("gfmFootnoteDefinitionLabelString"), t.enter("chunkString").contentType = "string", p) : e(b);
  }
  function p(b) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      b === 93 && !l || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      b === null || b === 91 || _(b)
    )
      return e(b);
    if (b === 93) {
      t.exit("chunkString");
      const C = t.exit("gfmFootnoteDefinitionLabelString");
      return a = et(r.sliceSerialize(C)), t.enter("gfmFootnoteDefinitionLabelMarker"), t.consume(b), t.exit("gfmFootnoteDefinitionLabelMarker"), t.exit("gfmFootnoteDefinitionLabel"), f;
    }
    return _(b) || (l = !0), i++, t.consume(b), b === 92 ? h : p;
  }
  function h(b) {
    return b === 91 || b === 92 || b === 93 ? (t.consume(b), i++, p) : p(b);
  }
  function f(b) {
    return b === 58 ? (t.enter("definitionMarker"), t.consume(b), t.exit("definitionMarker"), u.includes(a) || u.push(a), N(t, s, "gfmFootnoteDefinitionWhitespace")) : e(b);
  }
  function s(b) {
    return n(b);
  }
}
function Ei(t, n, e) {
  return t.check(dt, n, t.attempt(wi, n, e));
}
function Di(t) {
  t.exit("gfmFootnoteDefinition");
}
function qi(t, n, e) {
  const r = this;
  return N(t, u, "gfmFootnoteDefinitionIndent", 5);
  function u(a) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "gfmFootnoteDefinitionIndent" && i[2].sliceSerialize(i[1], !0).length === 4 ? n(a) : e(a);
  }
}
const Li = {}.hasOwnProperty, vi = {};
function zi(t, n) {
  return "Back to reference " + (t + 1) + (n > 1 ? "-" + n : "");
}
function Vi(t) {
  const n = vi, e = n.label || "Footnotes", r = n.labelTagName || "h2", u = n.labelAttributes === null || n.labelAttributes === void 0 ? 'class="sr-only"' : n.labelAttributes, a = n.backLabel || zi, i = n.clobberPrefix === null || n.clobberPrefix === void 0 ? "user-content-" : n.clobberPrefix;
  return {
    enter: {
      gfmFootnoteDefinition() {
        this.getData("tightStack").push(!1);
      },
      gfmFootnoteDefinitionLabelString() {
        this.buffer();
      },
      gfmFootnoteCallString() {
        this.buffer();
      }
    },
    exit: {
      gfmFootnoteDefinition() {
        let l = this.getData("gfmFootnoteDefinitions");
        const c = this.getData("gfmFootnoteDefinitionStack"), o = this.getData("tightStack"), p = c.pop(), h = this.resume();
        l || this.setData("gfmFootnoteDefinitions", l = {}), Li.call(l, p) || (l[p] = h), o.pop(), this.setData("slurpOneLineEnding", !0), this.setData("lastWasTag");
      },
      gfmFootnoteDefinitionLabelString(l) {
        let c = this.getData("gfmFootnoteDefinitionStack");
        c || this.setData("gfmFootnoteDefinitionStack", c = []), c.push(et(this.sliceSerialize(l))), this.resume(), this.buffer();
      },
      gfmFootnoteCallString(l) {
        let c = this.getData("gfmFootnoteCallOrder"), o = this.getData("gfmFootnoteCallCounts");
        const p = et(this.sliceSerialize(l));
        let h;
        this.resume(), c || this.setData("gfmFootnoteCallOrder", c = []), o || this.setData("gfmFootnoteCallCounts", o = {});
        const f = c.indexOf(p), s = gt(p.toLowerCase());
        f === -1 ? (c.push(p), o[p] = 1, h = c.length) : (o[p]++, h = f + 1);
        const b = o[p];
        this.tag('<sup><a href="#' + i + "fn-" + s + '" id="' + i + "fnref-" + s + (b > 1 ? "-" + b : "") + '" data-footnote-ref="" aria-describedby="footnote-label">' + String(h) + "</a></sup>");
      },
      null() {
        const l = this.getData("gfmFootnoteCallOrder") || [], c = this.getData("gfmFootnoteCallCounts") || {}, o = this.getData("gfmFootnoteDefinitions") || {};
        let p = -1;
        for (l.length > 0 && (this.lineEndingIfNeeded(), this.tag('<section data-footnotes="" class="footnotes"><' + r + ' id="footnote-label"' + (u ? " " + u : "") + ">"), this.raw(this.encode(e)), this.tag("</" + r + ">"), this.lineEndingIfNeeded(), this.tag("<ol>")); ++p < l.length; ) {
          const h = l[p], f = gt(h.toLowerCase());
          let s = 0;
          const b = [];
          for (; ++s <= c[h]; )
            b.push('<a href="#' + i + "fnref-" + f + (s > 1 ? "-" + s : "") + '" data-footnote-backref="" aria-label="' + this.encode(typeof a == "string" ? a : a(p, s)) + '" class="data-footnote-backref">↩' + (s > 1 ? "<sup>" + s + "</sup>" : "") + "</a>");
          const C = b.join(" ");
          let k = !1;
          this.lineEndingIfNeeded(), this.tag('<li id="' + i + "fn-" + f + '">'), this.lineEndingIfNeeded(), this.tag(o[h].replace(/<\/p>(?:\r?\n|\r)?$/, function(w) {
            return k = !0, " " + C + w;
          })), k || (this.lineEndingIfNeeded(), this.tag(C)), this.lineEndingIfNeeded(), this.tag("</li>");
        }
        l.length > 0 && (this.lineEndingIfNeeded(), this.tag("</ol>"), this.lineEndingIfNeeded(), this.tag("</section>"));
      }
    }
  };
}
function Hi() {
  return {
    enter: {
      strikethrough() {
        this.tag("<del>");
      }
    },
    exit: {
      strikethrough() {
        this.tag("</del>");
      }
    }
  };
}
function ji(t) {
  let e = (t || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: u
  };
  return e == null && (e = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function u(i, l) {
    let c = -1;
    for (; ++c < i.length; )
      if (i[c][0] === "enter" && i[c][1].type === "strikethroughSequenceTemporary" && i[c][1]._close) {
        let o = c;
        for (; o--; )
          if (i[o][0] === "exit" && i[o][1].type === "strikethroughSequenceTemporary" && i[o][1]._open && // If the sizes are the same:
          i[c][1].end.offset - i[c][1].start.offset === i[o][1].end.offset - i[o][1].start.offset) {
            i[c][1].type = "strikethroughSequence", i[o][1].type = "strikethroughSequence";
            const p = {
              type: "strikethrough",
              start: Object.assign({}, i[o][1].start),
              end: Object.assign({}, i[c][1].end)
            }, h = {
              type: "strikethroughText",
              start: Object.assign({}, i[o][1].end),
              end: Object.assign({}, i[c][1].start)
            }, f = [["enter", p, l], ["enter", i[o][1], l], ["exit", i[o][1], l], ["enter", h, l]], s = l.parser.constructs.insideSpan.null;
            s && $(f, f.length, 0, yt(s, i.slice(o + 1, c), l)), $(f, f.length, 0, [["exit", h, l], ["enter", i[c][1], l], ["exit", i[c][1], l], ["exit", p, l]]), $(i, o - 1, c - o + 3, f), c = o + f.length - 2;
            break;
          }
      }
    for (c = -1; ++c < i.length; )
      i[c][1].type === "strikethroughSequenceTemporary" && (i[c][1].type = "data");
    return i;
  }
  function a(i, l, c) {
    const o = this.previous, p = this.events;
    let h = 0;
    return f;
    function f(b) {
      return o === 126 && p[p.length - 1][1].type !== "characterEscape" ? c(b) : (i.enter("strikethroughSequenceTemporary"), s(b));
    }
    function s(b) {
      const C = St(o);
      if (b === 126)
        return h > 1 ? c(b) : (i.consume(b), h++, s);
      if (h < 2 && !e) return c(b);
      const k = i.exit("strikethroughSequenceTemporary"), w = St(b);
      return k._open = !w || w === 2 && !!C, k._close = !C || C === 2 && !!w, l(b);
    }
  }
}
const qt = {
  none: "",
  left: ' align="left"',
  right: ' align="right"',
  center: ' align="center"'
};
function Ui() {
  return {
    enter: {
      table(t) {
        const n = t._align;
        this.lineEndingIfNeeded(), this.tag("<table>"), this.setData("tableAlign", n);
      },
      tableBody() {
        this.tag("<tbody>");
      },
      tableData() {
        const t = this.getData("tableAlign"), n = this.getData("tableColumn"), e = qt[t[n]];
        e === void 0 ? this.buffer() : (this.lineEndingIfNeeded(), this.tag("<td" + e + ">"));
      },
      tableHead() {
        this.lineEndingIfNeeded(), this.tag("<thead>");
      },
      tableHeader() {
        const t = this.getData("tableAlign"), n = this.getData("tableColumn"), e = qt[t[n]];
        this.lineEndingIfNeeded(), this.tag("<th" + e + ">");
      },
      tableRow() {
        this.setData("tableColumn", 0), this.lineEndingIfNeeded(), this.tag("<tr>");
      }
    },
    exit: {
      // Overwrite the default code text data handler to unescape escaped pipes when
      // they are in tables.
      codeTextData(t) {
        let n = this.sliceSerialize(t);
        this.getData("tableAlign") && (n = n.replace(/\\([\\|])/g, Ii)), this.raw(this.encode(n));
      },
      table() {
        this.setData("tableAlign"), this.setData("slurpAllLineEndings"), this.lineEndingIfNeeded(), this.tag("</table>");
      },
      tableBody() {
        this.lineEndingIfNeeded(), this.tag("</tbody>");
      },
      tableData() {
        const t = this.getData("tableAlign"), n = this.getData("tableColumn");
        n in t ? (this.tag("</td>"), this.setData("tableColumn", n + 1)) : this.resume();
      },
      tableHead() {
        this.lineEndingIfNeeded(), this.tag("</thead>");
      },
      tableHeader() {
        const t = this.getData("tableColumn");
        this.tag("</th>"), this.setData("tableColumn", t + 1);
      },
      tableRow() {
        const t = this.getData("tableAlign");
        let n = this.getData("tableColumn");
        for (; n < t.length; )
          this.lineEndingIfNeeded(), this.tag("<td" + qt[t[n]] + "></td>"), n++;
        this.setData("tableColumn", n), this.lineEndingIfNeeded(), this.tag("</tr>");
      }
    }
  };
}
function Ii(t, n) {
  return n === "|" ? n : t;
}
class Ti {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(n, e, r) {
    Fi(this, n, e, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(n) {
    if (this.map.sort(function(a, i) {
      return a[0] - i[0];
    }), this.map.length === 0)
      return;
    let e = this.map.length;
    const r = [];
    for (; e > 0; )
      e -= 1, r.push(n.slice(this.map[e][0] + this.map[e][1]), this.map[e][2]), n.length = this.map[e][0];
    r.push([...n]), n.length = 0;
    let u = r.pop();
    for (; u; )
      n.push(...u), u = r.pop();
    this.map.length = 0;
  }
}
function Fi(t, n, e, r) {
  let u = 0;
  if (!(e === 0 && r.length === 0)) {
    for (; u < t.map.length; ) {
      if (t.map[u][0] === n) {
        t.map[u][1] += e, t.map[u][2].push(...r);
        return;
      }
      u += 1;
    }
    t.map.push([n, e, r]);
  }
}
function Ni(t, n) {
  let e = !1;
  const r = [];
  for (; n < t.length; ) {
    const u = t[n];
    if (e) {
      if (u[0] === "enter")
        u[1].type === "tableContent" && r.push(t[n + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (u[1].type === "tableContent") {
        if (t[n - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (u[1].type === "tableDelimiterRow")
        break;
    } else u[0] === "enter" && u[1].type === "tableDelimiterRow" && (e = !0);
    n += 1;
  }
  return r;
}
function Gi() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: Oi,
        resolveAll: Ri
      }
    }
  };
}
function Oi(t, n, e) {
  const r = this;
  let u = 0, a = 0, i;
  return l;
  function l(x) {
    let L = r.events.length - 1;
    for (; L > -1; ) {
      const O = r.events[L][1].type;
      if (O === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      O === "linePrefix") L--;
      else break;
    }
    const D = L > -1 ? r.events[L][1].type : null, B = D === "tableHead" || D === "tableRow" ? S : c;
    return B === S && r.parser.lazy[r.now().line] ? e(x) : B(x);
  }
  function c(x) {
    return t.enter("tableHead"), t.enter("tableRow"), o(x);
  }
  function o(x) {
    return x === 124 || (i = !0, a += 1), p(x);
  }
  function p(x) {
    return x === null ? e(x) : z(x) ? a > 1 ? (a = 0, r.interrupt = !0, t.exit("tableRow"), t.enter("lineEnding"), t.consume(x), t.exit("lineEnding"), s) : e(x) : R(x) ? N(t, p, "whitespace")(x) : (a += 1, i && (i = !1, u += 1), x === 124 ? (t.enter("tableCellDivider"), t.consume(x), t.exit("tableCellDivider"), i = !0, p) : (t.enter("data"), h(x)));
  }
  function h(x) {
    return x === null || x === 124 || _(x) ? (t.exit("data"), p(x)) : (t.consume(x), x === 92 ? f : h);
  }
  function f(x) {
    return x === 92 || x === 124 ? (t.consume(x), h) : h(x);
  }
  function s(x) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? e(x) : (t.enter("tableDelimiterRow"), i = !1, R(x) ? N(t, b, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(x) : b(x));
  }
  function b(x) {
    return x === 45 || x === 58 ? k(x) : x === 124 ? (i = !0, t.enter("tableCellDivider"), t.consume(x), t.exit("tableCellDivider"), C) : v(x);
  }
  function C(x) {
    return R(x) ? N(t, k, "whitespace")(x) : k(x);
  }
  function k(x) {
    return x === 58 ? (a += 1, i = !0, t.enter("tableDelimiterMarker"), t.consume(x), t.exit("tableDelimiterMarker"), w) : x === 45 ? (a += 1, w(x)) : x === null || z(x) ? T(x) : v(x);
  }
  function w(x) {
    return x === 45 ? (t.enter("tableDelimiterFiller"), E(x)) : v(x);
  }
  function E(x) {
    return x === 45 ? (t.consume(x), E) : x === 58 ? (i = !0, t.exit("tableDelimiterFiller"), t.enter("tableDelimiterMarker"), t.consume(x), t.exit("tableDelimiterMarker"), A) : (t.exit("tableDelimiterFiller"), A(x));
  }
  function A(x) {
    return R(x) ? N(t, T, "whitespace")(x) : T(x);
  }
  function T(x) {
    return x === 124 ? b(x) : x === null || z(x) ? !i || u !== a ? v(x) : (t.exit("tableDelimiterRow"), t.exit("tableHead"), n(x)) : v(x);
  }
  function v(x) {
    return e(x);
  }
  function S(x) {
    return t.enter("tableRow"), y(x);
  }
  function y(x) {
    return x === 124 ? (t.enter("tableCellDivider"), t.consume(x), t.exit("tableCellDivider"), y) : x === null || z(x) ? (t.exit("tableRow"), n(x)) : R(x) ? N(t, y, "whitespace")(x) : (t.enter("data"), F(x));
  }
  function F(x) {
    return x === null || x === 124 || _(x) ? (t.exit("data"), y(x)) : (t.consume(x), x === 92 ? P : F);
  }
  function P(x) {
    return x === 92 || x === 124 ? (t.consume(x), F) : F(x);
  }
}
function Ri(t, n) {
  let e = -1, r = !0, u = 0, a = [0, 0, 0, 0], i = [0, 0, 0, 0], l = !1, c = 0, o, p, h;
  const f = new Ti();
  for (; ++e < t.length; ) {
    const s = t[e], b = s[1];
    s[0] === "enter" ? b.type === "tableHead" ? (l = !1, c !== 0 && (ie(f, n, c, o, p), p = void 0, c = 0), o = {
      type: "table",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, f.add(e, 0, [["enter", o, n]])) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (r = !0, h = void 0, a = [0, 0, 0, 0], i = [0, e + 1, 0, 0], l && (l = !1, p = {
      type: "tableBody",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, f.add(e, 0, [["enter", p, n]])), u = b.type === "tableDelimiterRow" ? 2 : p ? 3 : 1) : u && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") ? (r = !1, i[2] === 0 && (a[1] !== 0 && (i[0] = i[1], h = xt(f, n, a, u, void 0, h), a = [0, 0, 0, 0]), i[2] = e)) : b.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (i[0] = i[1], h = xt(f, n, a, u, void 0, h)), a = i, i = [a[1], e, 0, 0])) : b.type === "tableHead" ? (l = !0, c = e) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (c = e, a[1] !== 0 ? (i[0] = i[1], h = xt(f, n, a, u, e, h)) : i[1] !== 0 && (h = xt(f, n, i, u, e, h)), u = 0) : u && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") && (i[3] = e);
  }
  for (c !== 0 && ie(f, n, c, o, p), f.consume(n.events), e = -1; ++e < n.events.length; ) {
    const s = n.events[e];
    s[0] === "enter" && s[1].type === "table" && (s[1]._align = Ni(n.events, e));
  }
  return t;
}
function xt(t, n, e, r, u, a) {
  const i = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", l = "tableContent";
  e[0] !== 0 && (a.end = Object.assign({}, pt(n.events, e[0])), t.add(e[0], 0, [["exit", a, n]]));
  const c = pt(n.events, e[1]);
  if (a = {
    type: i,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, t.add(e[1], 0, [["enter", a, n]]), e[2] !== 0) {
    const o = pt(n.events, e[2]), p = pt(n.events, e[3]), h = {
      type: l,
      start: Object.assign({}, o),
      end: Object.assign({}, p)
    };
    if (t.add(e[2], 0, [["enter", h, n]]), r !== 2) {
      const f = n.events[e[2]], s = n.events[e[3]];
      if (f[1].end = Object.assign({}, s[1].end), f[1].type = "chunkText", f[1].contentType = "text", e[3] > e[2] + 1) {
        const b = e[2] + 1, C = e[3] - e[2] - 1;
        t.add(b, C, []);
      }
    }
    t.add(e[3] + 1, 0, [["exit", h, n]]);
  }
  return u !== void 0 && (a.end = Object.assign({}, pt(n.events, u)), t.add(u, 0, [["exit", a, n]]), a = void 0), a;
}
function ie(t, n, e, r, u) {
  const a = [], i = pt(n.events, e);
  u && (u.end = Object.assign({}, i), a.push(["exit", u, n])), r.end = Object.assign({}, i), a.push(["exit", r, n]), t.add(e + 1, 0, a);
}
function pt(t, n) {
  const e = t[n], r = e[0] === "enter" ? "start" : "end";
  return e[1][r];
}
export {
  ji as a,
  Gi as b,
  mi as c,
  Pi as d,
  Vi as e,
  Hi as f,
  Mi as g,
  Ui as h,
  _i as i,
  Bi as m
};
